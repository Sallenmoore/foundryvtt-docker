const JB2APATREONDB = {};
async function initializeJB2APatreonDB(path) {
  JB2APATREONDB._templates = {
    ranged: [200, 200, 200]
  };
  const BASE = `${path}/Library/`;
  const prefix = (str) => (strs, ...exprs) => `${BASE}${str}/${strs.reduce((a, c, i) => a + exprs[i - 1] + c)}`;
  const l0 = prefix("Cantrip");
  const l1 = prefix("1st_Level");
  const l2 = prefix("2nd_Level");
  const l3 = prefix("3rd_Level");
  const l4 = prefix("4th_Level");
  const l5 = prefix("5th_Level");
  const l6 = prefix("6th_Level");
  const l7 = prefix("7th_Level");
  const lg = prefix("Generic");
  JB2APATREONDB.range = {
    _template: "ranged",
    weapon: {
      arrow: {
        "regular": {
          regular: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_White_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_White_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Glowing_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Glowing_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Glowing_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Glowing_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Glowing_Green_90ft_4000x400.webm`]
          }
        },
        "physical": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Physical_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Physical_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Physical_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Physical_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Physical_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Physical_90ft_4000x400.webm`]
          },
          white: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_White_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_White_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_White_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_White_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_White_Physical_90ft_4000x400.webm`]
          }
        },
        "poison": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Poison_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Poison_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Poison_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Poison_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Poison_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Poison_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Poison_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Poison_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Poison_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Poison_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Poison_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Poison_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Poison_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Poison_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Poison_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Poison_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Poison_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Poison_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Poison_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Poison_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Poison_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Poison_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Poison_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Poison_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Poison_90ft_4000x400.webm`]
          }
        },
        "fire": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Fire_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Fire_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Fire_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Fire_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Fire_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Fire_90ft_4000x400.webm`]
          }
        },
        "cold": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Cold_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Cold_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Cold_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Cold_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Cold_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Cold_90ft_4000x400.webm`]
          }
        },
        "lightning": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Lightning_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Green_Lightning_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Orange_Lightning_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Pink_Lightning_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Purple_Lightning_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Red_Lightning_90ft_4000x400.webm`]
          }
        }
      },
      bolt: {
        "physical": {
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Physical_90ft_4000x400.webm`]
          },
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Physical_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Physical_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Physical_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Physical_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Physical_90ft_4000x400.webm`]
          },
          white: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_White_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_White_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_White_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_White_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_White_Physical_90ft_4000x400.webm`]
          }
        },
        "poison": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Poison_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Poison_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Poison_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Poison_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Poison_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Poison_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Poison_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Poison_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Poison_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Poison_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Poison_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Poison_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Poison_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Poison_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Poison_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Poison_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Poison_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Poison_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Poison_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Poison_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Poison_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Poison_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Poison_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Poison_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Poison_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Poison_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Poison_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Poison_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Poison_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Poison_90ft_4000x400.webm`]
          }
        },
        "fire": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Fire_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Fire_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Fire_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Fire_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Fire_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Fire_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Fire_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Fire_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Fire_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Fire_90ft_4000x400.webm`]
          }
        },
        "cold": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Cold_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Cold_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Cold_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Cold_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Cold_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Cold_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Cold_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Cold_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Cold_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Cold_90ft_4000x400.webm`]
          }
        },
        "lightning": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Blue_Lightning_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Green_Lightning_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Lightning_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Pink_Lightning_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Purple_Lightning_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Lightning_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Lightning_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Lightning_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Lightning_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Red_Lightning_90ft_4000x400.webm`]
          }
        }
      },
      bomb: {
        "01": {
          black: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Black_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Black_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Black_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Black_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Black_90ft_4000x400.webm`]
          },
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Green_90ft_4000x400.webm`]
          },
          grey: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Grey_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Grey_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Grey_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Grey_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Grey_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Red_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Red_90ft_4000x400.webm`]
          }
        }
      },
      boulder: {
        "01": {
          white: {
            "05ft": [lg`Weapon_Attacks/Ranged/BoulderToss01_01_Regular_White_05ft_600x500.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/BoulderToss01_01_Regular_White_15ft_1000x500.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/BoulderToss01_01_Regular_White_30ft_1600x500.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/BoulderToss01_01_Regular_White_60ft_2800x500.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/BoulderToss01_01_Regular_White_90ft_4000x500.webm`]
          }
        }
      },
      bone: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Bone01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bone01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bone01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bone01_01_Regular_White_90ft_4000x400.webm`]
          }
        }
      },
      bullet: {
        "1": {
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Orange_90ft_4000x400.webm`]
          },
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Green_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Red_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Red_90ft_4000x400.webm`]
          }
        },
        "2": {
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Orange_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Orange_90ft_4000x400.webm`]
          },
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Green_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Red_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Red_90ft_4000x400.webm`]
          }
        },
        "3": {
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Orange_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Orange_90ft_4000x400.webm`]
          },
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Green_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Red_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Red_90ft_4000x400.webm`]
          }
        }
      },
      cannonball: {
        "01": {
          black: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaunchCannonBall01_01_Regular_Black_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaunchCannonBall01_01_Regular_Black_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaunchCannonBall01_01_Regular_Black_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaunchCannonBall01_01_Regular_Black_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaunchCannonBall01_01_Regular_Black_90ft_4000x400.webm`]
          }
        }
      },
      chakram: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Chakram01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Chakram01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Chakram01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Chakram01_01_Regular_White_90ft_4000x400.webm`]
          }
        },
        "02": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Chakram01_02_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Chakram01_02_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Chakram01_02_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Chakram01_02_Regular_White_90ft_4000x400.webm`]
          }
        }
      },
      dagger: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_90ft_4000x400.webm`]
          },
          blue: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Blue_90ft_4000x400.webm`]
          },
          darkpurple: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Dark_Purple_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Dark_Purple_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Dark_Purple_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Dark_Purple_90ft_4000x400.webm`]
          },
          pink: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Pink_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Pink_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Pink_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Pink_90ft_4000x400.webm`]
          },
          red: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Red_90ft_4000x400.webm`]
          }
        },
        "02": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_White_90ft_4000x400.webm`]
          },
          blue: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Blue_90ft_4000x400.webm`]
          },
          darkpurple: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Dark_Purple_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Dark_Purple_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Dark_Purple_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Dark_Purple_90ft_4000x400.webm`]
          },
          pink: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_90ft_4000x400.webm`]
          },
          red: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_90ft_4000x400.webm`]
          }
        },
        "kunai": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Kunai01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Kunai01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Kunai01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Kunai01_01_Regular_White_90ft_4000x400.webm`]
          }
        }
      },
      dart: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dart01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dart01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dart01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dart01_01_Regular_White_90ft_4000x400.webm`]
          }
        }
      },
      flask: {
        "01": {
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Orange_90ft_4000x400.webm`]
          }
        },
        "02": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Blue_90ft_4000x400.webm`]
          }
        },
        "03": {
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Green_90ft_4000x400.webm`]
          }
        }
      },
      greataxe: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_White_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_White_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_White_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_White_90ft_4000x600.webm`]
          },
          blue: {
            "15ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Blue_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Blue_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Blue_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Blue_90ft_4000x600.webm`]
          },
          yellow: {
            "15ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Yellow_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Yellow_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Yellow_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Yellow_90ft_4000x600.webm`]
          },
          red: {
            "15ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Red_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Red_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Red_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/GreatAxe01_01_Regular_Red_90ft_4000x600.webm`]
          }
        }
      },
      greatsword: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/GreatSword01_01_Regular_White_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/GreatSword01_01_Regular_White_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/GreatSword01_01_Regular_White_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/GreatSword01_01_Regular_White_90ft_4000x600.webm`]
          }
        }
      },
      grenade: {
        "01": {
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade01_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade01_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade01_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade01_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade01_01_Regular_Green_90ft_4000x400.webm`]
          }
        },
        "02": {
          blackyellow: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade02_01_Regular_BlackYellow_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade02_01_Regular_BlackYellow_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade02_01_Regular_BlackYellow_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade02_01_Regular_BlackYellow_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade02_01_Regular_BlackYellow_90ft_4000x400.webm`]
          }
        },
        "03": {
          blackblue: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_BlackBlue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_BlackBlue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_BlackBlue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_BlackBlue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_BlackBlue_90ft_4000x400.webm`]
          }
        },
        stick: {
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowStickGrenade01_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowStickGrenade01_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowStickGrenade01_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowStickGrenade01_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowStickGrenade01_01_Regular_Green_90ft_4000x400.webm`]
          }
        }
      },
      grenadelaunch: {
        "01": {
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade01_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade01_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade01_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade01_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade01_01_Regular_Green_90ft_4000x400.webm`]
          }
        },
        "02": {
          blackyellow: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade02_01_Regular_BlackYellow_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade02_01_Regular_BlackYellow_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade02_01_Regular_BlackYellow_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade02_01_Regular_BlackYellow_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade02_01_Regular_BlackYellow_90ft_4000x400.webm`]
          }
        },
        "03": {
          blackblue: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_BlackBlue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_BlackBlue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_BlackBlue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_BlackBlue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_BlackBlue_90ft_4000x400.webm`]
          }
        }
      },
      hammer: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Hammer01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Hammer01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Hammer01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Hammer01_01_Regular_White_90ft_4000x400.webm`]
          }
        }
      },
      handaxe: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/HandAxe01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/HandAxe01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/HandAxe01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/HandAxe01_01_Regular_White_90ft_4000x400.webm`]
          }
        },
        "02": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/HandAxe02_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/HandAxe02_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/HandAxe02_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/HandAxe02_01_Regular_White_90ft_4000x400.webm`]
          }
        }
      },
      javelin: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Javelin01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Javelin01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Javelin01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Javelin01_01_Regular_White_90ft_4000x400.webm`]
          }
        }
      },
      lasershot: {
        "01": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Green_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Orange_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Pink_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Pink_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Pink_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Pink_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Pink_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Purple_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Purple_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Purple_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Purple_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Purple_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Red_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Red_90ft_4000x400.webm`]
          }
        }
      },
      lasersword: {
        "01": {
          blue: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue_90ft_4000x600.webm`]
          },
          blue03: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue03_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue03_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue03_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue03_90ft_4000x600.webm`]
          },
          darkred: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Dark_Red_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Dark_Red_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Dark_Red_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Dark_Red_90ft_4000x600.webm`]
          },
          darkwhite: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Dark_White_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Dark_White_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Dark_White_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Dark_White_90ft_4000x600.webm`]
          },
          darkblue: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue02_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue02_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue02_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue02_90ft_4000x600.webm`]
          },
          green: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Green_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Green_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Green_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Green_90ft_4000x600.webm`]
          },
          palegreen: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Green02_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Green02_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Green02_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Green02_90ft_4000x600.webm`]
          },
          orange: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Orange_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Orange_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Orange_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Orange_90ft_4000x600.webm`]
          },
          purple: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Purple_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Purple_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Purple_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Purple_90ft_4000x600.webm`]
          },
          red: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Red_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Red_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Red_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Red_90ft_4000x600.webm`]
          },
          yellow: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Yellow_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Yellow_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Yellow_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Yellow_90ft_4000x600.webm`]
          },
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_White_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_White_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_White_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_White_90ft_4000x600.webm`]
          }
        },
        "02": {
          blue: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue_90ft_4000x600.webm`]
          },
          blue02: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue03_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue03_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue03_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue03_90ft_4000x600.webm`]
          },
          darkred: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Dark_Red_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Dark_Red_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Dark_Red_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Dark_Red_90ft_4000x600.webm`]
          },
          darkwhite: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Dark_White_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Dark_White_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Dark_White_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Dark_White_90ft_4000x600.webm`]
          },
          darkblue: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue02_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue02_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue02_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Blue02_90ft_4000x600.webm`]
          },
          green: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Green_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Green_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Green_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Green_90ft_4000x600.webm`]
          },
          palegreen: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Green02_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Green02_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Green02_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Green02_90ft_4000x600.webm`]
          },
          orange: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Orange_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Orange_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Orange_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Orange_90ft_4000x600.webm`]
          },
          purple: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Purple_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Purple_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Purple_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Purple_90ft_4000x600.webm`]
          },
          red: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Red_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Red_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Red_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Red_90ft_4000x600.webm`]
          },
          yellow: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Yellow_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Yellow_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Yellow_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Yellow_90ft_4000x600.webm`]
          },
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_White_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_White_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_White_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_White_90ft_4000x600.webm`]
          }
        }
      },
      mace: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Mace01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Mace01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Mace01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Mace01_01_Regular_White_90ft_4000x400.webm`]
          }
        }
      },
      pumpkin: {
        "01": {
          regular: {
            "05ft": [lg`Weapon_Attacks/Ranged/PumpkinToss01_01_Regular_Orange_05ft_600x500.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/PumpkinToss01_01_Regular_Orange_15ft_1000x500.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/PumpkinToss01_01_Regular_Orange_30ft_1600x500.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/PumpkinToss01_01_Regular_Orange_60ft_2800x500.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/PumpkinToss01_01_Regular_Orange_90ft_4000x500.webm`]
          }
        }
      },
      siegeboulder: {
        "01": {
          white: {
            "05ft": [lg`Weapon_Attacks/Ranged/SiegeBoulder01_01_Regular_White_05ft_600x500.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/SiegeBoulder01_01_Regular_White_15ft_1000x500.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/SiegeBoulder01_01_Regular_White_30ft_1600x500.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/SiegeBoulder01_01_Regular_White_60ft_2800x500.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/SiegeBoulder01_01_Regular_White_90ft_4000x500.webm`]
          }
        }
      },
      sling: {
        "01": {
          white: {
            "05ft": [lg`Weapon_Attacks/Ranged/SlingShot_01_Regular_White_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/SlingShot_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/SlingShot_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/SlingShot_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/SlingShot_01_Regular_White_90ft_4000x400.webm`]
          }
        }
      },
      snipe: {
        "01": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Green_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Orange_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Red_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Red_90ft_4000x400.webm`]
          }
        }
      },
      snowball: {
        "01": {
          white: {
            "05ft": [lg`Weapon_Attacks/Ranged/SnowballToss_01_Regular_White_05ft_600x500.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/SnowballToss_01_Regular_White_15ft_1000x500.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/SnowballToss_01_Regular_White_30ft_1600x500.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/SnowballToss_01_Regular_White_60ft_2800x500.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/SnowballToss_01_Regular_White_90ft_4000x500.webm`]
          }
        }
      },
      spear: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Spear01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Spear01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Spear01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Spear01_01_Regular_White_90ft_4000x400.webm`]
          }
        }
      },
      sword: {
        "01": {
          blue: {
            "15ft": [lg`Weapon_Attacks/Ranged/Sword01_02_Regular_Blue_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Sword01_02_Regular_Blue_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Sword01_02_Regular_Blue_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Sword01_02_Regular_Blue_90ft_4000x600.webm`]
          },
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Sword01_01_Regular_White_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Sword01_01_Regular_White_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Sword01_01_Regular_White_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Sword01_01_Regular_White_90ft_4000x600.webm`]
          }
        }
      }
    },
    spell: {
      chainlightning: {
        primary: {
          blue: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_05ft_Primary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_15ft_Primary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_30ft_Primary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_60ft_Primary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_90ft_Primary_4000x400.webm`]
          },
          darkgreen: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green02_05ft_Primary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green02_15ft_Primary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green02_30ft_Primary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green02_60ft_Primary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green02_90ft_Primary_4000x400.webm`]
          },
          darkpurple: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Purple_05ft_Primary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Purple_15ft_Primary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Purple_30ft_Primary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Purple_60ft_Primary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Purple_90ft_Primary_4000x400.webm`]
          },
          darkred: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Red_05ft_Primary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Red_15ft_Primary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Red_30ft_Primary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Red_60ft_Primary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Red_90ft_Primary_4000x400.webm`]
          },
          green: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green_05ft_Primary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green_15ft_Primary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green_30ft_Primary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green_60ft_Primary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green_90ft_Primary_4000x400.webm`]
          },
          orange: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Orange_05ft_Primary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Orange_15ft_Primary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Orange_30ft_Primary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Orange_60ft_Primary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Orange_90ft_Primary_4000x400.webm`]
          },
          purple: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Purple_05ft_Primary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Purple_15ft_Primary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Purple_30ft_Primary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Purple_60ft_Primary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Purple_90ft_Primary_4000x400.webm`]
          },
          purpleblue: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue02_05ft_Primary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue02_15ft_Primary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue02_30ft_Primary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue02_60ft_Primary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue02_90ft_Primary_4000x400.webm`]
          },
          red: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Red_05ft_Primary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Red_15ft_Primary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Red_30ft_Primary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Red_60ft_Primary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Red_90ft_Primary_4000x400.webm`]
          },
          yellow: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Yellow_05ft_Primary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Yellow_15ft_Primary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Yellow_30ft_Primary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Yellow_60ft_Primary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Yellow_90ft_Primary_4000x400.webm`]
          }
        },
        secondary: {
          blue: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_05ft_Secondary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_15ft_Secondary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_30ft_Secondary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_60ft_Secondary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_90ft_Secondary_4000x400.webm`]
          },
          darkgreen: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green02_05ft_Secondary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green02_15ft_Secondary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green02_30ft_Secondary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green02_60ft_Secondary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green02_90ft_Secondary_4000x400.webm`]
          },
          darkpurple: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Purple_05ft_Secondary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Purple_15ft_Secondary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Purple_30ft_Secondary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Purple_60ft_Secondary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Purple_90ft_Secondary_4000x400.webm`]
          },
          darkred: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Red_05ft_Secondary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Red_15ft_Secondary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Red_30ft_Secondary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Red_60ft_Secondary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Dark_Red_90ft_Secondary_4000x400.webm`]
          },
          green: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green_05ft_Secondary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green_15ft_Secondary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green_30ft_Secondary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green_60ft_Secondary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Green_90ft_Secondary_4000x400.webm`]
          },
          orange: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Orange_05ft_Secondary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Orange_15ft_Secondary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Orange_30ft_Secondary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Orange_60ft_Secondary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Orange_90ft_Secondary_4000x400.webm`]
          },
          purple: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Purple_05ft_Secondary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Purple_15ft_Secondary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Purple_30ft_Secondary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Purple_60ft_Secondary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Purple_90ft_Secondary_4000x400.webm`]
          },
          purpleblue: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue02_05ft_Secondary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue02_15ft_Secondary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue02_30ft_Secondary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue02_60ft_Secondary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue02_90ft_Secondary_4000x400.webm`]
          },
          red: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Red_05ft_Secondary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Red_15ft_Secondary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Red_30ft_Secondary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Red_60ft_Secondary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Red_90ft_Secondary_4000x400.webm`]
          },
          yellow: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Yellow_05ft_Secondary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Yellow_15ft_Secondary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Yellow_30ft_Secondary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Yellow_60ft_Secondary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Yellow_90ft_Secondary_4000x400.webm`]
          }
        }
      },
      disintegrate: {
        "01": {
          green: {
            "05ft": [l6`Disintegrate/Disintegrate_01_Regular_Green01_05ft_600x400.webm`],
            "15ft": [l6`Disintegrate/Disintegrate_01_Regular_Green01_15ft_1000x400.webm`],
            "30ft": [l6`Disintegrate/Disintegrate_01_Regular_Green01_30ft_1600x400.webm`],
            "60ft": [l6`Disintegrate/Disintegrate_01_Regular_Green01_60ft_2800x400.webm`],
            "90ft": [l6`Disintegrate/Disintegrate_01_Regular_Green01_90ft_4000x400.webm`]
          },
          darkred: {
            "05ft": [l6`Disintegrate/Disintegrate_01_Dark_Red_05ft_600x400.webm`],
            "15ft": [l6`Disintegrate/Disintegrate_01_Dark_Red_15ft_1000x400.webm`],
            "30ft": [l6`Disintegrate/Disintegrate_01_Dark_Red_30ft_1600x400.webm`],
            "60ft": [l6`Disintegrate/Disintegrate_01_Dark_Red_60ft_2800x400.webm`],
            "90ft": [l6`Disintegrate/Disintegrate_01_Dark_Red_90ft_4000x400.webm`]
          },
          orangepink: {
            "05ft": [l6`Disintegrate/Disintegrate_01_Regular_OrangePink_05ft_600x400.webm`],
            "15ft": [l6`Disintegrate/Disintegrate_01_Regular_OrangePink_15ft_1000x400.webm`],
            "30ft": [l6`Disintegrate/Disintegrate_01_Regular_OrangePink_30ft_1600x400.webm`],
            "60ft": [l6`Disintegrate/Disintegrate_01_Regular_OrangePink_60ft_2800x400.webm`],
            "90ft": [l6`Disintegrate/Disintegrate_01_Regular_OrangePink_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [l6`Disintegrate/Disintegrate_01_Regular_Pink_05ft_600x400.webm`],
            "15ft": [l6`Disintegrate/Disintegrate_01_Regular_Pink_15ft_1000x400.webm`],
            "30ft": [l6`Disintegrate/Disintegrate_01_Regular_Pink_30ft_1600x400.webm`],
            "60ft": [l6`Disintegrate/Disintegrate_01_Regular_Pink_60ft_2800x400.webm`],
            "90ft": [l6`Disintegrate/Disintegrate_01_Regular_Pink_90ft_4000x400.webm`]
          },
          purpleblue: {
            "05ft": [l6`Disintegrate/Disintegrate_01_Regular_PurpleBlue_05ft_600x400.webm`],
            "15ft": [l6`Disintegrate/Disintegrate_01_Regular_PurpleBlue_15ft_1000x400.webm`],
            "30ft": [l6`Disintegrate/Disintegrate_01_Regular_PurpleBlue_30ft_1600x400.webm`],
            "60ft": [l6`Disintegrate/Disintegrate_01_Regular_PurpleBlue_60ft_2800x400.webm`],
            "90ft": [l6`Disintegrate/Disintegrate_01_Regular_PurpleBlue_90ft_4000x400.webm`]
          }
        }
      },
      eldritchblast: {
        "01": {
          purple: {
            "05ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Purple_05ft_600x400.webm`],
            "15ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Purple_15ft_1000x400.webm`],
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Purple_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Purple_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Purple_90ft_4000x400.webm`]
          },
          darkpurple: {
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Purple_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Purple_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Purple_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Green_90ft_4000x400.webm`]
          },
          yellow: {
            "05ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Yellow_05ft_600x400.webm`],
            "15ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Yellow_15ft_1000x400.webm`],
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Yellow_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Yellow_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Yellow_90ft_4000x400.webm`]
          },
          darkred: {
            "05ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Red_05ft_600x400.webm`],
            "15ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Red_15ft_1000x400.webm`],
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Red_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Red_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Red_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Orange_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Pink_05ft_600x400.webm`],
            "15ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Pink_15ft_1000x400.webm`],
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Pink_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Pink_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Pink_90ft_4000x400.webm`]
          },
          lightgreen: {
            "05ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_LightGreen_05ft_600x400.webm`],
            "15ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_LightGreen_15ft_1000x400.webm`],
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_LightGreen_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_LightGreen_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_LightGreen_90ft_4000x400.webm`]
          },
          darkgreen: {
            "05ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Green_05ft_600x400.webm`],
            "15ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Green_15ft_1000x400.webm`],
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Green_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Green_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Dark_Green_90ft_4000x400.webm`]
          },
          rainbow: {
            "05ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Rainbow_05ft_600x400.webm`],
            "15ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Rainbow_15ft_1000x400.webm`],
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Rainbow_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Rainbow_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Rainbow_90ft_4000x400.webm`]
          },
          lightblue: {
            "05ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_LightBlue_05ft_600x400.webm`],
            "15ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_LightBlue_15ft_1000x400.webm`],
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_LightBlue_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_LightBlue_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_LightBlue_90ft_4000x400.webm`]
          }
        }
      },
      fireballbeam: {
        "01": {
          blue: {
            "05ft": [l3`Fireball/FireballBeam_01_Blue_05ft_600x400.webm`],
            "15ft": [l3`Fireball/FireballBeam_01_Blue_15ft_1000x400.webm`],
            "30ft": [l3`Fireball/FireballBeam_01_Blue_30ft_1600x400.webm`],
            "60ft": [l3`Fireball/FireballBeam_01_Blue_60ft_2800x400.webm`],
            "90ft": [l3`Fireball/FireballBeam_01_Blue_90ft_4000x400.webm`]
          },
          darkpurple: {
            "05ft": [l3`Fireball/FireballBeam_01_Dark_Purple_05ft_600x400.webm`],
            "15ft": [l3`Fireball/FireballBeam_01_Dark_Purple_15ft_1000x400.webm`],
            "30ft": [l3`Fireball/FireballBeam_01_Dark_Purple_30ft_1600x400.webm`],
            "60ft": [l3`Fireball/FireballBeam_01_Dark_Purple_60ft_2800x400.webm`],
            "90ft": [l3`Fireball/FireballBeam_01_Dark_Purple_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [l3`Fireball/FireballBeam_01_Orange_05ft_600x400.webm`],
            "15ft": [l3`Fireball/FireballBeam_01_Orange_15ft_1000x400.webm`],
            "30ft": [l3`Fireball/FireballBeam_01_Orange_30ft_1600x400.webm`],
            "60ft": [l3`Fireball/FireballBeam_01_Orange_60ft_2800x400.webm`],
            "90ft": [l3`Fireball/FireballBeam_01_Orange_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [l3`Fireball/FireballBeam_01_Purple_05ft_600x400.webm`],
            "15ft": [l3`Fireball/FireballBeam_01_Purple_15ft_1000x400.webm`],
            "30ft": [l3`Fireball/FireballBeam_01_Purple_30ft_1600x400.webm`],
            "60ft": [l3`Fireball/FireballBeam_01_Purple_60ft_2800x400.webm`],
            "90ft": [l3`Fireball/FireballBeam_01_Purple_90ft_4000x400.webm`]
          }
        }
      },
      firebolt: {
        "01": {
          orange: {
            "05ft": [l0`Fire_Bolt/FireBolt_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [l0`Fire_Bolt/FireBolt_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [l0`Fire_Bolt/FireBolt_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [l0`Fire_Bolt/FireBolt_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [l0`Fire_Bolt/FireBolt_01_Regular_Orange_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [l0`Fire_Bolt/FireBolt_01_Dark_Red_05ft_600x400.webm`],
            "15ft": [l0`Fire_Bolt/FireBolt_01_Dark_Red_15ft_1000x400.webm`],
            "30ft": [l0`Fire_Bolt/FireBolt_01_Dark_Red_30ft_1600x400.webm`],
            "60ft": [l0`Fire_Bolt/FireBolt_01_Dark_Red_60ft_2800x400.webm`],
            "90ft": [l0`Fire_Bolt/FireBolt_01_Dark_Red_90ft_4000x400.webm`]
          },
          blue: {
            "05ft": [l0`Fire_Bolt/FireBolt_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [l0`Fire_Bolt/FireBolt_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [l0`Fire_Bolt/FireBolt_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [l0`Fire_Bolt/FireBolt_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [l0`Fire_Bolt/FireBolt_01_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [l0`Fire_Bolt/FireBolt_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [l0`Fire_Bolt/FireBolt_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [l0`Fire_Bolt/FireBolt_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [l0`Fire_Bolt/FireBolt_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [l0`Fire_Bolt/FireBolt_01_Regular_Green_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [l0`Fire_Bolt/FireBolt_01_Regular_Purple_05ft_600x400.webm`],
            "15ft": [l0`Fire_Bolt/FireBolt_01_Regular_Purple_15ft_1000x400.webm`],
            "30ft": [l0`Fire_Bolt/FireBolt_01_Regular_Purple_30ft_1600x400.webm`],
            "60ft": [l0`Fire_Bolt/FireBolt_01_Regular_Purple_60ft_2800x400.webm`],
            "90ft": [l0`Fire_Bolt/FireBolt_01_Regular_Purple_90ft_4000x400.webm`]
          },
          darkgreen: {
            "05ft": [l0`Fire_Bolt/FireBolt_01_Dark_Green02_05ft_600x400.webm`],
            "15ft": [l0`Fire_Bolt/FireBolt_01_Dark_Green02_15ft_1000x400.webm`],
            "30ft": [l0`Fire_Bolt/FireBolt_01_Dark_Green02_30ft_1600x400.webm`],
            "60ft": [l0`Fire_Bolt/FireBolt_01_Dark_Green02_60ft_2800x400.webm`],
            "90ft": [l0`Fire_Bolt/FireBolt_01_Dark_Green02_90ft_4000x400.webm`]
          },
          palegreen: {
            "05ft": [l0`Fire_Bolt/FireBolt_01_Regular_Green02_05ft_600x400.webm`],
            "15ft": [l0`Fire_Bolt/FireBolt_01_Regular_Green02_15ft_1000x400.webm`],
            "30ft": [l0`Fire_Bolt/FireBolt_01_Regular_Green02_30ft_1600x400.webm`],
            "60ft": [l0`Fire_Bolt/FireBolt_01_Regular_Green02_60ft_2800x400.webm`],
            "90ft": [l0`Fire_Bolt/FireBolt_01_Regular_Green02_90ft_4000x400.webm`]
          }
        }
      },
      guidingbolt: {
        "01": {
          yellowblue: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_BlueYellow_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_BlueYellow_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_BlueYellow_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_BlueYellow_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_BlueYellow_90ft_4000x400.webm`]
          },
          greenorange: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_GreenOrange_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_GreenOrange_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_GreenOrange_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_GreenOrange_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_GreenOrange_90ft_4000x400.webm`]
          },
          purplepink: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_PurplePink_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_PurplePink_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_PurplePink_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_PurplePink_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_PurplePink_90ft_4000x400.webm`]
          },
          whiteblue: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_01_Dark_BlueWhite_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_01_Dark_BlueWhite_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_01_Dark_BlueWhite_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_01_Dark_BlueWhite_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_01_Dark_BlueWhite_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Pink_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Pink_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Pink_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Pink_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Pink_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Red_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Red_90ft_4000x400.webm`]
          }
        },
        "02": {
          yellowblue: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_BlueYellow_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_BlueYellow_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_BlueYellow_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_BlueYellow_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_BlueYellow_90ft_4000x400.webm`]
          },
          greenorange: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_GreenOrange_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_GreenOrange_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_GreenOrange_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_GreenOrange_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_GreenOrange_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Pink_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Pink_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Pink_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Pink_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Pink_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Red_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Red_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Red_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Red_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Red_90ft_4000x400.webm`]
          },
          purplepink: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_PurplePink_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_PurplePink_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_PurplePink_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_PurplePink_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_PurplePink_90ft_4000x400.webm`]
          },
          whiteblue: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_02_Dark_BlueWhite_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_02_Dark_BlueWhite_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_02_Dark_BlueWhite_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_02_Dark_BlueWhite_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_02_Dark_BlueWhite_90ft_4000x400.webm`]
          }
        }
      },
      magicmissile: {
        "01": {
          blue: {
            "05ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_05ft_01_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_05ft_02_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_05ft_03_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_05ft_04_600x400.webm`
            ],
            "15ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_15ft_01_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_15ft_02_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_15ft_03_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_15ft_04_1000x400.webm`
            ],
            "30ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_30ft_01_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_30ft_02_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_30ft_03_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_30ft_04_1600x400.webm`
            ],
            "60ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_60ft_01_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_60ft_02_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_60ft_03_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_60ft_04_2800x400.webm`
            ],
            "90ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_90ft_01_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_90ft_02_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_90ft_03_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Blue_90ft_04_4000x400.webm`
            ]
          },
          darkred: {
            "05ft": [
              l1`Magic_Missile/MagicMissile_01_Dark_Red_05ft_01_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_05ft_02_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_05ft_03_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_05ft_04_600x400.webm`
            ],
            "15ft": [
              l1`Magic_Missile/MagicMissile_01_Dark_Red_15ft_01_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_15ft_02_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_15ft_03_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_15ft_04_1000x400.webm`
            ],
            "30ft": [
              l1`Magic_Missile/MagicMissile_01_Dark_Red_30ft_01_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_30ft_02_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_30ft_03_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_30ft_04_1600x400.webm`
            ],
            "60ft": [
              l1`Magic_Missile/MagicMissile_01_Dark_Red_60ft_01_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_60ft_02_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_60ft_03_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_60ft_04_2800x400.webm`
            ],
            "90ft": [
              l1`Magic_Missile/MagicMissile_01_Dark_Red_90ft_01_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_90ft_02_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_90ft_03_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Dark_Red_90ft_04_4000x400.webm`
            ]
          },
          green: {
            "05ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Green_05ft_01_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_05ft_02_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_05ft_03_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_05ft_04_600x400.webm`
            ],
            "15ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Green_15ft_01_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_15ft_02_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_15ft_03_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_15ft_04_1000x400.webm`
            ],
            "30ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Green_30ft_01_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_30ft_02_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_30ft_03_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_30ft_04_1600x400.webm`
            ],
            "60ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Green_60ft_01_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_60ft_02_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_60ft_03_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_60ft_04_2800x400.webm`
            ],
            "90ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Green_90ft_01_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_90ft_02_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_90ft_03_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Green_90ft_04_4000x400.webm`
            ]
          },
          purple: {
            "05ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_05ft_01_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_05ft_02_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_05ft_03_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_05ft_04_600x400.webm`
            ],
            "15ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_15ft_01_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_15ft_02_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_15ft_03_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_15ft_04_1000x400.webm`
            ],
            "30ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_30ft_01_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_30ft_02_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_30ft_03_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_30ft_04_1600x400.webm`
            ],
            "60ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_60ft_01_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_60ft_02_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_60ft_03_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_60ft_04_2800x400.webm`
            ],
            "90ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_90ft_01_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_90ft_02_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_90ft_03_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_90ft_04_4000x400.webm`
            ]
          },
          yellow: {
            "05ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_05ft_01_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_05ft_02_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_05ft_03_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_05ft_04_600x400.webm`
            ],
            "15ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_15ft_01_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_15ft_02_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_15ft_03_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_15ft_04_1000x400.webm`
            ],
            "30ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_30ft_01_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_30ft_02_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_30ft_03_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_30ft_04_1600x400.webm`
            ],
            "60ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_60ft_01_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_60ft_02_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_60ft_03_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_60ft_04_2800x400.webm`
            ],
            "90ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_90ft_01_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_90ft_02_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_90ft_03_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Yellow_90ft_04_4000x400.webm`
            ]
          },
          orange: {
            "05ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_05ft_01_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_05ft_02_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_05ft_03_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_05ft_04_600x400.webm`
            ],
            "15ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_15ft_01_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_15ft_02_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_15ft_03_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_15ft_04_1000x400.webm`
            ],
            "30ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_30ft_01_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_30ft_02_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_30ft_03_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_30ft_04_1600x400.webm`
            ],
            "60ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_60ft_01_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_60ft_02_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_60ft_03_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_60ft_04_2800x400.webm`
            ],
            "90ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_90ft_01_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_90ft_02_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_90ft_03_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Orange_90ft_04_4000x400.webm`
            ]
          }
        }
      },
      rayoffrost: {
        "01": {
          blue: {
            "05ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Green_90ft_4000x400.webm`]
          },
          purpleteal: {
            "05ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_PurpleTeal_05ft_600x400.webm`],
            "15ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_PurpleTeal_15ft_1000x400.webm`],
            "30ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_PurpleTeal_30ft_1600x400.webm`],
            "60ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_PurpleTeal_60ft_2800x400.webm`],
            "90ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_PurpleTeal_90ft_4000x400.webm`]
          },
          yellowblue: {
            "05ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_BlueYellow_05ft_600x400.webm`],
            "15ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_BlueYellow_15ft_1000x400.webm`],
            "30ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_BlueYellow_30ft_1600x400.webm`],
            "60ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_BlueYellow_60ft_2800x400.webm`],
            "90ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_BlueYellow_90ft_4000x400.webm`]
          }
        }
      },
      scorchingray: {
        "01": {
          orange: {
            "05ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Orange_90ft_4000x400.webm`]
          },
          blue: {
            "05ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Green_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Pink_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Pink_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Pink_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Pink_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Pink_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Purple_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Purple_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Purple_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Purple_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Purple_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Red_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Red_90ft_4000x400.webm`]
          },
          yellow: {
            "05ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Yellow_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Yellow_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Yellow_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Yellow_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Yellow_90ft_4000x400.webm`]
          },
          rainbow01: {
            "05ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Rainbow01_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Rainbow01_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Rainbow01_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Rainbow01_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Rainbow01_90ft_4000x400.webm`]
          },
          rainbow02: {
            "05ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Rainbow02_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Rainbow02_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Rainbow02_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Rainbow02_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Rainbow02_90ft_4000x400.webm`]
          }
        },
        "02": {
          blue: {
            "05ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_05ft_01_600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_05ft_02_600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_05ft_03_600x400.webm`
            ],
            "15ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_15ft_01_1000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_15ft_02_1000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_15ft_03_1000x400.webm`
            ],
            "30ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_30ft_01_1600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_30ft_02_1600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_30ft_03_1600x400.webm`
            ],
            "60ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_60ft_01_2800x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_60ft_02_2800x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_60ft_03_2800x400.webm`
            ],
            "90ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_90ft_01_4000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_90ft_02_4000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Blue_90ft_03_4000x400.webm`
            ]
          },
          green: {
            "05ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_05ft_01_600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_05ft_02_600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_05ft_03_600x400.webm`
            ],
            "15ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_15ft_01_1000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_15ft_02_1000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_15ft_03_1000x400.webm`
            ],
            "30ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_30ft_01_1600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_30ft_02_1600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_30ft_03_1600x400.webm`
            ],
            "60ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_60ft_01_2800x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_60ft_02_2800x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_60ft_03_2800x400.webm`
            ],
            "90ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_90ft_01_4000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_90ft_02_4000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Green_90ft_03_4000x400.webm`
            ]
          },
          orange: {
            "05ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_05ft_01_600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_05ft_02_600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_05ft_03_600x400.webm`
            ],
            "15ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_15ft_01_1000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_15ft_02_1000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_15ft_03_1000x400.webm`
            ],
            "30ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_30ft_01_1600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_30ft_02_1600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_30ft_03_1600x400.webm`
            ],
            "60ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_60ft_01_2800x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_60ft_02_2800x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_60ft_03_2800x400.webm`
            ],
            "90ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_90ft_01_4000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_90ft_02_4000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Orange_90ft_03_4000x400.webm`
            ]
          },
          pink: {
            "05ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_05ft_01_600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_05ft_02_600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_05ft_03_600x400.webm`
            ],
            "15ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_15ft_01_1000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_15ft_02_1000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_15ft_03_1000x400.webm`
            ],
            "30ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_30ft_01_1600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_30ft_02_1600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_30ft_03_1600x400.webm`
            ],
            "60ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_60ft_01_2800x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_60ft_02_2800x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_60ft_03_2800x400.webm`
            ],
            "90ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_90ft_01_4000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_90ft_02_4000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Pink_90ft_03_4000x400.webm`
            ]
          },
          purple: {
            "05ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_05ft_01_600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_05ft_02_600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_05ft_03_600x400.webm`
            ],
            "15ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_15ft_01_1000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_15ft_02_1000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_15ft_03_1000x400.webm`
            ],
            "30ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_30ft_01_1600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_30ft_02_1600x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_30ft_03_1600x400.webm`
            ],
            "60ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_60ft_01_2800x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_60ft_02_2800x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_60ft_03_2800x400.webm`
            ],
            "90ft": [
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_90ft_01_4000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_90ft_02_4000x400.webm`,
              l2`Scorching_Ray/ScorchingRay_02_Regular_Purple_90ft_03_4000x400.webm`
            ]
          }
        },
        loop: {
          orange: {
            "05ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Orange_90ft_4000x400.webm`]
          },
          blue: {
            "05ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Green_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Pink_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Pink_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Pink_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Pink_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRayLoop_01_Regular_Pink_90ft_4000x400.webm`]
          }
        }
      },
      witchbolt: {
        "01": {
          blue: {
            "05ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Green_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Red_05ft_600x400.webm`],
            "15ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Red_90ft_4000x400.webm`]
          },
          yellow: {
            "05ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Yellow_05ft_600x400.webm`],
            "15ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Yellow_15ft_1000x400.webm`],
            "30ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Yellow_30ft_1600x400.webm`],
            "60ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Yellow_60ft_2800x400.webm`],
            "90ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Yellow_90ft_4000x400.webm`]
          },
          darkred: {
            "05ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Red_05ft_600x400.webm`],
            "15ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Red_15ft_1000x400.webm`],
            "30ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Red_30ft_1600x400.webm`],
            "60ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Red_60ft_2800x400.webm`],
            "90ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Red_90ft_4000x400.webm`]
          },
          darkgreen: {
            "05ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Green_05ft_600x400.webm`],
            "15ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Green_15ft_1000x400.webm`],
            "30ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Green_30ft_1600x400.webm`],
            "60ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Green_60ft_2800x400.webm`],
            "90ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Green_90ft_4000x400.webm`]
          },
          darkpurple: {
            "05ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Purple_05ft_600x400.webm`],
            "15ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Purple_15ft_1000x400.webm`],
            "30ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Purple_30ft_1600x400.webm`],
            "60ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Purple_60ft_2800x400.webm`],
            "90ft": [l1`Witch_Bolt/WitchBolt_01_Dark_Purple_90ft_4000x400.webm`]
          }
        }
      }
    },
    generic: {
      conduit: {
        square: {
          purpleblue: {
            "05ft": [lg`Energy/EnergyConduitSquare_01_Regular_BluePurple_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyConduitSquare_01_Regular_BluePurple_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyConduitSquare_01_Regular_BluePurple_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyConduitSquare_01_Regular_BluePurple_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyConduitSquare_01_Regular_BluePurple_90ft_4000x400.webm`]
          },
          greenyellow: {
            "05ft": [lg`Energy/EnergyConduitSquare_01_Regular_GreenYellow_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyConduitSquare_01_Regular_GreenYellow_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyConduitSquare_01_Regular_GreenYellow_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyConduitSquare_01_Regular_GreenYellow_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyConduitSquare_01_Regular_GreenYellow_90ft_4000x400.webm`]
          }
        },
        circle: {
          purpleblue: {
            "05ft": [lg`Energy/EnergyConduitCircle_01_Regular_BluePurple_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyConduitCircle_01_Regular_BluePurple_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyConduitCircle_01_Regular_BluePurple_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyConduitCircle_01_Regular_BluePurple_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyConduitCircle_01_Regular_BluePurple_90ft_4000x400.webm`]
          },
          greenyellow: {
            "05ft": [lg`Energy/EnergyConduitCircle_01_Regular_GreenYellow_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyConduitCircle_01_Regular_GreenYellow_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyConduitCircle_01_Regular_GreenYellow_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyConduitCircle_01_Regular_GreenYellow_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyConduitCircle_01_Regular_GreenYellow_90ft_4000x400.webm`]
          }
        }
      },
      energybeam: {
        "01": {
          blue: {
            "15ft": [lg`Energy/EnergyBeam_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_01_Regular_Blue_90ft_4000x400.webm`]
          },
          bluegreen: {
            "15ft": [lg`Energy/EnergyBeam_01_Regular_BlueGreen_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_01_Regular_BlueGreen_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_01_Regular_BlueGreen_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_01_Regular_BlueGreen_90ft_4000x400.webm`]
          },
          darkgreen: {
            "15ft": [lg`Energy/EnergyBeam_01_Dark_Green_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_01_Dark_Green_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_01_Dark_Green_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_01_Dark_Green_90ft_4000x400.webm`]
          },
          darkred: {
            "15ft": [lg`Energy/EnergyBeam_01_Dark_Red_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_01_Dark_Red_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_01_Dark_Red_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_01_Dark_Red_90ft_4000x400.webm`]
          },
          red: {
            "15ft": [lg`Energy/EnergyBeam_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_01_Regular_Red_90ft_4000x400.webm`]
          }
        },
        "02": {
          darkgreenpurple: {
            "05ft": [lg`Energy/EnergyBeam_02_Dark_GreenPurple_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyBeam_02_Dark_GreenPurple_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_02_Dark_GreenPurple_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_02_Dark_GreenPurple_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_02_Dark_GreenPurple_90ft_4000x400.webm`]
          },
          darkpurplered: {
            "05ft": [lg`Energy/EnergyBeam_02_Dark_PurpleRed_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyBeam_02_Dark_PurpleRed_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_02_Dark_PurpleRed_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_02_Dark_PurpleRed_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_02_Dark_PurpleRed_90ft_4000x400.webm`]
          },
          bluepink: {
            "05ft": [lg`Energy/EnergyBeam_02_Regular_BluePink_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyBeam_02_Regular_BluePink_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_02_Regular_BluePink_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_02_Regular_BluePink_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_02_Regular_BluePink_90ft_4000x400.webm`]
          },
          greenyellow: {
            "05ft": [lg`Energy/EnergyBeam_02_Regular_GreenYellow_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyBeam_02_Regular_GreenYellow_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_02_Regular_GreenYellow_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_02_Regular_GreenYellow_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_02_Regular_GreenYellow_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Energy/EnergyBeam_02_Regular_Red_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyBeam_02_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_02_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_02_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_02_Regular_Red_90ft_4000x400.webm`]
          }
        },
        "03": {
          darkgreenpurple: {
            "05ft": [lg`Energy/EnergyBeam_03_Dark_GreenPurple_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyBeam_03_Dark_GreenPurple_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_03_Dark_GreenPurple_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_03_Dark_GreenPurple_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_03_Dark_GreenPurple_90ft_4000x400.webm`]
          },
          darkpurplered: {
            "05ft": [lg`Energy/EnergyBeam_03_Dark_PurpleRed_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyBeam_03_Dark_PurpleRed_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_03_Dark_PurpleRed_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_03_Dark_PurpleRed_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_03_Dark_PurpleRed_90ft_4000x400.webm`]
          },
          bluepink: {
            "05ft": [lg`Energy/EnergyBeam_03_Regular_BluePink_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyBeam_03_Regular_BluePink_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_03_Regular_BluePink_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_03_Regular_BluePink_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_03_Regular_BluePink_90ft_4000x400.webm`]
          },
          greenyellow: {
            "05ft": [lg`Energy/EnergyBeam_03_Regular_GreenYellow_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyBeam_03_Regular_GreenYellow_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_03_Regular_GreenYellow_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_03_Regular_GreenYellow_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_03_Regular_GreenYellow_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Energy/EnergyBeam_03_Regular_Red_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyBeam_03_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_03_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_03_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_03_Regular_Red_90ft_4000x400.webm`]
          }
        },
        reverse: {
          blue: {
            "15ft": [lg`Energy/EnergyBeamReverse_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeamReverse_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeamReverse_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeamReverse_01_Regular_Blue_90ft_4000x400.webm`]
          },
          bluegreen: {
            "15ft": [lg`Energy/EnergyBeamReverse_01_Regular_BlueGreen_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeamReverse_01_Regular_BlueGreen_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeamReverse_01_Regular_BlueGreen_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeamReverse_01_Regular_BlueGreen_90ft_4000x400.webm`]
          },
          darkgreen: {
            "15ft": [lg`Energy/EnergyBeamReverse_01_Dark_Green_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeamReverse_01_Dark_Green_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeamReverse_01_Dark_Green_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeamReverse_01_Dark_Green_90ft_4000x400.webm`]
          },
          darkred: {
            "15ft": [lg`Energy/EnergyBeamReverse_01_Dark_Red_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeamReverse_01_Dark_Red_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeamReverse_01_Dark_Red_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeamReverse_01_Dark_Red_90ft_4000x400.webm`]
          },
          red: {
            "15ft": [lg`Energy/EnergyBeamReverse_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeamReverse_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeamReverse_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeamReverse_01_Regular_Red_90ft_4000x400.webm`]
          }
        }
      },
      energystrand: {
        "01": {
          darkgreen: {
            "05ft": [
              lg`Energy/EnergyStrand_01_Dark_Green_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Green_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Green_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Green_05ft_600x400.webm`
            ],
            "15ft": [
              lg`Energy/EnergyStrand_01_Dark_Green_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Green_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Green_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Green_15ft_1000x400.webm`
            ],
            "30ft": [
              lg`Energy/EnergyStrand_01_Dark_Green_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Green_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Green_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Green_30ft_1600x400.webm`
            ],
            "60ft": [
              lg`Energy/EnergyStrand_01_Dark_Green_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Green_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Green_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Green_60ft_2800x400.webm`
            ],
            "90ft": [
              lg`Energy/EnergyStrand_01_Dark_Green_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Green_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Green_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Green_90ft_4000x400.webm`
            ]
          },
          darkpurple: {
            "05ft": [
              lg`Energy/EnergyStrand_01_Dark_Purple_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Purple_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Purple_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Purple_05ft_600x400.webm`
            ],
            "15ft": [
              lg`Energy/EnergyStrand_01_Dark_Purple_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Purple_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Purple_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Purple_15ft_1000x400.webm`
            ],
            "30ft": [
              lg`Energy/EnergyStrand_01_Dark_Purple_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Purple_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Purple_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Purple_30ft_1600x400.webm`
            ],
            "60ft": [
              lg`Energy/EnergyStrand_01_Dark_Purple_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Purple_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Purple_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Purple_60ft_2800x400.webm`
            ],
            "90ft": [
              lg`Energy/EnergyStrand_01_Dark_Purple_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Purple_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Purple_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Purple_90ft_4000x400.webm`
            ]
          },
          darkred: {
            "05ft": [
              lg`Energy/EnergyStrand_01_Dark_Red_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Red_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Red_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Red_05ft_600x400.webm`
            ],
            "15ft": [
              lg`Energy/EnergyStrand_01_Dark_Red_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Red_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Red_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Red_15ft_1000x400.webm`
            ],
            "30ft": [
              lg`Energy/EnergyStrand_01_Dark_Red_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Red_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Red_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Red_30ft_1600x400.webm`
            ],
            "60ft": [
              lg`Energy/EnergyStrand_01_Dark_Red_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Red_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Red_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Red_60ft_2800x400.webm`
            ],
            "90ft": [
              lg`Energy/EnergyStrand_01_Dark_Red_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_02_Dark_Red_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_03_Dark_Red_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_04_Dark_Red_90ft_4000x400.webm`
            ]
          },
          blue: {
            "05ft": [
              lg`Energy/EnergyStrand_01_Regular_Blue_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Blue_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Blue_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Blue_05ft_600x400.webm`
            ],
            "15ft": [
              lg`Energy/EnergyStrand_01_Regular_Blue_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Blue_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Blue_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Blue_15ft_1000x400.webm`
            ],
            "30ft": [
              lg`Energy/EnergyStrand_01_Regular_Blue_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Blue_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Blue_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Blue_30ft_1600x400.webm`
            ],
            "60ft": [
              lg`Energy/EnergyStrand_01_Regular_Blue_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Blue_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Blue_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Blue_60ft_2800x400.webm`
            ],
            "90ft": [
              lg`Energy/EnergyStrand_01_Regular_Blue_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Blue_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Blue_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Blue_90ft_4000x400.webm`
            ]
          },
          orange: {
            "05ft": [
              lg`Energy/EnergyStrand_01_Regular_Orange_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Orange_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Orange_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Orange_05ft_600x400.webm`
            ],
            "15ft": [
              lg`Energy/EnergyStrand_01_Regular_Orange_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Orange_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Orange_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Orange_15ft_1000x400.webm`
            ],
            "30ft": [
              lg`Energy/EnergyStrand_01_Regular_Orange_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Orange_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Orange_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Orange_30ft_1600x400.webm`
            ],
            "60ft": [
              lg`Energy/EnergyStrand_01_Regular_Orange_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Orange_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Orange_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Orange_60ft_2800x400.webm`
            ],
            "90ft": [
              lg`Energy/EnergyStrand_01_Regular_Orange_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Orange_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Orange_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Orange_90ft_4000x400.webm`
            ]
          },
          purple: {
            "05ft": [
              lg`Energy/EnergyStrand_01_Regular_Purple_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Purple_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Purple_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Purple_05ft_600x400.webm`
            ],
            "15ft": [
              lg`Energy/EnergyStrand_01_Regular_Purple_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Purple_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Purple_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Purple_15ft_1000x400.webm`
            ],
            "30ft": [
              lg`Energy/EnergyStrand_01_Regular_Purple_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Purple_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Purple_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Purple_30ft_1600x400.webm`
            ],
            "60ft": [
              lg`Energy/EnergyStrand_01_Regular_Purple_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Purple_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Purple_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Purple_60ft_2800x400.webm`
            ],
            "90ft": [
              lg`Energy/EnergyStrand_01_Regular_Purple_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Purple_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Purple_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Purple_90ft_4000x400.webm`
            ]
          },
          red: {
            "05ft": [lg`Energy/EnergyStrand_05_Regular_Red_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyStrand_05_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyStrand_05_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyStrand_05_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyStrand_05_Regular_Red_90ft_4000x400.webm`]
          }
        },
        "02": {
          darkgreen: {
            "05ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Green_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Green_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Green_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Green_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Green_90ft_4000x400.webm`]
          },
          darkpurple: {
            "05ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Purple_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Purple_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Purple_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Purple_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Purple_90ft_4000x400.webm`]
          },
          darkred: {
            "05ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Red_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Red_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Red_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Red_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyStrand_Multiple01_Dark_Red_90ft_4000x400.webm`]
          },
          blue: {
            "05ft": [lg`Energy/EnergyStrand_Multiple01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyStrand_Multiple01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyStrand_Multiple01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyStrand_Multiple01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyStrand_Multiple01_Regular_Blue_90ft_4000x400.webm`]
          },
          purple: {
            "05ft": [lg`Energy/EnergyStrand_Multiple01_Regular_Purple_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyStrand_Multiple01_Regular_Purple_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyStrand_Multiple01_Regular_Purple_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyStrand_Multiple01_Regular_Purple_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyStrand_Multiple01_Regular_Purple_90ft_4000x400.webm`]
          }
        },
        "03": {
          bluepink: {
            "05ft": [lg`Energy/EnergyStrand_Multiple02_Regular_BluePink_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyStrand_Multiple02_Regular_BluePink_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyStrand_Multiple02_Regular_BluePink_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyStrand_Multiple02_Regular_BluePink_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyStrand_Multiple02_Regular_BluePink_90ft_4000x400.webm`]
          },
          greenyellow: {
            "05ft": [lg`Energy/EnergyStrand_Multiple02_Regular_GreenYellow_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyStrand_Multiple02_Regular_GreenYellow_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyStrand_Multiple02_Regular_GreenYellow_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyStrand_Multiple02_Regular_GreenYellow_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyStrand_Multiple02_Regular_GreenYellow_90ft_4000x400.webm`]
          },
          darkpurplered: {
            "05ft": [lg`Energy/EnergyStrand_Multiple02_Dark_PurpleRed_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyStrand_Multiple02_Dark_PurpleRed_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyStrand_Multiple02_Dark_PurpleRed_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyStrand_Multiple02_Dark_PurpleRed_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyStrand_Multiple02_Dark_PurpleRed_90ft_4000x400.webm`]
          },
          darkgreenpurple: {
            "05ft": [lg`Energy/EnergyStrand_Multiple02_Dark_GreenPurple_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyStrand_Multiple02_Dark_GreenPurple_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyStrand_Multiple02_Dark_GreenPurple_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyStrand_Multiple02_Dark_GreenPurple_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyStrand_Multiple02_Dark_GreenPurple_90ft_4000x400.webm`]
          }
        }
      },
      heart: {
        "01": {
          pinkyellow: {
            "05ft": [lg`RangedSpell/ProjectileHeart01_01_Regular_PinkYellow_05ft_600x400.webm`],
            "15ft": [lg`RangedSpell/ProjectileHeart01_01_Regular_PinkYellow_15ft_1000x400.webm`],
            "30ft": [lg`RangedSpell/ProjectileHeart01_01_Regular_PinkYellow_30ft_1600x400.webm`],
            "60ft": [lg`RangedSpell/ProjectileHeart01_01_Regular_PinkYellow_60ft_2800x400.webm`],
            "90ft": [lg`RangedSpell/ProjectileHeart01_01_Regular_PinkYellow_90ft_4000x400.webm`]
          }
        }
      },
      iceshard: {
        "01": {
          blue: {
            "05ft": [lg`RangedSpell/ProjectileIceShard01_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`RangedSpell/ProjectileIceShard01_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`RangedSpell/ProjectileIceShard01_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`RangedSpell/ProjectileIceShard01_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`RangedSpell/ProjectileIceShard01_01_Regular_Blue_90ft_4000x400.webm`]
          }
        }
      },
      leaves: {
        "01": {
          blue: {
            "05ft": [lg`Nature/SwirlingLeaves01_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Nature/SwirlingLeaves01_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Nature/SwirlingLeaves01_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Nature/SwirlingLeaves01_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Nature/SwirlingLeaves01_01_Regular_Blue_90ft_4000x400.webm`]
          },
          greenorange: {
            "05ft": [lg`Nature/SwirlingLeaves01_01_Regular_GreenOrange_05ft_600x400.webm`],
            "15ft": [lg`Nature/SwirlingLeaves01_01_Regular_GreenOrange_15ft_1000x400.webm`],
            "30ft": [lg`Nature/SwirlingLeaves01_01_Regular_GreenOrange_30ft_1600x400.webm`],
            "60ft": [lg`Nature/SwirlingLeaves01_01_Regular_GreenOrange_60ft_2800x400.webm`],
            "90ft": [lg`Nature/SwirlingLeaves01_01_Regular_GreenOrange_90ft_4000x400.webm`]
          },
          orangepink: {
            "05ft": [lg`Nature/SwirlingLeaves01_01_Regular_OrangePink_05ft_600x400.webm`],
            "15ft": [lg`Nature/SwirlingLeaves01_01_Regular_OrangePink_15ft_1000x400.webm`],
            "30ft": [lg`Nature/SwirlingLeaves01_01_Regular_OrangePink_30ft_1600x400.webm`],
            "60ft": [lg`Nature/SwirlingLeaves01_01_Regular_OrangePink_60ft_2800x400.webm`],
            "90ft": [lg`Nature/SwirlingLeaves01_01_Regular_OrangePink_90ft_4000x400.webm`]
          },
          pink: {
            "05ft": [lg`Nature/SwirlingLeaves01_01_Regular_Pink_05ft_600x400.webm`],
            "15ft": [lg`Nature/SwirlingLeaves01_01_Regular_Pink_15ft_1000x400.webm`],
            "30ft": [lg`Nature/SwirlingLeaves01_01_Regular_Pink_30ft_1600x400.webm`],
            "60ft": [lg`Nature/SwirlingLeaves01_01_Regular_Pink_60ft_2800x400.webm`],
            "90ft": [lg`Nature/SwirlingLeaves01_01_Regular_Pink_90ft_4000x400.webm`]
          }
        }
      },
      musicnote: {
        "01": {
          greenyellow: {
            "05ft": [lg`RangedSpell/ProjectileMusicNote01_01_Regular_GreenYellow_05ft_600x400.webm`],
            "15ft": [lg`RangedSpell/ProjectileMusicNote01_01_Regular_GreenYellow_15ft_1000x400.webm`],
            "30ft": [lg`RangedSpell/ProjectileMusicNote01_01_Regular_GreenYellow_30ft_1600x400.webm`],
            "60ft": [lg`RangedSpell/ProjectileMusicNote01_01_Regular_GreenYellow_60ft_2800x400.webm`],
            "90ft": [lg`RangedSpell/ProjectileMusicNote01_01_Regular_GreenYellow_90ft_4000x400.webm`]
          }
        }
      },
      skull: {
        "01": {
          purplepink: {
            "05ft": [lg`RangedSpell/ProjectileSkull01_01_Regular_PinkPurple_05ft_600x400.webm`],
            "15ft": [lg`RangedSpell/ProjectileSkull01_01_Regular_PinkPurple_15ft_1000x400.webm`],
            "30ft": [lg`RangedSpell/ProjectileSkull01_01_Regular_PinkPurple_30ft_1600x400.webm`],
            "60ft": [lg`RangedSpell/ProjectileSkull01_01_Regular_PinkPurple_60ft_2800x400.webm`],
            "90ft": [lg`RangedSpell/ProjectileSkull01_01_Regular_PinkPurple_90ft_4000x400.webm`]
          }
        }
      }
    }
  };
  JB2APATREONDB.melee = {
    creature: {
      bite: {
        "01": {
          red: [lg`Creature/Bite_01_Regular_Red_400x400.webm`],
          blue: [lg`Creature/Bite_01_Regular_Blue_400x400.webm`],
          green: [lg`Creature/Bite_01_Regular_Green_400x400.webm`],
          grey: [lg`Creature/Bite_01_Regular_Grey_400x400.webm`],
          orange: [lg`Creature/Bite_01_Regular_Orange_400x400.webm`],
          purple: [lg`Creature/Bite_01_Regular_Purple_400x400.webm`],
          yellow: [lg`Creature/Bite_01_Regular_Yellow_400x400.webm`]
        }
      },
      claw: {
        "01": {
          blue: [lg`Creature/Claws_01_Bright_Blue_400x400.webm`],
          brown: [lg`Creature/Claws_01_Regular_Brown_400x400.webm`],
          darkred: [lg`Creature/Claws_01_Dark_Red_400x400.webm`],
          green: [lg`Creature/Claws_01_Bright_Green_400x400.webm`],
          orange: [lg`Creature/Claws_01_Bright_Orange_400x400.webm`],
          purple: [lg`Creature/Claws_01_Bright_Purple_400x400.webm`],
          red: [lg`Creature/Claws_01_Regular_Red_400x400.webm`],
          yellow: [lg`Creature/Claws_01_Bright_Yellow_400x400.webm`]
        }
      }
    },
    generic: {
      "1hs": {
        "01": {
          white: [lg`Weapon_Attacks/Melee/DmgSlashing_01_Regular_Yellow_1Handed_800x600.webm`]
        }
      },
      "2hs": {
        "01": {
          white: [lg`Weapon_Attacks/Melee/DmgSlashing_01_Regular_Yellow_2Handed_800x600.webm`]
        }
      },
      "1hb": {
        "01": {
          white: [lg`Weapon_Attacks/Melee/DmgBludgeoning_01_Regular_Yellow_1Handed_800x600.webm`]
        }
      },
      "2hb": {
        "01": {
          white: [lg`Weapon_Attacks/Melee/DmgBludgeoning_01_Regular_Yellow_2Handed_800x600.webm`]
        }
      },
      "1hp": {
        "01": {
          white: [lg`Weapon_Attacks/Melee/DmgPiercing_01_Regular_Yellow_1Handed_800x600.webm`]
        }
      },
      "2hp": {
        "01": {
          white: [lg`Weapon_Attacks/Melee/DmgPiercing_01_Regular_Yellow_2Handed_800x600.webm`]
        }
      }
    },
    weapon: {
      club: {
        "01": {
          white: [
            [lg`Weapon_Attacks/Melee/Club01_01_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_02_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_03_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_04_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_05_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_06_Regular_White_800x600.webm`]
          ],
          blue: [
            [lg`Weapon_Attacks/Melee/Club01_01_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_02_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_03_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_04_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_05_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_06_Regular_Blue_800x600.webm`]
          ],
          orange: [
            [lg`Weapon_Attacks/Melee/Club01_01_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_02_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_03_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_04_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_05_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_06_Regular_Orange_800x600.webm`]
          ],
          purple: [
            [lg`Weapon_Attacks/Melee/Club01_01_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_02_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_03_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_04_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_05_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_06_Regular_Purple_800x600.webm`]
          ],
          darkorangepurple: [
            [lg`Weapon_Attacks/Melee/Club01_01_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_02_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_03_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_04_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_05_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_06_Dark_OrangePurple_800x600.webm`]
          ]
        }
      },
      dagger: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/Dagger02_01_Regular_White_800x600.webm`],
          orange: [lg`Weapon_Attacks/Melee/Dagger02_Fire_Regular_Orange_800x600.webm`],
          pink: [lg`Weapon_Attacks/Melee/Dagger02_Fire_Regular_Pink_800x600.webm`],
          red: [lg`Weapon_Attacks/Melee/Dagger02_Fire_Regular_Red_800x600.webm`],
          yellow: [lg`Weapon_Attacks/Melee/Dagger02_Fire_Regular_Yellow_800x600.webm`],
          purple: [lg`Weapon_Attacks/Melee/Dagger02_Fire_Dark_Purple_800x600.webm`],
          blue: [lg`Weapon_Attacks/Melee/Dagger02_Fire_Regular_Blue_800x600.webm`],
          green: [lg`Weapon_Attacks/Melee/Dagger02_Fire_Regular_Green_800x600.webm`],
          darkpurple: [lg`Weapon_Attacks/Melee/Dagger02_Fire_Dark_Purple_800x600.webm`]
        }
      },
      falchion: {
        "01": {
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Falchion01_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_06_Dark_OrangePurple_800x600.webm`
          ],
          black: [
            lg`Weapon_Attacks/Melee/Falchion01_01_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_02_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_03_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_04_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_05_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_06_Regular_Black_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Falchion01_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Falchion01_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Falchion01_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_06_Regular_Purple_800x600.webm`
          ],
          white: [
            lg`Weapon_Attacks/Melee/Falchion01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_06_Regular_White_800x600.webm`
          ]
        }
      },
      flurryofblows: {
        "magical": {
          darkred: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Dark_Red_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Dark_Red_Magical02_800x600.webm`
          ],
          darkpurple: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Dark_Purple_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Dark_Purple_Magical02_800x600.webm`
          ],
          blue: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Blue_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Blue_Magical02_800x600.webm`
          ],
          green: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Green_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Green_Magical02_800x600.webm`
          ],
          orange: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Orange_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Orange_Magical02_800x600.webm`
          ],
          purplepink: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_PinkPurple_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_PinkPurple_Magical02_800x600.webm`
          ],
          yellow: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Yellow_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Yellow_Magical02_800x600.webm`
          ]
        },
        "physical": {
          darkred: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Dark_Red_Physical01_800x600.webm`
          ],
          darkpurple: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Dark_Purple_Physical01_800x600.webm`
          ],
          blue: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Blue_Physical01_800x600.webm`
          ],
          green: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Green_Physical01_800x600.webm`
          ],
          orange: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Orange_Physical01_800x600.webm`
          ],
          purplepink: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_PinkPurple_Physical01_800x600.webm`
          ],
          yellow: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Yellow_Physical01_800x600.webm`
          ]
        },
        "nohit": {
          blue: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlowsNoHit_01_Regular_Blue_800x600.webm`
          ],
          yellow: [
            lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlowsNoHit_01_Regular_Yellow_800x600.webm`
          ]
        }
      },
      glaive: {
        "01": {
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Glaive01_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_06_Dark_OrangePurple_800x600.webm`
          ],
          black: [
            lg`Weapon_Attacks/Melee/Glaive01_01_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_02_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_03_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_04_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_05_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_06_Regular_Black_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Glaive01_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Glaive01_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Glaive01_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_06_Regular_Purple_800x600.webm`
          ],
          white: [
            lg`Weapon_Attacks/Melee/Glaive01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_06_Regular_White_800x600.webm`
          ]
        },
        "02": {
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Glaive02_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_06_Dark_OrangePurple_800x600.webm`
          ],
          black: [
            lg`Weapon_Attacks/Melee/Glaive02_01_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_02_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_03_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_04_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_05_Regular_Black_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_06_Regular_Black_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Glaive02_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Glaive02_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Glaive02_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_06_Regular_Purple_800x600.webm`
          ],
          white: [
            lg`Weapon_Attacks/Melee/Glaive02_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive02_06_Regular_White_800x600.webm`
          ]
        }
      },
      greataxe: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/GreatAxe01_01_Regular_White_800x600.webm`],
          orange: [lg`Weapon_Attacks/Melee/GreatAxe01_Fire_Regular_Orange_800x600.webm`],
          pink: [lg`Weapon_Attacks/Melee/GreatAxe01_Fire_Regular_Pink_800x600.webm`],
          red: [lg`Weapon_Attacks/Melee/GreatAxe01_Fire_Regular_Red_800x600.webm`],
          yellow: [lg`Weapon_Attacks/Melee/GreatAxe01_Fire_Regular_Yellow_800x600.webm`],
          purple: [lg`Weapon_Attacks/Melee/GreatAxe01_Fire_Dark_Purple_800x600.webm`],
          blue: [lg`Weapon_Attacks/Melee/GreatAxe01_Fire_Regular_Blue_800x600.webm`],
          green: [lg`Weapon_Attacks/Melee/GreatAxe01_Fire_Regular_Green_800x600.webm`]
        }
      },
      greatclub: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/GreatClub01_01_Regular_White_800x600.webm`],
          orange: [lg`Weapon_Attacks/Melee/GreatClub01_Fire_Regular_Orange_800x600.webm`],
          pink: [lg`Weapon_Attacks/Melee/GreatClub01_Fire_Regular_Pink_800x600.webm`],
          red: [lg`Weapon_Attacks/Melee/GreatClub01_Fire_Regular_Red_800x600.webm`],
          yellow: [lg`Weapon_Attacks/Melee/GreatClub01_Fire_Regular_Yellow_800x600.webm`],
          purple: [lg`Weapon_Attacks/Melee/GreatClub01_Fire_Dark_Purple_800x600.webm`],
          blue: [lg`Weapon_Attacks/Melee/GreatClub01_Fire_Regular_Blue_800x600.webm`],
          green: [lg`Weapon_Attacks/Melee/GreatClub01_Fire_Regular_Green_800x600.webm`]
        }
      },
      greatsword: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/GreatSword01_01_Regular_White_800x600.webm`],
          black: [lg`Weapon_Attacks/Melee/GreatSword01_Fire_Regular_Black_800x600.webm`],
          orange: [lg`Weapon_Attacks/Melee/GreatSword01_Fire_Regular_Orange_800x600.webm`],
          pink: [lg`Weapon_Attacks/Melee/GreatSword01_Fire_Regular_Pink_800x600.webm`],
          red: [lg`Weapon_Attacks/Melee/GreatSword01_Fire_Regular_Red_800x600.webm`],
          yellow: [lg`Weapon_Attacks/Melee/GreatSword01_Fire_Regular_Yellow_800x600.webm`],
          purple: [lg`Weapon_Attacks/Melee/GreatSword01_Fire_Dark_Purple_800x600.webm`],
          blue: [lg`Weapon_Attacks/Melee/GreatSword01_Fire_Regular_Blue_800x600.webm`],
          green: [lg`Weapon_Attacks/Melee/GreatSword01_Fire_Regular_Green_800x600.webm`]
        }
      },
      halberd: {
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Halberd01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_06_Regular_White_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Halberd01_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Halberd01_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Halberd01_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_06_Regular_Purple_800x600.webm`
          ],
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Halberd01_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_06_Dark_OrangePurple_800x600.webm`
          ]
        }
      },
      hammer: {
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Hammer01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_06_Regular_White_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Hammer01_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Hammer01_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Hammer01_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_06_Regular_Purple_800x600.webm`
          ],
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Hammer01_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_06_Dark_OrangePurple_800x600.webm`
          ],
          yellow: [
            lg`Weapon_Attacks/Melee/Hammer01_01_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_02_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_03_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_04_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_05_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Hammer01_06_Regular_Yellow_800x600.webm`
          ]
        }
      },
      handaxe: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/HandAxe02_01_Regular_White_800x600.webm`],
          orange: [lg`Weapon_Attacks/Melee/HandAxe02_Fire_Regular_Orange_800x600.webm`],
          pink: [lg`Weapon_Attacks/Melee/HandAxe02_Fire_Regular_Pink_800x600.webm`],
          red: [lg`Weapon_Attacks/Melee/HandAxe02_Fire_Regular_Red_800x600.webm`],
          yellow: [lg`Weapon_Attacks/Melee/HandAxe02_Fire_Regular_Yellow_800x600.webm`],
          purple: [lg`Weapon_Attacks/Melee/HandAxe02_Fire_Dark_Purple_800x600.webm`],
          blue: [lg`Weapon_Attacks/Melee/HandAxe02_Fire_Regular_Blue_800x600.webm`],
          green: [lg`Weapon_Attacks/Melee/HandAxe02_Fire_Regular_Green_800x600.webm`]
        }
      },
      lasersword: {
        "01": {
          blue: [lg`Weapon_Attacks/Melee/LaserSword01_01_Regular_Blue_800x600.webm`],
          blue02: [lg`Weapon_Attacks/Melee/LaserSword01_01_Regular_Blue02_800x600.webm`],
          blue03: [lg`Weapon_Attacks/Melee/LaserSword01_01_Regular_Blue03_800x600.webm`],
          orange: [lg`Weapon_Attacks/Melee/LaserSword01_01_Regular_Orange_800x600.webm`],
          red: [lg`Weapon_Attacks/Melee/LaserSword01_01_Regular_Red_800x600.webm`],
          yellow: [lg`Weapon_Attacks/Melee/LaserSword01_01_Regular_Yellow_800x600.webm`],
          darkred: [lg`Weapon_Attacks/Melee/LaserSword01_01_Dark_Red_800x600.webm`],
          darkwhite: [lg`Weapon_Attacks/Melee/LaserSword01_01_Dark_White_800x600.webm`],
          purple: [lg`Weapon_Attacks/Melee/LaserSword01_01_Regular_Purple_800x600.webm`],
          green: [lg`Weapon_Attacks/Melee/LaserSword01_01_Regular_Green_800x600.webm`],
          green02: [lg`Weapon_Attacks/Melee/LaserSword01_01_Regular_Green02_800x600.webm`],
          white: [lg`Weapon_Attacks/Melee/LaserSword01_01_Regular_White_800x600.webm`]
        }
      },
      mace: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/Legacy/Mace01_01_Regular_White_800x600.webm`],
          orange: [lg`Weapon_Attacks/Melee/Mace01_Fire_Regular_Orange_800x600.webm`],
          pink: [lg`Weapon_Attacks/Melee/Mace01_Fire_Regular_Pink_800x600.webm`],
          red: [lg`Weapon_Attacks/Melee/Mace01_Fire_Regular_Red_800x600.webm`],
          yellow: [lg`Weapon_Attacks/Melee/Mace01_Fire_Regular_Yellow_800x600.webm`],
          purple: [lg`Weapon_Attacks/Melee/Mace01_Fire_Dark_Purple_800x600.webm`],
          blue: [lg`Weapon_Attacks/Melee/Mace01_Fire_Regular_Blue_800x600.webm`],
          green: [lg`Weapon_Attacks/Melee/Mace01_Fire_Regular_Green_800x600.webm`]
        },
        "02": {
          white: [
            [lg`Weapon_Attacks/Melee/Mace01_01_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_02_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_03_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_04_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_05_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_06_Regular_White_800x600.webm`]
          ],
          blue: [
            [lg`Weapon_Attacks/Melee/Mace01_01_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_02_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_03_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_04_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_05_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_06_Regular_Blue_800x600.webm`]
          ],
          orange: [
            [lg`Weapon_Attacks/Melee/Mace01_01_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_02_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_03_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_04_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_05_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_06_Regular_Orange_800x600.webm`]
          ],
          purple: [
            [lg`Weapon_Attacks/Melee/Mace01_01_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_02_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_03_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_04_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_05_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_06_Regular_Purple_800x600.webm`]
          ],
          darkorangepurple: [
            [lg`Weapon_Attacks/Melee/Mace01_01_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_02_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_03_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_04_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_05_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_06_Dark_OrangePurple_800x600.webm`]
          ]
        }
      },
      maul: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/Maul01_01_Regular_White_800x600.webm`],
          orange: [lg`Weapon_Attacks/Melee/Maul01_Fire_Regular_Orange_800x600.webm`],
          pink: [lg`Weapon_Attacks/Melee/Maul01_Fire_Regular_Pink_800x600.webm`],
          red: [lg`Weapon_Attacks/Melee/Maul01_Fire_Regular_Red_800x600.webm`],
          yellow: [lg`Weapon_Attacks/Melee/Maul01_Fire_Regular_Yellow_800x600.webm`],
          purple: [lg`Weapon_Attacks/Melee/Maul01_Fire_Dark_Purple_800x600.webm`],
          blue: [lg`Weapon_Attacks/Melee/Maul01_Fire_Regular_Blue_800x600.webm`],
          green: [lg`Weapon_Attacks/Melee/Maul01_Fire_Regular_Green_800x600.webm`]
        }
      },
      quarterstaff: {
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Quarterstaff01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_06_Regular_White_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Quarterstaff01_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Quarterstaff01_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Quarterstaff01_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_06_Regular_Purple_800x600.webm`
          ],
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Quarterstaff01_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff01_06_Dark_OrangePurple_800x600.webm`
          ]
        },
        "02": {
          white: [
            lg`Weapon_Attacks/Melee/Quarterstaff02_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_06_Regular_White_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Quarterstaff02_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Quarterstaff02_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Quarterstaff02_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_06_Regular_Purple_800x600.webm`
          ],
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Quarterstaff02_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff02_06_Dark_OrangePurple_800x600.webm`
          ]
        },
        "03": {
          white: [
            lg`Weapon_Attacks/Melee/Quarterstaff03_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_06_Regular_White_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Quarterstaff03_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Quarterstaff03_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Quarterstaff03_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_06_Regular_Purple_800x600.webm`
          ],
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Quarterstaff03_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff03_06_Dark_OrangePurple_800x600.webm`
          ]
        },
        "04": {
          white: [
            lg`Weapon_Attacks/Melee/Quarterstaff04_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_06_Regular_White_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Quarterstaff04_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Quarterstaff04_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Quarterstaff04_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_06_Regular_Purple_800x600.webm`
          ],
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Quarterstaff04_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Quarterstaff04_06_Dark_OrangePurple_800x600.webm`
          ]
        }
      },
      rapier: {
        fire: {
          white: [lg`Weapon_Attacks/Melee/Legacy/Rapier01_01_Regular_White_800x600.webm`],
          orange: [lg`Weapon_Attacks/Melee/Rapier01_Fire_Regular_Orange_800x600.webm`],
          pink: [lg`Weapon_Attacks/Melee/Rapier01_Fire_Regular_Pink_800x600.webm`],
          red: [lg`Weapon_Attacks/Melee/Rapier01_Fire_Regular_Red_800x600.webm`],
          yellow: [lg`Weapon_Attacks/Melee/Rapier01_Fire_Regular_Yellow_800x600.webm`],
          purple: [lg`Weapon_Attacks/Melee/Rapier01_Fire_Dark_Purple_800x600.webm`],
          blue: [lg`Weapon_Attacks/Melee/Rapier01_Fire_Regular_Blue_800x600.webm`],
          green: [lg`Weapon_Attacks/Melee/Rapier01_Fire_Regular_Green_800x600.webm`]
        },
        "01": {
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Rapier01_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_06_Dark_OrangePurple_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Rapier01_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Rapier01_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Rapier01_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_06_Regular_Purple_800x600.webm`
          ],
          white: [
            lg`Weapon_Attacks/Melee/Rapier01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_06_Regular_White_800x600.webm`
          ]
        }
      },
      scimitar: {
        "01": {
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Scimitar01_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_06_Dark_OrangePurple_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Scimitar01_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Scimitar01_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Scimitar01_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_06_Regular_Purple_800x600.webm`
          ],
          white: [
            lg`Weapon_Attacks/Melee/Scimitar01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_06_Regular_White_800x600.webm`
          ]
        }
      },
      shortsword: {
        "01": {
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Shortsword01_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_06_Dark_OrangePurple_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Shortsword01_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Shortsword01_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Shortsword01_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_06_Regular_Purple_800x600.webm`
          ],
          white: [
            lg`Weapon_Attacks/Melee/Shortsword01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_06_Regular_White_800x600.webm`
          ],
          yellow: [
            lg`Weapon_Attacks/Melee/Shortsword01_01_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_02_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_03_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_04_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_05_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_06_Regular_Yellow_800x600.webm`
          ]
        }
      },
      spear: {
        "fire": {
          white: [lg`Weapon_Attacks/Melee/Legacy/Spear01_01_Regular_White_800x600.webm`],
          orange: [lg`Weapon_Attacks/Melee/Spear01_Fire_Regular_Orange_800x600.webm`],
          pink: [lg`Weapon_Attacks/Melee/Spear01_Fire_Regular_Pink_800x600.webm`],
          red: [lg`Weapon_Attacks/Melee/Spear01_Fire_Regular_Red_800x600.webm`],
          yellow: [lg`Weapon_Attacks/Melee/Spear01_Fire_Regular_Yellow_800x600.webm`],
          purple: [lg`Weapon_Attacks/Melee/Spear01_Fire_Dark_Purple_800x600.webm`],
          blue: [lg`Weapon_Attacks/Melee/Spear01_Fire_Regular_Blue_800x600.webm`],
          green: [lg`Weapon_Attacks/Melee/Spear01_Fire_Regular_Green_800x600.webm`]
        },
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Spear01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_06_Regular_White_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Spear01_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Spear01_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Spear01_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_06_Regular_Purple_800x600.webm`
          ],
          yellow: [
            lg`Weapon_Attacks/Melee/Spear01_01_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_02_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_03_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_04_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_05_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_06_Regular_Yellow_800x600.webm`
          ],
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Spear01_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_06_Dark_OrangePurple_800x600.webm`
          ]
        }
      },
      sword: {
        fire: {
          white: [lg`Weapon_Attacks/Melee/Legacy/Sword01_01_Regular_White_800x600.webm`],
          black: [lg`Weapon_Attacks/Melee/Sword01_Fire_Regular_Black_800x600.webm`],
          orange: [lg`Weapon_Attacks/Melee/Sword01_Fire_Regular_Orange_800x600.webm`],
          pink: [lg`Weapon_Attacks/Melee/Sword01_Fire_Regular_Pink_800x600.webm`],
          red: [lg`Weapon_Attacks/Melee/Sword01_Fire_Regular_Red_800x600.webm`],
          yellow: [lg`Weapon_Attacks/Melee/Sword01_Fire_Regular_Yellow_800x600.webm`],
          purple: [lg`Weapon_Attacks/Melee/Sword01_Fire_Dark_Purple_800x600.webm`],
          blue: [lg`Weapon_Attacks/Melee/Sword01_Fire_Regular_Blue_800x600.webm`],
          green: [lg`Weapon_Attacks/Melee/Sword01_Fire_Regular_Green_800x600.webm`]
        },
        "01": {
          darkorangepurple: [
            lg`Weapon_Attacks/Melee/Sword01_01_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_02_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_03_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_04_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_05_Dark_OrangePurple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_06_Dark_OrangePurple_800x600.webm`
          ],
          blue: [
            lg`Weapon_Attacks/Melee/Sword01_01_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_02_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_03_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_04_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_05_Regular_Blue_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_06_Regular_Blue_800x600.webm`
          ],
          orange: [
            lg`Weapon_Attacks/Melee/Sword01_01_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_02_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_03_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_04_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_05_Regular_Orange_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_06_Regular_Orange_800x600.webm`
          ],
          purple: [
            lg`Weapon_Attacks/Melee/Sword01_01_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_02_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_03_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_04_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_05_Regular_Purple_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_06_Regular_Purple_800x600.webm`
          ],
          white: [
            lg`Weapon_Attacks/Melee/Sword01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_06_Regular_White_800x600.webm`
          ],
          yellow: [
            lg`Weapon_Attacks/Melee/Sword01_01_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_02_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_03_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_04_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_05_Regular_Yellow_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_06_Regular_Yellow_800x600.webm`
          ]
        }
      },
      unarmedstrike: {
        "magical": {
          darkred: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Dark_Red_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Dark_Red_Magical02_800x600.webm`
          ],
          darkpurple: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Dark_Purple_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Dark_Purple_Magical02_800x600.webm`
          ],
          blue: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Blue_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Blue_Magical02_800x600.webm`
          ],
          green: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Green_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Green_Magical02_800x600.webm`
          ],
          orange: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Orange_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Orange_Magical02_800x600.webm`
          ],
          purplepink: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_PinkPurple_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_PinkPurple_Magical02_800x600.webm`
          ],
          yellow: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Yellow_Magical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Yellow_Magical02_800x600.webm`
          ]
        },
        "physical": {
          darkred: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Dark_Red_Physical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Dark_Red_Physical02_800x600.webm`
          ],
          darkpurple: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Dark_Purple_Physical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Dark_Purple_Physical02_800x600.webm`
          ],
          blue: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Blue_Physical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Blue_Physical02_800x600.webm`
          ],
          green: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Green_Physical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Green_Physical02_800x600.webm`
          ],
          orange: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Orange_Physical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Orange_Physical02_800x600.webm`
          ],
          purplepink: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_PinkPurple_Physical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_PinkPurple_Physical02_800x600.webm`
          ],
          yellow: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Yellow_Physical01_800x600.webm`,
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Yellow_Physical02_800x600.webm`
          ]
        },
        "nohit": {
          blue: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrikeNoHit_01_Regular_Blue_800x600.webm`
          ],
          yellow: [
            lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrikeNoHit_01_Regular_Yellow_800x600.webm`
          ]
        }
      },
      warhammer: {
        "01": {
          white: [
            [lg`Weapon_Attacks/Melee/Warhammer01_01_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_02_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_03_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_04_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_05_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_06_Regular_White_800x600.webm`]
          ],
          blue: [
            [lg`Weapon_Attacks/Melee/Warhammer01_01_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_02_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_03_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_04_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_05_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_06_Regular_Blue_800x600.webm`]
          ],
          orange: [
            [lg`Weapon_Attacks/Melee/Warhammer01_01_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_02_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_03_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_04_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_05_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_06_Regular_Orange_800x600.webm`]
          ],
          purple: [
            [lg`Weapon_Attacks/Melee/Warhammer01_01_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_02_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_03_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_04_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_05_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_06_Regular_Purple_800x600.webm`]
          ],
          darkorangepurple: [
            [lg`Weapon_Attacks/Melee/Warhammer01_01_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_02_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_03_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_04_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_05_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_06_Dark_OrangePurple_800x600.webm`]
          ]
        }
      },
      wrench: {
        "01": {
          white: [
            [lg`Weapon_Attacks/Melee/Wrench01_01_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_02_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_03_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_04_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_05_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_06_Regular_White_800x600.webm`]
          ],
          blue: [
            [lg`Weapon_Attacks/Melee/Wrench01_01_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_02_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_03_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_04_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_05_Regular_Blue_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_06_Regular_Blue_800x600.webm`]
          ],
          orange: [
            [lg`Weapon_Attacks/Melee/Wrench01_01_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_02_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_03_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_04_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_05_Regular_Orange_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_06_Regular_Orange_800x600.webm`]
          ],
          purple: [
            [lg`Weapon_Attacks/Melee/Wrench01_01_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_02_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_03_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_04_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_05_Regular_Purple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_06_Regular_Purple_800x600.webm`]
          ],
          darkorangepurple: [
            [lg`Weapon_Attacks/Melee/Wrench01_01_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_02_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_03_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_04_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_05_Dark_OrangePurple_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_06_Dark_OrangePurple_800x600.webm`]
          ]
        }
      }
    }
  };
  JB2APATREONDB.templatefx = {
    circle: {
      armsofhadar: {
        "01": {
          darkgreen: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Green_500x500.webm`],
          darkpurple: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Purple_500x500.webm`],
          darkred: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Red_500x500.webm`]
        }
      },
      blacktentacles: {
        "01": {
          darkgreen: [l4`Black_Tentacles/BlackTentacles_01_Dark_Green_600x600.webm`],
          darkpurple: [l4`Black_Tentacles/BlackTentacles_01_Dark_Purple_600x600.webm`],
          darkred: [l4`Black_Tentacles/BlackTentacles_01_Dark_Red_600x600.webm`]
        }
      },
      calllightning: {
        "01": {
          blue: [l3`Call_Lightning/CallLightning_01_Blue_1000x1000.webm`],
          blueorange: [l3`Call_Lightning/CallLightning_01_BlueOrange_1000x1000.webm`],
          green: [l3`Call_Lightning/CallLightning_01_Green_1000x1000.webm`],
          pinkyellow: [l3`Call_Lightning/CallLightning_01_PinkYellow_1000x1000.webm`],
          purple: [l3`Call_Lightning/CallLightning_01_Purple_1000x1000.webm`],
          red: [l3`Call_Lightning/CallLightning_01_Red_1000x1000.webm`],
          yellow: [l3`Call_Lightning/CallLightning_01_Yellow_1000x1000.webm`]
        }
      },
      cloudofdaggers: {
        "01": {
          darkpurple: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Dark_Purple_400x400.webm`],
          darkred: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Dark_Red_400x400.webm`],
          blue: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Blue_400x400.webm`],
          green: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Green_400x400.webm`],
          orange: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Orange_400x400.webm`],
          purple: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Purple_400x400.webm`],
          red: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Red_400x400.webm`],
          yellow: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Yellow_400x400.webm`]
        },
        kunai: {
          darkpurple: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Dark_Purple_400x400.webm`],
          darkred: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Dark_Red_400x400.webm`],
          blue: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Blue_400x400.webm`],
          green: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Green_400x400.webm`],
          orange: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Orange_400x400.webm`],
          purple: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Purple_400x400.webm`],
          red: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Red_400x400.webm`],
          yellow: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Yellow_400x400.webm`]
        }
      },
      crackedshield: {
        "01": {
          darkred: [lg`Template/Circle/TemplateShieldCrackedCircle_01_Dark_Red_800x800.webm`],
          darkpurple: [lg`Template/Circle/TemplateShieldCrackedCircle_01_Regular_Purple_800x800.webm`]
        }
      },
      darkness: {
        "01": {
          black: [l2`Darkness/Darkness_01_Black_600x600.webm`],
          green: [l2`Darkness/Darkness_01_Green_600x600.webm`]
        }
      },
      detectmagic: {
        "01": {
          blue: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Blue_1200x1200.webm`],
          green: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Green_1200x1200.webm`],
          greenorange: [l1`Detect_Magic/DetectMagicCircle_01_Regular_GreenOrange_1200x1200.webm`],
          grey: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Grey_1200x1200.webm`],
          purple: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Purple_1200x1200.webm`]
        }
      },
      drop: {
        "01": {
          darkgreen: [lg`Template/Circle/TemplateDropCircle_01_Dark_Green_800x800.webm`],
          red: [lg`Template/Circle/TemplateDropCircle_01_Regular_Red_800x800.webm`]
        }
      },
      explosion: {
        "01": {
          darkpurple: [
            lg`Explosion/Explosion_04_Dark_Purple_400x400.webm`
          ],
          darkred: [
            lg`Explosion/Explosion_04_Dark_Red_400x400.webm`
          ],
          blue: [
            lg`Explosion/Explosion_01_Blue_400x400.webm`,
            lg`Explosion/Explosion_02_Blue_400x400.webm`,
            lg`Explosion/Explosion_04_Regular_Blue_400x400.webm`
          ],
          green: [
            lg`Explosion/Explosion_01_Green_400x400.webm`,
            lg`Explosion/Explosion_02_Green_400x400.webm`,
            lg`Explosion/Explosion_04_Regular_Green_400x400.webm`
          ],
          greenorange: [
            lg`Explosion/Explosion_03_Regular_GreenOrange_400x400.webm`
          ],
          orange: [
            lg`Explosion/Explosion_01_Orange_400x400.webm`,
            lg`Explosion/Explosion_02_Orange_400x400.webm`,
            lg`Explosion/Explosion_04_Regular_Orange_400x400.webm`
          ],
          pink: [
            lg`Explosion/Explosion_03_Regular_Pink_400x400.webm`
          ],
          purplepink: [
            lg`Explosion/Explosion_03_Regular_PurplePink_400x400.webm`
          ],
          purple: [
            lg`Explosion/Explosion_01_Purple_400x400.webm`,
            lg`Explosion/Explosion_02_Purple_400x400.webm`
          ],
          red: [
            lg`Explosion/Explosion_03_Regular_Red_400x400.webm`
          ],
          yellow: [
            lg`Explosion/Explosion_01_Yellow_400x400.webm`,
            lg`Explosion/Explosion_02_Yellow_400x400.webm`
          ],
          yellowblue: [
            lg`Explosion/Explosion_03_Regular_BlueYellow_400x400.webm`
          ],
          whiteblue: [
            lg`Explosion/Explosion_03_Dark_BlueWhite_400x400.webm`
          ]
        }
      },
      fear: {
        "01": {
          darkorange: [lg`Template/Circle/TemplateFearCircle_01_Dark_Orange_800x800.webm`],
          darkpurple: [lg`Template/Circle/TemplateFearCircle_01_Dark_Purple_800x800.webm`],
          orange: [lg`Template/Circle/TemplateFearCircle_01_Regular_Orange_800x800.webm`]
        }
      },
      fireball: {
        loop: {
          blue: [l3`Fireball/FireballLoop_01_Blue_800x800.webm`],
          orange: [l3`Fireball/FireballLoop_01_Orange_800x800.webm`],
          purple: [l3`Fireball/FireballLoop_01_Purple_800x800.webm`]
        },
        explode: {
          blue: [l3`Fireball/FireballExplosion_01_Blue_800x800.webm`],
          orange: [l3`Fireball/FireballExplosion_01_Orange_800x800.webm`],
          purple: [l3`Fireball/FireballExplosion_01_Purple_800x800.webm`]
        },
        nodebris: {
          blue: [l3`Fireball/FireballLoopNoDebris_01_Blue_800x800.webm`],
          orange: [l3`Fireball/FireballLoopNoDebris_01_Orange_800x800.webm`],
          purple: [l3`Fireball/FireballLoopNoDebris_01_Purple_800x800.webm`]
        }
      },
      fogcloud: {
        "01": {
          white: [l1`Fog_Cloud/FogCloud_01_White_800x800.webm`]
        },
        "02": {
          white: [l1`Fog_Cloud/FogCloud_02_Regular_White_800x800.webm`],
          green: [l1`Fog_Cloud/FogCloud_02_Regular_Green_800x800.webm`]
        }
      },
      heart: {
        "01": {
          darkred: [lg`Template/Circle/TemplateHeartCircle_01_Dark_Red_800x800.webm`],
          pink: [lg`Template/Circle/TemplateHeartCircle_01_Regular_Pink_800x800.webm`],
          teal: [lg`Template/Circle/TemplateHeartCircle_01_Regular_Teal_800x800.webm`]
        }
      },
      horror: {
        "01": {
          darkteal: [lg`Template/Circle/TemplateHorrorCircle_01_Dark_Teal_800x800.webm`],
          purple: [lg`Template/Circle/TemplateHorrorCircle_01_Regular_Purple_800x800.webm`],
          teal: [lg`Template/Circle/TemplateHorrorCircle_01_Regular_Teal_800x800.webm`]
        }
      },
      magicsign: {
        abjuration: {
          blue: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        conjuration: {
          blue: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        divination: {
          blue: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        enchantment: {
          blue: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        evocation: {
          blue: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        illusion: {
          blue: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        necromancy: {
          blue: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        transmutation: {
          blue: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Yellow_800x800.webm`]
        }
      },
      moonbeam: {
        loop: {
          blue: [l2`Moonbeam/Moonbeam_01_Regular_Blue_400x400.webm`],
          green: [l2`Moonbeam/Moonbeam_01_Regular_Green_400x400.webm`],
          rainbow: [l2`Moonbeam/Moonbeam_01_Regular_Rainbow_400x400.webm`]
        },
        nopulse: {
          blue: [l2`Moonbeam/MoonbeamNoPulse_01_Regular_Blue_400x400.webm`],
          green: [l2`Moonbeam/MoonbeamNoPulse_01_Regular_Green_400x400.webm`],
          rainbow: [l2`Moonbeam/MoonbeamNoPulse_01_Regular_Rainbow_400x400.webm`]
        },
        intro: {
          blue: [l2`Moonbeam/MoonbeamIntro_01_Regular_Blue_400x400.webm`],
          green: [l2`Moonbeam/MoonbeamIntro_01_Regular_Green_400x400.webm`],
          rainbow: [l2`Moonbeam/MoonbeamIntro_01_Regular_Rainbow_400x400.webm`]
        },
        outro: {
          blue: [l2`Moonbeam/MoonbeamOutro_01_Regular_Blue_400x400.webm`],
          green: [l2`Moonbeam/MoonbeamOutro_01_Regular_Green_400x400.webm`],
          rainbow: [l2`Moonbeam/MoonbeamOutro_01_Regular_Rainbow_400x400.webm`]
        }
      },
      musicnote: {
        "01": {
          blue: [lg`Template/Circle/TemplateMusicNoteCircle_01_Regular_Blue_800x800.webm`],
          darkred: [lg`Template/Circle/TemplateMusicNoteCircle_01_Dark_Red_800x800.webm`],
          purple: [lg`Template/Circle/TemplateMusicNoteCircle_01_Regular_Purple_800x800.webm`]
        }
      },
      outpulse: {
        "01": {
          whiteblue: [lg`Template/Circle/OutPulse/OutPulse_01_Regular_BlueWhite_Burst_600x600.webm`],
          greenorange: [lg`Template/Circle/OutPulse/OutPulse_01_Regular_GreenOrange_Burst_600x600.webm`],
          purplepink: [lg`Template/Circle/OutPulse/OutPulse_01_Regular_PurplePink_Burst_600x600.webm`],
          tealyellow: [lg`Template/Circle/OutPulse/OutPulse_01_Regular_TealYellow_Burst_600x600.webm`]
        },
        "02": {
          whiteblue: [lg`Template/Circle/OutPulse/OutPulse_02_Regular_BlueWhite_Burst_600x600.webm`],
          greenorange: [lg`Template/Circle/OutPulse/OutPulse_02_Regular_GreenOrange_Burst_600x600.webm`],
          purplepink: [lg`Template/Circle/OutPulse/OutPulse_02_Regular_PurplePink_Burst_600x600.webm`],
          tealyellow: [lg`Template/Circle/OutPulse/OutPulse_02_Regular_TealYellow_Burst_600x600.webm`]
        }
      },
      poison: {
        "01": {
          darkgreen: [lg`Template/Circle/TemplatePoisonCircle_01_Dark_Green_800x800.webm`],
          purple: [lg`Template/Circle/TemplatePoisonCircle_01_Regular_Purple_800x800.webm`]
        }
      },
      runes: {
        "01": {
          darkorange: [lg`Template/Circle/TemplateRunesCircle_01_Dark_Orange_800x800.webm`],
          darkred: [lg`Template/Circle/TemplateRunesCircle_01_Dark_Red_800x800.webm`],
          blue: [lg`Template/Circle/TemplateRunesCircle_01_Regular_Blue_800x800.webm`],
          green: [lg`Template/Circle/TemplateRunesCircle_01_Regular_Green02_800x800.webm`],
          orange: [lg`Template/Circle/TemplateRunesCircle_01_Regular_Orange_800x800.webm`]
        }
      },
      shatter: {
        "01": {
          purple: [l2`Shatter/Shatter_01_Purple_400x400.webm`],
          red: [l2`Shatter/Shatter_01_Red_400x400.webm`],
          blue: [l2`Shatter/Shatter_01_Blue_400x400.webm`],
          green: [l2`Shatter/Shatter_01_Green_400x400.webm`],
          orange: [l2`Shatter/Shatter_01_Orange_400x400.webm`]
        }
      },
      shields: {
        "01": {
          darkred: [lg`Template/Circle/TemplateShieldCircle_01_Dark_Red_800x800.webm`],
          green: [lg`Template/Circle/TemplateShieldCircle_01_Regular_Green_800x800.webm`]
        }
      },
      skull: {
        "01": {
          darkgreen: [lg`Template/Circle/TemplateSkullCircle_01_Dark_Green_800x800.webm`],
          darkorange: [lg`Template/Circle/TemplateSkullCircle_01_Dark_Orange_800x800.webm`],
          purple: [lg`Template/Circle/TemplateSkullCircle_01_Regular_Purple_800x800.webm`]
        }
      },
      sleetstorm: {
        "01": {
          blue: [l3`Sleet_Storm/SleetStorm_01_Blue_800x800.webm`],
          green: [l3`Sleet_Storm/SleetStorm_01_Green_800x800.webm`],
          purple: [l3`Sleet_Storm/SleetStorm_01_Purple_800x800.webm`],
          tealyellow: [l3`Sleet_Storm/SleetStorm_01_TealYellow_800x800.webm`]
        }
      },
      snowflakes: {
        "01": {
          darkblue: [lg`Template/Circle/TemplateSnowflakeCircle_01_Dark_Blue_800x800.webm`],
          blue: [lg`Template/Circle/TemplateSnowflakeCircle_01_Regular_Blue_800x800.webm`]
        }
      },
      stun: {
        "01": {
          darkteal: [lg`Template/Circle/TemplateStunCircle_01_Dark_Teal_800x800.webm`],
          purple: [lg`Template/Circle/TemplateStunCircle_01_Regular_Purple_800x800.webm`]
        }
      },
      snowflake: {
        "01": {
          whiteblue: [lg`Ice/SnowflakeBurst_01_Regular_BlueWhite_Burst_600x600.webm`],
          greenorange: [lg`Ice/SnowflakeBurst_01_Regular_GreenOrange_Burst_600x600.webm`],
          purplepink: [lg`Ice/SnowflakeBurst_01_Regular_PurplePink_Burst_600x600.webm`],
          tealyellow: [lg`Ice/SnowflakeBurst_01_Regular_TealYellow_Burst_600x600.webm`]
        }
      },
      vortex: {
        loop: {
          black: [lg`Template/Circle/Vortex_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/Vortex_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/Vortex_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/Vortex_01_Regular_Purple_600x600.webm`]
        },
        intro: {
          black: [lg`Template/Circle/VortexIntro_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/VortexIntro_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/VortexIntro_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/VortexIntro_01_Regular_Purple_600x600.webm`]
        },
        outro: {
          black: [lg`Template/Circle/VortexOutro_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/VortexOutro_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/VortexOutro_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/VortexOutro_01_Regular_Purple_600x600.webm`]
        }
      },
      whirl: {
        loop: {
          black: [lg`Template/Circle/Whirl_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/Whirl_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/Whirl_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/Whirl_01_Regular_Purple_600x600.webm`]
        },
        intro: {
          black: [lg`Template/Circle/WhirlIntro_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/WhirlIntro_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/WhirlIntro_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/WhirlIntro_01_Regular_Purple_600x600.webm`]
        },
        outro: {
          black: [lg`Template/Circle/WhirlOutro_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/WhirlOutro_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/WhirlOutro_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/WhirlOutro_01_Regular_Purple_600x600.webm`]
        }
      }
    },
    cone: {
      breathweapon: {
        "cold": {
          blue: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Cold01_Regular_Blue_30ft_Cone_Burst_600x600.webm`],
          green: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Cold01_Regular_Green_30ft_Cone_Burst_600x600.webm`],
          orange: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Cold01_Regular_Orange_30ft_Cone_Burst_600x600.webm`],
          purple: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Cold01_Regular_Purple_30ft_Cone_Burst_600x600.webm`]
        },
        "fire01": {
          blue: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire01_Regular_Blue_30ft_Cone_Burst_600x600.webm`],
          green: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire01_Regular_Green_30ft_Cone_Burst_600x600.webm`],
          multi: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire01_Regular_MultiColor01_30ft_Cone_Burst_600x600.webm`],
          multi02: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire01_Regular_MultiColor02_30ft_Cone_Burst_600x600.webm`],
          multi03: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire01_Regular_MultiColor03_30ft_Cone_Burst_600x600.webm`],
          orange: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire01_Regular_Orange_30ft_Cone_Burst_600x600.webm`],
          purple: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire01_Regular_Purple_30ft_Cone_Burst_600x600.webm`],
          yellow: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire01_Regular_Yellow_30ft_Cone_Burst_600x600.webm`]
        },
        "fire02": {
          blue: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire02_Regular_Blue_30ft_Cone_Burst_600x600.webm`],
          green: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire02_Regular_Green_30ft_Cone_Burst_600x600.webm`],
          multi: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire02_Regular_MultiColor01_30ft_Cone_Burst_600x600.webm`],
          multi02: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire02_Regular_MultiColor02_30ft_Cone_Burst_600x600.webm`],
          multi03: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire02_Regular_MultiColor03_30ft_Cone_Burst_600x600.webm`],
          orange: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire02_Regular_Orange_30ft_Cone_Burst_600x600.webm`],
          purple: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire02_Regular_Purple_30ft_Cone_Burst_600x600.webm`],
          yellow: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire02_Regular_Yellow_30ft_Cone_Burst_600x600.webm`]
        },
        "poison": {
          black: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Poison01_Dark_Black_30ft_Cone_Burst_600x600.webm`],
          blue: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Poison01_Regular_Blue_30ft_Cone_Burst_600x600.webm`],
          darkred: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Poison01_Dark_Red_30ft_Cone_Burst_600x600.webm`],
          green: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Poison01_Regular_Green_30ft_Cone_Burst_600x600.webm`],
          orange: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Poison01_Regular_Orange_30ft_Cone_Burst_600x600.webm`],
          purple: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Poison01_Regular_Purple_30ft_Cone_Burst_600x600.webm`]
        }
      },
      breathweaponspray01: {
        burst: {
          green: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire01_Regular_Green_Cone_Burst_800x800.webm`],
          orange: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire01_Regular_Orange_Cone_Burst_800x800.webm`],
          yellow: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Holy01_Regular_Yellow_Cone_Burst_800x800.webm`],
          purple: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Arcana01_Regular_Purple_Cone_Burst_800x800.webm`]
        },
        loop: {
          green: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire01_Regular_Green_Cone_Loop_800x800.webm`],
          orange: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire01_Regular_Orange_Cone_Loop_800x800.webm`],
          yellow: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Holy01_Regular_Yellow_Cone_Loop_800x800.webm`],
          purple: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Arcana01_Regular_Purple_Cone_Loop_800x800.webm`]
        }
      },
      breathweaponspray02: {
        burst: {
          green: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire02_Regular_Green_Cone_Burst_800x800.webm`],
          orange: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire02_Regular_Orange_Cone_Burst_800x800.webm`],
          yellow: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Holy02_Regular_Yellow_Cone_Burst_800x800.webm`],
          purple: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Arcana02_Regular_Purple_Cone_Burst_800x800.webm`]
        },
        loop: {
          green: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire02_Regular_Green_Cone_Loop_800x800.webm`],
          orange: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire02_Regular_Orange_Cone_Loop_800x800.webm`],
          yellow: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Holy02_Regular_Yellow_Cone_Loop_800x800.webm`],
          purple: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Arcana02_Regular_Purple_Cone_Loop_800x800.webm`]
        }
      },
      coneofcold: {
        "01": {
          blue: [l5`Cone_Of_Cold/ConeOfCold_01_Regular_Blue_600x600.webm`],
          green: [l5`Cone_Of_Cold/ConeOfCold_01_Regular_Green_600x600.webm`],
          orange: [l5`Cone_Of_Cold/ConeOfCold_01_Regular_Orange_600x600.webm`],
          purple: [l5`Cone_Of_Cold/ConeOfCold_01_Regular_Purple_600x600.webm`]
        }
      },
      burninghands: {
        "01": {
          blue: [l1`Burning_Hands/BurningHands_01_Regular_Blue_600x600.webm`],
          green: [l1`Burning_Hands/BurningHands_01_Regular_Green_600x600.webm`],
          orange: [l1`Burning_Hands/BurningHands_01_Regular_Orange_600x600.webm`],
          purple: [l1`Burning_Hands/BurningHands_01_Regular_Purple_600x600.webm`]
        },
        "02": {
          blue: [l1`Burning_Hands/BurningHands_02_Regular_Blue_600x600.webm`],
          green: [l1`Burning_Hands/BurningHands_02_Regular_Green_600x600.webm`],
          orange: [l1`Burning_Hands/BurningHands_02_Regular_Orange_600x600.webm`],
          purple: [l1`Burning_Hands/BurningHands_02_Regular_Purple_600x600.webm`]
        }
      }
    },
    square: {
      armsofhadar: {
        "01": {
          darkgreen: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Green_500x500.webm`],
          darkpurple: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Purple_500x500.webm`],
          darkred: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Red_500x500.webm`]
        }
      },
      blacktentacles: {
        "01": {
          darkgreen: [l4`Black_Tentacles/BlackTentacles_01_Dark_Green_600x600.webm`],
          darkpurple: [l4`Black_Tentacles/BlackTentacles_01_Dark_Purple_600x600.webm`],
          darkred: [l4`Black_Tentacles/BlackTentacles_01_Dark_Red_600x600.webm`]
        }
      },
      crackedshield: {
        "01": {
          darkred: [lg`Template/Square/TemplateShieldCrackedSquare_01_Dark_Red_600x600.webm`],
          darkpurple: [lg`Template/Square/TemplateShieldCrackedSquare_01_Regular_Purple_600x600.webm`]
        }
      },
      drop: {
        "01": {
          darkgreen: [lg`Template/Square/TemplateDropSquare_01_Dark_Green_600x600.webm`],
          red: [lg`Template/Square/TemplateDropSquare_01_Regular_Red_600x600.webm`]
        }
      },
      entangle: {
        "01": {
          brown: [l1`Entangle/Entangle_01_Brown_400x400.webm`],
          green: [l1`Entangle/Entangle_01_Green_400x400.webm`],
          yellow: [l1`Entangle/Entangle_01_Yellow_400x400.webm`],
          darkpurple: [l1`Entangle/Entangle_01_Dark_Purple_400x400.webm`],
          palegreen: [l1`Entangle/Entangle_01_Regular_Green02_400x400.webm`]
        }
      },
      fear: {
        "01": {
          darkorange: [lg`Template/Square/TemplateFearSquare_01_Dark_Orange_600x600.webm`],
          darkpurple: [lg`Template/Square/TemplateFearSquare_01_Dark_Purple_600x600.webm`],
          orange: [lg`Template/Square/TemplateFearSquare_01_Regular_Orange_600x600.webm`]
        }
      },
      grease: {
        "01": {
          brown: [l1`Grease/Grease_Dark_Brown_600x600.webm`],
          green: [l1`Grease/Grease_Dark_Green_600x600.webm`],
          grey: [l1`Grease/Grease_Dark_Grey_600x600.webm`],
          purple: [l1`Grease/Grease_Dark_Purple_600x600.webm`]
        }
      },
      heart: {
        "01": {
          darkred: [lg`Template/Square/TemplateHeartSquare_01_Dark_Red_600x600.webm`],
          pink: [lg`Template/Square/TemplateHeartSquare_01_Regular_Pink_600x600.webm`],
          teal: [lg`Template/Square/TemplateHeartSquare_01_Regular_Teal_600x600.webm`]
        }
      },
      horror: {
        "01": {
          darkteal: [lg`Template/Square/TemplateHorrorSquare_01_Dark_Teal_600x600.webm`],
          purple: [lg`Template/Square/TemplateHorrorSquare_01_Regular_Purple_600x600.webm`],
          teal: [lg`Template/Square/TemplateHorrorSquare_01_Regular_Teal_600x600.webm`]
        }
      },
      musicnote: {
        "01": {
          blue: [lg`Template/Square/TemplateMusicNoteSquare_01_Regular_Blue_600x600.webm`],
          darkred: [lg`Template/Square/TemplateMusicNoteSquare_01_Dark_Red_600x600.webm`],
          purple: [lg`Template/Square/TemplateMusicNoteSquare_01_Regular_Purple_600x600.webm`]
        }
      },
      poison: {
        "01": {
          darkgreen: [lg`Template/Square/TemplatePoisonSquare_01_Dark_Green_600x600.webm`],
          purple: [lg`Template/Square/TemplatePoisonSquare_01_Regular_Purple_600x600.webm`]
        }
      },
      runes: {
        "01": {
          darkorange: [lg`Template/Square/TemplateRunesSquare_01_Dark_Orange_600x600.webm`],
          darkred: [lg`Template/Square/TemplateRunesSquare_01_Dark_Red_600x600.webm`],
          blue: [lg`Template/Square/TemplateRunesSquare_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Square/TemplateRunesSquare_01_Regular_Green02_600x600.webm`],
          orange: [lg`Template/Square/TemplateRunesSquare_01_Regular_Orange_600x600.webm`]
        }
      },
      shields: {
        "01": {
          darkred: [lg`Template/Square/TemplateShieldSquare_01_Dark_Red_600x600.webm`],
          green: [lg`Template/Square/TemplateShieldSquare_01_Regular_Green_600x600.webm`]
        }
      },
      snowflakes: {
        "01": {
          darkblue: [lg`Template/Square/TemplateSnowflakeSquare_01_Dark_Blue_600x600.webm`],
          blue: [lg`Template/Square/TemplateSnowflakeSquare_01_Regular_Blue_600x600.webm`]
        }
      },
      skull: {
        "01": {
          darkgreen: [lg`Template/Square/TemplateSkullSquare_01_Dark_Green_600x600.webm`],
          darkorange: [lg`Template/Square/TemplateSkullSquare_01_Dark_Orange_600x600.webm`],
          purple: [lg`Template/Square/TemplateSkullSquare_01_Regular_Purple_600x600.webm`]
        }
      },
      stun: {
        "01": {
          darkteal: [lg`Template/Square/TemplateStunSquare_01_Dark_Teal_600x600.webm`],
          purple: [lg`Template/Square/TemplateStunSquare_01_Regular_Purple_600x600.webm`]
        }
      },
      thunderwave: {
        left: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_BLeft_600x600.webm`],
          green: [l1`Thunderwave/Thunderwave_01_Bright_Green_BLeft_600x600.webm`],
          orange: [l1`Thunderwave/Thunderwave_01_Bright_Orange_BLeft_600x600.webm`],
          purple: [l1`Thunderwave/Thunderwave_01_Dark_Purple_BLeft_600x600.webm`],
          red: [l1`Thunderwave/Thunderwave_01_Dark_Red_BLeft_600x600.webm`]
        },
        mid: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_BMid_600x600.webm`],
          green: [l1`Thunderwave/Thunderwave_01_Bright_Green_BMid_600x600.webm`],
          orange: [l1`Thunderwave/Thunderwave_01_Bright_Orange_BMid_600x600.webm`],
          purple: [l1`Thunderwave/Thunderwave_01_Dark_Purple_BMid_600x600.webm`],
          red: [l1`Thunderwave/Thunderwave_01_Dark_Red_BMid_600x600.webm`]
        },
        center: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_Center_600x600.webm`],
          green: [l1`Thunderwave/Thunderwave_01_Bright_Green_Center_600x600.webm`],
          orange: [l1`Thunderwave/Thunderwave_01_Bright_Orange_Center_600x600.webm`],
          purple: [l1`Thunderwave/Thunderwave_01_Dark_Purple_Center_600x600.webm`],
          red: [l1`Thunderwave/Thunderwave_01_Dark_Red_Center_600x600.webm`]
        }
      },
      web: {
        "01": {
          white: [l2`Web/Web_01_White_01_400x400.webm`]
        },
        "02": {
          white: [l2`Web/Web_01_White_02_400x400.webm`]
        }
      }
    },
    ray: {
      breathweapon: {
        acid: {
          blue: [lg`Template/Line/Breath_Weapon/BreathWeapon_Acid01_Regular_Blue_30ft_Line_Burst_1200x200.webm`],
          green: [lg`Template/Line/Breath_Weapon/BreathWeapon_Acid01_Regular_Green_30ft_Line_Burst_1200x200.webm`],
          orange: [lg`Template/Line/Breath_Weapon/BreathWeapon_Acid01_Regular_Orange_30ft_Line_Burst_1200x200.webm`],
          purple: [lg`Template/Line/Breath_Weapon/BreathWeapon_Acid01_Regular_Purple_30ft_Line_Burst_1200x200.webm`]
        },
        fire: {
          blue: [lg`Template/Line/Breath_Weapon/BreathWeapon_Fire01_Regular_Blue_30ft_Line_Burst_1200x200.webm`],
          green: [lg`Template/Line/Breath_Weapon/BreathWeapon_Fire01_Regular_Green_30ft_Line_Burst_1200x200.webm`],
          orange: [lg`Template/Line/Breath_Weapon/BreathWeapon_Fire01_Regular_Orange_30ft_Line_Burst_1200x200.webm`],
          purple: [lg`Template/Line/Breath_Weapon/BreathWeapon_Fire01_Regular_Purple_30ft_Line_Burst_1200x200.webm`]
        },
        lightning: {
          blue: [lg`Template/Line/Breath_Weapon/BreathWeapon_Lightning01_Regular_Blue_30ft_Line_Burst_1200x200.webm`],
          green: [lg`Template/Line/Breath_Weapon/BreathWeapon_Lightning01_Regular_Green_30ft_Line_Burst_1200x200.webm`],
          orange: [lg`Template/Line/Breath_Weapon/BreathWeapon_Lightning01_Regular_Orange_30ft_Line_Burst_1200x200.webm`],
          purple: [lg`Template/Line/Breath_Weapon/BreathWeapon_Lightning01_Regular_Purple_30ft_Line_Burst_1200x200.webm`]
        }
      },
      breathweaponspray01: {
        burst: {
          green: [lg`Template/Line/Breath_Weapon/Breathweapon02_Fire01_Regular_Green_Line_Burst_1200x400.webm`],
          orange: [lg`Template/Line/Breath_Weapon/Breathweapon02_Fire01_Regular_Orange_Line_Burst_1200x400.webm`],
          yellow: [lg`Template/Line/Breath_Weapon/Breathweapon02_Holy01_Regular_Yellow_Line_Burst_1200x400.webm`],
          purple: [lg`Template/Line/Breath_Weapon/Breathweapon02_Arcana01_Regular_Purple_Line_Burst_1200x400.webm`]
        },
        loop: {
          green: [lg`Template/Line/Breath_Weapon/Breathweapon02_Fire01_Regular_Green_Line_Loop_1200x400.webm`],
          orange: [lg`Template/Line/Breath_Weapon/Breathweapon02_Fire01_Regular_Orange_Line_Loop_1200x400.webm`],
          yellow: [lg`Template/Line/Breath_Weapon/Breathweapon02_Holy01_Regular_Yellow_Line_Loop_1200x400.webm`],
          purple: [lg`Template/Line/Breath_Weapon/Breathweapon02_Arcana01_Regular_Purple_Line_Loop_1200x400.webm`]
        }
      },
      lightningbolt: {
        "01": {
          darkblue: [l3`Lightning_Bolt/LightningBolt_01_Dark_Blue_4000x200.webm`],
          blue: [l3`Lightning_Bolt/LightningBolt_01_Regular_Blue_4000x200.webm`],
          green: [l3`Lightning_Bolt/LightningBolt_01_Regular_Green_4000x200.webm`],
          orange: [l3`Lightning_Bolt/LightningBolt_01_Regular_Orange_4000x200.webm`],
          purple: [l3`Lightning_Bolt/LightningBolt_01_Regular_Purple_4000x200.webm`],
          red: [l3`Lightning_Bolt/LightningBolt_01_Regular_Red_4000x200.webm`]
        },
        "02": {
          darkblue: [l3`Lightning_Bolt/LightningBolt_01_Dark_Blue_4000x400.webm`],
          blue: [l3`Lightning_Bolt/LightningBolt_01_Regular_Blue_4000x400.webm`],
          green: [l3`Lightning_Bolt/LightningBolt_01_Regular_Green_4000x400.webm`],
          orange: [l3`Lightning_Bolt/LightningBolt_01_Regular_Orange_4000x400.webm`],
          purple: [l3`Lightning_Bolt/LightningBolt_01_Regular_Purple_4000x400.webm`],
          red: [l3`Lightning_Bolt/LightningBolt_01_Regular_Red_4000x400.webm`]
        }
      },
      gustofwind: {
        slow: {
          white: [l2`Gust_Of_Wind/GustOfWind_01_White_1200x200.webm`]
        },
        fast: {
          white: [l2`Gust_Of_Wind/GustOfWind_01_White_VeryFast_1200x200.webm`]
        }
      }
    }
  };
  JB2APATREONDB.static = {
    chains: {
      diamond: {
        "01": {
          blue: [lg`Marker/MarkerChainDiamond01_01_Regular_Blue_Loop_400x400.webm`],
          purple: [lg`Marker/MarkerChainDiamond01_01_Regular_Purple_Loop_400x400.webm`],
          red: [lg`Marker/MarkerChainDiamond01_01_Regular_Red_Loop_400x400.webm`],
          yellow: [lg`Marker/MarkerChainDiamond01_01_Regular_Yellow_Loop_400x400.webm`]
        },
        complete: {
          _markers: {
            loop: { start: 2033, end: 7e3 },
            forcedEnd: 7933
          },
          blue: [lg`Marker/MarkerChainDiamond01_02_Regular_Blue_Complete_400x400.webm`],
          purple: [lg`Marker/MarkerChainDiamond01_02_Regular_Purple_Complete_400x400.webm`],
          red: [lg`Marker/MarkerChainDiamond01_02_Regular_Red_Complete_400x400.webm`],
          yellow: [lg`Marker/MarkerChainDiamond01_02_Regular_Yellow_Complete_400x400.webm`]
        },
        loop: {
          blue: [lg`Marker/MarkerChainDiamond01_02_Regular_Blue_Loop_400x400.webm`],
          purple: [lg`Marker/MarkerChainDiamond01_02_Regular_Purple_Loop_400x400.webm`],
          red: [lg`Marker/MarkerChainDiamond01_02_Regular_Red_Loop_400x400.webm`],
          yellow: [lg`Marker/MarkerChainDiamond01_02_Regular_Yellow_Loop_400x400.webm`]
        }
      },
      spike: {
        "01": {
          blue: [lg`Marker/MarkerChainSpike01_01_Regular_Blue_Loop_400x400.webm`],
          purple: [lg`Marker/MarkerChainSpike01_01_Regular_Purple_Loop_400x400.webm`],
          red: [lg`Marker/MarkerChainSpike01_01_Regular_Red_Loop_400x400.webm`],
          yellow: [lg`Marker/MarkerChainSpike01_01_Regular_Yellow_Loop_400x400.webm`]
        },
        complete: {
          _markers: {
            loop: { start: 2033, end: 7e3 },
            forcedEnd: 7933
          },
          blue: [lg`Marker/MarkerChainSpike01_02_Regular_Blue_Complete_400x400.webm`],
          purple: [lg`Marker/MarkerChainSpike01_02_Regular_Purple_Complete_400x400.webm`],
          red: [lg`Marker/MarkerChainSpike01_02_Regular_Red_Complete_400x400.webm`],
          yellow: [lg`Marker/MarkerChainSpike01_02_Regular_Yellow_Complete_400x400.webm`]
        },
        loop: {
          blue: [lg`Marker/MarkerChainSpike01_02_Regular_Blue_Loop_400x400.webm`],
          purple: [lg`Marker/MarkerChainSpike01_02_Regular_Purple_Loop_400x400.webm`],
          red: [lg`Marker/MarkerChainSpike01_02_Regular_Red_Loop_400x400.webm`],
          yellow: [lg`Marker/MarkerChainSpike01_02_Regular_Yellow_Loop_400x400.webm`]
        }
      },
      square: {
        "01": {
          blue: [lg`Marker/MarkerChainSquare01_01_Regular_Blue_Loop_400x400.webm`],
          purple: [lg`Marker/MarkerChainSquare01_01_Regular_Purple_Loop_400x400.webm`],
          red: [lg`Marker/MarkerChainSquare01_01_Regular_Red_Loop_400x400.webm`],
          yellow: [lg`Marker/MarkerChainSquare01_01_Regular_Yellow_Loop_400x400.webm`]
        },
        complete: {
          _markers: {
            loop: { start: 2033, end: 7e3 },
            forcedEnd: 7933
          },
          blue: [lg`Marker/MarkerChainSquare01_02_Regular_Blue_Complete_400x400.webm`],
          purple: [lg`Marker/MarkerChainSquare01_02_Regular_Purple_Complete_400x400.webm`],
          red: [lg`Marker/MarkerChainSquare01_02_Regular_Red_Complete_400x400.webm`],
          yellow: [lg`Marker/MarkerChainSquare01_02_Regular_Yellow_Complete_400x400.webm`]
        },
        loop: {
          blue: [lg`Marker/MarkerChainSquare01_02_Regular_Blue_Loop_400x400.webm`],
          purple: [lg`Marker/MarkerChainSquare01_02_Regular_Purple_Loop_400x400.webm`],
          red: [lg`Marker/MarkerChainSquare01_02_Regular_Red_Loop_400x400.webm`],
          yellow: [lg`Marker/MarkerChainSquare01_02_Regular_Yellow_Loop_400x400.webm`]
        }
      },
      standard: {
        "01": {
          blue: [lg`Marker/MarkerChainStandard01_01_Regular_Blue_Loop_400x400.webm`],
          purple: [lg`Marker/MarkerChainStandard01_01_Regular_Purple_Loop_400x400.webm`],
          red: [lg`Marker/MarkerChainStandard01_01_Regular_Red_Loop_400x400.webm`],
          yellow: [lg`Marker/MarkerChainStandard01_01_Regular_Yellow_Loop_400x400.webm`]
        },
        complete: {
          _markers: {
            loop: { start: 2033, end: 7e3 },
            forcedEnd: 7933
          },
          blue: [lg`Marker/MarkerChainStandard01_02_Regular_Blue_Complete_400x400.webm`],
          purple: [lg`Marker/MarkerChainStandard01_02_Regular_Purple_Complete_400x400.webm`],
          red: [lg`Marker/MarkerChainStandard01_02_Regular_Red_Complete_400x400.webm`],
          yellow: [lg`Marker/MarkerChainStandard01_02_Regular_Yellow_Complete_400x400.webm`]
        },
        loop: {
          blue: [lg`Marker/MarkerChainStandard01_02_Regular_Blue_Loop_400x400.webm`],
          purple: [lg`Marker/MarkerChainStandard01_02_Regular_Purple_Loop_400x400.webm`],
          red: [lg`Marker/MarkerChainStandard01_02_Regular_Red_Loop_400x400.webm`],
          yellow: [lg`Marker/MarkerChainStandard01_02_Regular_Yellow_Loop_400x400.webm`]
        }
      }
    },
    conditions: {
      drop: {
        "01": {
          green: [lg`Marker/MarkerDrop_01_Dark_Green_400x400.webm`],
          red: [lg`Marker/MarkerDrop_01_Regular_Red_400x400.webm`]
        },
        "02": {
          green: [lg`Marker/MarkerDrop_02_Dark_Green_400x400.webm`],
          red: [lg`Marker/MarkerDrop_02_Regular_Red_400x400.webm`]
        },
        "03": {
          green: [lg`Marker/MarkerDrop_03_Dark_Green_400x400.webm`],
          red: [lg`Marker/MarkerDrop_03_Regular_Red_400x400.webm`]
        }
      },
      fear: {
        "01": {
          orange: [lg`Marker/MarkerFear_01_Regular_Orange_400x400.webm`],
          darkorange: [lg`Marker/MarkerFear_01_Dark_Orange_400x400.webm`],
          darkpurple: [lg`Marker/MarkerFear_01_Dark_Purple_400x400.webm`]
        },
        "02": {
          orange: [lg`Marker/MarkerFear_02_Regular_Orange_400x400.webm`],
          darkorange: [lg`Marker/MarkerFear_02_Dark_Orange_400x400.webm`],
          darkpurple: [lg`Marker/MarkerFear_02_Dark_Purple_400x400.webm`]
        },
        "03": {
          orange: [lg`Marker/MarkerFear_03_Regular_Orange_400x400.webm`],
          darkorange: [lg`Marker/MarkerFear_03_Dark_Orange_400x400.webm`],
          darkpurple: [lg`Marker/MarkerFear_03_Dark_Purple_400x400.webm`]
        }
      },
      heart: {
        "01": {
          darkred: [lg`Marker/MarkerHeart_01_Dark_Red_400x400.webm`],
          pink: [lg`Marker/MarkerHeart_01_Regular_Pink_400x400.webm`],
          teal: [lg`Marker/MarkerHeart_01_Regular_Teal_400x400.webm`]
        },
        "02": {
          darkred: [lg`Marker/MarkerHeart_02_Dark_Red_400x400.webm`],
          pink: [lg`Marker/MarkerHeart_02_Regular_Pink_400x400.webm`],
          teal: [lg`Marker/MarkerHeart_02_Regular_Teal_400x400.webm`]
        },
        "03": {
          darkred: [lg`Marker/MarkerHeart_03_Dark_Red_400x400.webm`],
          pink: [lg`Marker/MarkerHeart_03_Regular_Pink_400x400.webm`],
          teal: [lg`Marker/MarkerHeart_03_Regular_Teal_400x400.webm`]
        }
      },
      horror: {
        "01": {
          purple: [lg`Marker/MarkerHorror_01_Regular_Purple_400x400.webm`],
          teal: [lg`Marker/MarkerHorror_01_Regular_Teal_400x400.webm`],
          darkteal: [lg`Marker/MarkerHorror_01_Dark_Teal_400x400.webm`]
        },
        "02": {
          purple: [lg`Marker/MarkerHorror_02_Regular_Purple_400x400.webm`],
          teal: [lg`Marker/MarkerHorror_02_Dark_Teal_400x400.webm`],
          darkteal: [lg`Marker/MarkerHorror_02_Dark_Teal_400x400.webm`]
        },
        "03": {
          purple: [lg`Marker/MarkerHorror_03_Regular_Purple_400x400.webm`],
          teal: [lg`Marker/MarkerHorror_02_Regular_Teal_400x400.webm`],
          darkteal: [lg`Marker/MarkerHorror_03_Dark_Teal_400x400.webm`]
        }
      },
      light: {
        pulse: {
          blue: [lg`Marker/MarkerLight_01_Regular_Blue_400x400.webm`],
          green: [lg`Marker/MarkerLight_01_Regular_Green_400x400.webm`],
          yellow: [lg`Marker/MarkerLight_01_Regular_Yellow_400x400.webm`]
        },
        nopulse: {
          blue: [lg`Marker/MarkerLightNoPulse_01_Regular_Blue_400x400.webm`],
          green: [lg`Marker/MarkerLightNoPulse_01_Regular_Green_400x400.webm`],
          yellow: [lg`Marker/MarkerLightNoPulse_01_Regular_Yellow_400x400.webm`]
        }
      },
      poison: {
        "01": {
          darkgreen: [lg`Marker/MarkerPoison_01_Dark_Green_400x400.webm`],
          purple: [lg`Marker/MarkerPoison_01_Regular_Purple_400x400.webm`]
        },
        "02": {
          darkgreen: [lg`Marker/MarkerPoison_02_Dark_Green_400x400.webm`],
          purple: [lg`Marker/MarkerPoison_02_Regular_Purple_400x400.webm`]
        },
        "03": {
          darkgreen: [lg`Marker/MarkerPoison_03_Dark_Green_400x400.webm`],
          purple: [lg`Marker/MarkerPoison_03_Regular_Purple_400x400.webm`]
        }
      },
      runes: {
        "01": {
          black: [lg`Marker/MarkerRunes_01_Dark_Black_400x400.webm`],
          blue: [lg`Marker/MarkerRunes_01_Regular_Blue_400x400.webm`],
          darkorange: [lg`Marker/MarkerRunes_01_Dark_Orange_400x400.webm`],
          green: [lg`Marker/MarkerRunes_01_Regular_Green02_400x400.webm`],
          orange: [lg`Marker/MarkerRunes_01_Regular_Orange_400x400.webm`],
          darkred: [lg`Marker/MarkerRunes_01_Dark_Red_400x400.webm`],
          red: [lg`Marker/MarkerRunes_01_Regular_Red_400x400.webm`],
          yellow: [lg`Marker/MarkerRunes_01_Regular_Yellow_400x400.webm`],
          white: [lg`Marker/MarkerRunes_01_Regular_White_400x400.webm`]
        },
        "02": {
          black: [lg`Marker/MarkerRunes_02_Dark_Black_400x400.webm`],
          blue: [lg`Marker/MarkerRunes_02_Regular_Blue_400x400.webm`],
          darkorange: [lg`Marker/MarkerRunes_02_Dark_Orange_400x400.webm`],
          green: [lg`Marker/MarkerRunes_02_Regular_Green02_400x400.webm`],
          orange: [lg`Marker/MarkerRunes_02_Regular_Orange_400x400.webm`],
          darkred: [lg`Marker/MarkerRunes_02_Dark_Red_400x400.webm`],
          red: [lg`Marker/MarkerRunes_02_Regular_Red_400x400.webm`],
          yellow: [lg`Marker/MarkerRunes_02_Regular_Yellow_400x400.webm`],
          white: [lg`Marker/MarkerRunes_02_Regular_White_400x400.webm`]
        },
        "03": {
          black: [lg`Marker/MarkerRunes_03_Dark_Black_400x400.webm`],
          blue: [lg`Marker/MarkerRunes_03_Regular_Blue_400x400.webm`],
          darkorange: [lg`Marker/MarkerRunes_03_Dark_Orange_400x400.webm`],
          green: [lg`Marker/MarkerRunes_03_Regular_Green02_400x400.webm`],
          orange: [lg`Marker/MarkerRunes_03_Regular_Orange_400x400.webm`],
          darkred: [lg`Marker/MarkerRunes_03_Dark_Red_400x400.webm`],
          red: [lg`Marker/MarkerRunes_02_Regular_Red_400x400.webm`],
          yellow: [lg`Marker/MarkerRunes_03_Regular_Yellow_400x400.webm`],
          white: [lg`Marker/MarkerRunes_03_Regular_White_400x400.webm`]
        }
      },
      shields: {
        "01": {
          blue: [lg`Marker/MarkerShield_01_Regular_Blue_400x400.webm`],
          darkred: [lg`Marker/MarkerShield_01_Dark_Red_400x400.webm`],
          green: [lg`Marker/MarkerShield_01_Regular_Green_400x400.webm`]
        },
        "02": {
          blue: [lg`Marker/MarkerShield_02_Regular_Blue_400x400.webm`],
          darkred: [lg`Marker/MarkerShield_02_Dark_Red_400x400.webm`],
          green: [lg`Marker/MarkerShield_02_Regular_Green_400x400.webm`]
        },
        "03": {
          blue: [lg`Marker/MarkerShield_03_Regular_Blue_400x400.webm`],
          darkred: [lg`Marker/MarkerShield_03_Dark_Red_400x400.webm`],
          green: [lg`Marker/MarkerShield_03_Regular_Green_400x400.webm`]
        }
      },
      crackedshield: {
        "01": {
          darkred: [lg`Marker/MarkerShieldCracked_01_Dark_Red_400x400.webm`],
          purple: [lg`Marker/MarkerShieldCracked_01_Regular_Purple_400x400.webm`]
        },
        "02": {
          darkred: [lg`Marker/MarkerShieldCracked_02_Dark_Red_400x400.webm`],
          purple: [lg`Marker/MarkerShieldCracked_02_Regular_Purple_400x400.webm`]
        },
        "03": {
          darkred: [lg`Marker/MarkerShieldCracked_03_Dark_Red_400x400.webm`],
          purple: [lg`Marker/MarkerShieldCracked_03_Regular_Purple_400x400.webm`]
        }
      },
      skull: {
        "01": {
          darkgreen: [lg`Marker/MarkerSkull_01_Dark_Green_400x400.webm`],
          darkorange: [lg`Marker/MarkerSkull_01_Dark_Orange_400x400.webm`],
          purple: [lg`Marker/MarkerSkull_01_Regular_Purple_400x400.webm`]
        },
        "02": {
          darkgreen: [lg`Marker/MarkerSkull_02_Dark_Green_400x400.webm`],
          darkorange: [lg`Marker/MarkerSkull_02_Dark_Orange_400x400.webm`],
          purple: [lg`Marker/MarkerSkull_02_Regular_Purple_400x400.webm`]
        },
        "03": {
          darkgreen: [lg`Marker/MarkerSkull_03_Dark_Green_400x400.webm`],
          darkorange: [lg`Marker/MarkerSkull_03_Dark_Orange_400x400.webm`],
          purple: [lg`Marker/MarkerSkull_03_Regular_Purple_400x400.webm`]
        }
      },
      snowflakes: {
        "01": {
          darkblue: [lg`Marker/MarkerSnowflake_01_Dark_Blue_400x400.webm`],
          blue: [lg`Marker/MarkerSnowflake_01_Regular_Blue_400x400.webm`]
        },
        "02": {
          darkblue: [lg`Marker/MarkerSnowflake_02_Dark_Blue_400x400.webm`],
          blue: [lg`Marker/MarkerSnowflake_02_Regular_Blue_400x400.webm`]
        },
        "03": {
          darkblue: [lg`Marker/MarkerSnowflake_03_Dark_Blue_400x400.webm`],
          blue: [lg`Marker/MarkerSnowflake_03_Regular_Blue_400x400.webm`]
        }
      },
      stun: {
        "01": {
          darkteal: [lg`Marker/MarkerStun_01_Dark_Teal_400x400.webm`],
          purple: [lg`Marker/MarkerStun_01_Regular_Purple_400x400.webm`]
        },
        "02": {
          darkteal: [lg`Marker/MarkerStun_02_Dark_Teal_400x400.webm`],
          purple: [lg`Marker/MarkerStun_02_Regular_Purple_400x400.webm`]
        },
        "03": {
          darkteal: [lg`Marker/MarkerStun_03_Dark_Teal_400x400.webm`],
          purple: [lg`Marker/MarkerStun_03_Regular_Purple_400x400.webm`]
        }
      },
      dizzystars: {
        "01": {
          black: [lg`Conditions/Dizzy_Stars/DizzyStars_01_Black_400x400.webm`],
          blueorange: [lg`Conditions/Dizzy_Stars/DizzyStars_01_BlueOrange_400x400.webm`],
          green: [lg`Conditions/Dizzy_Stars/DizzyStars_01_Green_400x400.webm`],
          orange: [lg`Conditions/Dizzy_Stars/DizzyStars_01_Orange_400x400.webm`],
          pink: [lg`Conditions/Dizzy_Stars/DizzyStars_01_Pink_400x400.webm`],
          purple: [lg`Conditions/Dizzy_Stars/DizzyStars_01_Purple_400x400.webm`],
          red: [lg`Conditions/Dizzy_Stars/DizzyStars_01_Red_400x400.webm`],
          white: [lg`Conditions/Dizzy_Stars/DizzyStars_01_White_400x400.webm`],
          yellow: [lg`Conditions/Dizzy_Stars/DizzyStars_01_Yellow_400x400.webm`]
        }
      }
    },
    creature: {
      bite: {
        "01": {
          red: [lg`Creature/Bite_01_Regular_Red_400x400.webm`],
          blue: [lg`Creature/Bite_01_Regular_Blue_400x400.webm`],
          green: [lg`Creature/Bite_01_Regular_Green_400x400.webm`],
          grey: [lg`Creature/Bite_01_Regular_Grey_400x400.webm`],
          orange: [lg`Creature/Bite_01_Regular_Orange_400x400.webm`],
          purple: [lg`Creature/Bite_01_Regular_Purple_400x400.webm`],
          yellow: [lg`Creature/Bite_01_Regular_Yellow_400x400.webm`]
        }
      },
      claw: {
        "01": {
          blue: [lg`Creature/Claws_01_Bright_Blue_400x400.webm`],
          brown: [lg`Creature/Claws_01_Regular_Brown_400x400.webm`],
          darkred: [lg`Creature/Claws_01_Dark_Red_400x400.webm`],
          green: [lg`Creature/Claws_01_Bright_Green_400x400.webm`],
          orange: [lg`Creature/Claws_01_Bright_Orange_400x400.webm`],
          purple: [lg`Creature/Claws_01_Bright_Purple_400x400.webm`],
          red: [lg`Creature/Claws_01_Regular_Red_400x400.webm`],
          yellow: [lg`Creature/Claws_01_Bright_Yellow_400x400.webm`]
        }
      }
    },
    energy: {
      energyfield: {
        "01": {
          blue: [lg`Energy/EnergyField_01_Regular_Blue_600x600.webm`],
          green: [lg`Energy/EnergyField_01_Regular_Green_600x600.webm`],
          rainbow: [lg`Energy/EnergyField_01_Regular_Rainbow_600x600.webm`]
        }
      },
      dodecahedron: {
        simple: {
          blue: [lg`Energy/Dodecahedron_01_Regular_Blue_600x600.webm`],
          green: [lg`Energy/Dodecahedron_01_Regular_Green_600x600.webm`]
        },
        rolled: {
          blue: [lg`Energy/DodecahedronRoll_01_Regular_Blue_600x600.webm`],
          green: [lg`Energy/DodecahedronRoll_01_Regular_Green_600x600.webm`]
        },
        runeabove: {
          yellowblue: [lg`Energy/DodecahedronRuneAbove_01_Regular_BlueYellow_600x600.webm`],
          darkgreenpurple: [lg`Energy/DodecahedronRuneAbove_01_Dark_GreenPurple_600x600.webm`]
        },
        runebelow: {
          yellowblue: [lg`Energy/DodecahedronRuneBelow_01_Regular_BlueYellow_600x600.webm`],
          darkgreenpurple: [lg`Energy/DodecahedronRuneBelow_01_Dark_GreenPurple_600x600.webm`]
        },
        skullabove: {
          darkgreenpurple: [lg`Energy/DodecahedronSkullAbove_01_Dark_GreenPurple_600x600.webm`]
        },
        skullbelow: {
          darkgreenpurple: [lg`Energy/DodecahedronSkullBelow_01_Dark_GreenPurple_600x600.webm`]
        },
        starabove: {
          yellowblue: [lg`Energy/DodecahedronStarAbove_01_Regular_BlueYellow_600x600.webm`]
        },
        starbelow: {
          yellowblue: [lg`Energy/DodecahedronStarBelow_01_Regular_BlueYellow_600x600.webm`]
        }
      },
      shimmer: {
        "01": {
          blue: [lg`Energy/Shimmer01_01_Regular_Blue_400x400.webm`],
          green: [lg`Energy/Shimmer01_01_Regular_Green_400x400.webm`],
          orange: [lg`Energy/Shimmer01_01_Regular_Orange_400x400.webm`],
          purple: [lg`Energy/Shimmer01_01_Regular_Purple_400x400.webm`]
        }
      },
      sparkles: {
        "01": {
          blue: [lg`Energy/SwirlingSparkles_01_Regular_Blue_400x400.webm`],
          bluepink: [lg`Energy/SwirlingSparkles_01_Regular_BluePink_400x400.webm`],
          greenorange: [lg`Energy/SwirlingSparkles_01_Regular_GreenOrange_400x400.webm`],
          orangepurple: [lg`Energy/SwirlingSparkles_01_Regular_OrangePurple_400x400.webm`]
        }
      },
      strands: {
        "01": {
          blue: [lg`Energy/EnergyStrandIN01_01_Regular_Blue_600x600.webm`],
          green: [lg`Energy/EnergyStrandIN01_01_Regular_Green_600x600.webm`],
          purple: [lg`Energy/EnergyStrandIN01_01_Regular_Purple_600x600.webm`],
          red: [lg`Energy/EnergyStrandIN01_01_Regular_Red_600x600.webm`],
          yellow: [lg`Energy/EnergyStrandIN01_01_Regular_Yellow_600x600.webm`]
        },
        "02": {
          blue: [lg`Energy/EnergyStrandIN01_02_Regular_Blue_600x600.webm`],
          green: [lg`Energy/EnergyStrandIN01_02_Regular_Green_600x600.webm`],
          purple: [lg`Energy/EnergyStrandIN01_02_Regular_Purple_600x600.webm`],
          red: [lg`Energy/EnergyStrandIN01_02_Regular_Red_600x600.webm`],
          yellow: [lg`Energy/EnergyStrandIN01_02_Regular_Yellow_600x600.webm`]
        },
        "03": {
          blue: [lg`Energy/EnergyStrandIN01_03_Regular_Blue_600x600.webm`],
          green: [lg`Energy/EnergyStrandIN01_03_Regular_Green_600x600.webm`],
          purple: [lg`Energy/EnergyStrandIN01_03_Regular_Purple_600x600.webm`],
          red: [lg`Energy/EnergyStrandIN01_03_Regular_Red_600x600.webm`],
          yellow: [lg`Energy/EnergyStrandIN01_03_Regular_Yellow_600x600.webm`]
        }
      }
    },
    fire: {
      eruption: {
        "01": {
          blue: [lg`Fire/Eruption_01_Regular_Blue_600x600.webm`],
          green: [lg`Fire/Eruption_01_Regular_Green_600x600.webm`],
          orange: [lg`Fire/Eruption_01_Regular_Orange_600x600.webm`]
        }
      },
      groundcrack: {
        "01": {
          blue: [lg`Fire/GroundCrackLoop_01_Regular_Blue_600x600.webm`],
          green: [lg`Fire/GroundCrackLoop_01_Regular_Green_600x600.webm`],
          orange: [lg`Fire/GroundCrackLoop_01_Regular_Orange_600x600.webm`],
          purple: [lg`Fire/GroundCrackLoop_01_Regular_Purple_600x600.webm`]
        },
        "02": {
          blue: [lg`Fire/GroundCrackLoop_02_Regular_Blue_600x600.webm`],
          green: [lg`Fire/GroundCrackLoop_02_Regular_Green_600x600.webm`],
          orange: [lg`Fire/GroundCrackLoop_02_Regular_Orange_600x600.webm`],
          purple: [lg`Fire/GroundCrackLoop_02_Regular_Purple_600x600.webm`]
        },
        "03": {
          blue: [lg`Fire/GroundCrackLoop_03_Regular_Blue_600x600.webm`],
          green: [lg`Fire/GroundCrackLoop_03_Regular_Green_600x600.webm`],
          orange: [lg`Fire/GroundCrackLoop_03_Regular_Orange_600x600.webm`],
          purple: [lg`Fire/GroundCrackLoop_03_Regular_Purple_600x600.webm`]
        }
      },
      fireworks: {
        "01": {
          green: [
            lg`Fireworks/Firework02_01_Regular_Green_600x600.webm`
          ],
          greenorange: [
            lg`Fireworks/Firework01_01_Regular_GreenOrange_600x600.webm`
          ],
          greenred: [
            lg`Fireworks/Firework01_01_Regular_GreenRed_600x600.webm`,
            lg`Fireworks/Firework03_01_Regular_GreenRed_600x600.webm`
          ],
          orange: [
            lg`Fireworks/Firework02_01_Regular_Orange_600x600.webm`
          ],
          orangeyellow: [
            lg`Fireworks/Firework01_01_Regular_OrangeYellow_600x600.webm`,
            lg`Fireworks/Firework03_01_Regular_OrangeYellow_600x600.webm`
          ],
          yellow: [
            lg`Fireworks/Firework02_01_Regular_Yellow_600x600.webm`
          ],
          bluepink: [
            lg`Fireworks/Firework03_01_Regular_BluePink_600x600.webm`
          ]
        },
        "02": {
          green: [
            lg`Fireworks/Firework02_02_Regular_Green_600x600.webm`
          ],
          greenorange: [
            lg`Fireworks/Firework01_02_Regular_GreenOrange_600x600.webm`
          ],
          greenred: [
            lg`Fireworks/Firework03_02_Regular_GreenRed_600x600.webm`
          ],
          orange: [
            lg`Fireworks/Firework02_02_Regular_Orange_600x600.webm`
          ],
          orangeyellow: [
            lg`Fireworks/Firework01_02_Regular_OrangeYellow_600x600.webm`,
            lg`Fireworks/Firework03_02_Regular_OrangeYellow_600x600.webm`
          ],
          yellow: [
            lg`Fireworks/Firework02_02_Regular_Yellow_600x600.webm`,
            lg`Fireworks/Firework03_02_Regular_OrangeYellow_600x600.webm`
          ],
          bluepink: [
            lg`Fireworks/Firework03_02_Regular_BluePink_600x600.webm`
          ]
        }
      }
    },
    generic: {
      boulderimpact: {
        "01": {
          white: [lg`Impact/BoulderImpact_01_Regular_White_500x500.webm`]
        }
      },
      explosion: {
        "01": {
          darkblue: [
            lg`Explosion/Explosion_05_Dark_Blue_400x400.webm`
          ],
          darkgreen: [
            lg`Explosion/Explosion_05_Dark_Green_400x400.webm`
          ],
          darkorange: [
            lg`Explosion/Explosion_05_Dark_Orange_400x400.webm`
          ],
          darkpurple: [
            lg`Explosion/Explosion_04_Dark_Purple_400x400.webm`
          ],
          darkred: [
            lg`Explosion/Explosion_04_Dark_Red_400x400.webm`
          ],
          blue: [
            lg`Explosion/Explosion_01_Blue_400x400.webm`,
            lg`Explosion/Explosion_02_Blue_400x400.webm`,
            lg`Explosion/Explosion_04_Regular_Blue_400x400.webm`,
            lg`Explosion/Explosion_05_Regular_Blue_400x400.webm`
          ],
          green: [
            lg`Explosion/Explosion_01_Green_400x400.webm`,
            lg`Explosion/Explosion_02_Green_400x400.webm`,
            lg`Explosion/Explosion_04_Regular_Green_400x400.webm`,
            lg`Explosion/Explosion_05_Regular_Green_400x400.webm`
          ],
          greenorange: [
            lg`Explosion/Explosion_03_Regular_GreenOrange_400x400.webm`
          ],
          orange: [
            lg`Explosion/Explosion_01_Orange_400x400.webm`,
            lg`Explosion/Explosion_02_Orange_400x400.webm`,
            lg`Explosion/Explosion_04_Regular_Orange_400x400.webm`,
            lg`Explosion/Explosion_05_Regular_Orange_400x400.webm`
          ],
          pink: [
            lg`Explosion/Explosion_03_Regular_Pink_400x400.webm`
          ],
          purplepink: [
            lg`Explosion/Explosion_03_Regular_PurplePink_400x400.webm`
          ],
          purple: [
            lg`Explosion/Explosion_01_Purple_400x400.webm`,
            lg`Explosion/Explosion_02_Purple_400x400.webm`
          ],
          red: [
            lg`Explosion/Explosion_03_Regular_Red_400x400.webm`
          ],
          yellow: [
            lg`Explosion/Explosion_01_Yellow_400x400.webm`,
            lg`Explosion/Explosion_02_Yellow_400x400.webm`
          ],
          yellowblue: [
            lg`Explosion/Explosion_03_Regular_BlueYellow_400x400.webm`
          ],
          whiteblue: [
            lg`Explosion/Explosion_03_Dark_BlueWhite_400x400.webm`
          ]
        }
      },
      fire: {
        ring: {
          blue: [lg`Fire/FireRing_01_Circle_Blue_900.webm`],
          green: [lg`Fire/FireRing_01_Circle_Green_900.webm`],
          red: [lg`Fire/FireRing_01_Circle_Red_900.webm`]
        }
      },
      impact: {
        "01": {
          blue: [
            lg`Impact/Impact_01_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_02_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_03_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_04_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_05_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_07_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_08_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_09_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_10_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_11_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_12_Regular_Blue_400x400.webm`
          ],
          darkpurple: [
            lg`Impact/Impact_01_Dark_Purple_400x400.webm`,
            lg`Impact/Impact_02_Dark_Purple_400x400.webm`,
            lg`Impact/Impact_03_Dark_Purple_400x400.webm`,
            lg`Impact/Impact_04_Dark_Purple_400x400.webm`,
            lg`Impact/Impact_11_Dark_Purple_400x400.webm`,
            lg`Impact/Impact_12_Dark_Purple_400x400.webm`
          ],
          darkred: [
            lg`Impact/Impact_01_Dark_Red_400x400.webm`,
            lg`Impact/Impact_02_Dark_Red_400x400.webm`,
            lg`Impact/Impact_03_Dark_Red_400x400.webm`,
            lg`Impact/Impact_04_Dark_Red_400x400.webm`,
            lg`Impact/Impact_11_Dark_Red_400x400.webm`,
            lg`Impact/Impact_12_Dark_Red_400x400.webm`
          ],
          green: [
            lg`Impact/Impact_01_Regular_Green_400x400.webm`,
            lg`Impact/Impact_02_Regular_Green_400x400.webm`,
            lg`Impact/Impact_03_Regular_Green_400x400.webm`,
            lg`Impact/Impact_04_Regular_Green_400x400.webm`,
            lg`Impact/Impact_05_Regular_Green_400x400.webm`,
            lg`Impact/Impact_07_Regular_Green_400x400.webm`,
            lg`Impact/Impact_08_Regular_Green_400x400.webm`,
            lg`Impact/Impact_09_Regular_Green_400x400.webm`,
            lg`Impact/Impact_10_Regular_Green_400x400.webm`,
            lg`Impact/Impact_11_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_12_Regular_Blue_400x400.webm`
          ],
          orange: [
            lg`Impact/Impact_01_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_02_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_03_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_04_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_05_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_07_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_08_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_09_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_10_Regular_Orange_400x400.webm`
          ],
          pink: [
            lg`Impact/Impact_07_Regular_Pink_400x400.webm`,
            lg`Impact/Impact_09_Regular_Pink_400x400.webm`
          ],
          purplepink: [
            lg`Impact/Impact_01_Regular_PinkPurple_400x400.webm`,
            lg`Impact/Impact_02_Regular_PinkPurple_400x400.webm`,
            lg`Impact/Impact_03_Regular_PinkPurple_400x400.webm`,
            lg`Impact/Impact_04_Regular_PinkPurple_400x400.webm`
          ],
          purple: [
            lg`Impact/Impact_05_Regular_Purple_400x400.webm`,
            lg`Impact/Impact_07_Regular_Purple_400x400.webm`,
            lg`Impact/Impact_09_Regular_Purple_400x400.webm`,
            lg`Impact/Impact_11_Regular_Purple_400x400.webm`,
            lg`Impact/Impact_12_Regular_Purple_400x400.webm`
          ],
          red: [
            lg`Impact/Impact_05_Regular_Red_400x400.webm`,
            lg`Impact/Impact_07_Regular_Red_400x400.webm`,
            lg`Impact/Impact_08_Regular_Red_400x400.webm`,
            lg`Impact/Impact_10_Regular_Red_400x400.webm`,
            lg`Impact/Impact_11_Regular_Red_400x400.webm`,
            lg`Impact/Impact_12_Regular_Red_400x400.webm`,
            lg`Impact/Impact_07_Regular_Red02_400x400.webm`
          ],
          white: [
            lg`Impact/Impact_07_Regular_White_400x400.webm`,
            lg`Impact/Impact_09_Regular_White_400x400.webm`
          ],
          yellow: [
            lg`Impact/Impact_01_Regular_Yellow_400x400.webm`,
            lg`Impact/Impact_02_Regular_Yellow_400x400.webm`,
            lg`Impact/Impact_03_Regular_Yellow_400x400.webm`,
            lg`Impact/Impact_04_Regular_Yellow_400x400.webm`,
            lg`Impact/Impact_05_Regular_Yellow_400x400.webm`,
            lg`Impact/Impact_06_Regular_Yellow_400x400.webm`,
            lg`Impact/Impact_07_Regular_Yellow_400x400.webm`,
            lg`Impact/Impact_11_Regular_Yellow_400x400.webm`,
            lg`Impact/Impact_12_Regular_Yellow_400x400.webm`
          ]
        }
      },
      indicator: {
        chevron: {
          green: [lg`UI/3Chevrons_01_Regular_Green_200x200.webm`],
          purple: [lg`UI/3Chevrons_01_Regular_Purple_200x200.webm`],
          red: [lg`UI/3Chevrons_01_Regular_Red_200x200.webm`],
          yellow: [lg`UI/3Chevrons_01_Regular_Yellow_200x200.webm`]
        },
        "01": {
          green: [lg`UI/Indicator_01_Regular_Green_200x200.webm`],
          purple: [lg`UI/Indicator_01_Regular_Purple_200x200.webm`],
          red: [lg`UI/Indicator_01_Regular_Red_200x200.webm`],
          yellow: [lg`UI/Indicator_01_Regular_Yellow_200x200.webm`]
        },
        "02": {
          green: [lg`UI/Indicator01_02_Regular_BlueGreen_400x400.webm`],
          red: [lg`UI/Indicator01_02_Regular_RedYellow_400x400.webm`]
        },
        "03": {
          green: [lg`UI/Indicator01_03_Regular_BlueGreen_200x200.webm`],
          red: [lg`UI/Indicator01_03_Regular_RedYellow_200x200.webm`]
        },
        "04": {
          green: [lg`UI/Indicator02_02_Regular_BlueGreen_400x400.webm`],
          red: [lg`UI/Indicator02_02_Regular_RedYellow_400x400.webm`]
        },
        "05": {
          green: [lg`UI/Indicator02_03_Regular_BlueGreen_200x200.webm`],
          red: [lg`UI/Indicator02_03_Regular_RedYellow_200x200.webm`]
        },
        "06": {
          green: [lg`UI/Indicator03_02_Regular_BlueGreen_400x400.webm`],
          red: [lg`UI/Indicator03_02_Regular_RedYellow_400x400.webm`]
        },
        "07": {
          green: [lg`UI/Indicator03_03_Regular_BlueGreen_200x200.webm`],
          red: [lg`UI/Indicator03_03_Regular_RedYellow_200x200.webm`]
        }
      },
      outpulse: {
        "01": {
          whiteblue: [lg`Template/Circle/OutPulse/OutPulse_01_Regular_BlueWhite_Burst_600x600.webm`],
          greenorange: [lg`Template/Circle/OutPulse/OutPulse_01_Regular_GreenOrange_Burst_600x600.webm`],
          purplepink: [lg`Template/Circle/OutPulse/OutPulse_01_Regular_PurplePink_Burst_600x600.webm`],
          tealyellow: [lg`Template/Circle/OutPulse/OutPulse_01_Regular_TealYellow_Burst_600x600.webm`]
        },
        "02": {
          whiteblue: [lg`Template/Circle/OutPulse/OutPulse_02_Regular_BlueWhite_Burst_600x600.webm`],
          greenorange: [lg`Template/Circle/OutPulse/OutPulse_02_Regular_GreenOrange_Burst_600x600.webm`],
          purplepink: [lg`Template/Circle/OutPulse/OutPulse_02_Regular_PurplePink_Burst_600x600.webm`],
          tealyellow: [lg`Template/Circle/OutPulse/OutPulse_02_Regular_TealYellow_Burst_600x600.webm`]
        }
      },
      smoke: {
        "01": {
          black: [lg`Smoke/SmokePuff01_01_Dark_Black_400x400.webm`],
          blue: [lg`Smoke/SmokePuff01_01_Regular_Blue_400x400.webm`],
          darkgreen: [lg`Smoke/SmokePuff01_01_Dark_Green_400x400.webm`],
          darkpurple: [lg`Smoke/SmokePuff01_01_Dark_Purple_400x400.webm`],
          grey: [lg`Smoke/SmokePuff01_01_Regular_Grey_400x400.webm`]
        },
        "02": {
          black: [lg`Smoke/SmokePuff01_02_Dark_Black_400x400.webm`],
          blue: [lg`Smoke/SmokePuff01_02_Regular_Blue_400x400.webm`],
          darkgreen: [lg`Smoke/SmokePuff01_02_Dark_Green_400x400.webm`],
          darkpurple: [lg`Smoke/SmokePuff01_02_Dark_Purple_400x400.webm`],
          grey: [lg`Smoke/SmokePuff01_02_Regular_Grey_400x400.webm`]
        },
        "03": {
          black: [lg`Smoke/SmokePuff01_03_Dark_Black_400x400.webm`],
          blue: [lg`Smoke/SmokePuff01_03_Regular_Blue_400x400.webm`],
          darkgreen: [lg`Smoke/SmokePuff01_03_Dark_Green_400x400.webm`],
          darkpurple: [lg`Smoke/SmokePuff01_03_Dark_Purple_400x400.webm`],
          grey: [lg`Smoke/SmokePuff01_03_Regular_Grey_400x400.webm`]
        },
        ring: {
          black: [lg`Smoke/SmokeRing_01_Dark_Black_800x800.webm`],
          white: [lg`Smoke/SmokeRing_01_Regular_White_800x800.webm`]
        },
        "ring02": {
          black: [
            lg`Smoke/SmokePuffRing01_01_Dark_Black_400x400.webm`,
            lg`Smoke/SmokePuffRing01_02_Dark_Black_400x400.webm`,
            lg`Smoke/SmokePuffRing01_03_Dark_Black_400x400.webm`
          ],
          white: [
            lg`Smoke/SmokePuffRing01_01_Regular_White_400x400.webm`,
            lg`Smoke/SmokePuffRing01_02_Regular_White_400x400.webm`,
            lg`Smoke/SmokePuffRing01_03_Regular_White_400x400.webm`
          ]
        },
        "ring03": {
          black: [lg`Smoke/SmokePuffRing02_01_Dark_Black_400x400.webm`],
          white: [lg`Smoke/SmokePuffRing02_01_Regular_White_400x400.webm`]
        }
      },
      ui: {
        drop: {
          green: [lg`UI/IconDrop_01_Dark_Green_200x200.webm`],
          red: [lg`UI/IconDrop_01_Regular_Red_200x200.webm`]
        },
        fear: {
          darkorange: [lg`UI/IconFear_01_Dark_Orange_200x200.webm`],
          orange: [lg`UI/IconFear_01_Regular_Orange_200x200.webm`],
          darkpurple: [lg`UI/IconFear_01_Dark_Purple_200x200.webm`]
        },
        heart: {
          darkred: [lg`UI/IconHeart_01_Dark_Red_200x200.webm`],
          pink: [lg`UI/IconHeart_01_Regular_Pink_200x200.webm`],
          teal: [lg`UI/IconHeart_01_Regular_Teal_200x200.webm`]
        },
        horror: {
          darkteal: [lg`UI/IconHorror_01_Dark_Teal_200x200.webm`],
          purple: [lg`UI/IconHorror_01_Regular_Purple_200x200.webm`],
          teal: [lg`UI/IconHorror_01_Regular_Teal_200x200.webm`]
        },
        music: {
          blue: [lg`UI/IconMusicNote_01_Regular_Blue_200x200.webm`],
          darkred: [lg`UI/IconMusicNote_01_Dark_Red_200x200.webm`],
          purple: [lg`UI/IconMusicNote_01_Regular_Purple_200x200.webm`]
        },
        poison: {
          darkgreen: [lg`UI/IconPoison_01_Dark_Green_200x200.webm`],
          purple: [lg`UI/IconPoison_01_Regular_Purple_200x200.webm`]
        },
        rune01: {
          black: [lg`UI/IconRunes_01_Dark_Black_200x200.webm`],
          blue: [lg`UI/IconRunes_01_Regular_Blue_200x200.webm`],
          darkorange: [lg`UI/IconRunes_01_Dark_Orange_200x200.webm`],
          darkred: [lg`UI/IconRunes_01_Dark_Red_200x200.webm`],
          green: [lg`UI/IconRunes_01_Regular_Green02_200x200.webm`],
          orange: [lg`UI/IconRunes_01_Regular_Orange_200x200.webm`],
          red: [lg`UI/IconRunes_01_Regular_Red_200x200.webm`],
          white: [lg`UI/IconRunes_01_Regular_White_200x200.webm`],
          yellow: [lg`UI/IconRunes_01_Regular_Yellow_200x200.webm`]
        },
        rune02: {
          black: [lg`UI/IconRunes02_01_Dark_Black_200x200.webm`],
          blue: [lg`UI/IconRunes02_01_Regular_Blue_200x200.webm`],
          darkorange: [lg`UI/IconRunes02_01_Dark_Orange_200x200.webm`],
          darkred: [lg`UI/IconRunes02_01_Dark_Red_200x200.webm`],
          green: [lg`UI/IconRunes02_01_Regular_Green02_200x200.webm`],
          orange: [lg`UI/IconRunes02_01_Regular_Orange_200x200.webm`],
          red: [lg`UI/IconRunes02_01_Regular_Red_200x200.webm`],
          white: [lg`UI/IconRunes02_01_Regular_White_200x200.webm`],
          yellow: [lg`UI/IconRunes02_01_Regular_Yellow_200x200.webm`]
        },
        rune03: {
          black: [lg`UI/IconRunes03_01_Dark_Black_200x200.webm`],
          blue: [lg`UI/IconRunes03_01_Regular_Blue_200x200.webm`],
          darkorange: [lg`UI/IconRunes03_01_Dark_Orange_200x200.webm`],
          darkred: [lg`UI/IconRunes03_01_Dark_Red_200x200.webm`],
          green: [lg`UI/IconRunes03_01_Regular_Green02_200x200.webm`],
          orange: [lg`UI/IconRunes03_01_Regular_Orange_200x200.webm`],
          red: [lg`UI/IconRunes03_01_Regular_Red_200x200.webm`],
          white: [lg`UI/IconRunes03_01_Regular_White_200x200.webm`],
          yellow: [lg`UI/IconRunes03_01_Regular_Yellow_200x200.webm`]
        },
        shields: {
          blue: [lg`UI/IconShield_01_Regular_Blue_200x200.webm`],
          darkred: [lg`UI/IconShield_01_Dark_Red_200x200.webm`],
          green: [lg`UI/IconShield_01_Regular_Green_200x200.webm`]
        },
        crackedshield: {
          darkred: [lg`UI/IconShieldCracked_01_Dark_Red_200x200.webm`],
          purple: [lg`UI/IconShieldCracked_01_Regular_Purple_200x200.webm`]
        },
        skull: {
          darkgreen: [lg`UI/IconSkull_01_Dark_Green_200x200.webm`],
          darkorange: [lg`UI/IconSkull_01_Dark_Orange_200x200.webm`],
          purple: [lg`UI/IconSkull_01_Regular_Purple_200x200.webm`]
        },
        snowflake: {
          darkblue: [lg`UI/IconSnowflake_01_Dark_Blue_200x200.webm`],
          blue: [lg`UI/IconSnowflake_01_Regular_Blue_200x200.webm`]
        },
        stun: {
          darkteal: [lg`UI/IconStun_01_Dark_Teal_200x200.webm`],
          purple: [lg`UI/IconStun_01_Regular_Purple_200x200.webm`]
        }
      },
      vortex: {
        loop: {
          black: [lg`Template/Circle/Vortex_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/Vortex_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/Vortex_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/Vortex_01_Regular_Purple_600x600.webm`]
        },
        intro: {
          black: [lg`Template/Circle/VortexIntro_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/VortexIntro_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/VortexIntro_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/VortexIntro_01_Regular_Purple_600x600.webm`]
        },
        outro: {
          black: [lg`Template/Circle/VortexOutro_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/VortexOutro_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/VortexOutro_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/VortexOutro_01_Regular_Purple_600x600.webm`]
        }
      },
      whirl: {
        loop: {
          black: [lg`Template/Circle/Whirl_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/Whirl_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/Whirl_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/Whirl_01_Regular_Purple_600x600.webm`]
        },
        intro: {
          black: [lg`Template/Circle/WhirlIntro_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/WhirlIntro_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/WhirlIntro_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/WhirlIntro_01_Regular_Purple_600x600.webm`]
        },
        outro: {
          black: [lg`Template/Circle/WhirlOutro_01_Dark_Black_600x600.webm`],
          blue: [lg`Template/Circle/WhirlOutro_01_Regular_Blue_600x600.webm`],
          green: [lg`Template/Circle/WhirlOutro_01_Regular_Green_600x600.webm`],
          purple: [lg`Template/Circle/WhirlOutro_01_Regular_Purple_600x600.webm`]
        }
      }
    },
    ice: {
      icespikes: {
        "01": {
          blue: [lg`Ice/IceSpikesRadialBurst_01_Regular_Blue_1000x1000.webm`],
          red: [lg`Ice/IceSpikesRadialBurst_01_Regular_Red_1000x1000.webm`],
          white: [lg`Ice/IceSpikesRadialBurst_01_Regular_White_1000x1000.webm`]
        }
      },
      snowflake: {
        "01": {
          whiteblue: [lg`Ice/SnowflakeBurst_01_Regular_BlueWhite_Burst_600x600.webm`],
          greenorange: [lg`Ice/SnowflakeBurst_01_Regular_GreenOrange_Burst_600x600.webm`],
          purplepink: [lg`Ice/SnowflakeBurst_01_Regular_PurplePink_Burst_600x600.webm`],
          tealyellow: [lg`Ice/SnowflakeBurst_01_Regular_TealYellow_Burst_600x600.webm`]
        }
      }
    },
    leaves: {
      complete: {
        "01": {
          green: [lg`Nature/SwirlingLeavesComplete01_01_Regular_Green_400x400.webm`],
          greenorange: [lg`Nature/SwirlingLeavesComplete01_01_Regular_GreenOrange_400x400.webm`]
        },
        "02": {
          green: [lg`Nature/SwirlingLeavesComplete01_02_Regular_Green_400x400.webm`],
          greenorange: [lg`Nature/SwirlingLeavesComplete01_02_Regular_GreenOrange_400x400.webm`]
        },
        "03": {
          green: [lg`Nature/SwirlingLeavesComplete02_01_Regular_Green_400x400.webm`],
          greenorange: [lg`Nature/SwirlingLeavesComplete02_01_Regular_GreenOrange_400x400.webm`]
        }
      },
      loop: {
        "01": {
          green: [lg`Nature/SwirlingLeavesLoop01_01_Regular_GreenOrange_400x400.webm`],
          greenorange: [lg`Nature/SwirlingLeavesLoop01_01_Regular_GreenOrange_400x400.webm`]
        },
        "02": {
          green: [lg`Nature/SwirlingLeavesLoop01_02_Regular_Green_400x400.webm`],
          greenorange: [lg`Nature/SwirlingLeavesLoop01_02_Regular_GreenOrange_400x400.webm`]
        },
        "03": {
          green: [lg`Nature/SwirlingLeavesLoop02_01_Regular_Green_400x400.webm`],
          greenorange: [lg`Nature/SwirlingLeavesLoop02_01_Regular_GreenOrange_400x400.webm`]
        }
      }
    },
    lightning: {
      ball: {
        "01": {
          blue: [lg`Lightning/LightningBall_01_Regular_Blue_400x400.webm`],
          green: [lg`Lightning/LightningBall_01_Regular_Green_400x400.webm`],
          darkgreen: [lg`Lightning/LightningBall_01_Regular_Green02_400x400.webm`],
          darkpurple: [lg`Lightning/LightningBall_01_Dark_Purple_400x400.webm`],
          darkred: [lg`Lightning/LightningBall_01_Dark_Red_400x400.webm`],
          orange: [lg`Lightning/LightningBall_01_Regular_Orange_400x400.webm`],
          purple: [lg`Lightning/LightningBall_01_Regular_Purple_400x400.webm`],
          purpleblue: [lg`Lightning/LightningBall_01_Regular_Blue02_400x400.webm`],
          red: [lg`Lightning/LightningBall_01_Regular_Red_400x400.webm`],
          yellow: [lg`Lightning/LightningBall_01_Regular_Yellow_400x400.webm`]
        }
      },
      strike: {
        "01": {
          blue: [
            lg`Lightning/LightningStrike01_01_Regular_Blue_800x800.webm`,
            lg`Lightning/LightningStrike01_02_Regular_Blue_800x800.webm`,
            lg`Lightning/LightningStrike01_03_Regular_Blue_800x800.webm`,
            lg`Lightning/LightningStrike01_04_Regular_Blue_800x800.webm`,
            lg`Lightning/LightningStrike01_05_Regular_Blue_800x800.webm`,
            lg`Lightning/LightningStrike01_06_Regular_Blue_800x800.webm`
          ],
          purple: [
            lg`Lightning/LightningStrike01_01_Regular_Purple_800x800.webm`,
            lg`Lightning/LightningStrike01_02_Regular_Purple_800x800.webm`,
            lg`Lightning/LightningStrike01_03_Regular_Purple_800x800.webm`,
            lg`Lightning/LightningStrike01_04_Regular_Purple_800x800.webm`,
            lg`Lightning/LightningStrike01_05_Regular_Purple_800x800.webm`,
            lg`Lightning/LightningStrike01_06_Regular_Purple_800x800.webm`
          ],
          yellow: [
            lg`Lightning/LightningStrike01_01_Regular_Yellow_800x800.webm`,
            lg`Lightning/LightningStrike01_02_Regular_Yellow_800x800.webm`,
            lg`Lightning/LightningStrike01_03_Regular_Yellow_800x800.webm`,
            lg`Lightning/LightningStrike01_04_Regular_Yellow_800x800.webm`,
            lg`Lightning/LightningStrike01_05_Regular_Yellow_800x800.webm`,
            lg`Lightning/LightningStrike01_06_Regular_Yellow_800x800.webm`
          ]
        }
      },
      staticelectricity: {
        "01": {
          blue: [lg`Lightning/StaticElectricity_01_Regular_Blue_400x400.webm`],
          darkgreen: [lg`Lightning/StaticElectricity_01_Regular_Green02_400x400.webm`],
          darkpurple: [lg`Lightning/StaticElectricity_01_Dark_Purple_400x400.webm`],
          darkred: [lg`Lightning/StaticElectricity_01_Dark_Red_400x400.webm`],
          green: [lg`Lightning/StaticElectricity_01_Regular_Green_400x400.webm`],
          orange: [lg`Lightning/StaticElectricity_01_Regular_Orange_400x400.webm`],
          purple: [lg`Lightning/StaticElectricity_01_Regular_Purple_400x400.webm`],
          purpleblue: [lg`Lightning/StaticElectricity_01_Regular_Blue02_400x400.webm`],
          red: [lg`Lightning/StaticElectricity_01_Regular_Red_400x400.webm`],
          yellow: [lg`Lightning/StaticElectricity_01_Regular_Yellow_400x400.webm`]
        },
        "02": {
          blue: [lg`Lightning/StaticElectricity_02_Regular_Blue_400x400.webm`],
          darkgreen: [lg`Lightning/StaticElectricity_02_Regular_Green02_400x400.webm`],
          darkpurple: [lg`Lightning/StaticElectricity_02_Dark_Purple_400x400.webm`],
          darkred: [lg`Lightning/StaticElectricity_02_Dark_Red_400x400.webm`],
          green: [lg`Lightning/StaticElectricity_02_Regular_Green_400x400.webm`],
          orange: [lg`Lightning/StaticElectricity_02_Regular_Orange_400x400.webm`],
          purple: [lg`Lightning/StaticElectricity_02_Regular_Purple_400x400.webm`],
          purpleblue: [lg`Lightning/StaticElectricity_02_Regular_Blue02_400x400.webm`],
          red: [lg`Lightning/StaticElectricity_02_Regular_Red_400x400.webm`],
          yellow: [lg`Lightning/StaticElectricity_02_Regular_Yellow_400x400.webm`]
        },
        "03": {
          blue: [lg`Lightning/StaticElectricity_03_Regular_Blue_400x400.webm`],
          darkgreen: [lg`Lightning/StaticElectricity_03_Regular_Green02_400x400.webm`],
          darkpurple: [lg`Lightning/StaticElectricity_03_Dark_Purple_400x400.webm`],
          darkred: [lg`Lightning/StaticElectricity_03_Dark_Red_400x400.webm`],
          green: [lg`Lightning/StaticElectricity_03_Regular_Green_400x400.webm`],
          orange: [lg`Lightning/StaticElectricity_03_Regular_Orange_400x400.webm`],
          purple: [lg`Lightning/StaticElectricity_03_Regular_Purple_400x400.webm`],
          purpleblue: [lg`Lightning/StaticElectricity_03_Regular_Blue02_400x400.webm`],
          red: [lg`Lightning/StaticElectricity_03_Regular_Red_400x400.webm`],
          yellow: [lg`Lightning/StaticElectricity_03_Regular_Yellow_400x400.webm`]
        }
      }
    },
    liquid: {
      splash: {
        "01": {
          black: [lg`Liquid/LiquidSplash01_Dark_Black_400x400.webm`],
          blue: [lg`Liquid/LiquidSplash01_Regular_Blue_400x400.webm`],
          brightgreen: [lg`Liquid/LiquidSplash01_Bright_Green_400x400.webm`],
          brightblue: [lg`Liquid/LiquidSplash01_Bright_Blue_400x400.webm`],
          green: [lg`Liquid/LiquidSplash01_Regular_Green_400x400.webm`],
          grey: [lg`Liquid/LiquidSplash01_Regular_Grey_400x400.webm`],
          purple: [lg`Liquid/LiquidSplash01_Bright_Purple_400x400.webm`],
          red: [lg`Liquid/LiquidSplash01_Regular_Red_400x400.webm`]
        }
      },
      blob: {
        "01": {
          blue: [lg`Liquid/LiquidBlob01_01_Regular_Blue_400x400.webm`],
          green: [lg`Liquid/LiquidBlob01_01_Regular_Green_400x400.webm`],
          purple: [lg`Liquid/LiquidBlob01_01_Regular_Purple_400x400.webm`]
        }
      }
    },
    magicsign: {
      abjuration: {
        "01": {
          blue: [lg`Magic_Signs/Abjuration_01_Blue_Circle_800x800.webm`],
          green: [lg`Magic_Signs/Abjuration_01_Green_Circle_800x800.webm`],
          red: [lg`Magic_Signs/Abjuration_01_Red_Circle_800x800.webm`]
        },
        "02": {
          blue: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        "runeintro": {
          blue: [lg`Magic_Signs/Runes/AbjurationRuneIntro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/AbjurationRuneIntro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/AbjurationRuneIntro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/AbjurationRuneIntro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/AbjurationRuneIntro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/AbjurationRuneIntro_01_Regular_Yellow_400x400.webm`]
        },
        "runeloop": {
          blue: [lg`Magic_Signs/Runes/AbjurationRuneLoop_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/AbjurationRuneLoop_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/AbjurationRuneLoop_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/AbjurationRuneLoop_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/AbjurationRuneLoop_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/AbjurationRuneLoop_01_Regular_Yellow_400x400.webm`]
        },
        "runeoutro": {
          blue: [lg`Magic_Signs/Runes/AbjurationRuneOutro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/AbjurationRuneOutro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/AbjurationRuneOutro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/AbjurationRuneOutro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/AbjurationRuneOutro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/AbjurationRuneOutro_01_Regular_Yellow_400x400.webm`]
        }
      },
      conjuration: {
        "01": {
          yellow: [lg`Magic_Signs/Conjuration_01_Yellow_Circle_800x800.webm`]
        },
        "02": {
          blue: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        "runeintro": {
          blue: [lg`Magic_Signs/Runes/ConjurationRuneIntro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/ConjurationRuneIntro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/ConjurationRuneIntro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/ConjurationRuneIntro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/ConjurationRuneIntro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/ConjurationRuneIntro_01_Regular_Yellow_400x400.webm`]
        },
        "runeloop": {
          blue: [lg`Magic_Signs/Runes/ConjurationRuneLoop_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/ConjurationRuneLoop_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/ConjurationRuneLoop_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/ConjurationRuneLoop_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/ConjurationRuneLoop_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/ConjurationRuneLoop_01_Regular_Yellow_400x400.webm`]
        },
        "runeoutro": {
          blue: [lg`Magic_Signs/Runes/ConjurationRuneOutro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/ConjurationRuneOutro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/ConjurationRuneOutro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/ConjurationRuneOutro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/ConjurationRuneOutro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/ConjurationRuneOutro_01_Regular_Yellow_400x400.webm`]
        }
      },
      divination: {
        "01": {
          lightblue: [lg`Magic_Signs/Divination_01_Light_Blue_Circle_800x800.webm`]
        },
        "02": {
          blue: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        "runeintro": {
          blue: [lg`Magic_Signs/Runes/DivinationRuneIntro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/DivinationRuneIntro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/DivinationRuneIntro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/DivinationRuneIntro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/DivinationRuneIntro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/DivinationRuneIntro_01_Regular_Yellow_400x400.webm`]
        },
        "runeloop": {
          blue: [lg`Magic_Signs/Runes/DivinationRuneLoop_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/DivinationRuneLoop_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/DivinationRuneLoop_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/DivinationRuneLoop_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/DivinationRuneLoop_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/DivinationRuneLoop_01_Regular_Yellow_400x400.webm`]
        },
        "runeoutro": {
          blue: [lg`Magic_Signs/Runes/DivinationRuneOutro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/DivinationRuneOutro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/DivinationRuneOutro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/DivinationRuneOutro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/DivinationRuneOutro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/DivinationRuneOutro_01_Regular_Yellow_400x400.webm`]
        }
      },
      enchantment: {
        "02": {
          blue: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        "runeintro": {
          blue: [lg`Magic_Signs/Runes/EnchantmentRuneIntro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/EnchantmentRuneIntro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/EnchantmentRuneIntro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/EnchantmentRuneIntro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/EnchantmentRuneIntro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/EnchantmentRuneIntro_01_Regular_Yellow_400x400.webm`]
        },
        "runeloop": {
          blue: [lg`Magic_Signs/Runes/EnchantmentRuneLoop_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/EnchantmentRuneLoop_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/EnchantmentRuneLoop_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/EnchantmentRuneLoop_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/EnchantmentRuneLoop_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/EnchantmentRuneLoop_01_Regular_Yellow_400x400.webm`]
        },
        "runeoutro": {
          blue: [lg`Magic_Signs/Runes/EnchantmentRuneOutro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/EnchantmentRuneOutro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/EnchantmentRuneOutro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/EnchantmentRuneOutro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/EnchantmentRuneOutro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/EnchantmentRuneOutro_01_Regular_Yellow_400x400.webm`]
        }
      },
      evocation: {
        "02": {
          blue: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        "runeintro": {
          blue: [lg`Magic_Signs/Runes/EvocationRuneIntro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/EvocationRuneIntro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/EvocationRuneIntro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/EvocationRuneIntro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/EvocationRuneIntro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/EvocationRuneIntro_01_Regular_Yellow_400x400.webm`]
        },
        "runeloop": {
          blue: [lg`Magic_Signs/Runes/EvocationRuneLoop_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/EvocationRuneLoop_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/EvocationRuneLoop_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/EvocationRuneLoop_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/EvocationRuneLoop_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/EvocationRuneLoop_01_Regular_Yellow_400x400.webm`]
        },
        "runeoutro": {
          blue: [lg`Magic_Signs/Runes/EvocationRuneOutro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/EvocationRuneOutro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/EvocationRuneOutro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/EvocationRuneOutro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/EvocationRuneOutro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/EvocationRuneOutro_01_Regular_Yellow_400x400.webm`]
        }
      },
      illusion: {
        "02": {
          blue: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        "runeintro": {
          blue: [lg`Magic_Signs/Runes/IllusionRuneIntro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/IllusionRuneIntro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/IllusionRuneIntro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/IllusionRuneIntro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/IllusionRuneIntro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/IllusionRuneIntro_01_Regular_Yellow_400x400.webm`]
        },
        "runeloop": {
          blue: [lg`Magic_Signs/Runes/IllusionRuneLoop_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/IllusionRuneLoop_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/IllusionRuneLoop_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/IllusionRuneLoop_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/IllusionRuneLoop_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/IllusionRuneLoop_01_Regular_Yellow_400x400.webm`]
        },
        "runeoutro": {
          blue: [lg`Magic_Signs/Runes/IllusionRuneOutro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/IllusionRuneOutro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/IllusionRuneOutro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/IllusionRuneOutro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/IllusionRuneOutro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/IllusionRuneOutro_01_Regular_Yellow_400x400.webm`]
        }
      },
      necromancy: {
        "02": {
          blue: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        "runeintro": {
          blue: [lg`Magic_Signs/Runes/NecromancyRuneIntro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/NecromancyRuneIntro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/NecromancyRuneIntro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/NecromancyRuneIntro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/NecromancyRuneIntro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/NecromancyRuneIntro_01_Regular_Yellow_400x400.webm`]
        },
        "runeloop": {
          blue: [lg`Magic_Signs/Runes/NecromancyRuneLoop_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/NecromancyRuneLoop_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/NecromancyRuneLoop_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/NecromancyRuneLoop_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/NecromancyRuneLoop_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/NecromancyRuneLoop_01_Regular_Yellow_400x400.webm`]
        },
        "runeoutro": {
          blue: [lg`Magic_Signs/Runes/NecromancyRuneOutro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/NecromancyRuneOutro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/NecromancyRuneOutro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/NecromancyRuneOutro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/NecromancyRuneOutro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/NecromancyRuneOutro_01_Regular_Yellow_400x400.webm`]
        }
      },
      transmutation: {
        "02": {
          blue: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Blue_800x800.webm`],
          green: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Green_800x800.webm`],
          pink: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Pink_800x800.webm`],
          purple: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Purple_800x800.webm`],
          red: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Red_800x800.webm`],
          yellow: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        "runeintro": {
          blue: [lg`Magic_Signs/Runes/TransmutationRuneIntro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/TransmutationRuneIntro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/TransmutationRuneIntro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/TransmutationRuneIntro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/TransmutationRuneIntro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/TransmutationRuneIntro_01_Regular_Yellow_400x400.webm`]
        },
        "runeloop": {
          blue: [lg`Magic_Signs/Runes/TransmutationRuneLoop_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/TransmutationRuneLoop_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/TransmutationRuneLoop_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/TransmutationRuneLoop_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/TransmutationRuneLoop_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/TransmutationRuneLoop_01_Regular_Yellow_400x400.webm`]
        },
        "runeoutro": {
          blue: [lg`Magic_Signs/Runes/TransmutationRuneOutro_01_Regular_Blue_400x400.webm`],
          green: [lg`Magic_Signs/Runes/TransmutationRuneOutro_01_Regular_Green_400x400.webm`],
          pink: [lg`Magic_Signs/Runes/TransmutationRuneOutro_01_Regular_Pink_400x400.webm`],
          purple: [lg`Magic_Signs/Runes/TransmutationRuneOutro_01_Regular_Purple_400x400.webm`],
          red: [lg`Magic_Signs/Runes/TransmutationRuneOutro_01_Regular_Red_400x400.webm`],
          yellow: [lg`Magic_Signs/Runes/TransmutationRuneOutro_01_Regular_Yellow_400x400.webm`]
        }
      }
    },
    marker: {
      bubble: {
        "01": {
          blue: [lg`Marker/MarkerBubble_01_Regular_Blue_400x400.webm`],
          green: [lg`Marker/MarkerBubble_01_Regular_Green_400x400.webm`],
          rainbow: [lg`Marker/MarkerBubble_01_Regular_Rainbow_400x400.webm`]
        }
      },
      circleofstars: {
        "01": {
          blue: [lg`Marker/MarkerCircleOfStars_Regular_Blue_400x400.webm`],
          green: [lg`Marker/MarkerCircleOfStars_Regular_Green_400x400.webm`],
          greenorange: [lg`Marker/MarkerCircleOfStars_Regular_GreenOrange_400x400.webm`],
          orangepurple: [lg`Marker/MarkerCircleOfStars_Regular_OrangePurple_400x400.webm`],
          purplegreen: [lg`Marker/MarkerCircleOfStars_Regular_PurpleGreen_400x400.webm`],
          yellowblue: [lg`Marker/MarkerCircleOfStars_Regular_YellowBlue_400x400.webm`]
        }
      },
      energystrand: {
        "01": {
          blue: [lg`Marker/EnergyStrands_01_Regular_Blue_600x600.webm`],
          blueorange: [lg`Marker/EnergyStrands_01_Regular_BlueOrange_600x600.webm`],
          darkred: [lg`Marker/EnergyStrands_01_Dark_Red_600x600.webm`],
          orange: [lg`Marker/EnergyStrands_01_Regular_Orange_600x600.webm`],
          pinkyellow: [lg`Marker/EnergyStrands_01_Regular_PinkYellow_600x600.webm`],
          purple: [lg`Marker/EnergyStrands_01_Regular_Purple_600x600.webm`]
        }
      },
      music: {
        "01": {
          darkred: [lg`Marker/MusicMarker_01_Dark_Red_400x400.webm`],
          yellowblue: [lg`Marker/MusicMarker_01_Regular_BlueYellow_400x400.webm`],
          greenorange: [lg`Marker/MusicMarker_01_Regular_GreenOrange_400x400.webm`],
          pink: [lg`Marker/MusicMarker_01_Regular_Pink_400x400.webm`],
          purplepink: [lg`Marker/MusicMarker_01_Regular_PurplePink_400x400.webm`]
        }
      },
      standard: {
        "01": {
          whiteblue: [lg`Marker/Marker_01_Dark_BlueWhite_400x400.webm`],
          yellowblue: [lg`Marker/Marker_01_Regular_BlueYellow_400x400.webm`],
          greenorange: [lg`Marker/Marker_01_Regular_GreenOrange_400x400.webm`],
          pink: [lg`Marker/Marker_01_Regular_Pink_400x400.webm`],
          purplepink: [lg`Marker/Marker_01_Regular_PurplePink_400x400.webm`],
          red: [lg`Marker/Marker_01_Regular_Red_400x400.webm`]
        },
        "02": {
          whiteblue: [lg`Marker/Marker_02_Dark_BlueWhite_400x400.webm`],
          yellowblue: [lg`Marker/Marker_02_Regular_BlueYellow_400x400.webm`],
          greenorange: [lg`Marker/Marker_02_Regular_GreenOrange_400x400.webm`],
          pink: [lg`Marker/Marker_02_Regular_Pink_400x400.webm`],
          purplepink: [lg`Marker/Marker_02_Regular_PurplePink_400x400.webm`],
          pink: [lg`Marker/Marker_02_Regular_Red_400x400.webm`]
        }
      }
    },
    music: {
      notes: {
        "01": {
          blue: [
            lg`Music_Notation/BassClef_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/BeamedQuavers_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/Crotchet_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/Flat_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/Quaver_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/Sharp_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/TrebleClef_01_Regular_Blue_200x200.webm`
          ],
          green: [
            lg`Music_Notation/BassClef_01_Regular_Green_200x200.webm`,
            lg`Music_Notation/BeamedQuavers_01_Regular_Green_200x200.webm`,
            lg`Music_Notation/Crotchet_01_Regular_Green_200x200.webm`,
            lg`Music_Notation/Flat_01_Regular_Green_200x200.webm`,
            lg`Music_Notation/Quaver_01_Regular_Green_200x200.webm`,
            lg`Music_Notation/Sharp_01_Regular_Green_200x200.webm`,
            lg`Music_Notation/TrebleClef_01_Regular_Green_200x200.webm`
          ],
          orange: [
            lg`Music_Notation/BassClef_01_Regular_Orange_200x200.webm`,
            lg`Music_Notation/BeamedQuavers_01_Regular_Orange_200x200.webm`,
            lg`Music_Notation/Crotchet_01_Regular_Orange_200x200.webm`,
            lg`Music_Notation/Flat_01_Regular_Orange_200x200.webm`,
            lg`Music_Notation/Quaver_01_Regular_Orange_200x200.webm`,
            lg`Music_Notation/Sharp_01_Regular_Orange_200x200.webm`,
            lg`Music_Notation/TrebleClef_01_Regular_Orange_200x200.webm`
          ],
          purple: [
            lg`Music_Notation/BassClef_01_Regular_Purple_200x200.webm`,
            lg`Music_Notation/BeamedQuavers_01_Regular_Purple_200x200.webm`,
            lg`Music_Notation/Crotchet_01_Regular_Purple_200x200.webm`,
            lg`Music_Notation/Flat_01_Regular_Purple_200x200.webm`,
            lg`Music_Notation/Quaver_01_Regular_Purple_200x200.webm`,
            lg`Music_Notation/Sharp_01_Regular_Purple_200x200.webm`,
            lg`Music_Notation/TrebleClef_01_Regular_Purple_200x200.webm`
          ]
        }
      }
    },
    particles: {
      dots: {
        "01": {
          blue: [lg`Particles/ParticlesOutward01_01_Regular_Blue_400x400.webm`],
          green: [lg`Particles/ParticlesOutward01_01_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesOutward01_01_Regular_Orange_400x400.webm`]
        },
        "02": {
          blue: [lg`Particles/ParticlesOutward01_02_Regular_Blue_400x400.webm`],
          green: [lg`Particles/ParticlesOutward01_02_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesOutward01_02_Regular_Orange_400x400.webm`]
        },
        "03": {
          blue: [lg`Particles/ParticlesOutward01_03_Regular_Blue_400x400.webm`],
          green: [lg`Particles/ParticlesOutward01_03_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesOutward01_03_Regular_Orange_400x400.webm`]
        },
        "04": {
          blue: [lg`Particles/ParticlesOutward01_04_Regular_Blue_400x400.webm`],
          green: [lg`Particles/ParticlesOutward01_04_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesOutward01_04_Regular_Orange_400x400.webm`]
        },
        "05": {
          blue: [lg`Particles/ParticlesOutward01_05_Regular_Blue_400x400.webm`],
          green: [lg`Particles/ParticlesOutward01_05_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesOutward01_05_Regular_Orange_400x400.webm`]
        }
      },
      inwarddots: {
        "01": {
          blue: [lg`Particles/ParticlesInward01_01_Regular_Blue_400x400.webm`],
          greenyellow: [lg`Particles/ParticlesInward01_01_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesInward01_01_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesInward01_01_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesInward01_01_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesInward01_01_Regular_White_400x400.webm`]
        },
        "02": {
          blue: [lg`Particles/ParticlesInward01_02_Regular_Blue_400x400.webm`],
          greenyellow: [lg`Particles/ParticlesInward01_02_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesInward01_02_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesInward01_02_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesInward01_02_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesInward01_02_Regular_White_400x400.webm`]
        },
        "03": {
          blue: [lg`Particles/ParticlesInward01_03_Regular_Blue_400x400.webm`],
          greenyellow: [lg`Particles/ParticlesInward01_03_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesInward01_03_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesInward01_03_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesInward01_03_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesInward01_03_Regular_White_400x400.webm`]
        },
        "04": {
          blue: [lg`Particles/ParticlesInward01_04_Regular_Blue_400x400.webm`],
          greenyellow: [lg`Particles/ParticlesInward01_04_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesInward01_04_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesInward01_04_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesInward01_04_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesInward01_04_Regular_White_400x400.webm`]
        },
        "05": {
          blue: [lg`Particles/ParticlesInward01_05_Regular_Blue_400x400.webm`],
          greenyellow: [lg`Particles/ParticlesInward01_05_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesInward01_05_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesInward01_05_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesInward01_05_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesInward01_05_Regular_White_400x400.webm`]
        }
      },
      stars: {
        "01": {
          blue: [lg`Particles/ParticlesOutward02_01_Regular_Blue_400x400.webm`],
          green: [lg`Particles/ParticlesOutward02_01_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesOutward02_01_Regular_Orange_400x400.webm`]
        },
        "02": {
          blue: [lg`Particles/ParticlesOutward02_02_Regular_Blue_400x400.webm`],
          green: [lg`Particles/ParticlesOutward02_02_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesOutward02_02_Regular_Orange_400x400.webm`]
        },
        "03": {
          blue: [lg`Particles/ParticlesOutward02_03_Regular_Blue_400x400.webm`],
          green: [lg`Particles/ParticlesOutward02_03_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesOutward02_03_Regular_Orange_400x400.webm`]
        },
        "04": {
          blue: [lg`Particles/ParticlesOutward02_04_Regular_Blue_400x400.webm`],
          green: [lg`Particles/ParticlesOutward02_04_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesOutward02_04_Regular_Orange_400x400.webm`]
        },
        "05": {
          blue: [lg`Particles/ParticlesOutward02_05_Regular_Blue_400x400.webm`],
          green: [lg`Particles/ParticlesOutward02_05_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesOutward02_05_Regular_Orange_400x400.webm`]
        }
      },
      inwardstars: {
        "01": {
          blue: [lg`Particles/ParticlesInward02_01_Regular_Blue_400x400.webm`],
          greenyellow: [lg`Particles/ParticlesInward02_01_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesInward02_01_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesInward02_01_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesInward02_01_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesInward02_01_Regular_White_400x400.webm`]
        },
        "02": {
          blue: [lg`Particles/ParticlesInward02_02_Regular_Blue_400x400.webm`],
          greenyellow: [lg`Particles/ParticlesInward02_02_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesInward02_02_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesInward02_02_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesInward02_02_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesInward02_02_Regular_White_400x400.webm`]
        },
        "03": {
          blue: [lg`Particles/ParticlesInward02_03_Regular_Blue_400x400.webm`],
          greenyellow: [lg`Particles/ParticlesInward02_03_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesInward02_03_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesInward02_03_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesInward02_03_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesInward02_03_Regular_White_400x400.webm`]
        },
        "04": {
          blue: [lg`Particles/ParticlesInward02_04_Regular_Blue_400x400.webm`],
          greenyellow: [lg`Particles/ParticlesInward02_04_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesInward02_04_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesInward02_04_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesInward02_04_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesInward02_04_Regular_White_400x400.webm`]
        },
        "05": {
          blue: [lg`Particles/ParticlesInward02_05_Regular_Blue_400x400.webm`],
          greenyellow: [lg`Particles/ParticlesInward02_05_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesInward02_05_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesInward02_05_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesInward02_05_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesInward02_05_Regular_White_400x400.webm`]
        }
      },
      swirl: {
        "01": {
          blue: [lg`Particles/ParticlesSwirl01_01_Regular_Blue_400x400.webm`],
          greenyellow: [lg`Particles/ParticlesSwirl01_01_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesSwirl01_01_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesSwirl01_01_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesSwirl01_01_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesSwirl01_01_Regular_White_400x400.webm`]
        },
        "02": {
          blue: [lg`Particles/ParticlesSwirl02_01_Regular_Blue_400x400.webm`],
          green: [lg`Particles/ParticlesSwirl02_01_Regular_GreenYellow_400x400.webm`],
          orange: [lg`Particles/ParticlesSwirl02_01_Regular_Orange_400x400.webm`],
          purple: [lg`Particles/ParticlesSwirl02_01_Regular_Purple_400x400.webm`],
          red: [lg`Particles/ParticlesSwirl02_01_Regular_Red_400x400.webm`],
          white: [lg`Particles/ParticlesSwirl02_01_Regular_White_400x400.webm`]
        }
      }
    },
    shieldfx: {
      eldritchweb: {
        "01": {
          darkgreen: [lg`Energy/ShieldEldritchWebAbove01_01_Dark_Green_400x400.webm`],
          darkpurple: [lg`Energy/ShieldEldritchWebAbove01_01_Dark_Purple_400x400.webm`]
        },
        "03": {
          darkgreen: [lg`Energy/ShieldEldritchWebAbove01_03_Dark_Green_400x400.webm`],
          darkpurple: [lg`Energy/ShieldEldritchWebAbove01_03_Dark_Purple_400x400.webm`]
        }
      },
      /*
      shieldeldritchwebbottom: {
          '01': {
              darkgreen: [lg`Energy/ShieldEldritchWebBelow01_02_Dark_Green_400x400.webm`],
              darkpurple: [lg`Energy/ShieldEldritchWebBelow01_02_Dark_Purple_400x400.webm`],
          },
          '03': {
              darkgreen: [lg`Energy/ShieldEldritchWebBelow01_03_Dark_Green_400x400.webm`],
              darkpurple: [lg`Energy/ShieldEldritchWebBelow01_03_Dark_Purple_400x400.webm`],
          }
      },
      */
      fire: {
        "01": {
          darkgreen: [lg`Fire/ShieldFireAbove01_01_Dark_Green_400x400.webm`],
          orange: [lg`Fire/ShieldFireAbove01_01_Regular_Orange_400x400.webm`]
        },
        "03": {
          darkgreen: [lg`Fire/ShieldFireAbove01_03_Dark_Green_400x400.webm`],
          orange: [lg`Fire/ShieldFireAbove01_03_Regular_Orange_400x400.webm`]
        }
      },
      /*
      shieldfirebottom: {
          '01': {
              darkgreen: [lg`Fire/ShieldFireBelow01_02_Dark_Green_400x400.webm`],
              orange: [lg`Fire/ShieldFireBelow01_02_Regular_Orange_400x400.webm`],
          },
          '03': {
              darkgreen: [lg`Fire/ShieldFireBelow01_03_Dark_Green_400x400.webm`],
              orange: [lg`Fire/ShieldFireBelow01_03_Regular_Orange_400x400.webm`],
          },
      },
      */
      earth: {
        "01": {
          darkorange: [lg`Fire/ShieldMoltenEarthAbove01_01_Dark_Orange_400x400.webm`],
          orange: [lg`Fire/ShieldMoltenEarthAbove01_01_Regular_Orange_400x400.webm`]
        },
        "03": {
          darkorange: [lg`Fire/ShieldMoltenEarthAbove01_03_Dark_Orange_400x400.webm`],
          orange: [lg`Fire/ShieldMoltenEarthAbove01_03_Regular_Orange_400x400.webm`]
        }
      },
      /*
      shieldearthbottom: {
          '01': {
              darkorange: [lg`Fire/ShieldMoltenEarthBelow01_02_Dark_Orange_400x400.webm`],
              orange: [lg`Fire/ShieldMoltenEarthBelow01_02_Regular_Orange_400x400.webm`],
          },
          '03': {
              darkorange: [lg`Fire/ShieldMoltenEarthBelow01_03_Dark_Orange_400x400.webm`],
              orange: [lg`Fire/ShieldMoltenEarthBelow01_03_Regular_Orange_400x400.webm`],
          },
      },
      */
      ice: {
        "01": {
          blue: [lg`Ice/ShieldIceAbove01_01_Regular_Blue_400x400.webm`],
          purple: [lg`Ice/ShieldIceAbove01_01_Regular_Purple_400x400.webm`]
        },
        "03": {
          blue: [lg`Ice/ShieldIceAbove01_03_Regular_Blue_400x400.webm`],
          purple: [lg`Ice/ShieldIceAbove01_03_Regular_Purple_400x400.webm`]
        }
      },
      /*
      shieldicebottom: {
          '01': {
              blue: [lg`Ice/ShieldIceBelow01_02_Regular_Blue_400x400.webm`],
              purple: [lg`Ice/ShieldIceBelow01_02_Regular_Purple_400x400.webm`],
          },
          '03': {
              blue: [lg`Ice/ShieldIceBelow01_03_Regular_Blue_400x400.webm`],
              purple: [lg`Ice/ShieldIceBelow01_03_Regular_Purple_400x400.webm`],
          },
      },
      energyfieldbottom: {
          '01': {
              blue: [lg`Energy/EnergyFieldBot_02_Regular_Blue_400x400.webm`],
              green: [lg`Energy/EnergyFieldBot_02_Regular_Green_400x400.webm`],
              purple: [lg`Energy/EnergyFieldBot_02_Regular_Purple_400x400.webm`],
          }
      },
      */
      energyfield: {
        "01": {
          blue: [lg`Energy/EnergyFieldTop_02_Regular_Blue_400x400.webm`],
          green: [lg`Energy/EnergyFieldTop_02_Regular_Green_400x400.webm`],
          purple: [lg`Energy/EnergyFieldTop_02_Regular_Purple_400x400.webm`]
        }
      }
    },
    shieldspell: {
      intro: {
        "01": {
          blue: [l1`Shield/Shield_01_Regular_Blue_Intro_400x400.webm`],
          green: [l1`Shield/Shield_01_Regular_Green_Intro_400x400.webm`],
          purple: [l1`Shield/Shield_01_Regular_Purple_Intro_400x400.webm`],
          red: [l1`Shield/Shield_01_Regular_Red_Intro_400x400.webm`],
          yellow: [l1`Shield/Shield_01_Regular_Yellow_Intro_400x400.webm`]
        },
        "02": {
          blue: [l1`Shield/Shield_02_Regular_Blue_Intro_400x400.webm`],
          green: [l1`Shield/Shield_02_Regular_Green_Intro_400x400.webm`],
          purple: [l1`Shield/Shield_02_Regular_Purple_Intro_400x400.webm`],
          red: [l1`Shield/Shield_02_Regular_Red_Intro_400x400.webm`],
          yellow: [l1`Shield/Shield_02_Regular_Yellow_Intro_400x400.webm`]
        },
        "03": {
          blue: [l1`Shield/Shield_03_Regular_Blue_Intro_400x400.webm`],
          green: [l1`Shield/Shield_03_Regular_Green_Intro_400x400.webm`],
          purple: [l1`Shield/Shield_03_Regular_Purple_Intro_400x400.webm`],
          red: [l1`Shield/Shield_03_Regular_Red_Intro_400x400.webm`],
          yellow: [l1`Shield/Shield_03_Regular_Yellow_Intro_400x400.webm`]
        }
      },
      loop: {
        "01": {
          blue: [l1`Shield/Shield_01_Regular_Blue_Loop_400x400.webm`],
          green: [l1`Shield/Shield_01_Regular_Green_Loop_400x400.webm`],
          purple: [l1`Shield/Shield_01_Regular_Purple_Loop_400x400.webm`],
          red: [l1`Shield/Shield_01_Regular_Red_Loop_400x400.webm`],
          yellow: [l1`Shield/Shield_01_Regular_Yellow_Loop_400x400.webm`]
        },
        "02": {
          blue: [l1`Shield/Shield_02_Regular_Blue_Loop_400x400.webm`],
          green: [l1`Shield/Shield_02_Regular_Green_Loop_400x400.webm`],
          purple: [l1`Shield/Shield_02_Regular_Purple_Loop_400x400.webm`],
          red: [l1`Shield/Shield_02_Regular_Red_Loop_400x400.webm`],
          yellow: [l1`Shield/Shield_02_Regular_Yellow_Loop_400x400.webm`]
        },
        "03": {
          blue: [l1`Shield/Shield_03_Regular_Blue_Loop_400x400.webm`],
          green: [l1`Shield/Shield_03_Regular_Green_Loop_400x400.webm`],
          purple: [l1`Shield/Shield_03_Regular_Purple_Loop_400x400.webm`],
          red: [l1`Shield/Shield_03_Regular_Red_Loop_400x400.webm`],
          yellow: [l1`Shield/Shield_03_Regular_Yellow_Loop_400x400.webm`]
        }
      },
      outro_explode: {
        "01": {
          blue: [l1`Shield/Shield_01_Regular_Blue_OutroExplode_400x400.webm`],
          green: [l1`Shield/Shield_01_Regular_Green_OutroExplode_400x400.webm`],
          purple: [l1`Shield/Shield_01_Regular_Purple_OutroExplode_400x400.webm`],
          red: [l1`Shield/Shield_01_Regular_Red_OutroExplode_400x400.webm`],
          yellow: [l1`Shield/Shield_01_Regular_Yellow_OutroExplode_400x400.webm`]
        },
        "02": {
          blue: [l1`Shield/Shield_02_Regular_Blue_OutroExplode_400x400.webm`],
          green: [l1`Shield/Shield_02_Regular_Green_OutroExplode_400x400.webm`],
          purple: [l1`Shield/Shield_02_Regular_Purple_OutroExplode_400x400.webm`],
          red: [l1`Shield/Shield_02_Regular_Red_OutroExplode_400x400.webm`],
          yellow: [l1`Shield/Shield_02_Regular_Yellow_OutroExplode_400x400.webm`]
        },
        "03": {
          blue: [l1`Shield/Shield_03_Regular_Blue_OutroExplode_400x400.webm`],
          green: [l1`Shield/Shield_03_Regular_Green_OutroExplode_400x400.webm`],
          purple: [l1`Shield/Shield_03_Regular_Purple_OutroExplode_400x400.webm`],
          red: [l1`Shield/Shield_03_Regular_Red_OutroExplode_400x400.webm`],
          yellow: [l1`Shield/Shield_03_Regular_Yellow_OutroExplode_400x400.webm`]
        }
      },
      outro_fade: {
        "01": {
          blue: [l1`Shield/Shield_01_Regular_Blue_OutroFade_400x400.webm`],
          green: [l1`Shield/Shield_01_Regular_Green_OutroFade_400x400.webm`],
          purple: [l1`Shield/Shield_01_Regular_Green_OutroFade_400x400.webm`],
          red: [l1`Shield/Shield_01_Regular_Red_OutroFade_400x400.webm`],
          yellow: [l1`Shield/Shield_01_Regular_Yellow_OutroFade_400x400.webm`]
        },
        "02": {
          blue: [l1`Shield/Shield_02_Regular_Blue_OutroFade_400x400.webm`],
          green: [l1`Shield/Shield_02_Regular_Green_OutroFade_400x400.webm`],
          purple: [l1`Shield/Shield_02_Regular_Purple_OutroFade_400x400.webm`],
          red: [l1`Shield/Shield_02_Regular_Red_OutroFade_400x400.webm`],
          yellow: [l1`Shield/Shield_02_Regular_Yellow_OutroFade_400x400.webm`]
        },
        "03": {
          blue: [l1`Shield/Shield_03_Regular_Blue_OutroFade_400x400.webm`],
          green: [l1`Shield/Shield_03_Regular_Green_OutroFade_400x400.webm`],
          purple: [l1`Shield/Shield_03_Regular_Purple_OutroFade_400x400.webm`],
          red: [l1`Shield/Shield_03_Regular_Red_OutroFade_400x400.webm`],
          yellow: [l1`Shield/Shield_03_Regular_Yellow_OutroFade_400x400.webm`]
        }
      },
      complete: {
        "01": {
          _markers: {
            loop: { start: 1533, end: 5533 },
            forcedEnd: 5533
          },
          blue: [l1`Shield/Shield_01_Regular_Blue_Complete_400x400.webm`],
          green: [l1`Shield/Shield_01_Regular_Green_Complete_400x400.webm`],
          purple: [l1`Shield/Shield_01_Regular_Purple_Complete_400x400.webm`],
          red: [l1`Shield/Shield_01_Regular_Red_Complete_400x400.webm`],
          yellow: [l1`Shield/Shield_01_Regular_Yellow_Complete_400x400.webm`]
        },
        "02": {
          _markers: {
            loop: { start: 1533, end: 5533 },
            forcedEnd: 5533
          },
          blue: [l1`Shield/Shield_02_Regular_Blue_Complete_400x400.webm`],
          green: [l1`Shield/Shield_02_Regular_Green_Complete_400x400.webm`],
          purple: [l1`Shield/Shield_02_Regular_Purple_Complete_400x400.webm`],
          red: [l1`Shield/Shield_02_Regular_Red_Complete_400x400.webm`],
          yellow: [l1`Shield/Shield_02_Regular_Yellow_Complete_400x400.webm`]
        },
        "03": {
          _markers: {
            loop: { start: 1533, end: 5533 },
            forcedEnd: 5533
          },
          blue: [l1`Shield/Shield_03_Regular_Blue_Complete_400x400.webm`],
          green: [l1`Shield/Shield_03_Regular_Green_Complete_400x400.webm`],
          purple: [l1`Shield/Shield_03_Regular_Purple_Complete_400x400.webm`],
          red: [l1`Shield/Shield_03_Regular_Red_Complete_400x400.webm`],
          yellow: [l1`Shield/Shield_03_Regular_Yellow_Complete_400x400.webm`]
        }
      }
    },
    shrapnel: {
      bomb: {
        "01": {
          black: [lg`Explosion/ShrapnelBomb01_01_Regular_Black_800x800.webm`],
          blue: [lg`Explosion/ShrapnelBomb01_01_Regular_Blue_800x800.webm`],
          green: [lg`Explosion/ShrapnelBomb01_01_Regular_Green_800x800.webm`],
          grey: [lg`Explosion/ShrapnelBomb01_01_Regular_Grey_800x800.webm`],
          red: [lg`Explosion/ShrapnelBomb01_01_Regular_Red_800x800.webm`]
        }
      },
      grenade: {
        "01": {
          green: [lg`Explosion/ShrapnelGrenade01_01_Regular_Green_800x800.webm`]
        },
        "02": {
          black: [lg`Explosion/ShrapnelGrenade02_01_Regular_Black_800x800.webm`]
        },
        "03": {
          black: [lg`Explosion/ShrapnelGrenade03_01_Regular_Black_800x800.webm`]
        }
      }
    },
    spell: {
      antilifeshell: {
        "01": {
          blue: [l5`Antilife_Shell/AntilifeShell_01_Blue_NoCircle_400x400.webm`]
        }
      },
      armsofhadar: {
        "01": {
          darkgreen: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Green_500x500.webm`],
          darkpurple: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Purple_500x500.webm`],
          darkred: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Red_500x500.webm`]
        }
      },
      bardicinspiration: {
        inspire: {
          yellowblue: [l1`Bardic_Inspiration/BardicInspiration_01_Regular_BlueYellow_400x400.webm`],
          greenorange: [l1`Bardic_Inspiration/BardicInspiration_01_Regular_GreenOrange_400x400.webm`],
          purplepink: [l1`Bardic_Inspiration/BardicInspiration_01_Regular_PurplePink_400x400.webm`],
          darkred: [l1`Bardic_Inspiration/BardicInspiration_01_Dark_Red_400x400.webm`],
          pink: [l1`Bardic_Inspiration/BardicInspiration_01_Regular_Pink_400x400.webm`]
        },
        marker: {
          yellowblue: [lg`Marker/MusicMarker_01_Regular_BlueYellow_400x400.webm`],
          greenorange: [lg`Marker/MusicMarker_01_Regular_GreenOrange_400x400.webm`],
          pink: [lg`Marker/MusicMarker_01_Regular_Pink_400x400.webm`],
          purplepink: [lg`Marker/MusicMarker_01_Regular_PurplePink_400x400.webm`],
          darkred: [lg`Marker/MusicMarker_01_Dark_Red_400x400.webm`]
        }
      },
      blacktentacles: {
        "01": {
          darkgreen: [l4`Black_Tentacles/BlackTentacles_01_Dark_Green_600x600.webm`],
          darkpurple: [l4`Black_Tentacles/BlackTentacles_01_Dark_Purple_600x600.webm`],
          darkred: [l4`Black_Tentacles/BlackTentacles_01_Dark_Red_600x600.webm`]
        }
      },
      bless: {
        "intro": {
          blue: [l1`Bless/Bless_01_Regular_Blue_Intro_400x400.webm`],
          green: [l1`Bless/Bless_01_Regular_Green_Intro_400x400.webm`],
          purple: [l1`Bless/Bless_01_Regular_Purple_Intro_400x400.webm`],
          yellow: [l1`Bless/Bless_01_Regular_Yellow_Intro_400x400.webm`]
        },
        "loop": {
          blue: [l1`Bless/Bless_01_Regular_Blue_Loop_400x400.webm`],
          green: [l1`Bless/Bless_01_Regular_Green_Loop_400x400.webm`],
          purple: [l1`Bless/Bless_01_Regular_Purple_Loop_400x400.webm`],
          yellow: [l1`Bless/Bless_01_Regular_Yellow_Loop_400x400.webm`]
        }
      },
      calllightning: {
        "01": {
          blue: [l3`Call_Lightning/CallLightning_01_Blue_1000x1000.webm`],
          blueorange: [l3`Call_Lightning/CallLightning_01_BlueOrange_1000x1000.webm`],
          green: [l3`Call_Lightning/CallLightning_01_Green_1000x1000.webm`],
          pinkyellow: [l3`Call_Lightning/CallLightning_01_PinkYellow_1000x1000.webm`],
          purple: [l3`Call_Lightning/CallLightning_01_Purple_1000x1000.webm`],
          red: [l3`Call_Lightning/CallLightning_01_Red_1000x1000.webm`],
          yellow: [l3`Call_Lightning/CallLightning_01_Yellow_1000x1000.webm`]
        }
      },
      cloudofdaggers: {
        "01": {
          darkpurple: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Dark_Purple_400x400.webm`],
          darkred: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Dark_Red_400x400.webm`],
          blue: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Blue_400x400.webm`],
          green: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Green_400x400.webm`],
          orange: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Orange_400x400.webm`],
          purple: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Purple_400x400.webm`],
          red: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Red_400x400.webm`],
          yellow: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Yellow_400x400.webm`]
        },
        kunai: {
          darkpurple: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Dark_Purple_400x400.webm`],
          darkred: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Dark_Red_400x400.webm`],
          blue: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Blue_400x400.webm`],
          green: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Green_400x400.webm`],
          orange: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Orange_400x400.webm`],
          purple: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Purple_400x400.webm`],
          red: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Red_400x400.webm`],
          yellow: [l2`Cloud_Of_Daggers/CloudOfDaggers_Kunai_01_Light_Yellow_400x400.webm`]
        }
      },
      curewounds: {
        "01": {
          blue: [l1`Cure_Wounds/CureWounds_01_Blue_400x400.webm`],
          green: [l1`Cure_Wounds/CureWounds_01_Green_400x400.webm`],
          pink: [l1`Cure_Wounds/CureWounds_01_Pink_400x400.webm`],
          purple: [l1`Cure_Wounds/CureWounds_01_Purple_400x400.webm`],
          red: [l1`Cure_Wounds/CureWounds_01_Red_400x400.webm`]
        }
      },
      darkness: {
        "01": {
          black: [l2`Darkness/Darkness_01_Black_600x600.webm`],
          green: [l2`Darkness/Darkness_01_Green_600x600.webm`]
        }
      },
      detectmagic: {
        "01": {
          blue: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Blue_1200x1200.webm`],
          green: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Green_1200x1200.webm`],
          greenorange: [l1`Detect_Magic/DetectMagicCircle_01_Regular_GreenOrange_1200x1200.webm`],
          grey: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Grey_1200x1200.webm`],
          purple: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Purple_1200x1200.webm`]
        }
      },
      divinesmite: {
        "source": {
          yellowblue: [l2`Divine_Smite/DivineSmite_01_Regular_BlueYellow_Caster_400x400.webm`],
          greenyellow: [l2`Divine_Smite/DivineSmite_01_Regular_GreenYellow_Caster_400x400.webm`],
          orange: [l2`Divine_Smite/DivineSmite_01_Regular_Orange_Caster_400x400.webm`],
          purplepink: [l2`Divine_Smite/DivineSmite_01_Regular_PurplePink_Caster_400x400.webm`],
          darkpurple: [l2`Divine_Smite/DivineSmite_01_Dark_Purple_Caster_400x400.webm`],
          yellowwhite: [l2`Divine_Smite/DivineSmite_01_Regular_YellowWhite_Caster_400x400.webm`],
          darkred: [l2`Divine_Smite/DivineSmite_01_Dark_Red_Caster_400x400.webm`]
        },
        "target": {
          yellowblue: [l2`Divine_Smite/DivineSmite_01_Regular_BlueYellow_Target_400x400.webm`],
          greenyellow: [l2`Divine_Smite/DivineSmite_01_Regular_GreenYellow_Target_400x400.webm`],
          orange: [l2`Divine_Smite/DivineSmite_01_Regular_Orange_Target_400x400.webm`],
          purplepink: [l2`Divine_Smite/DivineSmite_01_Regular_PurplePink_Target_400x400.webm`],
          darkpurple: [l2`Divine_Smite/DivineSmite_01_Dark_Purple_Target_400x400.webm`],
          yellowwhite: [l2`Divine_Smite/DivineSmite_01_Regular_YellowWhite_Target_400x400.webm`],
          darkred: [l2`Divine_Smite/DivineSmite_01_Dark_Red_Target_400x400.webm`]
        }
      },
      entangle: {
        "01": {
          brown: [l1`Entangle/Entangle_01_Brown_400x400.webm`],
          green: [l1`Entangle/Entangle_01_Green_400x400.webm`],
          yellow: [l1`Entangle/Entangle_01_Yellow_400x400.webm`],
          darkpurple: [l1`Entangle/Entangle_01_Dark_Purple_400x400.webm`],
          palegreen: [l1`Entangle/Entangle_01_Regular_Green02_400x400.webm`]
        }
      },
      fireball: {
        loop: {
          blue: [l3`Fireball/FireballLoop_01_Blue_800x800.webm`],
          orange: [l3`Fireball/FireballLoop_01_Orange_800x800.webm`],
          purple: [l3`Fireball/FireballLoop_01_Purple_800x800.webm`]
        },
        explode: {
          blue: [l3`Fireball/FireballExplosion_01_Blue_800x800.webm`],
          orange: [l3`Fireball/FireballExplosion_01_Orange_800x800.webm`],
          purple: [l3`Fireball/FireballExplosion_01_Purple_800x800.webm`]
        },
        nodebris: {
          blue: [l3`Fireball/FireballLoopNoDebris_01_Blue_800x800.webm`],
          orange: [l3`Fireball/FireballLoopNoDebris_01_Orange_800x800.webm`],
          purple: [l3`Fireball/FireballLoopNoDebris_01_Purple_800x800.webm`]
        }
      },
      fogcloud: {
        "01": {
          white: [l1`Fog_Cloud/FogCloud_01_White_800x800.webm`]
        },
        "02": {
          white: [l1`Fog_Cloud/FogCloud_02_Regular_White_800x800.webm`],
          green: [l1`Fog_Cloud/FogCloud_02_Regular_Green_800x800.webm`]
        }
      },
      generichealing: {
        "01": {
          blue: [lg`Healing/HealingAbility_01_Blue_400x400.webm`],
          green: [lg`Healing/HealingAbility_01_Green_400x400.webm`],
          purple: [lg`Healing/HealingAbility_01_Purple_400x400.webm`],
          red: [lg`Healing/HealingAbility_01_Red_400x400.webm`],
          yellow: [lg`Healing/HealingAbility_01_Yellow_400x400.webm`]
        },
        "02": {
          whiteblue: [lg`Healing/HealingAbility_02_Regular_BlueWhite_Burst_600x600.webm`],
          greenorange: [lg`Healing/HealingAbility_02_Regular_GreenOrange_Burst_600x600.webm`],
          purplepink: [lg`Healing/HealingAbility_02_Regular_PurplePink_Burst_600x600.webm`],
          tealyellow: [lg`Healing/HealingAbility_02_Regular_TealYellow_Burst_600x600.webm`]
        }
      },
      grease: {
        "01": {
          brown: [l1`Grease/Grease_Dark_Brown_600x600.webm`],
          green: [l1`Grease/Grease_Dark_Green_600x600.webm`],
          grey: [l1`Grease/Grease_Dark_Grey_600x600.webm`],
          purple: [l1`Grease/Grease_Dark_Purple_600x600.webm`]
        }
      },
      huntersmark: {
        "eye": {
          blue: [l1`Hunters_Mark/HuntersMark_01_Regular_Blue_Pulse_200x200.webm`],
          green: [l1`Hunters_Mark/HuntersMark_01_Regular_Green_Pulse_200x200.webm`],
          purple: [l1`Hunters_Mark/HuntersMark_01_Regular_Purple_Pulse_200x200.webm`],
          red: [l1`Hunters_Mark/HuntersMark_01_Regular_Red_Pulse_200x200.webm`]
        },
        "eyeloop": {
          blue: [l1`Hunters_Mark/HuntersMark_01_Regular_Blue_Loop_200x200.webm`],
          green: [l1`Hunters_Mark/HuntersMark_01_Regular_Green_Loop_200x200.webm`],
          purple: [l1`Hunters_Mark/HuntersMark_01_Regular_Purple_Loop_200x200.webm`],
          red: [l1`Hunters_Mark/HuntersMark_01_Regular_Red_Loop_200x200.webm`]
        },
        "paw": {
          blue: [l1`Hunters_Mark/HuntersMark_02_Regular_Blue_Pulse_200x200.webm`],
          green: [l1`Hunters_Mark/HuntersMark_02_Regular_Green_Pulse_200x200.webm`],
          purple: [l1`Hunters_Mark/HuntersMark_02_Regular_Purple_Pulse_200x200.webm`],
          red: [l1`Hunters_Mark/HuntersMark_02_Regular_Red_Pulse_200x200.webm`]
        },
        "pawloop": {
          blue: [l1`Hunters_Mark/HuntersMark_02_Regular_Blue_Loop_200x200.webm`],
          green: [l1`Hunters_Mark/HuntersMark_02_Regular_Green_Loop_200x200.webm`],
          purple: [l1`Hunters_Mark/HuntersMark_02_Regular_Purple_Loop_200x200.webm`],
          red: [l1`Hunters_Mark/HuntersMark_02_Regular_Red_Loop_200x200.webm`]
        }
      },
      mistystep: {
        "01": {
          black: [l2`Misty_Step/MistyStep_01_Dark_Black_400x400.webm`],
          blue: [l2`Misty_Step/MistyStep_01_Regular_Blue_400x400.webm`],
          green: [l2`Misty_Step/MistyStep_01_Regular_Green_400x400.webm`],
          orange: [l2`Misty_Step/MistyStep_01_Regular_Orange_400x400.webm`],
          purple: [l2`Misty_Step/MistyStep_01_Regular_Purple_400x400.webm`],
          darkgreen: [l2`Misty_Step/MistyStep_01_Dark_Green_400x400.webm`],
          darkred: [l2`Misty_Step/MistyStep_01_Dark_Red_400x400.webm`],
          grey: [l2`Misty_Step/MistyStep_01_Regular_Grey_400x400.webm`],
          red: [l2`Misty_Step/MistyStep_01_Regular_Red_400x400.webm`],
          yellow: [l2`Misty_Step/MistyStep_01_Regular_Yellow_400x400.webm`]
        },
        "02": {
          black: [l2`Misty_Step/MistyStep_02_Dark_Black_400x400.webm`],
          blue: [l2`Misty_Step/MistyStep_02_Regular_Blue_400x400.webm`],
          green: [l2`Misty_Step/MistyStep_02_Regular_Green_400x400.webm`],
          orange: [l2`Misty_Step/MistyStep_02_Regular_Orange_400x400.webm`],
          purple: [l2`Misty_Step/MistyStep_02_Regular_Purple_400x400.webm`],
          darkgreen: [l2`Misty_Step/MistyStep_02_Dark_Green_400x400.webm`],
          darkred: [l2`Misty_Step/MistyStep_02_Dark_Red_400x400.webm`],
          grey: [l2`Misty_Step/MistyStep_02_Regular_Grey_400x400.webm`],
          red: [l2`Misty_Step/MistyStep_02_Regular_Red_400x400.webm`],
          yellow: [l2`Misty_Step/MistyStep_02_Regular_Yellow_400x400.webm`]
        }
      },
      moonbeam: {
        loop: {
          blue: [l2`Moonbeam/Moonbeam_01_Regular_Blue_400x400.webm`],
          green: [l2`Moonbeam/Moonbeam_01_Regular_Green_400x400.webm`],
          rainbow: [l2`Moonbeam/Moonbeam_01_Regular_Rainbow_400x400.webm`]
        },
        nopulse: {
          blue: [l2`Moonbeam/MoonbeamNoPulse_01_Regular_Blue_400x400.webm`],
          green: [l2`Moonbeam/MoonbeamNoPulse_01_Regular_Green_400x400.webm`],
          rainbow: [l2`Moonbeam/MoonbeamNoPulse_01_Regular_Rainbow_400x400.webm`]
        },
        intro: {
          blue: [l2`Moonbeam/MoonbeamIntro_01_Regular_Blue_400x400.webm`],
          green: [l2`Moonbeam/MoonbeamIntro_01_Regular_Green_400x400.webm`],
          rainbow: [l2`Moonbeam/MoonbeamIntro_01_Regular_Rainbow_400x400.webm`]
        },
        outro: {
          blue: [l2`Moonbeam/MoonbeamOutro_01_Regular_Blue_400x400.webm`],
          green: [l2`Moonbeam/MoonbeamOutro_01_Regular_Green_400x400.webm`],
          rainbow: [l2`Moonbeam/MoonbeamOutro_01_Regular_Rainbow_400x400.webm`]
        }
      },
      sacredflame: {
        source: {
          blue: [l0`Sacred_Flame/SacredFlameSource_01_Regular_Blue_400x400.webm`],
          green: [l0`Sacred_Flame/SacredFlameSource_01_Regular_Green_400x400.webm`],
          purple: [l0`Sacred_Flame/SacredFlameSource_01_Regular_Purple_400x400.webm`],
          yellow: [l0`Sacred_Flame/SacredFlameSource_01_Regular_Yellow_400x400.webm`],
          white: [l0`Sacred_Flame/SacredFlameSource_01_Regular_White_400x400.webm`]
        },
        target: {
          blue: [l0`Sacred_Flame/SacredFlameTarget_01_Regular_Blue_400x400.webm`],
          green: [l0`Sacred_Flame/SacredFlameTarget_01_Regular_Green_400x400.webm`],
          purple: [l0`Sacred_Flame/SacredFlameTarget_01_Regular_Purple_400x400.webm`],
          yellow: [l0`Sacred_Flame/SacredFlameTarget_01_Regular_Yellow_400x400.webm`],
          white: [l0`Sacred_Flame/SacredFlameTarget_01_Regular_White_400x400.webm`]
        }
      },
      sneakattack: {
        "01": {
          darkgreen: [l1`Sneak_Attack/Sneak_Attack_Dark_Green_300x300.webm`],
          darkpurple: [l1`Sneak_Attack/Sneak_Attack_Dark_Purple_300x300.webm`],
          darkred: [l1`Sneak_Attack/Sneak_Attack_Dark_Red_300x300.webm`],
          blue: [l1`Sneak_Attack/Sneak_Attack_Regular_Blue_300x300.webm`],
          orange: [l1`Sneak_Attack/Sneak_Attack_Regular_Orange_300x300.webm`],
          pink: [l1`Sneak_Attack/Sneak_Attack_Regular_Pink_300x300.webm`],
          yellow: [l1`Sneak_Attack/Sneak_Attack_Regular_Yellow_300x300.webm`]
        }
      },
      thunderwave: {
        left: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_BLeft_600x600.webm`],
          green: [l1`Thunderwave/Thunderwave_01_Bright_Green_BLeft_600x600.webm`],
          orange: [l1`Thunderwave/Thunderwave_01_Bright_Orange_BLeft_600x600.webm`],
          purple: [l1`Thunderwave/Thunderwave_01_Dark_Purple_BLeft_600x600.webm`],
          red: [l1`Thunderwave/Thunderwave_01_Dark_Red_BLeft_600x600.webm`]
        },
        mid: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_BMid_600x600.webm`],
          green: [l1`Thunderwave/Thunderwave_01_Bright_Green_BMid_600x600.webm`],
          orange: [l1`Thunderwave/Thunderwave_01_Bright_Orange_BMid_600x600.webm`],
          purple: [l1`Thunderwave/Thunderwave_01_Dark_Purple_BMid_600x600.webm`],
          red: [l1`Thunderwave/Thunderwave_01_Dark_Red_BMid_600x600.webm`]
        },
        center: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_Center_600x600.webm`],
          green: [l1`Thunderwave/Thunderwave_01_Bright_Green_Center_600x600.webm`],
          orange: [l1`Thunderwave/Thunderwave_01_Bright_Orange_Center_600x600.webm`],
          purple: [l1`Thunderwave/Thunderwave_01_Dark_Purple_Center_600x600.webm`],
          red: [l1`Thunderwave/Thunderwave_01_Dark_Red_Center_600x600.webm`]
        }
      },
      shatter: {
        "01": {
          purple: [l2`Shatter/Shatter_01_Purple_400x400.webm`],
          red: [l2`Shatter/Shatter_01_Red_400x400.webm`],
          blue: [l2`Shatter/Shatter_01_Blue_400x400.webm`],
          green: [l2`Shatter/Shatter_01_Green_400x400.webm`],
          orange: [l2`Shatter/Shatter_01_Orange_400x400.webm`]
        }
      },
      sleep: {
        "01": {
          darkpurple: [l1`Sleep/Cloud01_01_Dark_Purple_400x400.webm`],
          blue: [l1`Sleep/Cloud01_01_Regular_Blue_400x400.webm`],
          green: [l1`Sleep/Cloud01_01_Regular_Green_400x400.webm`],
          orangepurple: [l1`Sleep/Cloud01_01_Dark_OrangePurple_400x400.webm`],
          pink: [l1`Sleep/Cloud01_01_Regular_Pink_400x400.webm`],
          yellow: [l1`Sleep/Cloud01_01_Regular_Yellow_400x400.webm`]
        },
        "02": {
          darkpurple: [l1`Sleep/Cloud01_02_Dark_Purple_400x400.webm`],
          blue: [l1`Sleep/Cloud01_02_Regular_Blue_400x400.webm`],
          green: [l1`Sleep/Cloud01_02_Regular_Green_400x400.webm`],
          orangepurple: [l1`Sleep/Cloud01_02_Dark_OrangePurple_400x400.webm`],
          pink: [l1`Sleep/Cloud01_02_Regular_Pink_400x400.webm`],
          yellow: [l1`Sleep/Cloud01_02_Regular_Yellow_400x400.webm`]
        },
        marker: {
          darkpurple: [l1`Sleep/SleepMarker01_01_Dark_Purple_400x400.webm`],
          blue: [l1`Sleep/SleepMarker01_01_Regular_Blue_400x400.webm`],
          green: [l1`Sleep/SleepMarker01_01_Regular_Green_400x400.webm`],
          orangepurple: [l1`Sleep/SleepMarker01_01_Dark_OrangePurple_400x400.webm`],
          pink: [l1`Sleep/SleepMarker01_01_Regular_Pink_400x400.webm`],
          yellow: [l1`Sleep/SleepMarker01_01_Regular_Yellow_400x400.webm`]
        },
        symbol: {
          darkpurple: [l1`Sleep/SleepSymbol01_01_Dark_Purple_400x400.webm`],
          blue: [l1`Sleep/SleepSymbol01_01_Regular_Blue_400x400.webm`],
          green: [l1`Sleep/SleepSymbol01_01_Regular_Green_400x400.webm`],
          orangepurple: [l1`Sleep/SleepSymbol01_01_Dark_OrangePurple_400x400.webm`],
          pink: [l1`Sleep/SleepSymbol01_01_Regular_Pink_400x400.webm`],
          yellow: [l1`Sleep/SleepSymbol01_01_Regular_Yellow_400x400.webm`]
        }
      },
      sleetstorm: {
        "01": {
          blue: [l3`Sleet_Storm/SleetStorm_01_Blue_800x800.webm`],
          green: [l3`Sleet_Storm/SleetStorm_01_Green_800x800.webm`],
          purple: [l3`Sleet_Storm/SleetStorm_01_Purple_800x800.webm`],
          tealyellow: [l3`Sleet_Storm/SleetStorm_01_TealYellow_800x800.webm`]
        }
      },
      spiritguardians: {
        "01": {
          black: [l3`Spirit_Guardians/SpiritGuardians_01_Dark_Black_600x600.webm`],
          darkblue: [l3`Spirit_Guardians/SpiritGuardians_01_Dark_Blue_600x600.webm`],
          darkpurple: [l3`Spirit_Guardians/SpiritGuardians_01_Dark_Purple_600x600.webm`],
          darkred: [l3`Spirit_Guardians/SpiritGuardians_01_Dark_Red_600x600.webm`],
          darkwhiteblue: [l3`Spirit_Guardians/SpiritGuardians_01_Dark_WhiteBlue_600x600.webm`],
          greenorange: [l3`Spirit_Guardians/SpiritGuardians_01_Light_GreenOrange_600x600.webm`],
          lightblue: [l3`Spirit_Guardians/SpiritGuardians_01_Light_Blue_600x600.webm`],
          lightgreen: [l3`Spirit_Guardians/SpiritGuardians_01_Light_Green_600x600.webm`],
          lightorange: [l3`Spirit_Guardians/SpiritGuardians_01_Light_Orange_600x600.webm`],
          yellowblue: [l3`Spirit_Guardians/SpiritGuardians_01_Light_BlueYellow_600x600.webm`],
          purplepink: [l3`Spirit_Guardians/SpiritGuardians_01_Light_PinkPurple_600x600.webm`]
        },
        "02": {
          black: [l3`Spirit_Guardians/SpiritGuardiansParticles_01_Dark_Black_600x600.webm`],
          darkblue: [l3`Spirit_Guardians/SpiritGuardiansParticles_01_Dark_Blue_600x600.webm`],
          darkpurple: [l3`Spirit_Guardians/SpiritGuardiansParticles_01_Dark_Purple_600x600.webm`],
          darkred: [l3`Spirit_Guardians/SpiritGuardiansParticles_01_Dark_Red_600x600.webm`],
          darkwhiteblue: [l3`Spirit_Guardians/SpiritGuardiansParticles_01_Dark_WhiteBlue_600x600.webm`],
          greenorange: [l3`Spirit_Guardians/SpiritGuardiansParticles_01_Light_GreenOrange_600x600.webm`],
          lightblue: [l3`Spirit_Guardians/SpiritGuardiansParticles_01_Light_Blue_600x600.webm`],
          lightgreen: [l3`Spirit_Guardians/SpiritGuardiansParticles_01_Light_Green_600x600.webm`],
          lightorange: [l3`Spirit_Guardians/SpiritGuardiansParticles_01_Light_Orange_600x600.webm`],
          yellowblue: [l3`Spirit_Guardians/SpiritGuardiansParticles_01_Light_BlueYellow_600x600.webm`],
          purplepink: [l3`Spirit_Guardians/SpiritGuardiansParticles_01_Light_PinkPurple_600x600.webm`]
        },
        "03": {
          black: [l3`Spirit_Guardians/SpiritGuardiansSpirits_01_Dark_Black_600x600.webm`],
          darkblue: [l3`Spirit_Guardians/SpiritGuardiansSpirits_01_Dark_Blue_600x600.webm`],
          darkpurple: [l3`Spirit_Guardians/SpiritGuardiansSpirits_01_Dark_Purple_600x600.webm`],
          darkred: [l3`Spirit_Guardians/SpiritGuardiansSpirits_01_Dark_Red_600x600.webm`],
          darkwhiteblue: [l3`Spirit_Guardians/SpiritGuardiansSpirits_01_Dark_WhiteBlue_600x600.webm`],
          greenorange: [l3`Spirit_Guardians/SpiritGuardiansSpirits_01_Light_GreenOrange_600x600.webm`],
          lightblue: [l3`Spirit_Guardians/SpiritGuardiansSpirits_01_Light_Blue_600x600.webm`],
          lightgreen: [l3`Spirit_Guardians/SpiritGuardiansSpirits_01_Light_Green_600x600.webm`],
          lightorange: [l3`Spirit_Guardians/SpiritGuardiansSpirits_01_Light_Orange_600x600.webm`],
          yellowblue: [l3`Spirit_Guardians/SpiritGuardiansSpirits_01_Light_BlueYellow_600x600.webm`],
          purplepink: [l3`Spirit_Guardians/SpiritGuardiansSpirits_01_Light_PinkPurple_600x600.webm`]
        },
        noring: {
          black: [l3`Spirit_Guardians/SpiritGuardiansNoRing_01_Dark_Black_600x600.webm`],
          darkblue: [l3`Spirit_Guardians/SpiritGuardiansNoRing_01_Dark_Blue_600x600.webm`],
          darkpurple: [l3`Spirit_Guardians/SpiritGuardiansNoRing_01_Dark_Purple_600x600.webm`],
          darkred: [l3`Spirit_Guardians/SpiritGuardiansNoRing_01_Dark_Red_600x600.webm`],
          darkwhiteblue: [l3`Spirit_Guardians/SpiritGuardiansNoRing_01_Dark_WhiteBlue_600x600.webm`],
          greenorange: [l3`Spirit_Guardians/SpiritGuardiansNoRing_01_Light_GreenOrange_600x600.webm`],
          lightblue: [l3`Spirit_Guardians/SpiritGuardiansNoRing_01_Light_Blue_600x600.webm`],
          lightgreen: [l3`Spirit_Guardians/SpiritGuardiansNoRing_01_Light_Green_600x600.webm`],
          lightorange: [l3`Spirit_Guardians/SpiritGuardiansNoRing_01_Light_Orange_600x600.webm`],
          yellowblue: [l3`Spirit_Guardians/SpiritGuardiansNoRing_01_Light_BlueYellow_600x600.webm`],
          purplepink: [l3`Spirit_Guardians/SpiritGuardiansNoRing_01_Light_PinkPurple_600x600.webm`]
        }
      },
      tollthedead: {
        bell: {
          blue: [l0`Toll_The_Dead/TollTheDeadBell_01_Regular_Blue_400x400.webm`],
          green: [l0`Toll_The_Dead/TollTheDeadBell_01_Regular_Green_400x400.webm`],
          purple: [l0`Toll_The_Dead/TollTheDeadBell_01_Regular_Purple_400x400.webm`],
          red: [l0`Toll_The_Dead/TollTheDeadBell_01_Regular_Red_400x400.webm`],
          grey: [l0`Toll_The_Dead/TollTheDeadBell_01_Regular_Grey_400x400.webm`]
        },
        complete: {
          blue: [l0`Toll_The_Dead/TollTheDead_01_Regular_Blue_400x400.webm`],
          green: [l0`Toll_The_Dead/TollTheDead_01_Regular_Green_400x400.webm`],
          purple: [l0`Toll_The_Dead/TollTheDead_01_Regular_Purple_400x400.webm`],
          red: [l0`Toll_The_Dead/TollTheDead_01_Regular_Red_400x400.webm`],
          grey: [l0`Toll_The_Dead/TollTheDead_01_Regular_Grey_400x400.webm`]
        },
        shockwave: {
          blue: [l0`Toll_The_Dead/TollTheDeadShockwave_01_Regular_Blue_400x400.webm`],
          green: [l0`Toll_The_Dead/TollTheDeadShockwave_01_Regular_Green_400x400.webm`],
          purple: [l0`Toll_The_Dead/TollTheDeadShockwave_01_Regular_Purple_400x400.webm`],
          red: [l0`Toll_The_Dead/TollTheDeadShockwave_01_Regular_Red_400x400.webm`],
          grey: [l0`Toll_The_Dead/TollTheDeadShockwave_01_Regular_Grey_400x400.webm`]
        },
        skull: {
          blue: [l0`Toll_The_Dead/TollTheDeadSkullSmoke_01_Regular_Blue_400x400.webm`],
          green: [l0`Toll_The_Dead/TollTheDeadSkullSmoke_01_Regular_Green_400x400.webm`],
          purple: [l0`Toll_The_Dead/TollTheDeadSkullSmoke_01_Regular_Purple_400x400.webm`],
          red: [l0`Toll_The_Dead/TollTheDeadSkullSmoke_01_Regular_Red_400x400.webm`],
          grey: [l0`Toll_The_Dead/TollTheDeadSkullSmoke_01_Regular_Grey_400x400.webm`]
        }
      },
      wallofforce: {
        "01": {
          blue: [l5`Wall_Of_Force/WallOfForce_01_Blue_Sphere_400x400.webm`],
          green: [l5`Wall_Of_Force/WallOfForce_01_Green_Sphere_400x400.webm`],
          grey: [l5`Wall_Of_Force/WallOfForce_01_Grey_Sphere_400x400.webm`],
          orange: [l5`Wall_Of_Force/WallOfForce_01_Orange_Sphere_400x400.webm`],
          purple: [l5`Wall_Of_Force/WallOfForce_01_Purple_Sphere_400x400.webm`],
          red: [l5`Wall_Of_Force/WallOfForce_01_Red_Sphere_400x400.webm`],
          yellow: [l5`Wall_Of_Force/WallOfForce_01_Yellow_Sphere_400x400.webm`]
        }
      },
      web: {
        "01": {
          white: [l2`Web/Web_01_White_01_400x400.webm`]
        },
        "02": {
          white: [l2`Web/Web_01_White_02_400x400.webm`]
        }
      },
      whirlwind: {
        "01": {
          blue: [l7`Whirlwind/Whirlwind_01_Blue_400x400.webm`],
          bluegrey: [l7`Whirlwind/Whirlwind_01_BlueGrey_01_400x400.webm`],
          green: [l7`Whirlwind/Whirlwind_01_Green_400x400.webm`],
          purple: [l7`Whirlwind/Whirlwind_01_Purple_400x400.webm`],
          red: [l7`Whirlwind/Whirlwind_01_Red_400x400.webm`]
        }
      }
    },
    tokenborder: {
      static: {
        "01": {
          blue: [lg`Token_Border/TokenBorderCircle_01_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_01_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_01_Regular_Purple_400x400.webm`]
        },
        "02": {
          blue: [lg`Token_Border/TokenBorderCircle_02_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_02_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_02_Regular_Purple_400x400.webm`]
        },
        "03": {
          blue: [lg`Token_Border/TokenBorderCircle_03_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_03_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_03_Regular_Purple_400x400.webm`]
        },
        "04": {
          blue: [lg`Token_Border/TokenBorderCircle_04_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_04_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_04_Regular_Purple_400x400.webm`]
        },
        "05": {
          blue: [lg`Token_Border/TokenBorderCircle_05_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_05_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_05_Regular_Purple_400x400.webm`]
        },
        "06": {
          blue: [lg`Token_Border/TokenBorderCircle_06_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_06_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_06_Regular_Purple_400x400.webm`]
        },
        "07": {
          blue: [lg`Token_Border/TokenBorderCircle_07_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_07_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_07_Regular_Purple_400x400.webm`]
        },
        "08": {
          blue: [lg`Token_Border/TokenBorderCircle_08_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_08_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_08_Regular_Purple_400x400.webm`]
        },
        "09": {
          blue: [lg`Token_Border/TokenBorderCircle_09_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_09_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_09_Regular_Purple_400x400.webm`]
        },
        "10": {
          blue: [lg`Token_Border/TokenBorderCircle_10_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_10_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_10_Regular_Purple_400x400.webm`]
        },
        "11": {
          blue: [lg`Token_Border/TokenBorderCircle_11_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_11_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_11_Regular_Purple_400x400.webm`]
        },
        "12": {
          blue: [lg`Token_Border/TokenBorderCircle_12_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_12_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_12_Regular_Purple_400x400.webm`]
        },
        "13": {
          blue: [lg`Token_Border/TokenBorderCircle_13_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircle_13_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircle_13_Regular_Purple_400x400.webm`]
        }
      },
      spinning: {
        "01": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_01_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_01_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_01_Regular_Purple_400x400.webm`]
        },
        "02": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_02_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_02_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_02_Regular_Purple_400x400.webm`]
        },
        "03": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_03_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_03_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_03_Regular_Purple_400x400.webm`]
        },
        "04": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_04_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_04_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_04_Regular_Purple_400x400.webm`]
        },
        "05": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_05_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_05_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_05_Regular_Purple_400x400.webm`]
        },
        "06": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_06_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_06_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_06_Regular_Purple_400x400.webm`]
        },
        "07": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_07_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_07_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_07_Regular_Purple_400x400.webm`]
        },
        "08": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_08_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_08_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_08_Regular_Purple_400x400.webm`]
        },
        "09": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_09_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_09_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_09_Regular_Purple_400x400.webm`]
        },
        "10": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_10_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_10_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_10_Regular_Purple_400x400.webm`]
        },
        "11": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_11_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_11_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_11_Regular_Purple_400x400.webm`]
        },
        "12": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_12_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_12_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_12_Regular_Purple_400x400.webm`]
        },
        "13": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_13_Regular_Blue_400x400.webm`],
          orange: [lg`Token_Border/TokenBorderCircleSpin_13_Regular_Orange_400x400.webm`],
          purple: [lg`Token_Border/TokenBorderCircleSpin_13_Regular_Purple_400x400.webm`]
        }
      }
    },
    trap: {
      fire: {
        single: {
          orange: [lg`Traps/FireTrap02_01_Regular_Orange_1400x1400.webm`],
          green: [lg`Traps/FireTrap02_01_Regular_Green_1400x1400.webm`]
        },
        double: {
          orange: [lg`Traps/FireTrapDual02_01_Regular_Orange_1400x1400.webm`],
          green: [lg`Traps/FireTrapDual02_01_Regular_Green_1400x1400.webm`]
        }
      }
    }
  };
  JB2APATREONDB.return = {
    _template: "ranged",
    weapon: {
      bone: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Bone01_01_Regular_White_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bone01_01_Regular_White_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bone01_01_Regular_White_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bone01_01_Regular_White_Return_90ft_4000x400.webm`]
          }
        }
      },
      chakram: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Chakram01_01_Regular_White_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Chakram01_01_Regular_White_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Chakram01_01_Regular_White_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Chakram01_01_Regular_White_Return_90ft_4000x400.webm`]
          }
        }
      },
      dagger: {
        "01": {
          blue: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Blue_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Blue_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Blue_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_Blue_Return_90ft_4000x400.webm`]
          },
          darkpurple: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Dark_Purple_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Dark_Purple_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Dark_Purple_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Dark_Purple_Return_90ft_4000x400.webm`]
          },
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_Return_90ft_4000x400.webm`]
          },
          pink: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_Return_90ft_4000x400.webm`]
          },
          red: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_Return_90ft_4000x400.webm`]
          }
        },
        "02": {
          blue: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Blue_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Blue_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Blue_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Blue_Return_90ft_4000x400.webm`]
          },
          darkpurple: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Dark_Purple_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Dark_Purple_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Dark_Purple_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Dark_Purple_Return_90ft_4000x400.webm`]
          },
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_White_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_White_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_White_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_White_Return_90ft_4000x400.webm`]
          },
          pink: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Pink_Return_90ft_4000x400.webm`]
          },
          red: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger02_01_Regular_Red_90ft_4000x400.webm`]
          }
        }
      },
      dart: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dart01_01_Regular_White_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dart01_01_Regular_White_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dart01_01_Regular_White_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dart01_01_Regular_White_Return_90ft_4000x400.webm`]
          }
        }
      },
      greatsword: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/GreatSword01_01_Regular_White_Return_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/GreatSword01_01_Regular_White_Return_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/GreatSword01_01_Regular_White_Return_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/GreatSword01_01_Regular_White_Return_90ft_4000x600.webm`]
          }
        }
      },
      hammer: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Hammer01_01_Regular_White_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Hammer01_01_Regular_White_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Hammer01_01_Regular_White_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Hammer01_01_Regular_White_Return_90ft_4000x400.webm`]
          }
        }
      },
      javelin: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Javelin01_01_Regular_White_Return_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Javelin01_01_Regular_White_Return_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Javelin01_01_Regular_White_Return_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Javelin01_01_Regular_White_Return_90ft_4000x600.webm`]
          }
        }
      },
      spear: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Spear01_01_Regular_White_Return_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Spear01_01_Regular_White_Return_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Spear01_01_Regular_White_Return_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Spear01_01_Regular_White_Return_90ft_4000x600.webm`]
          }
        }
      }
    }
  };
}
const JB2AFREEDB = {};
async function initializeJB2AFreeDB(path) {
  JB2AFREEDB._templates = {
    ranged: [200, 200, 200]
  };
  const BASE = `${path}/Library/`;
  const prefix = (str) => (strs, ...exprs) => `${BASE}${str}/${strs.reduce((a, c, i) => a + exprs[i - 1] + c)}`;
  const l0 = prefix("Cantrip");
  const l1 = prefix("1st_Level");
  const l2 = prefix("2nd_Level");
  const l3 = prefix("3rd_Level");
  const l4 = prefix("4th_Level");
  const l5 = prefix("5th_Level");
  const l6 = prefix("6th_Level");
  const l7 = prefix("7th_Level");
  const lg = prefix("Generic");
  JB2AFREEDB.range = {
    _template: "ranged",
    weapon: {
      arrow: {
        "regular": {
          regular: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_White_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_White_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow01_01_Regular_Green_90ft_4000x400.webm`]
          }
        },
        "physical": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Arrow02_01_Regular_Blue_Physical_90ft_4000x400.webm`]
          }
        }
      },
      bolt: {
        "physical": {
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Physical_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Physical_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Physical_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Physical_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bolt01_01_Regular_Orange_Physical_90ft_4000x400.webm`]
          }
        }
      },
      bomb: {
        "01": {
          black: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Black_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Black_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Black_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Black_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowBomb01_01_Regular_Black_90ft_4000x400.webm`]
          }
        }
      },
      bullet: {
        "1": {
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Orange_90ft_4000x400.webm`]
          }
        },
        "2": {
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Orange_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Orange_90ft_4000x400.webm`]
          }
        },
        "3": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Blue_90ft_4000x400.webm`]
          }
        }
      },
      cannonball: {
        "01": {
          black: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaunchCannonBall01_01_Regular_Black_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaunchCannonBall01_01_Regular_Black_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaunchCannonBall01_01_Regular_Black_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaunchCannonBall01_01_Regular_Black_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaunchCannonBall01_01_Regular_Black_90ft_4000x400.webm`]
          }
        }
      },
      dagger: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_90ft_4000x400.webm`]
          }
        }
      },
      flask: {
        "01": {
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Orange_90ft_4000x400.webm`]
          }
        }
      },
      lasershot: {
        "01": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Blue_90ft_4000x400.webm`]
          },
          green: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Green_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Green_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Green_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Green_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Green_90ft_4000x400.webm`]
          },
          orange: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Orange_90ft_4000x400.webm`]
          },
          red: {
            "05ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Red_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Red_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Red_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Red_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserShot_01_Regular_Red_90ft_4000x400.webm`]
          }
        }
      },
      lasersword: {
        "01": {
          blue: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSword01_01_Regular_Blue_90ft_4000x600.webm`]
          }
        },
        "02": {
          red: {
            "15ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Red_15ft_1000x600.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Red_30ft_1600x600.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Red_60ft_2800x600.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/LaserSwordDB01_01_Regular_Red_90ft_4000x600.webm`]
          }
        }
      },
      snipe: {
        "01": {
          blue: {
            "05ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Blue_90ft_4000x400.webm`]
          }
        }
      },
      snowball: {
        "01": {
          white: {
            "05ft": [lg`Weapon_Attacks/Ranged/SnowballToss_01_Regular_White_05ft_600x500.webm`],
            "15ft": [lg`Weapon_Attacks/Ranged/SnowballToss_01_Regular_White_15ft_1000x500.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/SnowballToss_01_Regular_White_30ft_1600x500.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/SnowballToss_01_Regular_White_60ft_2800x500.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/SnowballToss_01_Regular_White_90ft_4000x500.webm`]
          }
        }
      }
    },
    spell: {
      chainlightning: {
        primary: {
          blue: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_05ft_Primary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_15ft_Primary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_30ft_Primary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_60ft_Primary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_90ft_Primary_4000x400.webm`]
          }
        },
        secondary: {
          blue: {
            "05ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_05ft_Secondary_600x400.webm`],
            "15ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_15ft_Secondary_1000x400.webm`],
            "30ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_30ft_Secondary_1600x400.webm`],
            "60ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_60ft_Secondary_2800x400.webm`],
            "90ft": [l6`Chain_Lightning/ChainLightning_01_Regular_Blue_90ft_Secondary_4000x400.webm`]
          }
        }
      },
      disintegrate: {
        "01": {
          green: {
            "05ft": [l6`Disintegrate/Disintegrate_01_Regular_Green01_05ft_600x400.webm`],
            "15ft": [l6`Disintegrate/Disintegrate_01_Regular_Green01_15ft_1000x400.webm`],
            "30ft": [l6`Disintegrate/Disintegrate_01_Regular_Green01_30ft_1600x400.webm`],
            "60ft": [l6`Disintegrate/Disintegrate_01_Regular_Green01_60ft_2800x400.webm`],
            "90ft": [l6`Disintegrate/Disintegrate_01_Regular_Green01_90ft_4000x400.webm`]
          }
        }
      },
      eldritchblast: {
        "01": {
          purple: {
            "05ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Purple_05ft_600x400.webm`],
            "15ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Purple_15ft_1000x400.webm`],
            "30ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Purple_30ft_1600x400.webm`],
            "60ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Purple_60ft_2800x400.webm`],
            "90ft": [l0`Eldritch_Blast/EldritchBlast_01_Regular_Purple_90ft_4000x400.webm`]
          }
        }
      },
      fireballbeam: {
        "01": {
          orange: {
            "05ft": [l3`Fireball/FireballBeam_01_Orange_05ft_600x400.webm`],
            "15ft": [l3`Fireball/FireballBeam_01_Orange_15ft_1000x400.webm`],
            "30ft": [l3`Fireball/FireballBeam_01_Orange_30ft_1600x400.webm`],
            "60ft": [l3`Fireball/FireballBeam_01_Orange_60ft_2800x400.webm`],
            "90ft": [l3`Fireball/FireballBeam_01_Orange_90ft_4000x400.webm`]
          }
        }
      },
      firebolt: {
        "01": {
          orange: {
            "05ft": [l0`Fire_Bolt/FireBolt_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [l0`Fire_Bolt/FireBolt_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [l0`Fire_Bolt/FireBolt_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [l0`Fire_Bolt/FireBolt_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [l0`Fire_Bolt/FireBolt_01_Regular_Orange_90ft_4000x400.webm`]
          }
        }
      },
      guidingbolt: {
        "01": {
          yellowblue: {
            "05ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_BlueYellow_05ft_600x400.webm`],
            "15ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_BlueYellow_15ft_1000x400.webm`],
            "30ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_BlueYellow_30ft_1600x400.webm`],
            "60ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_BlueYellow_60ft_2800x400.webm`],
            "90ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_BlueYellow_90ft_4000x400.webm`]
          }
        }
      },
      magicmissile: {
        "01": {
          purple: {
            "05ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_05ft_01_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_05ft_02_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_05ft_03_600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_05ft_04_600x400.webm`
            ],
            "15ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_15ft_01_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_15ft_02_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_15ft_03_1000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_15ft_04_1000x400.webm`
            ],
            "30ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_30ft_01_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_30ft_02_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_30ft_03_1600x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_30ft_04_1600x400.webm`
            ],
            "60ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_60ft_01_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_60ft_02_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_60ft_03_2800x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_60ft_04_2800x400.webm`
            ],
            "90ft": [
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_90ft_01_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_90ft_02_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_90ft_03_4000x400.webm`,
              l1`Magic_Missile/MagicMissile_01_Regular_Purple_90ft_04_4000x400.webm`
            ]
          }
        }
      },
      rayoffrost: {
        "01": {
          blue: {
            "05ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [l0`Ray_Of_Frost/RayOfFrost_01_Regular_Blue_90ft_4000x400.webm`]
          }
        }
      },
      scorchingray: {
        "01": {
          orange: {
            "05ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Orange_05ft_600x400.webm`],
            "15ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Orange_15ft_1000x400.webm`],
            "30ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Orange_30ft_1600x400.webm`],
            "60ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Orange_60ft_2800x400.webm`],
            "90ft": [l2`Scorching_Ray/ScorchingRay_01_Regular_Orange_90ft_4000x400.webm`]
          }
        }
      },
      witchbolt: {
        "01": {
          blue: {
            "05ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [l1`Witch_Bolt/WitchBolt_01_Regular_Blue_90ft_4000x400.webm`]
          }
        }
      }
    },
    generic: {
      conduit: {
        circle: {
          purpleblue: {
            "05ft": [lg`Energy/EnergyConduitCircle_01_Regular_BluePurple_05ft_600x400.webm`],
            "15ft": [lg`Energy/EnergyConduitCircle_01_Regular_BluePurple_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyConduitCircle_01_Regular_BluePurple_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyConduitCircle_01_Regular_BluePurple_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyConduitCircle_01_Regular_BluePurple_90ft_4000x400.webm`]
          }
        }
      },
      energybeam: {
        "01": {
          blue: {
            "15ft": [lg`Energy/EnergyBeam_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_01_Regular_Blue_90ft_4000x400.webm`]
          }
        },
        "02": {
          blue: {
            "15ft": [lg`Energy/EnergyBeam_02_Regular_BluePink_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_02_Regular_BluePink_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_02_Regular_BluePink_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_02_Regular_BluePink_90ft_4000x400.webm`]
          }
        },
        "03": {
          blue: {
            "15ft": [lg`Energy/EnergyBeam_03_Regular_BluePink_15ft_1000x400.webm`],
            "30ft": [lg`Energy/EnergyBeam_03_Regular_BluePink_30ft_1600x400.webm`],
            "60ft": [lg`Energy/EnergyBeam_03_Regular_BluePink_60ft_2800x400.webm`],
            "90ft": [lg`Energy/EnergyBeam_03_Regular_BluePink_90ft_4000x400.webm`]
          }
        }
      },
      energystrand: {
        "01": {
          purple: {
            "05ft": [
              lg`Energy/EnergyStrand_01_Regular_Purple_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Purple_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Purple_05ft_600x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Purple_05ft_600x400.webm`
            ],
            "15ft": [
              lg`Energy/EnergyStrand_01_Regular_Purple_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Purple_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Purple_15ft_1000x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Purple_15ft_1000x400.webm`
            ],
            "30ft": [
              lg`Energy/EnergyStrand_01_Regular_Purple_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Purple_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Purple_30ft_1600x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Purple_30ft_1600x400.webm`
            ],
            "60ft": [
              lg`Energy/EnergyStrand_01_Regular_Purple_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Purple_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Purple_60ft_2800x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Purple_60ft_2800x400.webm`
            ],
            "90ft": [
              lg`Energy/EnergyStrand_01_Regular_Purple_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_02_Regular_Purple_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_03_Regular_Purple_90ft_4000x400.webm`,
              lg`Energy/EnergyStrand_04_Regular_Purple_90ft_4000x400.webm`
            ]
          }
        }
      },
      iceshard: {
        "01": {
          blue: {
            "05ft": [lg`RangedSpell/ProjectileIceShard01_01_Regular_Blue_05ft_600x400.webm`],
            "15ft": [lg`RangedSpell/ProjectileIceShard01_01_Regular_Blue_15ft_1000x400.webm`],
            "30ft": [lg`RangedSpell/ProjectileIceShard01_01_Regular_Blue_30ft_1600x400.webm`],
            "60ft": [lg`RangedSpell/ProjectileIceShard01_01_Regular_Blue_60ft_2800x400.webm`],
            "90ft": [lg`RangedSpell/ProjectileIceShard01_01_Regular_Blue_90ft_4000x400.webm`]
          }
        }
      },
      leaves: {
        "01": {
          greenorange: {
            "05ft": [lg`Nature/SwirlingLeaves01_01_Regular_GreenOrange_05ft_600x400.webm`],
            "15ft": [lg`Nature/SwirlingLeaves01_01_Regular_GreenOrange_15ft_1000x400.webm`],
            "30ft": [lg`Nature/SwirlingLeaves01_01_Regular_GreenOrange_30ft_1600x400.webm`],
            "60ft": [lg`Nature/SwirlingLeaves01_01_Regular_GreenOrange_60ft_2800x400.webm`],
            "90ft": [lg`Nature/SwirlingLeaves01_01_Regular_GreenOrange_90ft_4000x400.webm`]
          }
        }
      }
    }
  };
  JB2AFREEDB.melee = {
    creature: {
      bite: {
        "01": {
          red: [lg`Creature/Bite_01_Regular_Red_400x400.webm`]
        }
      },
      claw: {
        "01": {
          red: [lg`Creature/Claws_01_Regular_Red_400x400.webm`]
        }
      }
    },
    weapon: {
      club: {
        "01": {
          white: [
            [lg`Weapon_Attacks/Melee/Club01_01_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_02_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_03_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_04_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_05_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Club01_06_Regular_White_800x600.webm`]
          ]
        }
      },
      dagger: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/Dagger02_01_Regular_White_800x600.webm`]
        }
      },
      falchion: {
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Falchion01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Falchion01_06_Regular_White_800x600.webm`
          ]
        }
      },
      flurryofblows: {
        "magical": {
          blue: {
            "1": [lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Blue_Magical01_800x600.webm`],
            "2": [lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Blue_Magical02_800x600.webm`]
          }
        },
        "physical": {
          blue: {
            "1": [lg`Unarmed_Attacks/Flurry_Of_Blows/FlurryOfBlows_01_Regular_Blue_Physical01_800x600.webm`]
          }
        }
      },
      glaive: {
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Glaive01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Glaive01_06_Regular_White_800x600.webm`
          ]
        }
      },
      greataxe: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/GreatAxe01_01_Regular_White_800x600.webm`]
        }
      },
      greatclub: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/GreatClub01_01_Regular_White_800x600.webm`]
        }
      },
      greatsword: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/GreatSword01_01_Regular_White_800x600.webm`]
        }
      },
      halberd: {
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Halberd01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Halberd01_06_Regular_White_800x600.webm`
          ]
        }
      },
      hammer: {
        "01": {
          white: [
            [lg`Weapon_Attacks/Melee/Hammer01_01_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Hammer01_02_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Hammer01_03_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Hammer01_04_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Hammer01_05_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Hammer01_06_Regular_White_800x600.webm`]
          ]
        }
      },
      handaxe: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/HandAxe02_01_Regular_White_800x600.webm`]
        }
      },
      lasersword: {
        "01": {
          blue: [lg`Weapon_Attacks/Melee/LaserSword01_01_Regular_Blue_800x600.webm`]
        }
      },
      mace: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/Mace01_01_Regular_White_800x600.webm`]
        },
        "02": {
          white: [
            [lg`Weapon_Attacks/Melee/Mace01_01_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_02_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_03_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_04_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_05_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Mace01_06_Regular_White_800x600.webm`]
          ]
        }
      },
      maul: {
        "01": {
          white: [lg`Weapon_Attacks/Melee/Maul01_01_Regular_White_800x600.webm`]
        }
      },
      quarterstaff: {
        white: [
          lg`Weapon_Attacks/Melee/Quarterstaff01_01_Regular_White_800x600.webm`,
          lg`Weapon_Attacks/Melee/Quarterstaff01_02_Regular_White_800x600.webm`,
          lg`Weapon_Attacks/Melee/Quarterstaff01_03_Regular_White_800x600.webm`,
          lg`Weapon_Attacks/Melee/Quarterstaff01_04_Regular_White_800x600.webm`,
          lg`Weapon_Attacks/Melee/Quarterstaff01_05_Regular_White_800x600.webm`,
          lg`Weapon_Attacks/Melee/Quarterstaff01_06_Regular_White_800x600.webm`
        ]
      },
      rapier: {
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Rapier01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Rapier01_06_Regular_White_800x600.webm`
          ]
        }
      },
      scimitar: {
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Scimitar01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Scimitar01_06_Regular_White_800x600.webm`
          ]
        }
      },
      shortsword: {
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Shortsword01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Shortsword01_06_Regular_White_800x600.webm`
          ]
        }
      },
      spear: {
        "fire": {
          white: [lg`Weapon_Attacks/Melee/Spear01_01_Regular_White_800x600.webm`]
        },
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Spear01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Spear01_06_Regular_White_800x600.webm`
          ]
        }
      },
      sword: {
        "01": {
          white: [
            lg`Weapon_Attacks/Melee/Sword01_01_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_02_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_03_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_04_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_05_Regular_White_800x600.webm`,
            lg`Weapon_Attacks/Melee/Sword01_06_Regular_White_800x600.webm`
          ]
        }
      },
      unarmedstrike: {
        "magical": {
          blue: {
            "1": [lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Blue_Magical01_800x600.webm`],
            "2": [lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Blue_Magical02_800x600.webm`]
          }
        },
        "physical": {
          blue: {
            "1": [lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Blue_Physical01_800x600.webm`],
            "2": [lg`Unarmed_Attacks/Unarmed_Strike/UnarmedStrike_01_Regular_Blue_Physical02_800x600.webm`]
          }
        }
      },
      warhammer: {
        "01": {
          white: [
            [lg`Weapon_Attacks/Melee/Warhammer01_01_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_02_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_03_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_04_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_05_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Warhammer01_06_Regular_White_800x600.webm`]
          ]
        }
      },
      wrench: {
        "01": {
          white: [
            [lg`Weapon_Attacks/Melee/Wrench01_01_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_02_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_03_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_04_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_05_Regular_White_800x600.webm`],
            [lg`Weapon_Attacks/Melee/Wrench01_06_Regular_White_800x600.webm`]
          ]
        }
      }
    }
  };
  JB2AFREEDB.templatefx = {
    circle: {
      armsofhadar: {
        "01": {
          darkpurple: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Purple_500x500.webm`]
        }
      },
      blacktentacles: {
        "01": {
          darkpurple: [l4`Black_Tentacles/BlackTentacles_01_Dark_Purple_600x600.webm`]
        }
      },
      calllightning: {
        "01": {
          blue: [l3`Call_Lightning/CallLightning_01_Blue_1000x1000.webm`],
          blueorange: [l3`Call_Lightning/CallLightning_01_BlueOrange_1000x1000.webm`],
          green: [l3`Call_Lightning/CallLightning_01_Green_1000x1000.webm`],
          pinkyellow: [l3`Call_Lightning/CallLightning_01_PinkYellow_1000x1000.webm`],
          purple: [l3`Call_Lightning/CallLightning_01_Purple_1000x1000.webm`],
          red: [l3`Call_Lightning/CallLightning_01_Red_1000x1000.webm`],
          yellow: [l3`Call_Lightning/CallLightning_01_Yellow_1000x1000.webm`]
        }
      },
      cloudofdaggers: {
        "01": {
          blue: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Blue_400x400.webm`],
          green: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Green_400x400.webm`],
          orange: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Orange_400x400.webm`],
          purple: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Purple_400x400.webm`],
          red: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Red_400x400.webm`],
          yellow: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Yellow_400x400.webm`]
        }
      },
      crackedshield: {
        "01": {
          darkpurple: [lg`Template/Circle/TemplateShieldCrackedCircle_01_Regular_Purple_800x800.webm`]
        }
      },
      darkness: {
        "01": {
          black: [l2`Darkness/Darkness_01_Black_600x600.webm`],
          green: [l2`Darkness/Darkness_01_Green_600x600.webm`]
        }
      },
      detectmagic: {
        "01": {
          blue: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Blue_1200x1200.webm`]
        }
      },
      drop: {
        "01": {
          red: [lg`Template/Circle/TemplateDropCircle_01_Regular_Red_800x800.webm`]
        }
      },
      explosion: {
        "01": {
          blue: [
            lg`Explosion/Explosion_02_Blue_400x400.webm`,
            lg`Explosion/Explosion_04_Regular_Blue_400x400.webm`
          ],
          orange: [
            lg`Explosion/Explosion_01_Orange_400x400.webm`,
            lg`Explosion/Explosion_05_Regular_Orange_400x400.webm`
          ],
          yellowblue: [
            lg`Explosion/Explosion_03_Regular_BlueYellow_400x400.webm`
          ]
        }
      },
      fear: {
        "01": {
          darkpurple: [lg`Template/Circle/TemplateFearCircle_01_Dark_Purple_800x800.webm`]
        }
      },
      fireball: {
        explode: {
          orange: [l3`Fireball/FireballExplosion_01_Orange_800x800.webm`]
        },
        loop: {
          orange: [l3`Fireball/FireballLoop_01_Orange_800x800.webm`]
        },
        nodebris: {
          orange: [l3`Fireball/FireballLoopNoDebris_01_Orange_800x800.webm`]
        }
      },
      fogcloud: {
        "01": {
          white: [l1`Fog_Cloud/FogCloud_01_White_800x800.webm`]
        }
      },
      heart: {
        "01": {
          pink: [lg`Template/Circle/TemplateHeartCircle_01_Regular_Pink_800x800.webm`]
        }
      },
      horror: {
        "01": {
          purple: [lg`Template/Circle/TemplateHorrorCircle_01_Regular_Purple_800x800.webm`]
        }
      },
      magicsign: {
        abjuration: {
          blue: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Blue_800x800.webm`]
        },
        conjuration: {
          yellow: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        divination: {
          blue: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Blue_800x800.webm`]
        },
        enchantment: {
          pink: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Pink_800x800.webm`]
        },
        evocation: {
          red: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Red_800x800.webm`]
        },
        illusion: {
          purple: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Purple_800x800.webm`]
        },
        necromancy: {
          green: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Green_800x800.webm`]
        },
        transmutation: {
          yellow: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Yellow_800x800.webm`]
        }
      },
      moonbeam: {
        loop: {
          blue: [l2`Moonbeam/Moonbeam_01_Regular_Blue_400x400.webm`]
        },
        nopulse: {
          blue: [l2`Moonbeam/MoonbeamNoPulse_01_Regular_Blue_400x400.webm`]
        },
        intro: {
          blue: [l2`Moonbeam/MoonbeamIntro_01_Regular_Blue_400x400.webm`]
        },
        outro: {
          blue: [l2`Moonbeam/MoonbeamOutro_01_Regular_Blue_400x400.webm`]
        }
      },
      musicnote: {
        "01": {
          blue: [lg`Template/Circle/TemplateMusicNoteCircle_01_Regular_Blue_800x800.webm`]
        }
      },
      outpulse: {
        "01": {
          whiteblue: [
            lg`Template/Circle/OutPulse/OutPulse_01_Regular_BlueWhite_Burst_600x600.webm`
          ]
        },
        "02": {
          whiteblue: [
            lg`Template/Circle/OutPulse/OutPulse_02_Regular_BlueWhite_Burst_600x600.webm`
          ]
        }
      },
      poison: {
        "01": {
          darkgreen: [lg`Template/Circle/TemplatePoisonCircle_01_Dark_Green_800x800.webm`]
        }
      },
      runes: {
        "01": {
          orange: [lg`Template/Circle/TemplateRunesCircle_01_Regular_Orange_800x800.webm`]
        }
      },
      shatter: {
        "01": {
          blue: [l2`Shatter/Shatter_01_Blue_400x400.webm`]
        }
      },
      shields: {
        "01": {
          green: [lg`Template/Circle/TemplateShieldCircle_01_Regular_Green_800x800.webm`]
        }
      },
      skull: {
        "01": {
          purple: [lg`Template/Circle/TemplateSkullCircle_01_Regular_Purple_800x800.webm`]
        }
      },
      sleetstorm: {
        "01": {
          blue: [l3`Sleet_Storm/SleetStorm_01_Blue_800x800.webm`]
        }
      },
      snowflakes: {
        "01": {
          blue: [lg`Template/Circle/TemplateSnowflakeCircle_01_Regular_Blue_800x800.webm`]
        }
      },
      stun: {
        "01": {
          purple: [lg`Template/Circle/TemplateStunCircle_01_Regular_Purple_800x800.webm`]
        }
      },
      snowflake: {
        "01": {
          whiteblue: [
            lg`Ice/SnowflakeBurst_01_Regular_BlueWhite_Burst_600x600.webm`
          ]
        }
      },
      vortex: {
        loop: {
          blue: [lg`Template/Circle/Vortex_01_Regular_Blue_600x600.webm`]
        },
        intro: {
          blue: [lg`Template/Circle/VortexIntro_01_Regular_Blue_600x600.webm`]
        },
        outro: {
          blue: [lg`Template/Circle/VortexOutro_01_Regular_Blue_600x600.webm`]
        }
      },
      whirl: {
        loop: {
          blue: [lg`Template/Circle/Whirl_01_Regular_Blue_600x600.webm`]
        },
        intro: {
          blue: [lg`Template/Circle/WhirlIntro_01_Regular_Blue_600x600.webm`]
        },
        outro: {
          blue: [lg`Template/Circle/WhirlOutro_01_Regular_Blue_600x600.webm`]
        }
      }
    },
    cone: {
      breathweapon: {
        "cold": {
          blue: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Cold01_Regular_Blue_30ft_Cone_Burst_600x600.webm`]
        },
        "fire01": {
          orange: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Fire01_Regular_Orange_30ft_Cone_Burst_600x600.webm`]
        },
        "poison": {
          green: [lg`Template/Cone/Breath_Weapon/BreathWeapon_Poison01_Regular_Green_30ft_Cone_Burst_600x600.webm`]
        }
      },
      breathweaponspray01: {
        burst: {
          orange: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire01_Regular_Orange_Cone_Burst_800x800.webm`]
        },
        loop: {
          orange: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire01_Regular_Orange_Cone_Loop_800x800.webm`]
        }
      },
      breathweaponspray02: {
        burst: {
          orange: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire02_Regular_Orange_Cone_Burst_800x800.webm`]
        },
        loop: {
          orange: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Fire02_Regular_Orange_Cone_Loop_800x800.webm`]
        }
      },
      coneofcold: {
        "01": {
          blue: [l5`Cone_Of_Cold/ConeOfCold_01_Regular_Blue_600x600.webm`]
        }
      },
      burninghands: {
        "01": {
          orange: [l1`Burning_Hands/BurningHands_01_Regular_Orange_600x600.webm`]
        }
      }
    },
    ray: {
      breathweapon: {
        acid: {
          green: [lg`Template/Line/Breath_Weapon/BreathWeapon_Acid01_Regular_Green_30ft_Line_Burst_1200x200.webm`]
        },
        fire: {
          orange: [lg`Template/Line/Breath_Weapon/BreathWeapon_Fire01_Regular_Orange_30ft_Line_Burst_1200x200.webm`]
        },
        lightning: {
          blue: [lg`Template/Line/Breath_Weapon/BreathWeapon_Lightning01_Regular_Blue_30ft_Line_Burst_1200x200.webm`]
        }
      },
      lightningbolt: {
        "01": {
          blue: [l3`Lightning_Bolt/LightningBolt_01_Regular_Blue_4000x200.webm`]
        },
        "02": {
          blue: [l3`Lightning_Bolt/LightningBolt_01_Regular_Blue_4000x400.webm`]
        }
      },
      gustofwind: {
        slow: {
          white: [l2`Gust_Of_Wind/GustOfWind_01_White_1200x200.webm`]
        },
        fast: {
          white: [l2`Gust_Of_Wind/GustOfWind_01_White_VeryFast_1200x200.webm`]
        }
      }
    },
    square: {
      armsofhadar: {
        "01": {
          darkpurple: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Purple_500x500.webm`]
        }
      },
      blacktentacles: {
        "01": {
          darkpurple: [l4`Black_Tentacles/BlackTentacles_01_Dark_Purple_600x600.webm`]
        }
      },
      crackedshield: {
        "01": {
          darkpurple: [lg`Template/Square/TemplateShieldCrackedSquare_01_Regular_Purple_600x600.webm`]
        }
      },
      drop: {
        "01": {
          red: [lg`Template/Square/TemplateDropSquare_01_Regular_Red_600x600.webm`]
        }
      },
      entangle: {
        "01": {
          brown: [l1`Entangle/Entangle_01_Brown_400x400.webm`],
          green: [l1`Entangle/Entangle_01_Green_400x400.webm`],
          yellow: [l1`Entangle/Entangle_01_Yellow_400x400.webm`]
        }
      },
      fear: {
        "01": {
          darkpurple: [lg`Template/Square/TemplateFearSquare_01_Dark_Purple_600x600.webm`]
        }
      },
      grease: {
        "01": {
          brown: [l1`Grease/Grease_Dark_Brown_600x600.webm`]
        }
      },
      heart: {
        "01": {
          pink: [lg`Template/Square/TemplateHeartSquare_01_Regular_Pink_600x600.webm`]
        }
      },
      horror: {
        "01": {
          purple: [lg`Template/Square/TemplateHorrorSquare_01_Regular_Purple_600x600.webm`]
        }
      },
      musicnote: {
        "01": {
          blue: [lg`Template/Circle/TemplateMusicNoteCircle_01_Regular_Blue_800x800.webm`]
        }
      },
      poison: {
        "01": {
          darkgreen: [lg`Template/Square/TemplatePoisonSquare_01_Dark_Green_600x600.webm`]
        }
      },
      runes: {
        "01": {
          orange: [lg`Template/Square/TemplateRunesSquare_01_Regular_Orange_600x600.webm`]
        }
      },
      shields: {
        "01": {
          green: [lg`Template/Square/TemplateShieldSquare_01_Regular_Green_600x600.webm`]
        }
      },
      snowflakes: {
        "01": {
          blue: [lg`Template/Square/TemplateSnowflakeSquare_01_Regular_Blue_600x600.webm`]
        }
      },
      skull: {
        "01": {
          purple: [lg`Template/Square/TemplateSkullSquare_01_Regular_Purple_600x600.webm`]
        }
      },
      stun: {
        "01": {
          purple: [lg`Template/Square/TemplateStunSquare_01_Regular_Purple_600x600.webm`]
        }
      },
      thunderwave: {
        left: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_BLeft_600x600.webm`]
        },
        mid: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_BMid_600x600.webm`]
        },
        center: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_Center_600x600.webm`]
        }
      },
      web: {
        "01": {
          white: [l2`Web/Web_01_White_01_400x400.webm`]
        }
      }
    }
  };
  JB2AFREEDB.static = {
    chains: {
      standard: {
        "01": {
          red: [lg`Marker/MarkerChainStandard01_01_Regular_Red_Loop_400x400.webm`]
        },
        complete: {
          _markers: {
            loop: { start: 2033, end: 7e3 },
            forcedEnd: 7933
          },
          red: [lg`Marker/MarkerChainStandard01_02_Regular_Red_Complete_400x400.webm`]
        },
        loop: {
          red: [lg`Marker/MarkerChainStandard01_02_Regular_Red_Loop_400x400.webm`]
        }
      }
    },
    conditions: {
      drop: {
        "02": {
          red: [lg`Marker/MarkerDrop_02_Regular_Red_400x400.webm`]
        },
        "03": {
          red: [lg`Marker/MarkerDrop_03_Regular_Red_400x400.webm`]
        }
      },
      fear: {
        "01": {
          darkpurple: [lg`Marker/MarkerFear_01_Dark_Purple_400x400.webm`]
        },
        "02": {
          darkpurple: [lg`Marker/MarkerFear_02_Dark_Purple_400x400.webm`]
        },
        "03": {
          darkpurple: [lg`Marker/MarkerFear_03_Dark_Purple_400x400.webm`]
        }
      },
      heart: {
        "01": {
          pink: [lg`Marker/MarkerHeart_01_Regular_Pink_400x400.webm`]
        },
        "02": {
          pink: [lg`Marker/MarkerHeart_02_Regular_Pink_400x400.webm`]
        },
        "03": {
          pink: [lg`Marker/MarkerHeart_03_Regular_Pink_400x400.webm`]
        }
      },
      horror: {
        "01": {
          purple: [lg`Marker/MarkerHorror_01_Regular_Purple_400x400.webm`]
        },
        "02": {
          purple: [lg`Marker/MarkerHorror_02_Regular_Purple_400x400.webm`]
        },
        "03": {
          purple: [lg`Marker/MarkerHorror_03_Regular_Purple_400x400.webm`]
        }
      },
      light: {
        pulse: {
          blue: [lg`Marker/MarkerLight_01_Regular_Blue_400x400.webm`]
        },
        nopulse: {
          blue: [lg`Marker/MarkerLightNoPulse_01_Regular_Blue_400x400.webm`]
        }
      },
      poison: {
        "02": {
          darkgreen: [lg`Marker/MarkerPoison_02_Dark_Green_400x400.webm`]
        },
        "03": {
          darkgreen: [lg`Marker/MarkerPoison_03_Dark_Green_400x400.webm`]
        }
      },
      runes: {
        "01": {
          darkorange: [lg`Marker/MarkerRunes_01_Dark_Orange_400x400.webm`]
        },
        "02": {
          orange: [lg`Marker/MarkerRunes_02_Regular_Orange_400x400.webm`]
        },
        "03": {
          orange: [lg`Marker/MarkerRunes_03_Regular_Orange_400x400.webm`]
        }
      },
      shields: {
        "02": {
          green: [lg`Marker/MarkerShield_02_Regular_Green_400x400.webm`]
        },
        "03": {
          green: [lg`Marker/MarkerShield_03_Regular_Green_400x400.webm`]
        }
      },
      crackedshield: {
        "02": {
          purple: [lg`Marker/MarkerShieldCracked_02_Regular_Purple_400x400.webm`]
        },
        "03": {
          purple: [lg`Marker/MarkerShieldCracked_03_Regular_Purple_400x400.webm`]
        }
      },
      skull: {
        "01": {
          darkorange: [lg`Marker/MarkerSkull_01_Dark_Orange_400x400.webm`]
        },
        "02": {
          purple: [lg`Marker/MarkerSkull_02_Regular_Purple_400x400.webm`]
        },
        "03": {
          purple: [lg`Marker/MarkerSkull_03_Regular_Purple_400x400.webm`]
        }
      },
      snowflakes: {
        "02": {
          blue: [lg`Marker/MarkerSnowflake_02_Regular_Blue_400x400.webm`]
        },
        "03": {
          blue: [lg`Marker/MarkerSnowflake_03_Regular_Blue_400x400.webm`]
        }
      },
      stun: {
        "02": {
          purple: [lg`Marker/MarkerStun_02_Regular_Purple_400x400.webm`]
        },
        "03": {
          purple: [lg`Marker/MarkerStun_03_Regular_Purple_400x400.webm`]
        }
      },
      dizzystars: {
        "01": {
          blueorange: [lg`Conditions/Dizzy_Stars/DizzyStars_01_BlueOrange_400x400.webm`]
        }
      }
    },
    creature: {
      bite: {
        "01": {
          red: [lg`Creature/Bite_01_Regular_Red_400x400.webm`]
        }
      },
      claw: {
        "01": {
          red: [lg`Creature/Claws_01_Regular_Red_400x400.webm`]
        }
      }
    },
    energy: {
      energyfield: {
        "01": {
          blue: [lg`Energy/EnergyField_01_Regular_Blue_600x600.webm`]
        }
      },
      shimmer: {
        "01": {
          blue: [lg`Energy/Shimmer01_01_Regular_Blue_400x400.webm`]
        }
      },
      sparkles: {
        "01": {
          blue: [lg`Energy/SwirlingSparkles_01_Regular_Blue_400x400.webm`]
        }
      },
      strands: {
        "01": {
          green: [lg`Energy/EnergyStrandIN01_01_Regular_Green_600x600.webm`]
        },
        "02": {
          green: [lg`Energy/EnergyStrandIN01_02_Regular_Green_600x600.webm`]
        },
        "03": {
          green: [lg`Energy/EnergyStrandIN01_03_Regular_Green_600x600.webm`]
        }
      }
    },
    fire: {
      eruption: {
        "01": {
          orange: [lg`Fire/Eruption_01_Regular_Orange_600x600.webm`]
        }
      },
      groundcrack: {
        "01": {
          orange: [lg`Fire/GroundCrackLoop_01_Regular_Orange_600x600.webm`]
        },
        "02": {
          orange: [lg`Fire/GroundCrackLoop_02_Regular_Orange_600x600.webm`]
        },
        "03": {
          orange: [lg`Fire/GroundCrackLoop_03_Regular_Orange_600x600.webm`]
        }
      },
      fireworks: {
        "01": {
          orangeyellow: [
            lg`Fireworks/Firework01_01_Regular_OrangeYellow_600x600.webm`,
            lg`Fireworks/Firework03_01_Regular_OrangeYellow_600x600.webm`
          ],
          yellow: [
            lg`Fireworks/Firework02_01_Regular_Yellow_600x600.webm`
          ]
        },
        "02": {
          orangeyellow: [
            lg`Fireworks/Firework01_02_Regular_OrangeYellow_600x600.webm`,
            lg`Fireworks/Firework03_02_Regular_OrangeYellow_600x600.webm`
          ],
          yellow: [
            lg`Fireworks/Firework02_02_Regular_Yellow_600x600.webm`
          ]
        }
      }
    },
    generic: {
      explosion: {
        "01": {
          blue: [
            lg`Explosion/Explosion_02_Blue_400x400.webm`,
            lg`Explosion/Explosion_04_Regular_Blue_400x400.webm`
          ],
          orange: [
            lg`Explosion/Explosion_01_Orange_400x400.webm`
          ],
          yellowblue: [
            lg`Explosion/Explosion_03_Regular_BlueYellow_400x400.webm`
          ]
        }
      },
      impact: {
        "01": {
          blue: [
            lg`Impact/Impact_01_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_02_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_03_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_04_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_11_Regular_Blue_400x400.webm`,
            lg`Impact/Impact_12_Regular_Blue_400x400.webm`
          ],
          orange: [
            lg`Impact/Impact_05_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_07_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_08_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_09_Regular_Orange_400x400.webm`,
            lg`Impact/Impact_10_Regular_Orange_400x400.webm`
          ],
          yellow: [
            lg`Impact/Impact_06_Regular_Yellow_400x400.webm`,
            lg`Impact/Impact_07_Regular_Yellow_400x400.webm`
          ]
        }
      },
      indicator: {
        chevron: {
          yellow: [lg`UI/3Chevrons_01_Regular_Yellow_200x200.webm`]
        },
        "01": {
          yellow: [lg`UI/Indicator_01_Regular_Yellow_200x200.webm`]
        },
        "02": {
          green: [lg`UI/Indicator01_02_Regular_BlueGreen_400x400.webm`]
        },
        "03": {
          green: [lg`UI/Indicator01_03_Regular_BlueGreen_200x200.webm`]
        },
        "04": {
          green: [lg`UI/Indicator02_02_Regular_BlueGreen_400x400.webm`]
        },
        "05": {
          green: [lg`UI/Indicator02_03_Regular_BlueGreen_200x200.webm`]
        }
      },
      outpulse: {
        "01": {
          whiteblue: [
            lg`Template/Circle/OutPulse/OutPulse_01_Regular_BlueWhite_Burst_600x600.webm`
          ]
        },
        "02": {
          whiteblue: [
            lg`Template/Circle/OutPulse/OutPulse_02_Regular_BlueWhite_Burst_600x600.webm`
          ]
        }
      },
      smoke: {
        "01": {
          grey: [lg`Smoke/SmokePuff01_01_Regular_Grey_400x400.webm`]
        },
        "02": {
          grey: [lg`Smoke/SmokePuff01_02_Regular_Grey_400x400.webm`]
        },
        "03": {
          grey: [lg`Smoke/SmokePuff01_03_Regular_Grey_400x400.webm`]
        },
        "ring02": {
          white: [
            lg`Smoke/SmokePuffRing01_01_Regular_White_400x400.webm`,
            lg`Smoke/SmokePuffRing01_02_Regular_White_400x400.webm`,
            lg`Smoke/SmokePuffRing01_03_Regular_White_400x400.webm`
          ]
        }
      },
      ui: {
        drop: {
          red: [lg`UI/IconDrop_01_Regular_Red_200x200.webm`]
        },
        fear: {
          darkpurple: [lg`UI/IconFear_01_Dark_Purple_200x200.webm`]
        },
        heart: {
          pink: [lg`UI/IconHeart_01_Regular_Pink_200x200.webm`]
        },
        horror: {
          purple: [lg`UI/IconHorror_01_Regular_Purple_200x200.webm`]
        },
        music: {
          blue: [lg`UI/IconMusicNote_01_Regular_Blue_200x200.webm`]
        },
        poison: {
          darkgreen: [lg`UI/IconPoison_01_Dark_Green_200x200.webm`]
        },
        rune01: {
          orange: [lg`UI/IconRunes_01_Regular_Orange_200x200.webm`]
        },
        rune02: {
          orange: [lg`UI/IconRunes02_01_Regular_Orange_200x200.webm`]
        },
        rune03: {
          orange: [lg`UI/IconRunes03_01_Regular_Orange_200x200.webm`]
        },
        shields: {
          green: [lg`UI/IconShield_01_Regular_Green_200x200.webm`]
        },
        crackedshield: {
          purple: [lg`UI/IconShieldCracked_01_Regular_Purple_200x200.webm`]
        },
        skull: {
          purple: [lg`UI/IconSkull_01_Regular_Purple_200x200.webm`]
        },
        snowflake: {
          blue: [lg`UI/IconSnowflake_01_Regular_Blue_200x200.webm`]
        },
        stun: {
          purple: [lg`UI/IconStun_01_Regular_Purple_200x200.webm`]
        }
      },
      vortex: {
        loop: {
          blue: [lg`Template/Circle/Vortex_01_Regular_Blue_600x600.webm`]
        },
        intro: {
          blue: [lg`Template/Circle/VortexIntro_01_Regular_Blue_600x600.webm`]
        },
        outro: {
          blue: [lg`Template/Circle/VortexOutro_01_Regular_Blue_600x600.webm`]
        }
      },
      whirl: {
        loop: {
          blue: [lg`Template/Circle/Whirl_01_Regular_Blue_600x600.webm`]
        },
        intro: {
          blue: [lg`Template/Circle/WhirlIntro_01_Regular_Blue_600x600.webm`]
        },
        outro: {
          blue: [lg`Template/Circle/WhirlOutro_01_Regular_Blue_600x600.webm`]
        }
      }
    },
    ice: {
      icespikes: {
        "01": {
          white: [lg`Ice/IceSpikesRadialBurst_01_Regular_White_1000x1000.webm`]
        }
      },
      snowflake: {
        "01": {
          whiteblue: [
            lg`Ice/SnowflakeBurst_01_Regular_BlueWhite_Burst_600x600.webm`
          ]
        }
      }
    },
    lightning: {
      ball: {
        "01": {
          blue: [lg`Lightning/LightningBall_01_Regular_Blue_400x400.webm`]
        }
      },
      staticelectricity: {
        "01": {
          blue: [lg`Lightning/StaticElectricity_01_Regular_Blue_400x400.webm`]
        },
        "02": {
          blue: [lg`Lightning/StaticElectricity_02_Regular_Blue_400x400.webm`]
        }
      }
    },
    liquid: {
      splash: {
        "01": {
          blue: [lg`Liquid/LiquidSplash01_Regular_Blue_400x400.webm`]
        }
      },
      blob: {
        "01": {
          blue: [lg`Liquid/LiquidBlob01_01_Regular_Blue_400x400.webm`]
        }
      }
    },
    magicsign: {
      abjuration: {
        "01": {
          blue: [lg`Magic_Signs/Abjuration_01_Blue_Circle_800x800.webm`]
        },
        "02": {
          blue: [lg`Magic_Signs/AbjurationCircleLoop_02_Regular_Blue_800x800.webm`]
        },
        "runeintro": {
          blue: [lg`Magic_Signs/Runes/AbjurationRuneIntro_01_Regular_Blue_400x400.webm`]
        },
        "runeloop": {
          blue: [lg`Magic_Signs/Runes/AbjurationRuneLoop_01_Regular_Blue_400x400.webm`]
        },
        "runeoutro": {
          blue: [lg`Magic_Signs/Runes/AbjurationRuneOutro_01_Regular_Blue_400x400.webm`]
        }
      },
      conjuration: {
        "01": {
          yellow: [lg`Magic_Signs/Conjuration_01_Yellow_Circle_800x800.webm`]
        },
        "02": {
          yellow: [lg`Magic_Signs/ConjurationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        "runeintro": {
          yellow: [lg`Magic_Signs/Runes/,ConjurationRuneIntro_01_Regular_Yellow_400x400.webm`]
        },
        "runeloop": {
          yellow: [lg`Magic_Signs/Runes/ConjurationRuneLoop_01_Regular_Yellow_400x400.webm`]
        },
        "runeoutro": {
          yellow: [lg`Magic_Signs/Runes/ConjurationRuneOutro_01_Regular_Yellow_400x400.webm`]
        }
      },
      divination: {
        "01": {
          lightblue: [lg`Magic_Signs/Divination_01_Light_Blue_Circle_800x800.webm`]
        },
        "02": {
          blue: [lg`Magic_Signs/DivinationCircleLoop_02_Regular_Blue_800x800.webm`]
        },
        "runeintro": {
          blue: [lg`Magic_Signs/Runes/DivinationRuneIntro_01_Regular_Blue_400x400.webm`]
        },
        "runeloop": {
          blue: [lg`Magic_Signs/Runes/DivinationRuneLoop_01_Regular_Blue_400x400.webm`]
        },
        "runeoutro": {
          blue: [lg`Magic_Signs/Runes/DivinationRuneOutro_01_Regular_Blue_400x400.webm`]
        }
      },
      enchantment: {
        "02": {
          pink: [lg`Magic_Signs/EnchantmentCircleLoop_02_Regular_Pink_800x800.webm`]
        },
        "runeintro": {
          pink: [lg`Magic_Signs/Runes/EnchantmentRuneIntro_01_Regular_Pink_400x400.webm`]
        },
        "runeloop": {
          pink: [lg`Magic_Signs/Runes/EnchantmentRuneLoop_01_Regular_Pink_400x400.webm`]
        },
        "runeoutro": {
          pink: [lg`Magic_Signs/Runes/EnchantmentRuneOutro_01_Regular_Pink_400x400.webm`]
        }
      },
      evocation: {
        "02": {
          red: [lg`Magic_Signs/EvocationCircleLoop_02_Regular_Red_800x800.webm`]
        },
        "runeintro": {
          red: [lg`Magic_Signs/Runes/EvocationRuneIntro_01_Regular_Red_400x400.webm`]
        },
        "runeloop": {
          red: [lg`Magic_Signs/Runes/EvocationRuneLoop_01_Regular_Red_400x400.webm`]
        },
        "runeoutro": {
          red: [lg`Magic_Signs/Runes/EvocationRuneOutro_01_Regular_Red_400x400.webm`]
        }
      },
      illusion: {
        "02": {
          purple: [lg`Magic_Signs/IllusionCircleLoop_02_Regular_Purple_800x800.webm`]
        },
        "runeintro": {
          purple: [lg`Magic_Signs/Runes/IllusionRuneIntro_01_Regular_Purple_400x400.webm`]
        },
        "runeloop": {
          purple: [lg`Magic_Signs/Runes/IllusionRuneLoop_01_Regular_Purple_400x400.webm`]
        },
        "runeoutro": {
          purple: [lg`Magic_Signs/Runes/IllusionRuneOutro_01_Regular_Purple_400x400.webm`]
        }
      },
      necromancy: {
        "02": {
          green: [lg`Magic_Signs/NecromancyCircleLoop_02_Regular_Green_800x800.webm`]
        },
        "runeintro": {
          green: [lg`Magic_Signs/Runes/NecromancyRuneIntro_01_Regular_Green_400x400.webm`]
        },
        "runeloop": {
          green: [lg`Magic_Signs/Runes/NecromancyRuneLoop_01_Regular_Green_400x400.webm`]
        },
        "runeoutro": {
          green: [lg`Magic_Signs/Runes/NecromancyRuneOutro_01_Regular_Green_400x400.webm`]
        }
      },
      transmutation: {
        "02": {
          yellow: [lg`Magic_Signs/TransmutationCircleLoop_02_Regular_Yellow_800x800.webm`]
        },
        "runeintro": {
          yellow: [lg`Magic_Signs/Runes/TransmutationRuneIntro_01_Regular_Yellow_400x400.webm`]
        },
        "runeloop": {
          yellow: [lg`Magic_Signs/Runes/TransmutationRuneLoop_01_Regular_Yellow_400x400.webm`]
        },
        "runeoutro": {
          yellow: [lg`Magic_Signs/Runes/TransmutationRuneOutro_01_Regular_Yellow_400x400.webm`]
        }
      }
    },
    marker: {
      bubble: {
        "01": {
          blue: [lg`Marker/MarkerBubble_01_Regular_Blue_400x400.webm`]
        }
      },
      circleofstars: {
        "01": {
          blue: [lg`Marker/MarkerCircleOfStars_Regular_Blue_400x400.webm`]
        }
      },
      energystrands: {
        "01": {
          blue: [lg`Marker/EnergyStrands_01_Regular_Blue_600x600.webm`]
        }
      },
      music: {
        "01": {
          greenorange: [lg`Marker/MusicMarker_01_Regular_GreenOrange_400x400.webm`]
        }
      },
      standard: {
        "01": {
          marker01: {
            "yellowblue": [lg`Marker/Marker_01_Regular_BlueYellow_400x400.webm`]
          },
          musicMarker: {
            "greenorange": [lg`Marker/MusicMarker_01_Regular_GreenOrange_400x400.webm`]
          }
        }
      }
    },
    music: {
      notes: {
        "01": {
          blue: [
            lg`Music_Notation/BassClef_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/BeamedQuavers_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/Crotchet_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/Flat_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/Quaver_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/Sharp_01_Regular_Blue_200x200.webm`,
            lg`Music_Notation/TrebleClef_01_Regular_Blue_200x200.webm`
          ]
        }
      }
    },
    particles: {
      dots: {
        "01": {
          green: [lg`Particles/ParticlesOutward01_01_Regular_GreenYellow_400x400.webm`]
        },
        "02": {
          green: [lg`Particles/ParticlesOutward01_02_Regular_GreenYellow_400x400.webm`]
        },
        "03": {
          green: [lg`Particles/ParticlesOutward01_03_Regular_GreenYellow_400x400.webm`]
        },
        "04": {
          green: [lg`Particles/ParticlesOutward01_04_Regular_GreenYellow_400x400.webm`]
        },
        "05": {
          green: [lg`Particles/ParticlesOutward01_05_Regular_GreenYellow_400x400.webm`]
        }
      },
      inwarddots: {
        "01": {
          greenyellow: [lg`Particles/ParticlesInward01_01_Regular_GreenYellow_400x400.webm`]
        },
        "02": {
          greenyellow: [lg`Particles/ParticlesInward01_02_Regular_GreenYellow_400x400.webm`]
        },
        "03": {
          greenyellow: [lg`Particles/ParticlesInward01_03_Regular_GreenYellow_400x400.webm`]
        },
        "04": {
          greenyellow: [lg`Particles/ParticlesInward01_04_Regular_GreenYellow_400x400.webm`]
        },
        "05": {
          greenyellow: [lg`Particles/ParticlesInward01_05_Regular_GreenYellow_400x400.webm`]
        }
      },
      stars: {
        "01": {
          green: [lg`Particles/ParticlesOutward02_01_Regular_GreenYellow_400x400.webm`]
        },
        "02": {
          green: [lg`Particles/ParticlesOutward02_02_Regular_GreenYellow_400x400.webm`]
        },
        "03": {
          green: [lg`Particles/ParticlesOutward02_03_Regular_GreenYellow_400x400.webm`]
        },
        "04": {
          green: [lg`Particles/ParticlesOutward02_04_Regular_GreenYellow_400x400.webm`]
        },
        "05": {
          green: [lg`Particles/ParticlesOutward02_05_Regular_GreenYellow_400x400.webm`]
        }
      },
      inwardstars: {
        "01": {
          greenyellow: [lg`Particles/ParticlesInward02_01_Regular_GreenYellow_400x400.webm`]
        },
        "02": {
          greenyellow: [lg`Particles/ParticlesInward02_02_Regular_GreenYellow_400x400.webm`]
        },
        "03": {
          greenyellow: [lg`Particles/ParticlesInward02_03_Regular_GreenYellow_400x400.webm`]
        },
        "04": {
          greenyellow: [lg`Particles/ParticlesInward02_04_Regular_GreenYellow_400x400.webm`]
        },
        "05": {
          greenyellow: [lg`Particles/ParticlesInward02_05_Regular_GreenYellow_400x400.webm`]
        }
      },
      swirl: {
        "01": {
          greenyellow: [lg`Particles/ParticlesSwirl01_01_Regular_GreenYellow_400x400.webm`]
        },
        "02": {
          greenyellow: [lg`Particles/ParticlesSwirl02_01_Regular_GreenYellow_400x400.webm`]
        }
      }
    },
    shieldfx: {
      eldritchweb: {
        "01": {
          darkpurple: [lg`Energy/ShieldEldritchWebAbove01_01_Dark_Purple_400x400.webm`]
        }
      },
      /*
      shieldeldritchwebbottom: {
          '01': {
              darkpurple: [lg`Energy/ShieldEldritchWebBelow01_01_Dark_Purple_400x400.webm`],
          },
      },
      */
      fire: {
        "01": {
          orange: [lg`Fire/ShieldFireAbove01_01_Regular_Orange_400x400.webm`]
        }
      },
      /*
      shieldfirebottom: {
          '01': {
              orange: [lg`Fire/ShieldFireBelow01_01_Regular_Orange_400x400.webm`],
          },
      },
      */
      earth: {
        "01": {
          orange: [lg`Fire/ShieldMoltenEarthAbove01_01_Regular_Orange_400x400.webm`]
        }
      },
      /*
      shieldearthbottom: {
          '01': {
              orange: [lg`Fire/ShieldMoltenEarthBelow01_01_Regular_Orange_400x400.webm`],
          },
      },
      */
      energyfield: {
        "01": {
          blue: [lg`Energy/EnergyFieldTop_02_Regular_Blue_400x400.webm`]
        }
      },
      /*
      energyfieldbottom: {
          '01': {
              blue: [lg`Energy/EnergyFieldBot_02_Regular_Blue_400x400.webm`],
          }
      },
      */
      ice: {
        "01": {
          blue: [lg`Ice/ShieldIceAbove01_01_Regular_Blue_400x400.webm`]
        }
      }
      /*
      shieldicebottom: {
          '01': {
              blue: [lg`Ice/ShieldIceBelow01_01_Regular_Blue_400x400.webm`],
          }
      },
      */
    },
    shieldspell: {
      intro: {
        "01": {
          blue: [l1`Shield/Shield_01_Regular_Blue_Intro_400x400.webm`]
        }
      },
      loop: {
        "01": {
          blue: [l1`Shield/Shield_01_Regular_Blue_Loop_400x400.webm`]
        }
      },
      outro_explode: {
        "01": {
          blue: [l1`Shield/Shield_01_Regular_Blue_OutroExplode_400x400.webm`]
        }
      },
      outro_fade: {
        "01": {
          blue: [l1`Shield/Shield_01_Regular_Blue_OutroFade_400x400.webm`]
        }
      },
      complete: {
        "01": {
          _markers: {
            loop: { start: 1533, end: 5533 },
            forcedEnd: 5533
          },
          blue: [l1`Shield/Shield_01_Regular_Blue_Complete_400x400.webm`]
        }
      }
    },
    shrapnel: {
      bomb: {
        "01": {
          black: [lg`Explosion/ShrapnelBomb01_01_Regular_Black_800x800.webm`]
        }
      }
    },
    spell: {
      antilifeshell: {
        "01": {
          blue: [l5`Antilife_Shell/AntilifeShell_01_Blue_NoCircle_400x400.webm`]
        }
      },
      armsofhadar: {
        "01": {
          darkpurple: [l1`Arms_Of_Hadar/ArmsOfHadar_01_Dark_Purple_500x500.webm`]
        }
      },
      bardicinspiration: {
        "inspire": {
          greenorange: [l1`Bardic_Inspiration/BardicInspiration_01_Regular_GreenOrange_400x400.webm`]
        },
        "marker": {
          greenorange: [lg`Marker/MusicMarker_01_Regular_GreenOrange_400x400.webm`]
        }
      },
      blacktentacles: {
        "01": {
          darkpurple: [l4`Black_Tentacles/BlackTentacles_01_Dark_Purple_600x600.webm`]
        }
      },
      bless: {
        "intro": {
          yellow: [l1`Bless/Bless_01_Regular_Yellow_Intro_400x400.webm`]
        },
        "loop": {
          yellow: [l1`Bless/Bless_01_Regular_Yellow_Loop_400x400.webm`]
        }
      },
      calllightning: {
        "01": {
          blue: [l3`Call_Lightning/CallLightning_01_Blue_1000x1000.webm`],
          blueorange: [l3`Call_Lightning/CallLightning_01_BlueOrange_1000x1000.webm`],
          green: [l3`Call_Lightning/CallLightning_01_Green_1000x1000.webm`],
          pinkyellow: [l3`Call_Lightning/CallLightning_01_PinkYellow_1000x1000.webm`],
          purple: [l3`Call_Lightning/CallLightning_01_Purple_1000x1000.webm`],
          red: [l3`Call_Lightning/CallLightning_01_Red_1000x1000.webm`],
          yellow: [l3`Call_Lightning/CallLightning_01_Yellow_1000x1000.webm`]
        }
      },
      cloudofdaggers: {
        "01": {
          blue: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Blue_400x400.webm`],
          green: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Green_400x400.webm`],
          orange: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Orange_400x400.webm`],
          purple: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Purple_400x400.webm`],
          red: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Red_400x400.webm`],
          yellow: [l2`Cloud_Of_Daggers/CloudOfDaggers_01_Light_Yellow_400x400.webm`]
        }
      },
      curewounds: {
        "01": {
          blue: [l1`Cure_Wounds/CureWounds_01_Blue_400x400.webm`]
        }
      },
      darkness: {
        "01": {
          black: [l2`Darkness/Darkness_01_Black_600x600.webm`],
          green: [l2`Darkness/Darkness_01_Green_600x600.webm`]
        }
      },
      detectmagic: {
        "01": {
          blue: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Blue_1200x1200.webm`]
        }
      },
      divinesmite: {
        "source": {
          yellowblue: [l2`Divine_Smite/DivineSmite_01_Regular_BlueYellow_Caster_400x400.webm`]
        },
        "target": {
          yellowblue: [l2`Divine_Smite/DivineSmite_01_Regular_BlueYellow_Target_400x400.webm`]
        }
      },
      entangle: {
        "01": {
          brown: [l1`Entangle/Entangle_01_Brown_400x400.webm`],
          green: [l1`Entangle/Entangle_01_Green_400x400.webm`],
          yellow: [l1`Entangle/Entangle_01_Yellow_400x400.webm`]
        }
      },
      fireball: {
        loop: {
          orange: [l3`Fireball/FireballLoop_01_Orange_800x800.webm`]
        },
        explode: {
          orange: [l3`Fireball/FireballExplosion_01_Orange_800x800.webm`]
        },
        nodebris: {
          orange: [l3`Fireball/FireballLoopNoDebris_01_Orange_800x800.webm`]
        }
      },
      fogcloud: {
        "01": {
          white: [l1`Fog_Cloud/FogCloud_01_White_800x800.webm`]
        }
      },
      generichealing: {
        "01": {
          blue: [lg`Healing/HealingAbility_01_Blue_400x400.webm`],
          green: [lg`Healing/HealingAbility_01_Green_400x400.webm`],
          purple: [lg`Healing/HealingAbility_01_Purple_400x400.webm`],
          yellow: [lg`Healing/HealingAbility_01_Yellow_400x400.webm`]
        },
        "02": {
          greenorange: [lg`Healing/HealingAbility_02_Regular_GreenOrange_Burst_600x600.webm`]
        }
      },
      grease: {
        "01": {
          brown: [l1`Grease/Grease_Dark_Brown_600x600.webm`]
        }
      },
      huntersmark: {
        "eye": {
          green: [l1`Hunters_Mark/HuntersMark_01_Regular_Green_Pulse_200x200.webm`]
        },
        "eyeloop": {
          green: [l1`Hunters_Mark/HuntersMark_01_Regular_Green_Loop_200x200.webm`]
        }
      },
      mistystep: {
        "01": {
          blue: [l2`Misty_Step/MistyStep_01_Regular_Blue_400x400.webm`]
        },
        "02": {
          blue: [l2`Misty_Step/MistyStep_02_Regular_Blue_400x400.webm`]
        }
      },
      moonbeam: {
        loop: {
          blue: [l2`Moonbeam/Moonbeam_01_Regular_Blue_400x400.webm`]
        },
        nopulse: {
          blue: [l2`Moonbeam/MoonbeamNoPulse_01_Regular_Blue_400x400.webm`]
        },
        intro: {
          blue: [l2`Moonbeam/MoonbeamIntro_01_Regular_Blue_400x400.webm`]
        },
        outro: {
          blue: [l2`Moonbeam/MoonbeamOutro_01_Regular_Blue_400x400.webm`]
        }
      },
      sacredflame: {
        source: {
          yellow: [l0`Sacred_Flame/SacredFlameSource_01_Regular_Yellow_400x400.webm`]
        },
        target: {
          yellow: [l0`Sacred_Flame/SacredFlameTarget_01_Regular_Yellow_400x400.webm`]
        }
      },
      shatter: {
        "01": {
          blue: [l2`Shatter/Shatter_01_Blue_400x400.webm`]
        }
      },
      sleep: {
        "01": {
          pink: [l1`Sleep/Cloud01_01_Regular_Pink_400x400.webm`]
        },
        "02": {
          pink: [l1`Sleep/Cloud01_02_Regular_Pink_400x400.webm`]
        },
        marker: {
          pink: [l1`Sleep/SleepMarker01_01_Regular_Pink_400x400.webm`]
        },
        symbol: {
          pink: [l1`Sleep/SleepSymbol01_01_Regular_Pink_400x400.webm`]
        }
      },
      sleetstorm: {
        "01": {
          blue: [l3`Sleet_Storm/SleetStorm_01_Blue_800x800.webm`]
        }
      },
      spiritguardians: {
        "01": {
          yellowblue: [l3`Spirit_Guardians/SpiritGuardians_01_Light_BlueYellow_600x600.webm`]
        }
      },
      sneakattack: {
        "01": {
          "darkgreen": [l1`Sneak_Attack/Sneak_Attack_Dark_Green_300x300.webm`]
        }
      },
      thunderwave: {
        left: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_BLeft_600x600.webm`]
        },
        mid: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_BMid_600x600.webm`]
        },
        center: {
          blue: [l1`Thunderwave/Thunderwave_01_Bright_Blue_Center_600x600.webm`]
        }
      },
      tollthedead: {
        bell: {
          green: [l0`Toll_The_Dead/TollTheDeadBell_01_Regular_Green_400x400.webm`]
        },
        complete: {
          green: [l0`Toll_The_Dead/TollTheDead_01_Regular_Green_400x400.webm`]
        },
        shockwave: {
          green: [l0`Toll_The_Dead/TollTheDeadShockwave_01_Regular_Green_400x400.webm`]
        },
        skull: {
          green: [l0`Toll_The_Dead/TollTheDeadSkullSmoke_01_Regular_Green_400x400.webm`]
        }
      },
      wallofforce: {
        "01": {
          grey: [l5`Wall_Of_Force/WallOfForce_01_Grey_Sphere_400x400.webm`]
        }
      },
      web: {
        "01": {
          white: [l2`Web/Web_01_White_01_400x400.webm`]
        }
      },
      whirlwind: {
        "01": {
          bluegrey: [l7`Whirlwind/Whirlwind_01_BlueGrey_01_400x400.webm`]
        }
      }
    },
    tokenborder: {
      static: {
        "01": {
          blue: [lg`Token_Border/TokenBorderCircle_01_Regular_Blue_400x400.webm`]
        },
        "02": {
          blue: [lg`Token_Border/TokenBorderCircle_02_Regular_Blue_400x400.webm`]
        },
        "03": {
          blue: [lg`Token_Border/TokenBorderCircle_03_Regular_Blue_400x400.webm`]
        },
        "04": {
          blue: [lg`Token_Border/TokenBorderCircle_04_Regular_Blue_400x400.webm`]
        },
        "05": {
          blue: [lg`Token_Border/TokenBorderCircle_05_Regular_Blue_400x400.webm`]
        },
        "06": {
          blue: [lg`Token_Border/TokenBorderCircle_06_Regular_Blue_400x400.webm`]
        },
        "07": {
          blue: [lg`Token_Border/TokenBorderCircle_07_Regular_Blue_400x400.webm`]
        }
      },
      spinning: {
        "01": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_01_Regular_Blue_400x400.webm`]
        },
        "02": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_02_Regular_Blue_400x400.webm`]
        },
        "03": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_03_Regular_Blue_400x400.webm`]
        },
        "04": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_04_Regular_Blue_400x400.webm`]
        },
        "05": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_05_Regular_Blue_400x400.webm`]
        },
        "06": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_06_Regular_Blue_400x400.webm`]
        },
        "07": {
          blue: [lg`Token_Border/TokenBorderCircleSpin_07_Regular_Blue_400x400.webm`]
        }
      }
    },
    trap: {
      fire: {
        single: {
          orange: [lg`Traps/FireTrap02_01_Regular_Orange_1400x1400.webm`]
        },
        double: {
          orange: [lg`Traps/FireTrapDual02_01_Regular_Orange_1400x1400.webm`]
        }
      }
    }
  };
  JB2AFREEDB.return = {
    _template: "ranged",
    weapon: {
      dagger: {
        "01": {
          white: {
            "15ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_Return_15ft_1000x400.webm`],
            "30ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_Return_30ft_1600x400.webm`],
            "60ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_Return_60ft_2800x400.webm`],
            "90ft": [lg`Weapon_Attacks/Ranged/Dagger01_01_Regular_White_Return_90ft_4000x400.webm`]
          }
        }
      }
    }
  };
}
async function db047(path) {
  const BASE = `${path}/Library/`;
  const prefix = (str) => (strs, ...exprs) => `${BASE}${str}/${strs.reduce((a, c, i) => a + exprs[i - 1] + c)}`;
  const l2 = prefix("2nd_Level");
  const lg = prefix("Generic");
  const patreonDB047 = {
    range: {
      _free: ["weapon"],
      weapon: {
        _free: ["missile"],
        missile: {
          _free: ["01", "02", "03", "04"],
          "01": {
            _free: ["blue"],
            blue: {
              "15ft": [lg`Weapon_Attacks/Ranged/Missile01_01_Regular_Blue_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Missile01_01_Regular_Blue_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Missile01_01_Regular_Blue_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Missile01_01_Regular_Blue_90ft_4000x400.webm`]
            }
          },
          "02": {
            _free: ["white"],
            white: {
              "15ft": [lg`Weapon_Attacks/Ranged/Missile02_01_Regular_White_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Missile02_01_Regular_White_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Missile02_01_Regular_White_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Missile02_01_Regular_White_90ft_4000x400.webm`]
            }
          },
          "03": {
            _free: ["white"],
            white: {
              "15ft": [lg`Weapon_Attacks/Ranged/Missile03_01_Regular_White_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Missile03_01_Regular_White_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Missile03_01_Regular_White_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Missile03_01_Regular_White_90ft_4000x400.webm`]
            }
          },
          "04": {
            _free: ["purplepink"],
            purplepink: {
              "15ft": [lg`Weapon_Attacks/Ranged/Missile04_01_Regular_PinkPurple_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Missile04_01_Regular_PinkPurple_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Missile04_01_Regular_PinkPurple_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Missile04_01_Regular_PinkPurple_90ft_4000x400.webm`]
            }
          }
        }
      }
    },
    static: {
      _free: ["eyes", "shrapnel", "sideImpact"],
      eyes: {
        _free: ["single", "few", "many"],
        single: {
          _free: ["01", "02", "03"],
          "01": {
            _free: ["darkgreen"],
            darkgreen: [lg`Eyes/Eyes_Single01_01_Dark_Green_300x300.webm`],
            darkred: [lg`Eyes/Eyes_Single01_01_Dark_Red_300x300.webm`],
            yellow: [lg`Eyes/Eyes_Single01_01_Dark_Yellow_300x300.webm`],
            bluegreen: [lg`Eyes/Eyes_Single01_01_Regular_BlueGreen_300x300.webm`],
            orange: [lg`Eyes/Eyes_Single01_01_Regular_OrangeRed_300x300.webm`],
            orangeyellow: [lg`Eyes/Eyes_Single01_01_Regular_OrangeYellow_300x300.webm`]
          },
          "02": {
            _free: ["darkgreen"],
            darkgreen: [lg`Eyes/Eyes_Single01_02_Dark_Green_300x300.webm`],
            darkred: [lg`Eyes/Eyes_Single01_02_Dark_Red_300x300.webm`],
            yellow: [lg`Eyes/Eyes_Single01_02_Dark_Yellow_300x300.webm`],
            bluegreen: [lg`Eyes/Eyes_Single01_02_Regular_BlueGreen_300x300.webm`],
            orange: [lg`Eyes/Eyes_Single01_02_Regular_OrangeRed_300x300.webm`],
            orangeyellow: [lg`Eyes/Eyes_Single01_02_Regular_OrangeYellow_300x300.webm`]
          },
          "03": {
            _free: ["darkgreen"],
            darkgreen: [lg`Eyes/Eyes_Single01_03_Dark_Green_300x300.webm`],
            darkred: [lg`Eyes/Eyes_Single01_03_Dark_Red_300x300.webm`],
            yellow: [lg`Eyes/Eyes_Single01_03_Dark_Yellow_300x300.webm`],
            bluegreen: [lg`Eyes/Eyes_Single01_03_Regular_BlueGreen_300x300.webm`],
            orange: [lg`Eyes/Eyes_Single01_03_Regular_OrangeRed_300x300.webm`],
            orangeyellow: [lg`Eyes/Eyes_Single01_03_Regular_OrangeYellow_300x300.webm`]
          }
        },
        few: {
          _free: ["01", "02", "03"],
          "01": {
            _free: ["darkgreen"],
            darkgreen: [lg`Eyes/Eyes_Few01_01_Dark_Green_600x600.webm`],
            darkred: [lg`Eyes/Eyes_Few01_01_Dark_Red_600x600.webm`],
            yellow: [lg`Eyes/Eyes_Few01_01_Dark_Yellow_600x600.webm`],
            bluegreen: [lg`Eyes/Eyes_Few01_01_Regular_BlueGreen_600x600.webm`],
            orange: [lg`Eyes/Eyes_Few01_01_Regular_OrangeRed_600x600.webm`],
            orangeyellow: [lg`Eyes/Eyes_Few01_01_Regular_OrangeYellow_600x600.webm`]
          },
          "02": {
            _free: ["darkgreen"],
            darkgreen: [lg`Eyes/Eyes_Few01_02_Dark_Green_600x600.webm`],
            darkred: [lg`Eyes/Eyes_Few01_02_Dark_Red_600x600.webm`],
            yellow: [lg`Eyes/Eyes_Few01_02_Dark_Yellow_600x600.webm`],
            bluegreen: [lg`Eyes/Eyes_Few01_02_Regular_BlueGreen_600x600.webm`],
            orange: [lg`Eyes/Eyes_Few01_02_Regular_OrangeRed_600x600.webm`],
            orangeyellow: [lg`Eyes/Eyes_Few01_02_Regular_OrangeYellow_600x600.webm`]
          },
          "03": {
            _free: ["darkgreen"],
            darkgreen: [lg`Eyes/Eyes_Few01_03_Dark_Green_600x600.webm`],
            darkred: [lg`Eyes/Eyes_Few01_03_Dark_Red_600x600.webm`],
            yellow: [lg`Eyes/Eyes_Few01_03_Dark_Yellow_600x600.webm`],
            bluegreen: [lg`Eyes/Eyes_Few01_03_Regular_BlueGreen_600x600.webm`],
            orange: [lg`Eyes/Eyes_Few01_03_Regular_OrangeRed_600x600.webm`],
            orangeyellow: [lg`Eyes/Eyes_Few01_03_Regular_OrangeYellow_600x600.webm`]
          }
        },
        many: {
          _free: ["01", "02", "03"],
          "01": {
            _free: ["darkgreen"],
            darkgreen: [lg`Eyes/Eyes_Many01_01_Dark_Green_600x600.webm`],
            darkred: [lg`Eyes/Eyes_Many01_01_Dark_Red_600x600.webm`],
            yellow: [lg`Eyes/Eyes_Many01_01_Dark_Yellow_600x600.webm`],
            bluegreen: [lg`Eyes/Eyes_Many01_01_Regular_BlueGreen_600x600.webm`],
            orange: [lg`Eyes/Eyes_Many01_01_Regular_OrangeRed_600x600.webm`],
            orangeyellow: [lg`Eyes/Eyes_Many01_01_Regular_OrangeYellow_600x600.webm`]
          },
          "02": {
            _free: ["darkgreen"],
            darkgreen: [lg`Eyes/Eyes_Many01_02_Dark_Green_600x600.webm`],
            darkred: [lg`Eyes/Eyes_Many01_02_Dark_Red_600x600.webm`],
            yellow: [lg`Eyes/Eyes_Many01_02_Dark_Yellow_600x600.webm`],
            bluegreen: [lg`Eyes/Eyes_Many01_02_Regular_BlueGreen_600x600.webm`],
            orange: [lg`Eyes/Eyes_Many01_02_Regular_OrangeRed_600x600.webm`],
            orangeyellow: [lg`Eyes/Eyes_Many01_02_Regular_OrangeYellow_600x600.webm`]
          },
          "03": {
            _free: ["darkgreen"],
            darkgreen: [lg`Eyes/Eyes_Many01_03_Dark_Green_600x600.webm`],
            darkred: [lg`Eyes/Eyes_Many01_03_Dark_Red_600x600.webm`],
            yellow: [lg`Eyes/Eyes_Many01_03_Dark_Yellow_600x600.webm`],
            bluegreen: [lg`Eyes/Eyes_Many01_03_Regular_BlueGreen_600x600.webm`],
            orange: [lg`Eyes/Eyes_Many01_03_Regular_OrangeRed_600x600.webm`],
            orangeyellow: [lg`Eyes/Eyes_Many01_03_Regular_OrangeYellow_600x600.webm`]
          }
        }
      },
      shrapnel: {
        flask: {
          "01": {
            white: [
              lg`Explosion/TopFractureFlask01_01_400x400.webm`,
              lg`Explosion/TopFractureFlask02_01_400x400.webm`,
              lg`Explosion/TopFractureFlask03_01_400x400.webm`
            ]
          }
        }
      },
      sideImpact: {
        flask: {
          "01": {
            white: [
              lg`Explosion/SideFractureFlask01_01_800x400.webm`,
              lg`Explosion/SideFractureFlask01_02_400x400.webm`,
              lg`Explosion/SideFractureFlask02_01_800x400.webm`,
              lg`Explosion/SideFractureFlask02_02_400x400.webm`,
              lg`Explosion/SideFractureFlask03_01_800x400.webm`,
              lg`Explosion/SideFractureFlask03_02_400x400.webm`
            ]
          }
        }
      },
      spell: {
        divinesmite: {
          "source": {
            greenorange: [l2`Divine_Smite/DivineSmite_01_Regular_GreenOrange_Caster_400x400.webm`],
            pink: [l2`Divine_Smite/DivineSmite_01_Regular_Pink_Caster_400x400.webm`]
          },
          "target": {
            greenorange: [l2`Divine_Smite/DivineSmite_01_Regular_GreenOrange_Target_400x400.webm`],
            pink: [l2`Divine_Smite/DivineSmite_01_Regular_Pink_Target_400x400.webm`]
          }
        }
      }
    }
  };
  return patreonDB047;
}
async function db048(path) {
  const BASE = `${path}/Library/`;
  const prefix = (str) => (strs, ...exprs) => `${BASE}${str}/${strs.reduce((a, c, i) => a + exprs[i - 1] + c)}`;
  const l1 = prefix("1st_Level");
  const lg = prefix("Generic");
  const patreonDB048 = {
    templatefx: {
      _free: ["circle", "cone", "square", "vines"],
      circle: {
        _free: ["water"],
        water: {
          _free: ["01"],
          "01": {
            _free: ["blue"],
            black: [lg`Liquid/WaterSplashLoop_01_01_Regular_Black_600x600.webm`],
            blue: [lg`Liquid/WaterSplashLoop_01_01_Regular_Blue_600x600.webm`],
            green: [lg`Liquid/WaterSplashLoop_01_01_Regular_Green_600x600.webm`],
            purple: [lg`Liquid/WaterSplashLoop_01_01_Regular_Purple_600x600.webm`],
            red: [lg`Liquid/WaterSplashLoop_01_01_Regular_Red_600x600.webm`]
          }
        }
      },
      cone: {
        _free: ["water"],
        water: {
          _free: ["01"],
          "01": {
            _free: ["blue"],
            black: [lg`Liquid/WaterSplashConeLoop_01_01_Regular_Black_600x600.webm`],
            blue: [lg`Liquid/WaterSplashConeLoop_01_01_Regular_Blue_600x600.webm`],
            green: [lg`Liquid/WaterSplashConeLoop_01_01_Regular_Green_600x600.webm`],
            purple: [lg`Liquid/WaterSplashConeLoop_01_01_Regular_Purple_600x600.webm`],
            red: [lg`Liquid/WaterSplashConeLoop_01_01_Regular_Red_600x600.webm`]
          }
        }
      },
      square: {
        _free: ["entangle"],
        entangle: {
          _free: ["02", "complete"],
          "02": {
            _free: ["green"],
            purplepink: [l1`Entangle/EntangleLoop02_01_Dark_PinkPurple_500x500.webm`],
            green: [l1`Entangle/EntangleLoop02_02_Regular_Green_500x500.webm`],
            darkblue: [l1`Entangle/EntangleLoop02_03_Dark_Blue_500x500.webm`]
          },
          complete: {
            _markers: {
              loop: { start: 2125, end: 6250 }
            },
            _free: ["green"],
            purplepink: [l1`Entangle/Entangle02_01_Dark_PinkPurple_500x500.webm`],
            green: [l1`Entangle/Entangle02_02_Regular_Green_500x500.webm`],
            darkblue: [l1`Entangle/Entangle02_03_Dark_Blue_500x500.webm`]
          }
        }
      },
      vines: {
        _free: ["complete", "loop"],
        complete: {
          _free: ["nature"],
          nature: {
            _markers: {
              loop: { start: 2125, end: 6250 }
            },
            _free: ["greem"],
            green: [
              lg`Nature/GroupVineNature01_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature01_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature01_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNature01_03_Regular_Green_300x300.webm`,
              lg`Nature/GroupVineNature02_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature02_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature02_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNature02_03_Regular_Green_300x300.webm`,
              lg`Nature/GroupVineNature03_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature03_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature03_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNature03_03_Regular_Green_300x300.webm`
            ]
          },
          elemental: {
            _markers: {
              loop: { start: 2125, end: 6250 }
            },
            darkblue: [
              lg`Nature/GroupVineElemental01_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental01_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental01_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental01_03_Dark_Blue_300x300.webm`,
              lg`Nature/GroupVineElemental02_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental02_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental02_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental02_03_Dark_Blue_300x300.webm`,
              lg`Nature/GroupVineElemental03_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental03_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental03_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental03_03_Dark_Blue_300x300.webm`
            ]
          },
          void: {
            _markers: {
              loop: { start: 2125, end: 6250 }
            },
            purplepink: [
              lg`Nature/GroupVineVoid01_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid01_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid01_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid01_03_Dark_PinkPurple_300x300.webm`,
              lg`Nature/GroupVineVoid02_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid02_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid02_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid02_03_Dark_PinkPurple_300x300.webm`,
              lg`Nature/GroupVineVoid03_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid03_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid03_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid03_03_Dark_PinkPurple_300x300.webm`
            ]
          }
        },
        loop: {
          _free: ["nature"],
          nature: {
            _free: ["green"],
            green: [
              lg`Nature/GroupVineNatureLoop01_01_Regular_Green_300x300.webm`,
              lg`Nature/GroupVineNatureLoop02_01_Regular_Green_300x300.webm`,
              lg`Nature/GroupVineNatureLoop03_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop01_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop01_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop01_03_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop02_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop02_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop02_03_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop03_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop03_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop03_03_Regular_Green_300x300.webm`
            ]
          },
          elemental: {
            darkblue: [
              lg`Nature/GroupVineElementalLoop01_01_Dark_Blue_300x300.webm`,
              lg`Nature/GroupVineElementalLoop02_01_Dark_Blue_300x300.webm`,
              lg`Nature/GroupVineElementalLoop03_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop01_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop01_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop01_03_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop02_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop02_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop02_03_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop03_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop03_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop03_03_Dark_Blue_300x300.webm`
            ]
          },
          void: {
            purplepink: [
              lg`Nature/GroupVineVoidLoop01_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/GroupVineVoidLoop02_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/GroupVineVoidLoop03_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop01_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop01_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop01_03_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop02_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop02_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop02_03_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop03_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop03_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop03_03_Dark_PinkPurple_300x300.webm`
            ]
          }
        }
      }
    },
    static: {
      _free: ["generic", "vines"],
      generic: {
        _free: ["water"],
        water: {
          _free: ["01"],
          "01": {
            _free: ["blue"],
            black: [lg`Liquid/WaterSplashLoop_01_01_Regular_Black_600x600.webm`],
            blue: [lg`Liquid/WaterSplashLoop_01_01_Regular_Blue_600x600.webm`],
            green: [lg`Liquid/WaterSplashLoop_01_01_Regular_Green_600x600.webm`],
            purple: [lg`Liquid/WaterSplashLoop_01_01_Regular_Purple_600x600.webm`],
            red: [lg`Liquid/WaterSplashLoop_01_01_Regular_Red_600x600.webm`]
          }
        }
      },
      liquid: {
        blob: {
          "01": {
            red: [lg`Liquid/LiquidBlob01_01_Regular_Red_400x400.webm`]
          }
        }
      },
      spell: {
        entangle: {
          "02": {
            purplepink: [l1`Entangle/EntangleLoop02_01_Dark_PinkPurple_500x500.webm`],
            green: [l1`Entangle/EntangleLoop02_02_Regular_Green_500x500.webm`],
            darkblue: [l1`Entangle/EntangleLoop02_03_Dark_Blue_500x500.webm`]
          },
          complete: {
            _markers: {
              loop: { start: 2125, end: 6250 }
            },
            purplepink: [l1`Entangle/Entangle02_01_Dark_PinkPurple_500x500.webm`],
            green: [l1`Entangle/Entangle02_02_Regular_Green_500x500.webm`],
            darkblue: [l1`Entangle/Entangle02_03_Dark_Blue_500x500.webm`]
          }
        }
      },
      vines: {
        _free: ["complete", "loop"],
        complete: {
          _free: ["nature"],
          nature: {
            _markers: {
              loop: { start: 2125, end: 6250 }
            },
            _free: ["green"],
            green: [
              lg`Nature/GroupVineNature01_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature01_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature01_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNature01_03_Regular_Green_300x300.webm`,
              lg`Nature/GroupVineNature02_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature02_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature02_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNature02_03_Regular_Green_300x300.webm`,
              lg`Nature/GroupVineNature03_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature03_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNature03_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNature03_03_Regular_Green_300x300.webm`
            ]
          },
          elemental: {
            _markers: {
              loop: { start: 2125, end: 6250 }
            },
            darkblue: [
              lg`Nature/GroupVineElemental01_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental01_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental01_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental01_03_Dark_Blue_300x300.webm`,
              lg`Nature/GroupVineElemental02_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental02_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental02_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental02_03_Dark_Blue_300x300.webm`,
              lg`Nature/GroupVineElemental03_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental03_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental03_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElemental03_03_Dark_Blue_300x300.webm`
            ]
          },
          void: {
            _markers: {
              loop: { start: 2125, end: 6250 }
            },
            purplepink: [
              lg`Nature/GroupVineVoid01_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid01_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid01_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid01_03_Dark_PinkPurple_300x300.webm`,
              lg`Nature/GroupVineVoid02_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid02_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid02_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid02_03_Dark_PinkPurple_300x300.webm`,
              lg`Nature/GroupVineVoid03_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid03_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid03_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoid03_03_Dark_PinkPurple_300x300.webm`
            ]
          }
        },
        loop: {
          _free: ["nature"],
          nature: {
            _free: ["green"],
            green: [
              lg`Nature/GroupVineNatureLoop01_01_Regular_Green_300x300.webm`,
              lg`Nature/GroupVineNatureLoop02_01_Regular_Green_300x300.webm`,
              lg`Nature/GroupVineNatureLoop03_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop01_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop01_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop01_03_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop02_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop02_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop02_03_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop03_01_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop03_02_Regular_Green_300x300.webm`,
              lg`Nature/VineNatureLoop03_03_Regular_Green_300x300.webm`
            ]
          },
          elemental: {
            darkblue: [
              lg`Nature/GroupVineElementalLoop01_01_Dark_Blue_300x300.webm`,
              lg`Nature/GroupVineElementalLoop02_01_Dark_Blue_300x300.webm`,
              lg`Nature/GroupVineElementalLoop03_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop01_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop01_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop01_03_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop02_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop02_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop02_03_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop03_01_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop03_02_Dark_Blue_300x300.webm`,
              lg`Nature/VineElementalLoop03_03_Dark_Blue_300x300.webm`
            ]
          },
          void: {
            purplepink: [
              lg`Nature/GroupVineVoidLoop01_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/GroupVineVoidLoop02_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/GroupVineVoidLoop03_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop01_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop01_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop01_03_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop02_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop02_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop02_03_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop03_01_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop03_02_Dark_PinkPurple_300x300.webm`,
              lg`Nature/VineVoidLoop03_03_Dark_PinkPurple_300x300.webm`
            ]
          }
        }
      }
    }
  };
  return patreonDB048;
}
async function db049(path) {
  const BASE = `${path}/Library/`;
  const prefix = (str) => (strs, ...exprs) => `${BASE}${str}/${strs.reduce((a, c, i) => a + exprs[i - 1] + c)}`;
  const l2 = prefix("2nd_Level");
  const lg = prefix("Generic");
  const patreonDB049 = {
    range: {
      _free: [],
      weapon: {
        flask: {
          "01": {
            purple: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Purple_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Purple_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Purple_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Purple_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Purple_90ft_4000x400.webm`]
            },
            red: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Red_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Red_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Red_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Red_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_Red_90ft_4000x400.webm`]
            },
            white: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_White_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_White_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_White_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_White_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask01_01_Regular_White_90ft_4000x400.webm`]
            }
          },
          "02": {
            purple: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Purple_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Purple_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Purple_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Purple_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Purple_90ft_4000x400.webm`]
            },
            red: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Red_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Red_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Red_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Red_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_Red_90ft_4000x400.webm`]
            },
            white: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_White_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_White_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_White_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_White_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask02_01_Regular_White_90ft_4000x400.webm`]
            }
          },
          "03": {
            purple: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Purple_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Purple_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Purple_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Purple_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Purple_90ft_4000x400.webm`]
            },
            red: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Red_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Red_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Red_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Red_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_Red_90ft_4000x400.webm`]
            },
            white: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_White_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_White_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_White_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_White_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowFlask03_01_Regular_White_90ft_4000x400.webm`]
            }
          }
        },
        grenade: {
          "03": {
            green: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Green_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Green_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Green_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Green_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Green_90ft_4000x400.webm`]
            },
            orange: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Orange_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Orange_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Orange_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Orange_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Orange_90ft_4000x400.webm`]
            },
            red: {
              "05ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Red_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Red_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Red_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Red_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/ThrowGrenade03_01_Regular_Red_90ft_4000x400.webm`]
            }
          }
        },
        grenadelaunch: {
          "03": {
            green: {
              "05ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Green_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Green_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Green_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Green_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Green_90ft_4000x400.webm`]
            },
            orange: {
              "05ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Orange_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Orange_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Orange_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Orange_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Orange_90ft_4000x400.webm`]
            },
            red: {
              "05ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Red_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Red_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Red_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Red_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/LaunchGrenade03_01_Regular_Red_90ft_4000x400.webm`]
            }
          }
        }
      }
    },
    static: {
      _free: ["spell"],
      generic: {
        fire: {
          ring: {
            grey: [lg`Fire/FireRing_01_Circle_Grey_900x900.webm`],
            purple: [lg`Fire/FireRing_01_Circle_Purple_900x900.webm`],
            yellow: [lg`Fire/FireRing_01_Circle_Yellow_900x900.webm`]
          }
        }
      },
      spell: {
        _free: ["divinesmite"],
        divinesmite: {
          _free: ["reverse"],
          reverse: {
            _free: ["yellowblue"],
            yellowblue: [l2`Divine_Smite/DivineSmiteReversed_01_Regular_BlueYellow_Caster_400x400.webm`],
            greenyellow: [l2`Divine_Smite/DivineSmiteReversed_01_Regular_GreenYellow_Caster_400x400.webm`],
            orange: [l2`Divine_Smite/DivineSmiteReversed_01_Regular_Orange_Caster_400x400.webm`],
            purplepink: [l2`Divine_Smite/DivineSmiteReversed_01_Regular_PurplePink_Caster_400x400.webm`],
            darkpurple: [l2`Divine_Smite/DivineSmiteReversed_01_Dark_Purple_Caster_400x400.webm`],
            yellowwhite: [l2`Divine_Smite/DivineSmiteReversed_01_Regular_YellowWhite_Caster_400x400.webm`],
            darkred: [l2`Divine_Smite/DivineSmiteReversed_01_Dark_Red_Caster_400x400.webm`],
            greenorange: [l2`Divine_Smite/DivineSmiteReversed_01_Regular_GreenOrange_Caster_400x400.webm`],
            pink: [l2`Divine_Smite/DivineSmiteReversed_01_Regular_Pink_Caster_400x400.webm`]
          }
        }
      }
    }
  };
  return patreonDB049;
}
async function db050(path) {
  const BASE = `${path}/Library/`;
  const prefix = (str) => (strs, ...exprs) => `${BASE}${str}/${strs.reduce((a, c, i) => a + exprs[i - 1] + c)}`;
  const l1 = prefix("1st_Level");
  const l7 = prefix("7th_Level");
  const lg = prefix("Generic");
  const patreonDB050 = {
    range: {
      _free: [],
      weapon: {
        boulder: {
          "02": {
            white: {
              "05ft": [lg`Weapon_Attacks/Ranged/BoulderToss01_02_Regular_White_05ft_600x500.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/BoulderToss01_02_Regular_White_15ft_1000x500.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/BoulderToss01_02_Regular_White_30ft_1600x500.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/BoulderToss01_02_Regular_White_60ft_2800x500.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/BoulderToss01_02_Regular_White_90ft_4000x500.webm`]
            }
          }
        }
      }
    },
    templatefx: {
      _free: [],
      cone: {
        breathweaponspray01: {
          burst: {
            blue: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Ice01_Regular_Blue_Cone_Burst_800x800.webm`]
          },
          loop: {
            blue: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Ice01_Regular_Blue_Cone_Loop_800x800.webm`]
          }
        },
        breathweaponspray02: {
          burst: {
            blue: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Ice02_Regular_Blue_Cone_Burst_800x800.webm`]
          },
          loop: {
            blue: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Ice02_Regular_Blue_Cone_Loop_800x800.webm`]
          }
        }
      },
      ray: {
        breathweaponspray01: {
          burst: {
            blue: [lg`Template/Line/Breath_Weapon/Breathweapon02_Ice01_Regular_Blue_Line_Burst_1200x400.webm`]
          },
          loop: {
            blue: [lg`Template/Line/Breath_Weapon/Breathweapon02_Ice01_Regular_Blue_Line_Loop_1200x400.webm`]
          }
        }
      },
      square: {
        entangle: {
          "02": {
            darkorange: [l1`Entangle/EntangleLoop02_03_Dark_Orange_500x500.webm`]
          },
          complete: {
            darkorange: [l1`Entangle/Entangle02_03_Dark_Orange_500x500.webm`]
          }
        }
      },
      vines: {
        complete: {
          elemental: {
            darkorange: [
              lg`Nature/GroupVineElemental01_01_Dark_Orange_300x300.webm`,
              lg`Nature/GroupVineElemental02_01_Dark_Orange_300x300.webm`,
              lg`Nature/GroupVineElemental03_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental01_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental01_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental01_03_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental02_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental02_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental02_03_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental03_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental03_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental03_03_Dark_Orange_300x300.webm`
            ]
          }
        },
        loop: {
          elemental: {
            darkorange: [
              lg`Nature/GroupVineElementalLoop01_01_Dark_Orange_300x300.webm`,
              lg`Nature/GroupVineElementalLoop02_01_Dark_Orange_300x300.webm`,
              lg`Nature/GroupVineElementalLoop03_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop01_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop01_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop01_03_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop02_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop02_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop02_03_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop03_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop03_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop03_03_Dark_Orange_300x300.webm`
            ]
          }
        }
      }
    },
    static: {
      _free: ["plants"],
      generic: {
        boulderimpact: {
          "02": {
            white: [lg`Impact/BoulderImpactNoCracks_01_Regular_White_500x500.webm`]
          }
        }
      },
      plants: {
        _free: ["circle", "ring", "square"],
        circle: {
          _free: ["complete", "loop"],
          complete: {
            _markers: {
              loop: { start: 2e3, end: 6e3 }
            },
            _free: ["greenyellow"],
            purpleblue: [lg`Nature/PlantGrowthRound01_01_Regular_BluePurple_500x500.webm`],
            greenred: [lg`Nature/PlantGrowthRound02_01_Regular_GreenRed_500x500.webm`],
            greenyellow: [lg`Nature/PlantGrowthRound03_01_Regular_GreenYellow_500x500.webm`]
          },
          loop: {
            _free: ["greenyellow"],
            purpleblue: [lg`Nature/PlantGrowthRoundLoop01_01_Regular_BluePurple_500x500.webm`],
            greenred: [lg`Nature/PlantGrowthRoundLoop02_01_Regular_GreenRed_500x500.webm`],
            greenyellow: [lg`Nature/PlantGrowthRoundLoop03_01_Regular_GreenYellow_500x500.webm`]
          }
        },
        ring: {
          _free: ["complete", "loop", "pulse"],
          complete: {
            _markers: {
              loop: { start: 2e3, end: 6e3 }
            },
            _free: ["greenyellow"],
            purpleblue: [lg`Nature/PlantGrowthRing01_01_Regular_BluePurple_500x500.webm`],
            greenred: [lg`Nature/PlantGrowthRing02_01_Regular_GreenRed_500x500.webm`],
            greenyellow: [lg`Nature/PlantGrowthRing03_01_Regular_GreenYellow_500x500.webm`]
          },
          loop: {
            _free: ["greenyellow"],
            purpleblue: [lg`Nature/PlantGrowthRingLoop01_01_Regular_BluePurple_500x500.webm`],
            greenred: [lg`Nature/PlantGrowthRingLoop02_01_Regular_GreenRed_500x500.webm`],
            greenyellow: [lg`Nature/PlantGrowthRingLoop03_01_Regular_GreenYellow_500x500.webm`]
          },
          pulse: {
            _free: ["greenyellow"],
            purpleblue: [lg`Nature/PlantGrowthRingPulse01_01_Regular_BluePurple_500x500.webm`],
            greenred: [lg`Nature/PlantGrowthRingPulse02_01_Regular_GreenRed_500x500.webm`],
            greenyellow: [lg`Nature/PlantGrowthRingPulse03_01_Regular_GreenYellow_500x500.webm`]
          }
        },
        square: {
          _free: ["complete", "loop"],
          complete: {
            _markers: {
              loop: { start: 2e3, end: 6e3 }
            },
            _free: ["greenyellow"],
            purpleblue: [lg`Nature/PlantGrowthSquare01_01_Regular_BluePurple_500x500.webm`],
            greenred: [lg`Nature/PlantGrowthSquare02_01_Regular_GreenRed_500x500.webm`],
            greenyellow: [lg`Nature/PlantGrowthSquare03_01_Regular_GreenYellow_500x500.webm`]
          },
          loop: {
            _free: ["greenyellow"],
            purpleblue: [lg`Nature/PlantGrowthSquareLoop01_01_Regular_BluePurple_500x500.webm`],
            greenred: [lg`Nature/PlantGrowthSquareLoop02_01_Regular_GreenRed_500x500.webm`],
            greenyellow: [lg`Nature/PlantGrowthSquareLoop03_01_Regular_GreenYellow_500x500.webm`]
          }
        }
      },
      spell: {
        entangle: {
          "02": {
            darkorange: [l1`Entangle/EntangleLoop02_03_Dark_Orange_500x500.webm`]
          },
          complete: {
            darkorange: [l1`Entangle/Entangle02_03_Dark_Orange_500x500.webm`]
          }
        },
        whirlwind: {
          "01": {
            whiteblue: [l7`Whirlwind/Whirlwind_01_BlueWhite_400x400.webm`]
          }
        }
      },
      vines: {
        complete: {
          elemental: {
            darkorange: [
              lg`Nature/GroupVineElemental01_01_Dark_Orange_300x300.webm`,
              lg`Nature/GroupVineElemental02_01_Dark_Orange_300x300.webm`,
              lg`Nature/GroupVineElemental03_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental01_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental01_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental01_03_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental02_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental02_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental02_03_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental03_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental03_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElemental03_03_Dark_Orange_300x300.webm`
            ]
          }
        },
        loop: {
          elemental: {
            darkorange: [
              lg`Nature/GroupVineElementalLoop01_01_Dark_Orange_300x300.webm`,
              lg`Nature/GroupVineElementalLoop02_01_Dark_Orange_300x300.webm`,
              lg`Nature/GroupVineElementalLoop03_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop01_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop01_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop01_03_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop02_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop02_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop02_03_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop03_01_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop03_02_Dark_Orange_300x300.webm`,
              lg`Nature/VineElementalLoop03_03_Dark_Orange_300x300.webm`
            ]
          }
        }
      }
    }
  };
  return patreonDB050;
}
async function db051(path) {
  const BASE = `${path}/Library/`;
  const prefix = (str) => (strs, ...exprs) => `${BASE}${str}/${strs.reduce((a, c, i) => a + exprs[i - 1] + c)}`;
  const l1 = prefix("1st_Level");
  const l3 = prefix("3rd_Level");
  const lg = prefix("Generic");
  const patreonDB051 = {
    range: {
      _template: "ranged",
      _free: [],
      weapon: {
        boomerang: {
          "01": {
            white: {
              "15ft": [lg`Weapon_Attacks/Ranged/Boomerang01_01_Regular_White_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Boomerang01_01_Regular_White_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Boomerang01_01_Regular_White_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Boomerang01_01_Regular_White_90ft_4000x400.webm`]
            }
          },
          "02": {
            white: {
              "15ft": [lg`Weapon_Attacks/Ranged/Boomerang01_02_Regular_White_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Boomerang01_02_Regular_White_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Boomerang01_02_Regular_White_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Boomerang01_02_Regular_White_90ft_4000x400.webm`]
            }
          }
        },
        bullet: {
          "1": {
            purple: {
              "05ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Purple_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Purple_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Purple_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Purple_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Bullet_01_Regular_Purple_90ft_4000x400.webm`]
            }
          },
          "2": {
            purple: {
              "05ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Purple_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Purple_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Purple_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Purple_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Bullet_02_Regular_Purple_90ft_4000x400.webm`]
            }
          },
          "3": {
            purple: {
              "05ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Purple_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Purple_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Purple_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Purple_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Bullet_03_Regular_Purple_90ft_4000x400.webm`]
            }
          }
        },
        snipe: {
          "01": {
            purple: {
              "05ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Purple_05ft_600x400.webm`],
              "15ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Purple_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Purple_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Purple_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Snipe_01_Regular_Purple_90ft_4000x400.webm`]
            }
          }
        },
        triboomerang: {
          "01": {
            white: {
              "15ft": [lg`Weapon_Attacks/Ranged/Boomerang02_01_Regular_White_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Boomerang02_01_Regular_White_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Boomerang02_01_Regular_White_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Boomerang02_01_Regular_White_90ft_4000x400.webm`]
            }
          },
          "02": {
            white: {
              "15ft": [lg`Weapon_Attacks/Ranged/Boomerang02_02_Regular_White_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Boomerang02_02_Regular_White_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Boomerang02_02_Regular_White_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Boomerang02_02_Regular_White_90ft_4000x400.webm`]
            }
          }
        }
      },
      spell: {
        fireballbeam: {
          "01": {
            darkgreen: {
              "05ft": [l3`Fireball/FireballBeam_01_Dark_Green_05ft_600x400.webm`],
              "15ft": [l3`Fireball/FireballBeam_01_Dark_Green_15ft_1000x400.webm`],
              "30ft": [l3`Fireball/FireballBeam_01_Dark_Green_30ft_1600x400.webm`],
              "60ft": [l3`Fireball/FireballBeam_01_Dark_Green_60ft_2800x400.webm`],
              "90ft": [l3`Fireball/FireballBeam_01_Dark_Green_90ft_4000x400.webm`]
            }
          }
        }
      }
    },
    templatefx: {
      _free: [],
      circle: {
        fireball: {
          loop: {
            darkgreen: [l3`Fireball/FireballLoop_01_Dark_Green_800x800.webm`]
          },
          explode: {
            darkgreen: [l3`Fireball/FireballExplosion_01_Dark_Green_800x800.webm`]
          },
          nodebris: {
            darkgreen: [l3`Fireball/FireballLoopNoDebris_01_Dark_Green_800x800.webm`]
          }
        }
      },
      square: {
        entangle: {
          "02": {
            grey: [l1`Entangle/EntangleLoop02_04_Regular_Grey_500x500.webm`]
          },
          complete: {
            grey: [l1`Entangle/Entangle02_04_Regular_Grey_500x500.webm`]
          }
        }
      },
      vines: {
        complete: {
          liquid: {
            _markers: {
              loop: { start: 2125, end: 6250 }
            },
            grey: [
              lg`Nature/GroupVineLiquid01_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid01_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid01_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid01_03_Regular_Grey_300x300.webm`,
              lg`Nature/GroupVineLiquid02_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid02_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid02_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid02_03_Regular_Grey_300x300.webm`,
              lg`Nature/GroupVineLiquid03_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid03_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid03_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid03_03_Regular_Grey_300x300.webm`
            ]
          }
        },
        loop: {
          liquid: {
            grey: [
              lg`Nature/GroupVineLiquidLoop01_01_Regular_Grey_300x300.webm`,
              lg`Nature/GroupVineLiquidLoop02_01_Regular_Grey_300x300.webm`,
              lg`Nature/GroupVineLiquidLoop03_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop01_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop01_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop01_03_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop02_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop02_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop02_03_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop03_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop03_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop03_03_Regular_Grey_300x300.webm`
            ]
          }
        }
      }
    },
    static: {
      _free: ["leaves", "marker"],
      leaves: {
        _free: ["outburst"],
        complete: {
          "01": {
            orangered: [lg`Nature/SwirlingLeavesComplete01_01_Regular_OrangeRed_400x400.webm`],
            pink: [lg`Nature/SwirlingLeavesComplete01_01_Regular_Pink_400x400.webm`]
          },
          "02": {
            orangered: [lg`Nature/SwirlingLeavesComplete01_02_Regular_OrangeRed_400x400.webm`],
            pink: [lg`Nature/SwirlingLeavesComplete01_02_Regular_Pink_400x400.webm`]
          },
          "03": {
            orangered: [lg`Nature/SwirlingLeavesComplete02_01_Regular_OrangeRed_400x400.webm`],
            pink: [lg`Nature/SwirlingLeavesComplete02_01_Regular_Pink_400x400.webm`]
          }
        },
        loop: {
          "01": {
            orangered: [lg`Nature/SwirlingLeavesLoop01_01_Regular_OrangeRed_400x400.webm`],
            pink: [lg`Nature/SwirlingLeavesLoop01_01_Regular_Pink_400x400.webm`]
          },
          "02": {
            orangered: [lg`Nature/SwirlingLeavesLoop01_02_Regular_OrangeRed_400x400.webm`],
            pink: [lg`Nature/SwirlingLeavesLoop01_02_Regular_Pink_400x400.webm`]
          },
          "03": {
            orangered: [lg`Nature/SwirlingLeavesLoop02_01_Regular_OrangeRed_400x400.webm`],
            pink: [lg`Nature/SwirlingLeavesLoop02_01_Regular_Pink_400x400.webm`]
          }
        },
        outburst: {
          _free: ["01"],
          "01": {
            _free: ["pink"],
            purpleblue: [lg`Nature/SwirlingLeavesOutburst_01_01_Regular_BluePurple_400x400.webm`],
            greenorange: [lg`Nature/SwirlingLeavesOutburst_01_01_Regular_GreenOrange_400x400.webm`],
            orangered: [lg`Nature/SwirlingLeavesOutburst_01_01_Regular_OrangeRed_400x400.webm`],
            pink: [lg`Nature/SwirlingLeavesOutburst_01_01_Regular_Pink_400x400.webm`]
          }
        }
      },
      magicsign: {
        abjuration: {
          complete: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            blue: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Yellow_800x800.webm`]
          }
        },
        conjuration: {
          complete: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            blue: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Yellow_800x800.webm`]
          }
        },
        divination: {
          complete: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            blue: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Yellow_800x800.webm`]
          }
        },
        enchantment: {
          complete: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            blue: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Yellow_800x800.webm`]
          }
        },
        evocation: {
          complete: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            blue: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Yellow_800x800.webm`]
          }
        },
        illusion: {
          complete: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            blue: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Yellow_800x800.webm`]
          }
        },
        necromancy: {
          complete: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            blue: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Yellow_800x800.webm`]
          }
        },
        transmutation: {
          complete: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            blue: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Yellow_800x800.webm`]
          }
        }
      },
      marker: {
        _free: ["energystrand"],
        energystrand: {
          _free: ["02"],
          "02": {
            _free: ["purpleblue"],
            purpleblue: [lg`Marker/EnergyStrands02_01_Regular_BluePurple_400x400.webm`],
            green: [lg`Marker/EnergyStrands02_01_Regular_Green_400x400.webm`],
            greenorange: [lg`Marker/EnergyStrands02_01_Regular_GreenOrange_400x400.webm`],
            orangered: [lg`Marker/EnergyStrands02_01_Regular_OrangeRed_400x400.webm`]
          }
        }
      },
      spell: {
        entangle: {
          "02": {
            grey: [l1`Entangle/EntangleLoop02_04_Regular_Grey_500x500.webm`]
          },
          complete: {
            grey: [l1`Entangle/Entangle02_04_Regular_Grey_500x500.webm`]
          }
        },
        fireball: {
          loop: {
            darkgreen: [l3`Fireball/FireballLoop_01_Dark_Green_800x800.webm`]
          },
          explode: {
            darkgreen: [l3`Fireball/FireballExplosion_01_Dark_Green_800x800.webm`]
          },
          nodebris: {
            darkgreen: [l3`Fireball/FireballLoopNoDebris_01_Dark_Green_800x800.webm`]
          }
        }
      },
      vines: {
        complete: {
          liquid: {
            _markers: {
              loop: { start: 2125, end: 6250 }
            },
            grey: [
              lg`Nature/GroupVineLiquid01_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid01_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid01_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid01_03_Regular_Grey_300x300.webm`,
              lg`Nature/GroupVineLiquid02_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid02_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid02_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid02_03_Regular_Grey_300x300.webm`,
              lg`Nature/GroupVineLiquid03_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid03_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid03_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquid03_03_Regular_Grey_300x300.webm`
            ]
          }
        },
        loop: {
          liquid: {
            grey: [
              lg`Nature/GroupVineLiquidLoop01_01_Regular_Grey_300x300.webm`,
              lg`Nature/GroupVineLiquidLoop02_01_Regular_Grey_300x300.webm`,
              lg`Nature/GroupVineLiquidLoop03_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop01_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop01_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop01_03_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop02_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop02_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop02_03_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop03_01_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop03_02_Regular_Grey_300x300.webm`,
              lg`Nature/VineLiquidLoop03_03_Regular_Grey_300x300.webm`
            ]
          }
        }
      }
    },
    return: {
      _template: "ranged",
      _free: [],
      weapon: {
        boomerang: {
          "01": {
            white: {
              "15ft": [lg`Weapon_Attacks/Ranged/Boomerang01_01_Regular_White_Return_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Boomerang01_01_Regular_White_Return_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Boomerang01_01_Regular_White_Return_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Boomerang01_01_Regular_White_Return_90ft_4000x400.webm`]
            }
          }
        },
        triboomerang: {
          "01": {
            white: {
              "15ft": [lg`Weapon_Attacks/Ranged/Boomerang02_01_Regular_White_Return_15ft_1000x400.webm`],
              "30ft": [lg`Weapon_Attacks/Ranged/Boomerang02_01_Regular_White_Return_30ft_1600x400.webm`],
              "60ft": [lg`Weapon_Attacks/Ranged/Boomerang02_01_Regular_White_Return_60ft_2800x400.webm`],
              "90ft": [lg`Weapon_Attacks/Ranged/Boomerang02_01_Regular_White_Return_90ft_4000x400.webm`]
            }
          }
        }
      }
    }
  };
  return patreonDB051;
}
async function db052(path) {
  const BASE = `${path}/Library/`;
  const prefix = (str) => (strs, ...exprs) => `${BASE}${str}/${strs.reduce((a, c, i) => a + exprs[i - 1] + c)}`;
  const lg = prefix("Generic");
  const patreonDB052 = {
    range: {
      _free: [],
      generic: {
        poison: {
          "01": {
            greenyellow: {
              "05ft": [lg`RangedSpell/ProjectilePoison01_01_Regular_GreenYellow_05ft_600x400.webm`],
              "15ft": [lg`RangedSpell/ProjectilePoison01_01_Regular_GreenYellow_15ft_1000x400.webm`],
              "30ft": [lg`RangedSpell/ProjectilePoison01_01_Regular_GreenYellow_30ft_1600x400.webm`],
              "60ft": [lg`RangedSpell/ProjectilePoison01_01_Regular_GreenYellow_60ft_2800x400.webm`],
              "90ft": [lg`RangedSpell/ProjectilePoison01_01_Regular_GreenYellow_90ft_4000x400.webm`]
            }
          }
        }
      }
    },
    melee: {
      _free: ["weapon", "generic"],
      weapon: {
        _free: ["lasersword"],
        lasersword: {
          _free: ["02"],
          "02": {
            _free: ["blue"],
            blue: [lg`Weapon_Attacks/Melee/LaserSword01_02_Regular_Blue_800x600.webm`],
            blue02: [lg`Weapon_Attacks/Melee/LaserSword01_02_Regular_Blue02_800x600.webm`],
            blue03: [lg`Weapon_Attacks/Melee/LaserSword01_02_Regular_Blue03_800x600.webm`],
            darkred: [lg`Weapon_Attacks/Melee/LaserSword01_02_Dark_Red_800x600.webm`],
            darkwhite: [lg`Weapon_Attacks/Melee/LaserSword01_02_Dark_White_800x600.webm`],
            green: [lg`Weapon_Attacks/Melee/LaserSword01_02_Regular_Green_800x600.webm`],
            green02: [lg`Weapon_Attacks/Melee/LaserSword01_02_Regular_Green02_800x600.webm`],
            orange: [lg`Weapon_Attacks/Melee/LaserSword01_02_Regular_Orange_800x600.webm`],
            purple: [lg`Weapon_Attacks/Melee/LaserSword01_02_Regular_Purple_800x600.webm`],
            red: [lg`Weapon_Attacks/Melee/LaserSword01_02_Regular_Red_800x600.webm`],
            white: [lg`Weapon_Attacks/Melee/LaserSword01_02_Regular_White_800x600.webm`],
            yellow: [lg`Weapon_Attacks/Melee/LaserSword01_02_Regular_Yellow_800x600.webm`]
          }
        }
      },
      generic: {
        _free: ["slashing", "whirlwind"],
        slashing: {
          _free: ["01", "02", "03"],
          "01": {
            _free: ["orange"],
            greenyellow: [lg`Weapon_Attacks/Melee/GenericSlash01_01_Regular_GreenYellow_800x600.webm`],
            purpleblue: [lg`Weapon_Attacks/Melee/GenericSlash01_01_Regular_BluePurple_800x600.webm`],
            orange: [lg`Weapon_Attacks/Melee/GenericSlash01_01_Regular_Orange_800x600.webm`]
          },
          "02": {
            _free: ["orange"],
            greenyellow: [lg`Weapon_Attacks/Melee/GenericSlash01_02_Regular_GreenYellow_800x600.webm`],
            purpleblue: [lg`Weapon_Attacks/Melee/GenericSlash01_02_Regular_BluePurple_800x600.webm`],
            orange: [lg`Weapon_Attacks/Melee/GenericSlash01_02_Regular_Orange_800x600.webm`]
          },
          "03": {
            _free: ["orange"],
            greenyellow: [lg`Weapon_Attacks/Melee/GenericSlash01_03_Regular_GreenYellow_800x600.webm`],
            purpleblue: [lg`Weapon_Attacks/Melee/GenericSlash01_03_Regular_BluePurple_800x600.webm`],
            orange: [lg`Weapon_Attacks/Melee/GenericSlash01_03_Regular_Orange_800x600.webm`]
          }
        },
        whirlwind: {
          _free: ["01", "02"],
          "01": {
            _free: ["orange"],
            greenyellow: [lg`Weapon_Attacks/Melee/GenericWhirlwind01_01_Regular_GreenYellow_800x600.webm`],
            purpleblue: [lg`Weapon_Attacks/Melee/GenericWhirlwind01_01_Regular_BluePurple_800x600.webm`],
            orange: [lg`Weapon_Attacks/Melee/GenericWhirlwind01_01_Regular_Orange_800x600.webm`]
          },
          "02": {
            _free: ["orange"],
            greenyellow: [lg`Weapon_Attacks/Melee/GenericWhirlwind01_02_Regular_GreenYellow_800x600.webm`],
            purpleblue: [lg`Weapon_Attacks/Melee/GenericWhirlwind01_02_Regular_BluePurple_800x600.webm`],
            orange: [lg`Weapon_Attacks/Melee/GenericWhirlwind01_02_Regular_Orange_800x600.webm`]
          }
        }
      }
    },
    templatefx: {
      _free: ["circle"],
      circle: {
        _free: ["magicsign"],
        magicsign: {
          _free: [
            "abjuration",
            "conjuration",
            "divination",
            "enchantment",
            "evocation",
            "illusion",
            "necromancy",
            "transmutation"
          ],
          abjuration: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            _free: ["blue"],
            blue: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/AbjurationCircleComplete_02_Regular_Yellow_800x800.webm`]
          },
          conjuration: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            _free: ["yellow"],
            blue: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/ConjurationCircleComplete_02_Regular_Yellow_800x800.webm`]
          },
          divination: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            _free: ["blue"],
            blue: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/DivinationCircleComplete_02_Regular_Yellow_800x800.webm`]
          },
          enchantment: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            _free: ["pink"],
            blue: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/EnchantmentCircleComplete_02_Regular_Yellow_800x800.webm`]
          },
          evocation: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            _free: ["red"],
            blue: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/EvocationCircleComplete_02_Regular_Yellow_800x800.webm`]
          },
          illusion: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            _free: ["purple"],
            blue: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/IllusionCircleComplete_02_Regular_Yellow_800x800.webm`]
          },
          necromancy: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            _free: ["green"],
            blue: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/NecromancyCircleComplete_02_Regular_Yellow_800x800.webm`]
          },
          transmutation: {
            _markers: {
              loop: { start: 3e3, end: 8e3 },
              forcedEnd: 8e3
            },
            _free: ["yellow"],
            blue: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Blue_800x800.webm`],
            green: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Green_800x800.webm`],
            pink: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Pink_800x800.webm`],
            purple: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Purple_800x800.webm`],
            red: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Red_800x800.webm`],
            yellow: [lg`Magic_Signs/TransmutationCircleComplete_02_Regular_Yellow_800x800.webm`]
          }
        }
      }
    },
    static: {
      _free: ["magicsign"],
      fire: {
        groundcrack: {
          "01": {
            white: [lg`Fire/GroundCrackLoop_01_Regular_White_600x600.webm`]
          },
          "02": {
            white: [lg`Fire/GroundCrackLoop_02_Regular_White_600x600.webm`]
          },
          "03": {
            white: [lg`Fire/GroundCrackLoop_03_Regular_White_600x600.webm`]
          }
        }
      },
      impact: {
        frost: {
          "01": {
            blue: [lg`Impact/FrostImpact_01_Regular_Blue_600x600.webm`],
            green: [lg`Impact/FrostImpact_01_Regular_Green_600x600.webm`],
            orange: [lg`Impact/FrostImpact_01_Regular_Orange_600x600.webm`],
            purple: [lg`Impact/FrostImpact_01_Regular_Purple_600x600.webm`],
            white: [lg`Impact/FrostImpact_01_Regular_White_600x600.webm`]
          }
        },
        groundcrack: {
          "01": {
            blue: [
              lg`Impact/GroundCrackImpact_01_Regular_Blue_600x600.webm`,
              lg`Impact/GroundCrackImpact_02_Regular_Blue_600x600.webm`,
              lg`Impact/GroundCrackImpact_03_Regular_Blue_600x600.webm`
            ],
            green: [
              lg`Impact/GroundCrackImpact_01_Regular_Green_600x600.webm`,
              lg`Impact/GroundCrackImpact_02_Regular_Green_600x600.webm`,
              lg`Impact/GroundCrackImpact_03_Regular_Green_600x600.webm`
            ],
            orange: [
              lg`Impact/GroundCrackImpact_01_Regular_Orange_600x600.webm`,
              lg`Impact/GroundCrackImpact_02_Regular_Orange_600x600.webm`,
              lg`Impact/GroundCrackImpact_03_Regular_Orange_600x600.webm`
            ],
            purple: [
              lg`Impact/GroundCrackImpact_01_Regular_Purple_600x600.webm`,
              lg`Impact/GroundCrackImpact_02_Regular_Purple_600x600.webm`,
              lg`Impact/GroundCrackImpact_03_Regular_Purple_600x600.webm`
            ],
            white: [
              lg`Impact/GroundCrackImpact_01_Regular_White_600x600.webm`,
              lg`Impact/GroundCrackImpact_02_Regular_White_600x600.webm`,
              lg`Impact/GroundCrackImpact_03_Regular_White_600x600.webm`
            ]
          },
          frost: {
            blue: [lg`Impact/GroundCrackFrostImpact_01_Regular_Blue_600x600.webm`],
            green: [lg`Impact/GroundCrackFrostImpact_01_Regular_Green_600x600.webm`],
            orange: [lg`Impact/GroundCrackFrostImpact_01_Regular_Orange_600x600.webm`],
            purple: [lg`Impact/GroundCrackFrostImpact_01_Regular_Purple_600x600.webm`],
            white: [lg`Impact/GroundCrackFrostImpact_01_Regular_White_600x600.webm`]
          }
        },
        poison: {
          "01": {
            green: [lg`Impact/ImpactPoison01_01_Regular_GreenYellow_400x400.webm`]
          }
        }
      },
      magicsign: {
        _free: [
          "abjuration",
          "conjuration",
          "divination",
          "enchantment",
          "evocation",
          "illusion",
          "necromancy",
          "transmutation"
        ],
        abjuration: {
          _free: ["complete"],
          complete: {
            _free: ["darkblue"],
            darkblue: [lg`Magic_Signs/AbjurationCircleComplete_02_Dark_Blue_800x800.webm`],
            darkgreen: [lg`Magic_Signs/AbjurationCircleComplete_02_Dark_Green_800x800.webm`],
            darkpink: [lg`Magic_Signs/AbjurationCircleComplete_02_Dark_Pink_800x800.webm`],
            darkpurple: [lg`Magic_Signs/AbjurationCircleComplete_02_Dark_Purple_800x800.webm`],
            darkred: [lg`Magic_Signs/AbjurationCircleComplete_02_Dark_Red_800x800.webm`],
            darkyellow: [lg`Magic_Signs/AbjurationCircleComplete_02_Dark_Yellow_800x800.webm`]
          }
        },
        conjuration: {
          _free: ["complete"],
          complete: {
            _free: ["darkyellow"],
            darkblue: [lg`Magic_Signs/ConjurationCircleComplete_02_Dark_Blue_800x800.webm`],
            darkgreen: [lg`Magic_Signs/ConjurationCircleComplete_02_Dark_Green_800x800.webm`],
            darkpink: [lg`Magic_Signs/ConjurationCircleComplete_02_Dark_Pink_800x800.webm`],
            darkpurple: [lg`Magic_Signs/ConjurationCircleComplete_02_Dark_Purple_800x800.webm`],
            darkred: [lg`Magic_Signs/ConjurationCircleComplete_02_Dark_Red_800x800.webm`],
            darkyellow: [lg`Magic_Signs/ConjurationCircleComplete_02_Dark_Yellow_800x800.webm`]
          }
        },
        divination: {
          _free: ["complete"],
          complete: {
            _free: ["darkblue"],
            darkblue: [lg`Magic_Signs/DivinationCircleComplete_02_Dark_Blue_800x800.webm`],
            darkgreen: [lg`Magic_Signs/DivinationCircleComplete_02_Dark_Green_800x800.webm`],
            darkpink: [lg`Magic_Signs/DivinationCircleComplete_02_Dark_Pink_800x800.webm`],
            darkpurple: [lg`Magic_Signs/DivinationCircleComplete_02_Dark_Purple_800x800.webm`],
            darkred: [lg`Magic_Signs/DivinationCircleComplete_02_Dark_Red_800x800.webm`],
            darkyellow: [lg`Magic_Signs/DivinationCircleComplete_02_Dark_Yellow_800x800.webm`]
          }
        },
        enchantment: {
          _free: ["complete"],
          complete: {
            _free: ["darkpink"],
            darkblue: [lg`Magic_Signs/EnchantmentCircleComplete_02_Dark_Blue_800x800.webm`],
            darkgreen: [lg`Magic_Signs/EnchantmentCircleComplete_02_Dark_Green_800x800.webm`],
            darkpink: [lg`Magic_Signs/EnchantmentCircleComplete_02_Dark_Pink_800x800.webm`],
            darkpurple: [lg`Magic_Signs/EnchantmentCircleComplete_02_Dark_Purple_800x800.webm`],
            darkred: [lg`Magic_Signs/EnchantmentCircleComplete_02_Dark_Red_800x800.webm`],
            darkyellow: [lg`Magic_Signs/EnchantmentCircleComplete_02_Dark_Yellow_800x800.webm`]
          }
        },
        illusion: {
          _free: ["complete"],
          complete: {
            _free: ["darkpurple"],
            darkblue: [lg`Magic_Signs/IllusionCircleComplete_02_Dark_Blue_800x800.webm`],
            darkgreen: [lg`Magic_Signs/IllusionCircleComplete_02_Dark_Green_800x800.webm`],
            darkpink: [lg`Magic_Signs/IllusionCircleComplete_02_Dark_Pink_800x800.webm`],
            darkpurple: [lg`Magic_Signs/IllusionCircleComplete_02_Dark_Purple_800x800.webm`],
            darkred: [lg`Magic_Signs/IllusionCircleComplete_02_Dark_Red_800x800.webm`],
            darkyellow: [lg`Magic_Signs/IllusionCircleComplete_02_Dark_Yellow_800x800.webm`]
          }
        },
        necromancy: {
          _free: ["complete"],
          complete: {
            _free: ["darkgreen"],
            darkblue: [lg`Magic_Signs/NecromancyCircleComplete_02_Dark_Blue_800x800.webm`],
            darkgreen: [lg`Magic_Signs/NecromancyCircleComplete_02_Dark_Green_800x800.webm`],
            darkpink: [lg`Magic_Signs/NecromancyCircleComplete_02_Dark_Pink_800x800.webm`],
            darkpurple: [lg`Magic_Signs/NecromancyCircleComplete_02_Dark_Purple_800x800.webm`],
            darkred: [lg`Magic_Signs/NecromancyCircleComplete_02_Dark_Red_800x800.webm`],
            darkyellow: [lg`Magic_Signs/NecromancyCircleComplete_02_Dark_Yellow_800x800.webm`]
          }
        },
        transmutation: {
          _free: ["complete"],
          complete: {
            _free: ["darkyellow"],
            darkblue: [lg`Magic_Signs/TransmutationCircleComplete_02_Dark_Blue_800x800.webm`],
            darkgreen: [lg`Magic_Signs/TransmutationCircleComplete_02_Dark_Green_800x800.webm`],
            darkpink: [lg`Magic_Signs/TransmutationCircleComplete_02_Dark_Pink_800x800.webm`],
            darkpurple: [lg`Magic_Signs/TransmutationCircleComplete_02_Dark_Purple_800x800.webm`],
            darkred: [lg`Magic_Signs/TransmutationCircleComplete_02_Dark_Red_800x800.webm`],
            darkyellow: [lg`Magic_Signs/TransmutationCircleComplete_02_Dark_Yellow_800x800.webm`]
          }
        }
      },
      sideImpact: {
        poison: {
          regular: {
            greenyellow: [lg`Impact/SideImpactPoison01_01_Regular_GreenYellow_600x600.webm`]
          },
          slow: {
            purplepink: [lg`Impact/PartSideImpactSlowPoison01_01_Regular_GreenYellow_600x600.webm`]
          }
        }
      }
    }
  };
  return patreonDB052;
}
async function db053(path) {
  const BASE = `${path}/Library/`;
  const prefix = (str) => (strs, ...exprs) => `${BASE}${str}/${strs.reduce((a, c, i) => a + exprs[i - 1] + c)}`;
  const l0 = prefix("Cantrip");
  const l1 = prefix("1st_Level");
  const l2 = prefix("2nd_Level");
  const lg = prefix("Generic");
  const patreonDB053 = {
    range: {
      _free: [],
      spell: {
        guidingbolt: {
          "01": {
            yellow: {
              "05ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Yellow_05ft_600x400.webm`],
              "15ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Yellow_15ft_1000x400.webm`],
              "30ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Yellow_30ft_1600x400.webm`],
              "60ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Yellow_60ft_2800x400.webm`],
              "90ft": [l1`Guiding_Bolt/GuidingBolt_01_Regular_Yellow_90ft_4000x400.webm`]
            }
          },
          "02": {
            yellow: {
              "05ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Yellow_05ft_600x400.webm`],
              "15ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Yellow_15ft_1000x400.webm`],
              "30ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Yellow_30ft_1600x400.webm`],
              "60ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Yellow_60ft_2800x400.webm`],
              "90ft": [l1`Guiding_Bolt/GuidingBolt_02_Regular_Yellow_90ft_4000x400.webm`]
            }
          }
        }
      },
      generic: {
        energybeam: {
          "01": {
            yellow: {
              "15ft": [lg`Energy/EnergyBeam_01_Regular_Yellow_15ft_1000x400.webm`],
              "30ft": [lg`Energy/EnergyBeam_01_Regular_Yellow_30ft_1600x400.webm`],
              "60ft": [lg`Energy/EnergyBeam_01_Regular_Yellow_60ft_2800x400.webm`],
              "90ft": [lg`Energy/EnergyBeam_01_Regular_Yellow_90ft_4000x400.webm`]
            }
          },
          "02": {
            yellow: {
              "05ft": [lg`Energy/EnergyBeam_02_Regular_Yellow_05ft_600x400.webm`],
              "15ft": [lg`Energy/EnergyBeam_02_Regular_Yellow_15ft_1000x400.webm`],
              "30ft": [lg`Energy/EnergyBeam_02_Regular_Yellow_30ft_1600x400.webm`],
              "60ft": [lg`Energy/EnergyBeam_02_Regular_Yellow_60ft_2800x400.webm`],
              "90ft": [lg`Energy/EnergyBeam_02_Regular_Yellow_90ft_4000x400.webm`]
            }
          },
          "03": {
            yellow: {
              "05ft": [lg`Energy/EnergyBeam_03_Regular_Yellow_05ft_600x400.webm`],
              "15ft": [lg`Energy/EnergyBeam_03_Regular_Yellow_15ft_1000x400.webm`],
              "30ft": [lg`Energy/EnergyBeam_03_Regular_Yellow_30ft_1600x400.webm`],
              "60ft": [lg`Energy/EnergyBeam_03_Regular_Yellow_60ft_2800x400.webm`],
              "90ft": [lg`Energy/EnergyBeam_03_Regular_Yellow_90ft_4000x400.webm`]
            }
          },
          reverse: {
            yellow: {
              "15ft": [lg`Energy/EnergyBeamReverse_01_Regular_Yellow_15ft_1000x400.webm`],
              "30ft": [lg`Energy/EnergyBeamReverse_01_Regular_Yellow_30ft_1600x400.webm`],
              "60ft": [lg`Energy/EnergyBeamReverse_01_Regular_Yellow_60ft_2800x400.webm`],
              "90ft": [lg`Energy/EnergyBeamReverse_01_Regular_Yellow_90ft_4000x400.webm`]
            }
          }
        },
        energystrand: {
          "02": {
            yellow: {
              "05ft": [lg`Energy/EnergyStrand_Multiple02_Regular_Yellow_05ft_600x400.webm`],
              "15ft": [lg`Energy/EnergyStrand_Multiple02_Regular_Yellow_15ft_1000x400.webm`],
              "30ft": [lg`Energy/EnergyStrand_Multiple02_Regular_Yellow_30ft_1600x400.webm`],
              "60ft": [lg`Energy/EnergyStrand_Multiple02_Regular_Yellow_60ft_2800x400.webm`],
              "90ft": [lg`Energy/EnergyStrand_Multiple02_Regular_Yellow_90ft_4000x400.webm`]
            }
          }
        }
      }
    },
    templatefx: {
      _free: [],
      circle: {
        detectmagic: {
          "01": {
            yellow: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Yellow_1200x1200.webm`]
          }
        },
        moonbeam: {
          loop: {
            yellow: [l2`Moonbeam/Moonbeam_01_Regular_Yellow_400x400.webm`]
          },
          intro: {
            yellow: [l2`Moonbeam/MoonbeamIntro_01_Regular_Yellow_400x400.webm`]
          },
          outro: {
            yellow: [l2`Moonbeam/MoonbeamOutro_01_Regular_Yellow_400x400.webm`]
          },
          complete: {
            _markers: {
              loop: { start: 3708, end: 8708 }
            },
            blue: [l2`Moonbeam/MoonbeamComplete_01_Regular_Blue_400x400.webm`],
            green: [l2`Moonbeam/MoonbeamComplete_01_Regular_Green_400x400.webm`],
            rainbow: [l2`Moonbeam/MoonbeamComplete_01_Regular_Rainbow_400x400.webm`],
            yellow: [l2`Moonbeam/MoonbeamComplete_01_Regular_Yellow_400x400.webm`]
          }
        },
        outpulse: {
          "01": {
            yellowwhite: [lg`Template/Circle/OutPulse/OutPulse_01_Regular_YellowWhite_Burst_600x600.webm`]
          },
          "02": {
            yellowwhite: [lg`Template/Circle/OutPulse/OutPulse_02_Regular_YellowWhite_Burst_600x600.webm`]
          }
        }
      },
      cone: {
        detectmagic: {
          "01": {
            blue: [l1`Detect_Magic/DetectMagicCone_01_Regular_Blue_15ft_500x500.webm`],
            green: [l1`Detect_Magic/DetectMagicCone_01_Regular_Green_15ft_500x500.webm`],
            greenorange: [l1`Detect_Magic/DetectMagicCone_01_Regular_GreenOrange_15ft_500x500.webm`],
            grey: [l1`Detect_Magic/DetectMagicCone_01_Regular_Grey_15ft_500x500.webm`],
            purple: [l1`Detect_Magic/DetectMagicCone_01_Regular_Purple_15ft_500x500.webm`],
            yellow: [l1`Detect_Magic/DetectMagicCone_01_Regular_Yellow_15ft_500x500.webm`]
          }
        }
      }
    },
    static: {
      _free: ["marker", "nature", "sideImpact", "smoke"],
      energy: {
        energyfield: {
          "01": {
            yellow: [lg`Energy/EnergyField_01_Regular_Yellow_600x600.webm`]
          }
        },
        sparkles: {
          "01": {
            yellow: [lg`Energy/SwirlingSparkles_01_Regular_Yellow_400x400.webm`]
          }
        }
      },
      generic: {
        outpulse: {
          "01": {
            yellowwhite: [lg`Template/Circle/OutPulse/OutPulse_01_Regular_YellowWhite_Burst_600x600.webm`]
          },
          "02": {
            yellowwhite: [lg`Template/Circle/OutPulse/OutPulse_02_Regular_YellowWhite_Burst_600x600.webm`]
          }
        },
        smoke: {
          "01": {
            green: [lg`Smoke/SmokePuff01_01_Regular_Green_400x400.webm`]
          },
          "02": {
            green: [lg`Smoke/SmokePuff01_02_Regular_Green_400x400.webm`]
          },
          "03": {
            green: [lg`Smoke/SmokePuff01_03_Regular_Green_400x400.webm`]
          }
        }
      },
      ice: {
        icespikes: {
          "01": {
            grey: [lg`Ice/IceSpikesRadialBurst_01_Regular_Grey_1000x1000.webm`],
            yellow: [lg`Ice/IceSpikesRadialBurst_01_Regular_Yellow_1000x1000.webm`]
          }
        },
        snowflake: {
          "01": {
            yellowwhite: [lg`Ice/SnowflakeBurst_01_Regular_YellowWhite_Burst_600x600.webm`]
          }
        }
      },
      marker: {
        _free: ["bubble", "roundshield", "smokering"],
        bubble: {
          _free: ["complete"],
          "01": {
            yellow: [lg`Marker/MarkerBubble_01_Regular_Yellow_400x400.webm`]
          },
          complete: {
            _markers: {
              loop: { start: 2625, end: 7625 }
            },
            _free: ["blue", "_markers"],
            blue: [lg`Marker/MarkerBubbleComplete_01_Regular_Blue_400x400.webm`],
            green: [lg`Marker/MarkerBubbleComplete_01_Regular_Green_400x400.webm`],
            rainbow: [lg`Marker/MarkerBubbleComplete_01_Regular_Rainbow_400x400.webm`],
            yellow: [lg`Marker/MarkerBubbleComplete_01_Regular_Yellow_400x400.webm`]
          }
        },
        light: {
          intro: {
            blue: [lg`Marker/MarkerLightIntro_01_Regular_Blue_400x400.webm`],
            green: [lg`Marker/MarkerLightIntro_01_Regular_Green_400x400.webm`],
            yellow: [lg`Marker/MarkerLightIntro_01_Regular_Yellow_400x400.webm`]
          },
          outro: {
            blue: [lg`Marker/MarkerLightOutro_01_Regular_Blue_400x400.webm`],
            green: [lg`Marker/MarkerLightOutro_01_Regular_Green_400x400.webm`],
            yellow: [lg`Marker/MarkerLightOutro_01_Regular_Yellow_400x400.webm`]
          },
          complete: {
            _markers: {
              loop: { start: 3750, end: 8750 }
            },
            blue: [lg`Marker/MarkerLightComplete_01_Regular_Blue_400x400.webm`],
            green: [lg`Marker/MarkerLightComplete_01_Regular_Green_400x400.webm`],
            yellow: [lg`Marker/MarkerLightComplete_01_Regular_Yellow_400x400.webm`]
          }
        },
        roundshield: {
          _free: ["loop", "complete"],
          loop: {
            _free: ["orange"],
            darkred: [lg`Marker/MarkerShieldRampartLoop01_01_Dark_Red_400x400.webm`],
            orange: [lg`Marker/MarkerShieldRampartLoop01_01_Regular_Orange_400x400.webm`]
          },
          complete: {
            _markers: {
              loop: { start: 1916, end: 6208 }
            },
            _free: ["orange", "_markers"],
            darkred: [lg`Marker/MarkerShieldRampart01_01_Dark_Red_400x400.webm`],
            orange: [lg`Marker/MarkerShieldRampart01_01_Regular_Orange_400x400.webm`]
          }
        },
        boneshield: {
          loop: {
            green: [lg`Marker/MarkerShieldRampartLoop02_01_Regular_Green_400x400.webm`],
            purple: [lg`Marker/MarkerShieldRampartLoop02_01_Regular_Purple_400x400.webm`]
          },
          complete: {
            _markers: {
              loop: { start: 1916, end: 6208 }
            },
            green: [lg`Marker/MarkerShieldRampart02_01_Regular_Green_400x400.webm`],
            purple: [lg`Marker/MarkerShieldRampart02_01_Regular_Purple_400x400.webm`]
          }
        },
        towershield: {
          loop: {
            blue: [lg`Marker/MarkerShieldRampartLoop03_01_Regular_Blue_400x400.webm`],
            yellow: [lg`Marker/MarkerShieldRampartLoop03_01_Regular_Yellow_400x400.webm`]
          },
          complete: {
            _markers: {
              loop: { start: 1916, end: 6208 }
            },
            blue: [lg`Marker/MarkerShieldRampart03_01_Regular_Blue_400x400.webm`],
            yellow: [lg`Marker/MarkerShieldRampart03_01_Regular_Yellow_400x400.webm`]
          }
        },
        smokering: {
          _free: ["loop"],
          loop: {
            _free: ["purpleblue"],
            darkred: [lg`Marker/MarkerSmokeRingLoop01_Dark_Red_400x400.webm`],
            purpleblue: [lg`Marker/MarkerSmokeRingLoop01_Regular_BluePurple_400x400.webm`],
            purple: [lg`Marker/MarkerSmokeRingLoop01_Regular_Purple_400x400.webm`],
            yellow: [lg`Marker/MarkerSmokeRingLoop01_Regular_Yellow_400x400.webm`]
          }
        },
        standard: {
          "01": {
            yellow: [lg`Marker/Marker_01_Regular_Yellow_400x400.webm`]
          },
          "02": {
            yellow: [lg`Marker/Marker_02_Regular_Yellow_400x400.webm`]
          }
        }
      },
      nature: {
        _free: ["feathers"],
        feathers: {
          _free: ["outburst"],
          outburst: {
            _free: ["textured"],
            blue: [
              lg`Nature/SwirlingFeathersOutburst01_01_Regular_Blue_400x400.webm`,
              lg`Nature/SwirlingFeathersOutburst02_01_Regular_Blue_400x400.webm`,
              lg`Nature/SwirlingFeathersOutburst03_01_Regular_Blue_400x400.webm`
            ],
            orange: [
              lg`Nature/SwirlingFeathersOutburst01_01_Regular_Orange_400x400.webm`,
              lg`Nature/SwirlingFeathersOutburst02_01_Regular_Orange_400x400.webm`,
              lg`Nature/SwirlingFeathersOutburst03_01_Regular_Orange_400x400.webm`
            ],
            purple: [
              lg`Nature/SwirlingFeathersOutburst01_01_Regular_Purple_400x400.webm`,
              lg`Nature/SwirlingFeathersOutburst02_01_Regular_Purple_400x400.webm`,
              lg`Nature/SwirlingFeathersOutburst03_01_Regular_Purple_400x400.webm`
            ],
            red: [
              lg`Nature/SwirlingFeathersOutburst01_01_Regular_Red_400x400.webm`,
              lg`Nature/SwirlingFeathersOutburst02_01_Regular_Red_400x400.webm`,
              lg`Nature/SwirlingFeathersOutburst03_01_Regular_Red_400x400.webm`
            ],
            textured: [
              lg`Nature/SwirlingFeathersOutburst01_01_Regular_Textured_400x400.webm`,
              lg`Nature/SwirlingFeathersOutburst02_01_Regular_Textured_400x400.webm`,
              lg`Nature/SwirlingFeathersOutburst03_01_Regular_Textured_400x400.webm`
            ]
          }
        }
      },
      shieldfx: {
        energyfield: {
          "01": {
            yellow: [lg`Energy/EnergyFieldTop_02_Regular_Yellow_400x400.webm`]
          }
        }
      },
      sideImpact: {
        _free: ["smoke"],
        smoke: {
          _free: ["01", "02"],
          "01": {
            _free: ["grey"],
            black: [
              lg`Smoke/SmokePuffSide01_01_Dark_Black_400x400.webm`,
              lg`Smoke/SmokePuffSide01_02_Dark_Black_400x400.webm`,
              lg`Smoke/SmokePuffSide01_03_Dark_Black_400x400.webm`,
              lg`Smoke/SmokePuffSide01_04_Dark_Black_400x400.webm`,
              lg`Smoke/SmokePuffSide01_05_Dark_Black_400x400.webm`
            ],
            blue: [
              lg`Smoke/SmokePuffSide01_01_Regular_Blue_400x400.webm`,
              lg`Smoke/SmokePuffSide01_02_Regular_Blue_400x400.webm`,
              lg`Smoke/SmokePuffSide01_03_Regular_Blue_400x400.webm`,
              lg`Smoke/SmokePuffSide01_04_Regular_Blue_400x400.webm`,
              lg`Smoke/SmokePuffSide01_05_Regular_Blue_400x400.webm`
            ],
            darkgreen: [
              lg`Smoke/SmokePuffSide01_01_Dark_Green_400x400.webm`,
              lg`Smoke/SmokePuffSide01_02_Dark_Green_400x400.webm`,
              lg`Smoke/SmokePuffSide01_03_Dark_Green_400x400.webm`,
              lg`Smoke/SmokePuffSide01_04_Dark_Green_400x400.webm`,
              lg`Smoke/SmokePuffSide01_05_Dark_Green_400x400.webm`
            ],
            darkpurple: [
              lg`Smoke/SmokePuffSide01_01_Dark_Purple_400x400.webm`,
              lg`Smoke/SmokePuffSide01_02_Dark_Purple_400x400.webm`,
              lg`Smoke/SmokePuffSide01_03_Dark_Purple_400x400.webm`,
              lg`Smoke/SmokePuffSide01_04_Dark_Purple_400x400.webm`,
              lg`Smoke/SmokePuffSide01_05_Dark_Purple_400x400.webm`
            ],
            green: [
              lg`Smoke/SmokePuffSide01_01_Regular_Green_400x400.webm`,
              lg`Smoke/SmokePuffSide01_02_Regular_Green_400x400.webm`,
              lg`Smoke/SmokePuffSide01_03_Regular_Green_400x400.webm`,
              lg`Smoke/SmokePuffSide01_04_Regular_Green_400x400.webm`,
              lg`Smoke/SmokePuffSide01_05_Regular_Green_400x400.webm`
            ],
            grey: [
              lg`Smoke/SmokePuffSide01_01_Regular_Grey_400x400.webm`,
              lg`Smoke/SmokePuffSide01_02_Regular_Grey_400x400.webm`,
              lg`Smoke/SmokePuffSide01_03_Regular_Grey_400x400.webm`,
              lg`Smoke/SmokePuffSide01_04_Regular_Grey_400x400.webm`,
              lg`Smoke/SmokePuffSide01_05_Regular_Grey_400x400.webm`
            ]
          },
          "02": {
            _free: ["white"],
            black: [
              lg`Smoke/SmokePuffSide02_01_Dark_Black_400x400.webm`,
              lg`Smoke/SmokePuffSide02_02_Dark_Black_400x400.webm`,
              lg`Smoke/SmokePuffSide02_03_Dark_Black_400x400.webm`
            ],
            white: [
              lg`Smoke/SmokePuffSide02_01_Regular_White_400x400.webm`,
              lg`Smoke/SmokePuffSide02_02_Regular_White_400x400.webm`,
              lg`Smoke/SmokePuffSide02_03_Regular_White_400x400.webm`
            ]
          }
        }
      },
      smoke: {
        _free: ["plume"],
        plume: {
          _free: ["complete"],
          complete: {
            _markers: {
              loop: { start: 2e3, end: 4e3 }
            },
            _free: ["grey", "_markers"],
            blue: [
              lg`Smoke/SmokePlumes01_01_Regular_Blue_400x400.webm`,
              lg`Smoke/SmokePlumes01_02_Regular_Blue_400x400.webm`,
              lg`Smoke/SmokePlumes01_03_Regular_Blue_400x400.webm`
            ],
            darkgreen: [
              lg`Smoke/SmokePlumes01_01_Dark_Green_400x400.webm`,
              lg`Smoke/SmokePlumes01_02_Dark_Green_400x400.webm`,
              lg`Smoke/SmokePlumes01_03_Dark_Green_400x400.webm`
            ],
            darkred: [
              lg`Smoke/SmokePlumes01_01_Dark_Red_400x400.webm`,
              lg`Smoke/SmokePlumes01_02_Dark_Red_400x400.webm`,
              lg`Smoke/SmokePlumes01_03_Dark_Red_400x400.webm`
            ],
            grey: [
              lg`Smoke/SmokePlumes01_01_Regular_Grey_400x400.webm`,
              lg`Smoke/SmokePlumes01_02_Regular_Grey_400x400.webm`,
              lg`Smoke/SmokePlumes01_03_Regular_Grey_400x400.webm`
            ],
            purple: [
              lg`Smoke/SmokePlumes01_01_Regular_Purple_400x400.webm`,
              lg`Smoke/SmokePlumes01_02_Regular_Purple_400x400.webm`,
              lg`Smoke/SmokePlumes01_03_Regular_Purple_400x400.webm`
            ],
            yellow: [
              lg`Smoke/SmokePlumes01_01_Regular_Yellow_400x400.webm`,
              lg`Smoke/SmokePlumes01_02_Regular_Yellow_400x400.webm`,
              lg`Smoke/SmokePlumes01_03_Regular_Yellow_400x400.webm`
            ]
          }
        }
      },
      spell: {
        moonbeam: {
          loop: {
            yellow: [l2`Moonbeam/Moonbeam_01_Regular_Yellow_400x400.webm`]
          },
          intro: {
            yellow: [l2`Moonbeam/MoonbeamIntro_01_Regular_Yellow_400x400.webm`]
          },
          outro: {
            yellow: [l2`Moonbeam/MoonbeamOutro_01_Regular_Yellow_400x400.webm`]
          },
          complete: {
            blue: [l2`Moonbeam/MoonbeamComplete_01_Regular_Blue_400x400.webm`],
            green: [l2`Moonbeam/MoonbeamComplete_01_Regular_Green_400x400.webm`],
            rainbow: [l2`Moonbeam/MoonbeamComplete_01_Regular_Rainbow_400x400.webm`],
            yellow: [l2`Moonbeam/MoonbeamComplete_01_Regular_Yellow_400x400.webm`]
          }
        },
        curewounds: {
          "01": {
            yellow: [l1`Cure_Wounds/CureWounds_01_Yellow_400x400.webm`]
          }
        },
        detectmagic: {
          "01": {
            yellow: [l1`Detect_Magic/DetectMagicCircle_01_Regular_Yellow_1200x1200.webm`]
          }
        },
        tollthedead: {
          bell: {
            yellow: [l0`Toll_The_Dead/TollTheDeadBell_01_Regular_Yellow_400x400.webm`]
          },
          complete: {
            yellow: [l0`Toll_The_Dead/TollTheDead_01_Regular_Yellow_400x400.webm`]
          },
          shockwave: {
            yellow: [l0`Toll_The_Dead/TollTheDeadShockwave_01_Regular_Yellow_400x400.webm`]
          },
          skull: {
            yellow: [l0`Toll_The_Dead/TollTheDeadSkullSmoke_01_Regular_Yellow_400x400.webm`]
          }
        }
      }
    }
  };
  return patreonDB053;
}
async function db054(path) {
  const BASE = `${path}/Library/`;
  const prefix = (str) => (strs, ...exprs) => `${BASE}${str}/${strs.reduce((a, c, i) => a + exprs[i - 1] + c)}`;
  const l1 = prefix("1st_Level");
  const l2 = prefix("2nd_Level");
  const l3 = prefix("3rd_Level");
  const lg = prefix("Generic");
  const patreonDB054 = {
    range: {
      _template: "ranged",
      _free: ["generic"],
      spell: {
        fireballbeam: {
          "01": {
            darkred: {
              "05ft": [l3`Fireball/FireballBeam_01_Dark_Red_05ft_600x400.webm`],
              "15ft": [l3`Fireball/FireballBeam_01_Dark_Red_15ft_1000x400.webm`],
              "30ft": [l3`Fireball/FireballBeam_01_Dark_Red_30ft_1600x400.webm`],
              "60ft": [l3`Fireball/FireballBeam_01_Dark_Red_60ft_2800x400.webm`],
              "90ft": [l3`Fireball/FireballBeam_01_Dark_Red_90ft_4000x400.webm`]
            }
          }
        }
      },
      generic: {
        _free: ["energywall"],
        energywall: {
          _free: ["loop", "complete"],
          loop: {
            _free: ["orange"],
            blue: {
              "05ft": [lg`Energy/EnergyWall01_01_Regular_Blue_05x05ft_Loop_400x400.webm`],
              "10ft": [lg`Energy/EnergyWall01_01_Regular_Blue_10x05ft_Loop_800x400.webm`],
              "15ft": [lg`Energy/EnergyWall01_01_Regular_Blue_15x05ft_Loop_1000x400.webm`],
              "25ft": [lg`Energy/EnergyWall01_01_Regular_Blue_25x05ft_Loop_1400x400.webm`]
            },
            green: {
              "05ft": [lg`Energy/EnergyWall01_01_Regular_Green_05x05ft_Loop_400x400.webm`],
              "10ft": [lg`Energy/EnergyWall01_01_Regular_Green_10x05ft_Loop_800x400.webm`],
              "15ft": [lg`Energy/EnergyWall01_01_Regular_Green_15x05ft_Loop_1000x400.webm`],
              "25ft": [lg`Energy/EnergyWall01_01_Regular_Green_25x05ft_Loop_1400x400.webm`]
            },
            orange: {
              "05ft": [lg`Energy/EnergyWall01_01_Regular_Orange_05x05ft_Loop_400x400.webm`],
              "10ft": [lg`Energy/EnergyWall01_01_Regular_Orange_10x05ft_Loop_800x400.webm`],
              "15ft": [lg`Energy/EnergyWall01_01_Regular_Orange_15x05ft_Loop_1000x400.webm`],
              "25ft": [lg`Energy/EnergyWall01_01_Regular_Orange_25x05ft_Loop_1400x400.webm`]
            },
            purple: {
              "05ft": [lg`Energy/EnergyWall01_01_Regular_Purple_05x05ft_Loop_400x400.webm`],
              "10ft": [lg`Energy/EnergyWall01_01_Regular_Purple_10x05ft_Loop_800x400.webm`],
              "15ft": [lg`Energy/EnergyWall01_01_Regular_Purple_15x05ft_Loop_1000x400.webm`],
              "25ft": [lg`Energy/EnergyWall01_01_Regular_Purple_25x05ft_Loop_1400x400.webm`]
            },
            red: {
              "05ft": [lg`Energy/EnergyWall01_01_Regular_Red_05x05ft_Loop_400x400.webm`],
              "10ft": [lg`Energy/EnergyWall01_01_Regular_Red_10x05ft_Loop_800x400.webm`],
              "15ft": [lg`Energy/EnergyWall01_01_Regular_Red_15x05ft_Loop_1000x400.webm`],
              "25ft": [lg`Energy/EnergyWall01_01_Regular_Red_25x05ft_Loop_1400x400.webm`]
            }
          },
          complete: {
            _free: ["orange"],
            blue: {
              "05ft": [lg`Energy/EnergyWall01_01_Regular_Blue_05x05ft_Complete_400x400.webm`],
              "10ft": [lg`Energy/EnergyWall01_01_Regular_Blue_10x05ft_Complete_800x400.webm`],
              "15ft": [lg`Energy/EnergyWall01_01_Regular_Blue_15x05ft_Complete_1000x400.webm`],
              "25ft": [lg`Energy/EnergyWall01_01_Regular_Blue_25x05ft_Complete_1400x400.webm`]
            },
            green: {
              "05ft": [lg`Energy/EnergyWall01_01_Regular_Green_05x05ft_Complete_400x400.webm`],
              "10ft": [lg`Energy/EnergyWall01_01_Regular_Green_10x05ft_Complete_800x400.webm`],
              "15ft": [lg`Energy/EnergyWall01_01_Regular_Green_15x05ft_Complete_1000x400.webm`],
              "25ft": [lg`Energy/EnergyWall01_01_Regular_Green_25x05ft_Complete_1400x400.webm`]
            },
            orange: {
              "05ft": [lg`Energy/EnergyWall01_01_Regular_Orange_05x05ft_Complete_400x400.webm`],
              "10ft": [lg`Energy/EnergyWall01_01_Regular_Orange_10x05ft_Complete_800x400.webm`],
              "15ft": [lg`Energy/EnergyWall01_01_Regular_Orange_15x05ft_Complete_1000x400.webm`],
              "25ft": [lg`Energy/EnergyWall01_01_Regular_Orange_25x05ft_Complete_1400x400.webm`]
            },
            purple: {
              "05ft": [lg`Energy/EnergyWall01_01_Regular_Purple_05x05ft_Complete_400x400.webm`],
              "10ft": [lg`Energy/EnergyWall01_01_Regular_Purple_10x05ft_Complete_800x400.webm`],
              "15ft": [lg`Energy/EnergyWall01_01_Regular_Purple_15x05ft_Complete_1000x400.webm`],
              "25ft": [lg`Energy/EnergyWall01_01_Regular_Purple_25x05ft_Complete_1400x400.webm`]
            },
            red: {
              "05ft": [lg`Energy/EnergyWall01_01_Regular_Red_05x05ft_Complete_400x400.webm`],
              "10ft": [lg`Energy/EnergyWall01_01_Regular_Red_10x05ft_Complete_800x400.webm`],
              "15ft": [lg`Energy/EnergyWall01_01_Regular_Red_15x05ft_Complete_1000x400.webm`],
              "25ft": [lg`Energy/EnergyWall01_01_Regular_Red_25x05ft_Complete_1400x400.webm`]
            }
          }
        }
      }
    },
    templatefx: {
      _free: ["circle"],
      circle: {
        _free: ["energy"],
        detectmagic: {
          "01": {
            darkred: [l1`Detect_Magic/DetectMagicCircle_01_Dark_Red_1200x1200.webm`]
          }
        },
        energy: {
          _free: ["loop", "complete"],
          loop: {
            _free: ["orange"],
            blue: [lg`Energy/EnergyWall01_01_Regular_Blue_Circle_Loop_900x900.webm`],
            green: [lg`Energy/EnergyWall01_01_Regular_Green_Circle_Loop_900x900.webm`],
            orange: [lg`Energy/EnergyWall01_01_Regular_Orange_Circle_Loop_900x900.webm`],
            purple: [lg`Energy/EnergyWall01_01_Regular_Purple_Circle_Loop_900x900.webm`],
            red: [lg`Energy/EnergyWall01_01_Regular_Red_Circle_Loop_900x900.webm`]
          },
          complete: {
            _free: ["orange", "_markers"],
            _markers: {
              loop: { start: 700, end: 3333 }
            },
            blue: [lg`Energy/EnergyWall01_01_Regular_Blue_Circle_Complete_900x900.webm`],
            green: [lg`Energy/EnergyWall01_01_Regular_Green_Circle_Complete_900x900.webm`],
            orange: [lg`Energy/EnergyWall01_01_Regular_Orange_Circle_Complete_900x900.webm`],
            purple: [lg`Energy/EnergyWall01_01_Regular_Purple_Circle_Complete_900x900.webm`],
            red: [lg`Energy/EnergyWall01_01_Regular_Red_Circle_Complete_900x900.webm`]
          }
        },
        fireball: {
          loop: {
            darkred: [l3`Fireball/FireballLoop_01_Dark_Red_800x800.webm`]
          },
          explode: {
            darkred: [l3`Fireball/FireballExplosion_01_Dark_Red_800x800.webm`]
          },
          nodebris: {
            darkred: [l3`Fireball/FireballLoopNoDebris_01_Dark_Red_800x800.webm`]
          }
        }
      },
      cone: {
        breathweaponspray01: {
          burst: {
            black: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Arcana01_Dark_Black_Cone_Burst_800x800.webm`]
          },
          loop: {
            black: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Arcana01_Dark_Black_Cone_Loop_800x800.webm`]
          }
        },
        breathweaponspray02: {
          burst: {
            black: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Arcana02_Dark_Black_Cone_Burst_800x800.webm`]
          },
          loop: {
            black: [lg`Template/Cone/Breath_Weapon/Breathweapon02_Arcana02_Dark_Black_Cone_Loop_800x800.webm`]
          }
        },
        detectmagic: {
          "01": {
            darkred: [l1`Detect_Magic/DetectMagicCone_01_Dark_Red_15ft_500x500.webm`]
          }
        }
      },
      ray: {
        breathweaponspray01: {
          burst: {
            black: [lg`Template/Line/Breath_Weapon/Breathweapon02_Arcana01_Dark_Black_Line_Burst_1200x400.webm`]
          },
          loop: {
            black: [lg`Template/Line/Breath_Weapon/Breathweapon02_Arcana01_Dark_Black_Line_Loop_1200x400.webm`]
          }
        }
      }
    },
    static: {
      _free: ["energy", "magicsign"],
      conditions: {
        skull: {
          "01": {
            darkred: [lg`Marker/MarkerSkull_01_Dark_Red_400x400.webm`]
          },
          "02": {
            darkred: [lg`Marker/MarkerSkull_02_Dark_Red_400x400.webm`]
          },
          "03": {
            darkred: [lg`Marker/MarkerSkull_03_Dark_Red_400x400.webm`]
          }
        }
      },
      energy: {
        _free: ["circle"],
        circle: {
          _free: ["loop", "complete"],
          loop: {
            _free: ["orange"],
            blue: [lg`Energy/EnergyWall01_01_Regular_Blue_Circle_Loop_500x500.webm`],
            green: [lg`Energy/EnergyWall01_01_Regular_Green_Circle_Loop_500x500.webm`],
            orange: [lg`Energy/EnergyWall01_01_Regular_Orange_Circle_Loop_500x500.webm`],
            purple: [lg`Energy/EnergyWall01_01_Regular_Purple_Circle_Loop_500x500.webm`],
            red: [lg`Energy/EnergyWall01_01_Regular_Red_Circle_Loop_500x500.webm`]
          },
          complete: {
            _free: ["orange"],
            blue: [lg`Energy/EnergyWall01_01_Regular_Blue_Circle_Complete_500x500.webm`],
            green: [lg`Energy/EnergyWall01_01_Regular_Green_Circle_Complete_500x500.webm`],
            orange: [lg`Energy/EnergyWall01_01_Regular_Orange_Circle_Complete_500x500.webm`],
            purple: [lg`Energy/EnergyWall01_01_Regular_Purple_Circle_Complete_500x500.webm`],
            red: [lg`Energy/EnergyWall01_01_Regular_Red_Circle_Complete_500x500.webm`]
          }
        }
      },
      fire: {
        groundcrack: {
          "01": {
            darkred: [lg`Fire/GroundCrackLoop_01_Dark_Red_600x600.webm`]
          },
          "02": {
            darkred: [lg`Fire/GroundCrackLoop_02_Dark_Red_600x600.webm`]
          },
          "03": {
            darkred: [lg`Fire/GroundCrackLoop_03_Dark_Red_600x600.webm`]
          }
        }
      },
      generic: {
        ui: {
          skull: {
            darkred: [lg`UI/IconSkull_01_Dark_Red_200x200.webm`]
          }
        }
      },
      lightning: {
        strike: {
          "01": {
            red: [
              lg`Lightning/LightningStrike01_01_Regular_Red_800x800.webm`,
              lg`Lightning/LightningStrike01_02_Regular_Red_800x800.webm`,
              lg`Lightning/LightningStrike01_03_Regular_Red_800x800.webm`,
              lg`Lightning/LightningStrike01_04_Regular_Red_800x800.webm`,
              lg`Lightning/LightningStrike01_05_Regular_Red_800x800.webm`,
              lg`Lightning/LightningStrike01_06_Regular_Red_800x800.webm`
            ]
          }
        }
      },
      magicsign: {
        _free: [
          "abjuration",
          "conjuration",
          "divination",
          "enchantment",
          "evocation",
          "illusion",
          "necromancy",
          "transmutation"
        ],
        abjuration: {
          _free: ["runecomplete"],
          runecomplete: {
            _free: ["blue"],
            blue: [lg`Magic_Signs/Runes/AbjurationRuneComplete_01_Regular_Blue_400x400.webm`],
            green: [lg`Magic_Signs/Runes/AbjurationRuneComplete_01_Regular_Green_400x400.webm`],
            pink: [lg`Magic_Signs/Runes/AbjurationRuneComplete_01_Regular_Pink_400x400.webm`],
            purple: [lg`Magic_Signs/Runes/AbjurationRuneComplete_01_Regular_Purple_400x400.webm`],
            red: [lg`Magic_Signs/Runes/AbjurationRuneComplete_01_Regular_Red_400x400.webm`],
            yellow: [lg`Magic_Signs/Runes/AbjurationRuneComplete_01_Regular_Yellow_400x400.webm`]
          }
        },
        conjuration: {
          _free: ["runecomplete"],
          runecomplete: {
            _free: ["yellow"],
            blue: [lg`Magic_Signs/Runes/ConjurationRuneComplete_01_Regular_Blue_400x400.webm`],
            green: [lg`Magic_Signs/Runes/ConjurationRuneComplete_01_Regular_Green_400x400.webm`],
            pink: [lg`Magic_Signs/Runes/ConjurationRuneComplete_01_Regular_Pink_400x400.webm`],
            purple: [lg`Magic_Signs/Runes/ConjurationRuneComplete_01_Regular_Purple_400x400.webm`],
            red: [lg`Magic_Signs/Runes/ConjurationRuneComplete_01_Regular_Red_400x400.webm`],
            yellow: [lg`Magic_Signs/Runes/ConjurationRuneComplete_01_Regular_Yellow_400x400.webm`]
          }
        },
        divination: {
          _free: ["runecomplete"],
          runecomplete: {
            _free: ["blue"],
            blue: [lg`Magic_Signs/Runes/DivinationRuneComplete_01_Regular_Blue_400x400.webm`],
            green: [lg`Magic_Signs/Runes/DivinationRuneComplete_01_Regular_Green_400x400.webm`],
            pink: [lg`Magic_Signs/Runes/DivinationRuneComplete_01_Regular_Pink_400x400.webm`],
            purple: [lg`Magic_Signs/Runes/DivinationRuneComplete_01_Regular_Purple_400x400.webm`],
            red: [lg`Magic_Signs/Runes/DivinationRuneComplete_01_Regular_Red_400x400.webm`],
            yellow: [lg`Magic_Signs/Runes/DivinationRuneComplete_01_Regular_Yellow_400x400.webm`]
          }
        },
        enchantment: {
          _free: ["runecomplete"],
          runecomplete: {
            _free: ["pink"],
            blue: [lg`Magic_Signs/Runes/EnchantmentRuneComplete_01_Regular_Blue_400x400.webm`],
            green: [lg`Magic_Signs/Runes/EnchantmentRuneComplete_01_Regular_Green_400x400.webm`],
            pink: [lg`Magic_Signs/Runes/EnchantmentRuneComplete_01_Regular_Pink_400x400.webm`],
            purple: [lg`Magic_Signs/Runes/EnchantmentRuneComplete_01_Regular_Purple_400x400.webm`],
            red: [lg`Magic_Signs/Runes/EnchantmentRuneComplete_01_Regular_Red_400x400.webm`],
            yellow: [lg`Magic_Signs/Runes/EnchantmentRuneComplete_01_Regular_Yellow_400x400.webm`]
          }
        },
        evocation: {
          _free: ["runecomplete"],
          runecomplete: {
            _free: ["red"],
            blue: [lg`Magic_Signs/Runes/EvocationRuneComplete_01_Regular_Blue_400x400.webm`],
            green: [lg`Magic_Signs/Runes/EvocationRuneComplete_01_Regular_Green_400x400.webm`],
            pink: [lg`Magic_Signs/Runes/EvocationRuneComplete_01_Regular_Pink_400x400.webm`],
            purple: [lg`Magic_Signs/Runes/EvocationRuneComplete_01_Regular_Purple_400x400.webm`],
            red: [lg`Magic_Signs/Runes/EvocationRuneComplete_01_Regular_Red_400x400.webm`],
            yellow: [lg`Magic_Signs/Runes/EvocationRuneComplete_01_Regular_Yellow_400x400.webm`]
          }
        },
        illusion: {
          _free: ["runecomplete"],
          runecomplete: {
            _free: ["purple"],
            blue: [lg`Magic_Signs/Runes/IllusionRuneComplete_01_Regular_Blue_400x400.webm`],
            green: [lg`Magic_Signs/Runes/IllusionRuneComplete_01_Regular_Green_400x400.webm`],
            pink: [lg`Magic_Signs/Runes/IllusionRuneComplete_01_Regular_Pink_400x400.webm`],
            purple: [lg`Magic_Signs/Runes/IllusionRuneComplete_01_Regular_Purple_400x400.webm`],
            red: [lg`Magic_Signs/Runes/IllusionRuneComplete_01_Regular_Red_400x400.webm`],
            yellow: [lg`Magic_Signs/Runes/IllusionRuneComplete_01_Regular_Yellow_400x400.webm`]
          }
        },
        necromancy: {
          _free: ["runecomplete"],
          runecomplete: {
            _free: ["green"],
            blue: [lg`Magic_Signs/Runes/NecromancyRuneComplete_01_Regular_Blue_400x400.webm`],
            green: [lg`Magic_Signs/Runes/NecromancyRuneComplete_01_Regular_Green_400x400.webm`],
            pink: [lg`Magic_Signs/Runes/NecromancyRuneComplete_01_Regular_Pink_400x400.webm`],
            purple: [lg`Magic_Signs/Runes/NecromancyRuneComplete_01_Regular_Purple_400x400.webm`],
            red: [lg`Magic_Signs/Runes/NecromancyRuneComplete_01_Regular_Red_400x400.webm`],
            yellow: [lg`Magic_Signs/Runes/NecromancyRuneComplete_01_Regular_Yellow_400x400.webm`]
          }
        },
        transmutation: {
          _free: ["runecomplete"],
          runecomplete: {
            _free: ["yellow"],
            blue: [lg`Magic_Signs/Runes/TransmutationRuneComplete_01_Regular_Blue_400x400.webm`],
            green: [lg`Magic_Signs/Runes/TransmutationRuneComplete_01_Regular_Green_400x400.webm`],
            pink: [lg`Magic_Signs/RunesTransmutationRuneComplete_01_Regular_Pink_400x400.webm`],
            purple: [lg`Magic_Signs/Runes/TransmutationRuneComplete_01_Regular_Purple_400x400.webm`],
            red: [lg`Magic_Signs/Runes/TransmutationRuneComplete_01_Regular_Red_400x400.webm`],
            yellow: [lg`Magic_Signs/Runes/TransmutationRuneComplete_01_Regular_Yellow_400x400.webm`]
          }
        }
      },
      shieldfx: {
        fire: {
          "01": {
            blue: [lg`Fire/ShieldFireAbove01_01_Regular_Blue_400x400.webm`],
            purple: [lg`Fire/ShieldFireAbove01_01_Regular_Purple_400x400.webm`]
          },
          "03": {
            blue: [lg`Fire/ShieldFireAbove01_03_Regular_Blue_400x400.webm`],
            purple: [lg`Fire/ShieldFireAbove01_03_Regular_Purple_400x400.webm`]
          }
        }
      },
      spell: {
        mistystep: {
          "01": {
            pink: [l2`Misty_Step/MistyStep_01_Regular_Pink_400x400.webm`]
          },
          "02": {
            pink: [l2`Misty_Step/MistyStep_02_Regular_Pink_400x400.webm`]
          }
        },
        shatter: {
          "01": {
            darkred: [l2`Shatter/Shatter_01_Dark_Red_400x400.webm`]
          }
        }
      }
    }
  };
  return patreonDB054;
}
const dbMerge = {
  async handle(freeVersion, patreonVersion, s3Location) {
    const freePath = s3Location ? s3Location : "modules/JB2A_DnD5e";
    const patreonPath = s3Location ? s3Location : "modules/jb2a_patreon";
    if (patreonVersion) {
      for (let [version, migration] of Object.entries(this.migrations)) {
        if (!isNewerVersion(patreonVersion, version)) {
          if (patreonVersion === version) {
            await migration(patreonPath, true);
            break;
          } else {
            break;
          }
        }
        await migration(patreonPath, true);
      }
    }
    if (freeVersion) {
      for (let [version, migration] of Object.entries(this.migrations)) {
        if (isNewerVersion(patreonVersion, version)) {
          continue;
        }
        if (patreonVersion === version) {
          continue;
        }
        if (!isNewerVersion(freeVersion, version)) {
          if (freeVersion === version) {
            await migration(freePath);
            break;
          } else {
            break;
          }
        }
        await migration(freePath);
      }
    }
    return;
  },
  migrations: {
    "0.4.7": async (path, isPatreon = false) => {
      let db047$1 = await db047(path);
      await sortDatabase(db047$1, isPatreon);
      foundry.utils.mergeObject(aaDatabase$1, db047$1);
    },
    "0.4.8": async (path, isPatreon = false) => {
      let db048$1 = await db048(path);
      await sortDatabase(db048$1, isPatreon);
      foundry.utils.mergeObject(aaDatabase$1, db048$1);
    },
    "0.4.9": async (path, isPatreon = false) => {
      let db049$1 = await db049(path);
      await sortDatabase(db049$1, isPatreon);
      foundry.utils.mergeObject(aaDatabase$1, db049$1);
    },
    "0.5.0": async (path, isPatreon = false) => {
      let db050$1 = await db050(path);
      await sortDatabase(db050$1, isPatreon);
      foundry.utils.mergeObject(aaDatabase$1, db050$1);
    },
    "0.5.1": async (path, isPatreon = false) => {
      let db051$1 = await db051(path);
      await sortDatabase(db051$1, isPatreon);
      foundry.utils.mergeObject(aaDatabase$1, db051$1);
    },
    "0.5.2": async (path, isPatreon = false) => {
      let db052$1 = await db052(path);
      await sortDatabase(db052$1, isPatreon);
      foundry.utils.mergeObject(aaDatabase$1, db052$1);
    },
    "0.5.3": async (path, isPatreon = false) => {
      let db053$1 = await db053(path);
      await sortDatabase(db053$1, isPatreon);
      foundry.utils.mergeObject(aaDatabase$1, db053$1);
    },
    "0.5.4": async (path, isPatreon = false) => {
      let db054$1 = await db054(path);
      await sortDatabase(db054$1, isPatreon);
      foundry.utils.mergeObject(aaDatabase$1, db054$1);
    }
  }
};
function debug$1(...args) {
  if (game.settings.get("autoanimations", "debug")) {
    console.log(`DEBUG | Automated Animations |`, ...args);
  }
}
function custom_notify(message, consoleLog = false) {
  message = `Automated Animations | ${message}`;
  if (consoleLog) {
    console.log(`%c${message.replace("<br>", "\n")}`, "color: orange");
  } else {
    ui.notifications.notify(message);
  }
}
function custom_warning(warning, notify = false, ...args) {
  warning = `Automated Animations | ${warning}`;
  if (notify) {
    ui.notifications.warn(warning);
  }
  console.warn(warning.replace("<br>", "\n"), ...args);
}
function custom_error$1(error, notify = true) {
  error = `Automated Animations | ${error}`;
  if (notify) {
    ui.notifications.error(error);
  }
  return new Error(error.replace("<br>", "\n"));
}
function howToDelete(type) {
  if (game.settings.get("autoanimations", "noTips")) {
    return;
  }
  let disableTips = "You can disabled these tips in the Automated Animations module settings";
  switch (type) {
    case "overheadtile":
      custom_notify(`This is an OVERHEAD Tile. Use the Tile Foreground Layer to remove the Animation. ${disableTips}`);
      break;
    case "groundtile":
      custom_notify(`This is an GROUND Tile. Use the Tile Layer to remove the Animation. ${disableTips}`);
      break;
    case "sequencerground":
      custom_notify(`This is a SEQUENCER Persistent Effect. Use the Sequencer Effect Manager to remove the Animation. ${disableTips}`);
      break;
  }
}
let aaDatabase$1;
async function initializeAADB() {
  const freePath = "modules/JB2A_DnD5e";
  const patreonPath = "modules/jb2a_patreon";
  let s3Location = game.settings.get("autoanimations", "jb2aLocation");
  const jb2aFreeFound = game.modules.get("JB2A_DnD5e");
  const jb2aPatreonFound = game.modules.get("jb2a_patreon");
  if (game.user.isGM && (!jb2aFreeFound && !jb2aPatreonFound)) {
    if (s3Location && (s3Location.includes("jb2a_patreon") || s3Location.includes("JB2A_DnD5e")))
      ;
    else {
      ui.notifications.error(game.i18n.format("autoanimations.settings.error"));
    }
  }
  const freeVersion = jb2aFreeFound?.version ?? "";
  const patreonVersion = jb2aPatreonFound?.version ?? "";
  if (s3Location) {
    if (s3Location.includes("patreon")) {
      await initializeJB2APatreonDB(s3Location);
      aaDatabase$1 = JB2APATREONDB;
      await dbMerge.handle("", patreonVersion, s3Location);
    } else if (s3Location.includes("JB2A_DnD5e")) {
      await initializeJB2AFreeDB(s3Location);
      aaDatabase$1 = JB2AFREEDB;
      await dbMerge.handle(freeVersion, "", s3Location);
    } else {
      await initializeJB2APatreonDB(s3Location);
      aaDatabase$1 = JB2APATREONDB;
      custom_error$1("You have specified an External path (S3 Bucket or other) incorrectly. Check your Automated Animations module settings", true);
    }
  } else if (!patreonVersion && !freeVersion) {
    await initializeJB2AFreeDB(freePath);
    custom_error$1("You do not have a JB2A module installed, Autmoated Animation Select menus will NOT work", true);
  } else {
    if (jb2aPatreonFound) {
      await initializeJB2APatreonDB(patreonPath);
      aaDatabase$1 = JB2APATREONDB;
    } else {
      await initializeJB2AFreeDB(freePath);
      aaDatabase$1 = JB2AFREEDB;
    }
    await dbMerge.handle(freeVersion, patreonVersion);
  }
  Sequencer.Database.registerEntries("autoanimations", aaDatabase$1, true);
  console.log("%cAutomated Animations Database has been compiled and registered", "color: green", { aaDatabase: aaDatabase$1 });
  Hooks.callAll("aa.ready", aaDatabase$1);
}
async function sortDatabase(database, isPatreon = false) {
  if (isPatreon) {
    return await removeFreeMarker(database);
  } else {
    await removePatreonContent();
  }
  return database;
  async function removePatreonContent() {
    let sections = Object.keys(database);
    for (let section2 of sections) {
      if (section2 === "_templates") {
        continue;
      }
      let freeOptions = database[section2]._free;
      if (!freeOptions) {
        continue;
      }
      await removePatreonTypes(freeOptions, section2);
      let types = Object.keys(database[section2]);
      for (let type of types) {
        if (type === "_template") {
          continue;
        }
        let freeOptions2 = database[section2][type]._free;
        if (!freeOptions2) {
          continue;
        }
        await removePatreonAnimations(freeOptions2, section2, type);
        let animations = Object.keys(database[section2][type]);
        for (let animation of animations) {
          let freeOptions3 = database[section2][type][animation]._free;
          if (!freeOptions3) {
            continue;
          }
          await removePatreonVariants(freeOptions3, section2, type, animation);
          let variants = Object.keys(database[section2][type][animation]);
          for (let variant of variants) {
            let freeOptions4 = database[section2][type][animation][variant]._free;
            if (!freeOptions4) {
              continue;
            }
            await removePatreonColors(freeOptions4, section2, type, animation, variant);
          }
        }
      }
    }
  }
  async function removePatreonTypes(freeOptions, section2) {
    let types = Object.keys(database[section2]);
    for (let i = 0; i < types.length; i++) {
      let typeFound = freeOptions.indexOf(types[i]);
      if (typeFound === -1) {
        delete database[section2][types[i]];
      }
    }
  }
  async function removePatreonAnimations(freeOptions, section2, type) {
    let animations = Object.keys(database[section2][type]);
    for (let i = 0; i < animations.length; i++) {
      let animationFound = freeOptions.indexOf(animations[i]);
      if (animationFound === -1) {
        delete database[section2][type][animations[i]];
      }
    }
  }
  async function removePatreonVariants(freeOptions, section2, type, animation) {
    let variants = Object.keys(database[section2][type][animation]);
    for (let i = 0; i < variants.length; i++) {
      let variantFound = freeOptions.indexOf(variants[i]);
      if (variantFound === -1) {
        delete database[section2][type][animation][variants[i]];
      }
    }
  }
  async function removePatreonColors(freeOptions, section2, type, animation, variant) {
    let colors = Object.keys(database[section2][type][animation][variant]);
    for (let i = 0; i < colors.length; i++) {
      let colorFound = freeOptions.indexOf(colors[i]);
      if (colorFound === -1) {
        delete database[section2][type][animation][variant][colors[i]];
      }
    }
  }
}
async function removeFreeMarker(database) {
  await deleteFreeMarker();
  return database;
  async function deleteFreeMarker() {
    let sections = Object.keys(database);
    for (let section2 of sections) {
      if (section2 === "_templates") {
        continue;
      }
      await removePatreonType(section2);
      let types = Object.keys(database[section2]);
      for (let type of types) {
        if (type === "_template") {
          continue;
        }
        await removePatreonAnimation(section2, type);
        let animations = Object.keys(database[section2][type]);
        for (let animation of animations) {
          await removePatreonVariant(section2, type, animation);
          let variants = Object.keys(database[section2][type][animation]);
          for (let variant of variants) {
            await removePatreonColor(section2, type, animation, variant);
          }
        }
      }
    }
  }
  async function removePatreonType(section2) {
    let types = Object.keys(database[section2]);
    for (let i = 0; i < types.length; i++) {
      delete database[section2]._free;
    }
  }
  async function removePatreonAnimation(section2, type) {
    let animations = Object.keys(database[section2][type]);
    for (let i = 0; i < animations.length; i++) {
      delete database[section2][type]._free;
    }
  }
  async function removePatreonVariant(section2, type, animation) {
    let variants = Object.keys(database[section2][type][animation]);
    for (let i = 0; i < variants.length; i++) {
      delete database[section2][type][animation]._free;
    }
  }
  async function removePatreonColor(section2, type, animation, variant) {
    let colors = Object.keys(database[section2][type][animation][variant]);
    for (let i = 0; i < colors.length; i++) {
      delete database[section2][type][animation][variant]._free;
    }
  }
}
function noop() {
}
const identity = (x) => x;
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj2) {
  return Object.keys(obj2).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
const is_client = typeof window !== "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
const globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function append(target2, node) {
  target2.appendChild(node);
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target2, node, anchor) {
  target2.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data2) {
  return document.createTextNode(data2);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options2) {
  node.addEventListener(event, handler, options2);
  return () => node.removeEventListener(event, handler, options2);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
const always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data2) {
  data2 = "" + data2;
  if (text2.data === data2)
    return;
  text2.data = data2;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
class HtmlTag {
  constructor(is_svg = false) {
    this.is_svg = false;
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  c(html) {
    this.h(html);
  }
  m(html, target2, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(target2.nodeName);
      else
        this.e = element(target2.nodeType === 11 ? "TEMPLATE" : target2.nodeName);
      this.t = target2.tagName !== "TEMPLATE" ? target2 : target2.content;
      this.c(html);
    }
    this.i(anchor);
  }
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes);
  }
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
}
function construct_svelte_component(component, props) {
  return new component(props);
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
function create_animation(node, from, fn, params) {
  if (!from)
    return noop;
  const to = node.getBoundingClientRect();
  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
    return noop;
  const {
    delay = 0,
    duration = 300,
    easing = identity,
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay,
    // @ts-ignore todo:
    end = start_time + duration,
    tick: tick2 = noop,
    css
  } = fn(node, { from, to }, params);
  let running = true;
  let started = false;
  let name;
  function start() {
    if (css) {
      name = create_rule(node, 0, 1, duration, delay, easing, css);
    }
    if (!delay) {
      started = true;
    }
  }
  function stop() {
    if (css)
      delete_rule(node, name);
    running = false;
  }
  loop((now2) => {
    if (!started && now2 >= start_time) {
      started = true;
    }
    if (started && now2 >= end) {
      tick2(1, 0);
      stop();
    }
    if (!running) {
      return false;
    }
    if (started) {
      const p = now2 - start_time;
      const t = 0 + 1 * easing(p / duration);
      tick2(t, 1 - t);
    }
    return true;
  });
  start();
  tick2(0, 1);
  return stop;
}
function fix_position(node) {
  const style = getComputedStyle(node);
  if (style.position !== "absolute" && style.position !== "fixed") {
    const { width, height } = style;
    const a = node.getBoundingClientRect();
    node.style.position = "absolute";
    node.style.width = width;
    node.style.height = height;
    add_transform(node, a);
  }
}
function add_transform(node, a) {
  const b = node.getBoundingClientRect();
  if (a.left !== b.left || a.top !== b.top) {
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
  }
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets2 = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets2.push(c));
  targets2.forEach((c) => c());
  render_callbacks = filtered;
}
let promise;
function wait$4() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
  const options2 = { direction: "in" };
  let config = fn(node, params, options2);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick2(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(t, 1 - t);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function(config)) {
        config = config(options2);
        wait$4().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_out_transition(node, fn, params) {
  const options2 = { direction: "out" };
  let config = fn(node, params, options2);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch(node, false, "start"));
    loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(0, 1);
          dispatch(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(1 - t, t);
        }
      }
      return running;
    });
  }
  if (is_function(config)) {
    wait$4().then(() => {
      config = config(options2);
      go();
    });
  } else {
    go();
  }
  return {
    end(reset) {
      if (reset && config.tick) {
        config.tick(1, 0);
      }
      if (running) {
        if (animation_name)
          delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
function create_bidirectional_transition(node, fn, params, intro) {
  const options2 = { direction: "both" };
  let config = fn(node, params, options2);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = program.b - t;
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait$4().then(() => {
          config = config(options2);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function fix_and_outro_and_destroy_block(block, lookup) {
  block.f();
  outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function debug(file, line, column, values) {
  console.log(`{@debug} ${file ? file + " " : ""}(${line}:${column})`);
  console.log(values);
  return "";
}
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target2, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target2, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options2, instance2, create_fragment2, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options2.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options2.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options2.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options2.target) {
    if (options2.hydrate) {
      const nodes = children(options2.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options2.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options2.target, options2.anchor, options2.customElement);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
}
const s_TAG_OBJECT = "[object Object]";
function deepMerge(target2 = {}, ...sourceObj) {
  if (Object.prototype.toString.call(target2) !== s_TAG_OBJECT) {
    throw new TypeError(`deepMerge error: 'target' is not an 'object'.`);
  }
  for (let cntr = 0; cntr < sourceObj.length; cntr++) {
    if (Object.prototype.toString.call(sourceObj[cntr]) !== s_TAG_OBJECT) {
      throw new TypeError(`deepMerge error: 'sourceObj[${cntr}]' is not an 'object'.`);
    }
  }
  return _deepMerge(target2, ...sourceObj);
}
function isIterable(value) {
  if (value === null || value === void 0 || typeof value !== "object") {
    return false;
  }
  return typeof value[Symbol.iterator] === "function";
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  if (Object.prototype.toString.call(value) !== s_TAG_OBJECT) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
}
function safeAccess(data2, accessor, defaultValue = void 0) {
  if (typeof data2 !== "object") {
    return defaultValue;
  }
  if (typeof accessor !== "string") {
    return defaultValue;
  }
  const access = accessor.split(".");
  for (let cntr = 0; cntr < access.length; cntr++) {
    if (typeof data2[access[cntr]] === "undefined" || data2[access[cntr]] === null) {
      return defaultValue;
    }
    data2 = data2[access[cntr]];
  }
  return data2;
}
function safeSet(data2, accessor, value, operation = "set", createMissing = true) {
  if (typeof data2 !== "object") {
    throw new TypeError(`safeSet Error: 'data' is not an 'object'.`);
  }
  if (typeof accessor !== "string") {
    throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`);
  }
  const access = accessor.split(".");
  for (let cntr = 0; cntr < access.length; cntr++) {
    if (Array.isArray(data2)) {
      const number = +access[cntr];
      if (!Number.isInteger(number) || number < 0) {
        return false;
      }
    }
    if (cntr === access.length - 1) {
      switch (operation) {
        case "add":
          data2[access[cntr]] += value;
          break;
        case "div":
          data2[access[cntr]] /= value;
          break;
        case "mult":
          data2[access[cntr]] *= value;
          break;
        case "set":
          data2[access[cntr]] = value;
          break;
        case "set-undefined":
          if (typeof data2[access[cntr]] === "undefined") {
            data2[access[cntr]] = value;
          }
          break;
        case "sub":
          data2[access[cntr]] -= value;
          break;
      }
    } else {
      if (createMissing && typeof data2[access[cntr]] === "undefined") {
        data2[access[cntr]] = {};
      }
      if (data2[access[cntr]] === null || typeof data2[access[cntr]] !== "object") {
        return false;
      }
      data2 = data2[access[cntr]];
    }
  }
  return true;
}
function _deepMerge(target2 = {}, ...sourceObj) {
  for (let cntr = 0; cntr < sourceObj.length; cntr++) {
    const obj2 = sourceObj[cntr];
    for (const prop in obj2) {
      if (Object.prototype.hasOwnProperty.call(obj2, prop)) {
        if (prop.startsWith("-=")) {
          delete target2[prop.slice(2)];
          continue;
        }
        target2[prop] = Object.prototype.hasOwnProperty.call(target2, prop) && target2[prop]?.constructor === Object && obj2[prop]?.constructor === Object ? _deepMerge({}, target2[prop], obj2[prop]) : obj2[prop];
      }
    }
  }
  return target2;
}
class A11yHelper {
  /**
   * Apply focus to the HTMLElement targets in a given A11yFocusSource data object. An iterable list `options.focusEl`
   * can contain HTMLElements or selector strings. If multiple focus targets are provided in a list then the first
   * valid target found will be focused. If focus target is a string then a lookup via `document.querySelector` is
   * performed. In this case you should provide a unique selector for the desired focus target.
   *
   * Note: The body of this method is postponed to the next clock tick to allow any changes in the DOM to occur that
   * might alter focus targets before applying.
   *
   * @param {A11yFocusSource|{ focusSource: A11yFocusSource }}   options - The focus options instance to apply.
   */
  static applyFocusSource(options2) {
    if (!isObject(options2)) {
      return;
    }
    const focusOpts = isObject(options2?.focusSource) ? options2.focusSource : options2;
    setTimeout(() => {
      const debug2 = typeof focusOpts.debug === "boolean" ? focusOpts.debug : false;
      if (isIterable(focusOpts.focusEl)) {
        if (debug2) {
          console.debug(`A11yHelper.applyFocusSource debug - Attempting to apply focus target: `, focusOpts.focusEl);
        }
        for (const target2 of focusOpts.focusEl) {
          if (target2 instanceof HTMLElement && target2.isConnected) {
            target2.focus();
            if (debug2) {
              console.debug(`A11yHelper.applyFocusSource debug - Applied focus to target: `, target2);
            }
            break;
          } else if (typeof target2 === "string") {
            const element2 = document.querySelector(target2);
            if (element2 instanceof HTMLElement && element2.isConnected) {
              element2.focus();
              if (debug2) {
                console.debug(`A11yHelper.applyFocusSource debug - Applied focus to target: `, element2);
              }
              break;
            } else if (debug2) {
              console.debug(`A11yHelper.applyFocusSource debug - Could not query selector: `, target2);
            }
          }
        }
      } else if (debug2) {
        console.debug(`A11yHelper.applyFocusSource debug - No focus targets defined.`);
      }
    }, 0);
  }
  /**
   * Returns first focusable element within a specified element.
   *
   * @param {HTMLElement|Document} [element=document] - Optional element to start query.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<HTMLElement>} [options.ignoreElements] - Set of elements to ignore.
   *
   * @returns {HTMLElement} First focusable child element
   */
  static getFirstFocusableElement(element2 = document, options2) {
    const focusableElements = this.getFocusableElements(element2, options2);
    return focusableElements.length > 0 ? focusableElements[0] : void 0;
  }
  /**
   * Returns all focusable elements within a specified element.
   *
   * @param {HTMLElement|Document} [element=document] Optional element to start query.
   *
   * @param {object}            [options] - Optional parameters.
   *
   * @param {boolean}           [options.anchorHref=true] - When true anchors must have an HREF.
   *
   * @param {Iterable<string>}  [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<HTMLElement>}  [options.ignoreElements] - Set of elements to ignore.
   *
   * @param {string}            [options.selectors] - Custom list of focusable selectors for `querySelectorAll`.
   *
   * @returns {Array<HTMLElement>} Child keyboard focusable
   */
  static getFocusableElements(element2 = document, { anchorHref = true, ignoreClasses, ignoreElements, selectors } = {}) {
    if (!(element2 instanceof HTMLElement) && !(element2 instanceof Document)) {
      throw new TypeError(`'element' is not a HTMLElement or Document instance.`);
    }
    if (typeof anchorHref !== "boolean") {
      throw new TypeError(`'anchorHref' is not a boolean.`);
    }
    if (ignoreClasses !== void 0 && !isIterable(ignoreClasses)) {
      throw new TypeError(`'ignoreClasses' is not an iterable list.`);
    }
    if (ignoreElements !== void 0 && !(ignoreElements instanceof Set)) {
      throw new TypeError(`'ignoreElements' is not a Set.`);
    }
    if (selectors !== void 0 && typeof selectors !== "string") {
      throw new TypeError(`'selectors' is not a string.`);
    }
    const selectorQuery = selectors ?? this.#getFocusableSelectors(anchorHref);
    const allElements = [...element2.querySelectorAll(selectorQuery)];
    if (ignoreElements && ignoreClasses) {
      return allElements.filter((el) => {
        let hasIgnoreClass = false;
        for (const ignoreClass of ignoreClasses) {
          if (el.classList.contains(ignoreClass)) {
            hasIgnoreClass = true;
            break;
          }
        }
        return !hasIgnoreClass && !ignoreElements.has(el) && el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    } else if (ignoreClasses) {
      return allElements.filter((el) => {
        let hasIgnoreClass = false;
        for (const ignoreClass of ignoreClasses) {
          if (el.classList.contains(ignoreClass)) {
            hasIgnoreClass = true;
            break;
          }
        }
        return !hasIgnoreClass && el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    } else if (ignoreElements) {
      return allElements.filter((el) => {
        return !ignoreElements.has(el) && el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    } else {
      return allElements.filter((el) => {
        return el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    }
  }
  /**
   * Returns the default focusable selectors query.
   *
   * @param {boolean}  [anchorHref=true] - When true anchors must have an HREF.
   *
   * @returns {string} Focusable selectors for `querySelectorAll`.
   */
  static #getFocusableSelectors(anchorHref = true) {
    return `button, [contenteditable=""], [contenteditable="true"], details summary:not([tabindex="-1"]), embed, a${anchorHref ? "[href]" : ""}, iframe, object, input:not([type=hidden]), select, textarea, [tabindex]:not([tabindex="-1"])`;
  }
  /**
   * Gets a A11yFocusSource object from the given DOM event allowing for optional X / Y screen space overrides.
   * Browsers (Firefox / Chrome) forwards a mouse event for the context menu keyboard button. Provides detection of
   * when the context menu event is from the keyboard. Firefox as of (1/23) does not provide the correct screen space
   * coordinates, so for keyboard context menu presses coordinates are generated from the centroid point of the
   * element.
   *
   * A default fallback element or selector string may be provided to provide the focus target. If the event comes from
   * the keyboard however the source focused element is inserted as the target with the fallback value appended to the
   * list of focus targets. When A11yFocusSource is applied by {@link A11yHelper.applyFocusSource} the target focus
   * list is iterated through until a connected target is found and focus applied.
   *
   * @param {object} options - Options
   *
   * @param {KeyboardEvent|MouseEvent}   [options.event] - The source DOM event.
   *
   * @param {boolean} [options.debug] - When true {@link A11yHelper.applyFocusSource} logs focus target data.
   *
   * @param {HTMLElement|string} [options.focusEl] - A specific HTMLElement or selector string as the focus target.
   *
   * @param {number}   [options.x] - Used when an event isn't provided; integer of event source in screen space.
   *
   * @param {number}   [options.y] - Used when an event isn't provided; integer of event source in screen space.
   *
   * @returns {A11yFocusSource} A A11yFocusSource object.
   *
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1426671
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=314314
   *
   * TODO: Evaluate / test against touch input devices.
   */
  static getFocusSource({ event, x, y, focusEl, debug: debug2 = false }) {
    if (focusEl !== void 0 && !(focusEl instanceof HTMLElement) && typeof focusEl !== "string") {
      throw new TypeError(
        `A11yHelper.getFocusSource error: 'focusEl' is not a HTMLElement or string.`
      );
    }
    if (debug2 !== void 0 && typeof debug2 !== "boolean") {
      throw new TypeError(`A11yHelper.getFocusSource error: 'debug' is not a boolean.`);
    }
    if (event === void 0) {
      if (typeof x !== "number") {
        throw new TypeError(`A11yHelper.getFocusSource error: 'event' not defined and 'x' is not a number.`);
      }
      if (typeof y !== "number") {
        throw new TypeError(`A11yHelper.getFocusSource error: 'event' not defined and 'y' is not a number.`);
      }
      return {
        debug: debug2,
        focusEl: focusEl !== void 0 ? [focusEl] : void 0,
        x,
        y
      };
    }
    if (!(event instanceof KeyboardEvent) && !(event instanceof MouseEvent)) {
      throw new TypeError(`A11yHelper.getFocusSource error: 'event' is not a KeyboardEvent or MouseEvent.`);
    }
    if (x !== void 0 && !Number.isInteger(x)) {
      throw new TypeError(`A11yHelper.getFocusSource error: 'x' is not a number.`);
    }
    if (y !== void 0 && !Number.isInteger(y)) {
      throw new TypeError(`A11yHelper.getFocusSource error: 'y' is not a number.`);
    }
    const targetEl = event.target;
    if (!(targetEl instanceof HTMLElement)) {
      throw new TypeError(`A11yHelper.getFocusSource error: 'event.target' is not an HTMLElement.`);
    }
    const result = { debug: debug2 };
    if (event instanceof MouseEvent) {
      if (event?.button !== 2 && event.type === "contextmenu") {
        const rect = targetEl.getBoundingClientRect();
        result.x = x ?? rect.left + rect.width / 2;
        result.y = y ?? rect.top + rect.height / 2;
        result.focusEl = focusEl !== void 0 ? [targetEl, focusEl] : [targetEl];
        result.source = "keyboard";
      } else {
        result.x = x ?? event.pageX;
        result.y = y ?? event.pageY;
        result.focusEl = focusEl !== void 0 ? [focusEl] : void 0;
      }
    } else {
      const rect = targetEl.getBoundingClientRect();
      result.x = x ?? rect.left + rect.width / 2;
      result.y = y ?? rect.top + rect.height / 2;
      result.focusEl = focusEl !== void 0 ? [targetEl, focusEl] : [targetEl];
      result.source = "keyboard";
    }
    return result;
  }
  /**
   * Returns first focusable element within a specified element.
   *
   * @param {HTMLElement|Document} [element=document] - Optional element to start query.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<HTMLElement>} [options.ignoreElements] - Set of elements to ignore.
   *
   * @returns {HTMLElement} First focusable child element
   */
  static getLastFocusableElement(element2 = document, options2) {
    const focusableElements = this.getFocusableElements(element2, options2);
    return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : void 0;
  }
  /**
   * Tests if the given element is focusable.
   *
   * @param {HTMLElement} [el] - Element to test.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {boolean} [options.anchorHref=true] - When true anchors must have an HREF.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @returns {boolean} Element is focusable.
   */
  static isFocusable(el, { anchorHref = true, ignoreClasses } = {}) {
    if (el === void 0 || el === null || !(el instanceof HTMLElement) || el?.hidden || !el?.isConnected) {
      return false;
    }
    if (typeof anchorHref !== "boolean") {
      throw new TypeError(`'anchorHref' is not a boolean.`);
    }
    if (ignoreClasses !== void 0 && !isIterable(ignoreClasses)) {
      throw new TypeError(`'ignoreClasses' is not an iterable list.`);
    }
    const contenteditableAttr = el.getAttribute("contenteditable");
    const contenteditableFocusable = typeof contenteditableAttr === "string" && (contenteditableAttr === "" || contenteditableAttr === "true");
    const tabindexAttr = el.getAttribute("tabindex");
    const tabindexFocusable = typeof tabindexAttr === "string" && tabindexAttr !== "-1";
    const isAnchor = el instanceof HTMLAnchorElement;
    if (contenteditableFocusable || tabindexFocusable || isAnchor || el instanceof HTMLButtonElement || el instanceof HTMLDetailsElement || el instanceof HTMLEmbedElement || el instanceof HTMLIFrameElement || el instanceof HTMLInputElement || el instanceof HTMLObjectElement || el instanceof HTMLSelectElement || el instanceof HTMLTextAreaElement) {
      if (isAnchor && anchorHref && typeof el.getAttribute("href") !== "string") {
        return false;
      }
      return el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
    }
    return false;
  }
  /**
   * Convenience method to check if the given data is a valid focus source.
   *
   * @param {HTMLElement|string}   data - Either an HTMLElement or selector string.
   *
   * @returns {boolean} Is valid focus source.
   */
  static isFocusSource(data2) {
    return data2 instanceof HTMLElement || typeof data2 === "string";
  }
}
class ManagedPromise {
  /** @type {boolean} */
  static #logging = false;
  /** @type {{ isProcessing?: boolean, promise?: Promise, reject: Function, resolve: Function }} */
  #current;
  /**
   * @returns {boolean} Whether global logging is enabled.
   */
  static get logging() {
    return this.#logging;
  }
  /**
   * @returns {boolean} Whether there is an active managed Promise.
   */
  get isActive() {
    return this.#current !== void 0;
  }
  /**
   * @returns {boolean} Whether there is an active managed Promise and resolution is currently being processed.
   */
  get isProcessing() {
    return this.#current !== void 0 ? this.#current.isProcessing : false;
  }
  /**
   * Sets global logging enabled state.
   *
   * @param {boolean}  logging - New logging enabled state.
   */
  static set logging(logging) {
    if (typeof logging !== "boolean") {
      throw new TypeError(`[TRL] ManagedPromise.logging error: 'logging' is not a boolean.`);
    }
    this.#logging = logging;
  }
  // ----------------------------------------------------------------------------------------------------------------
  /**
   * Resolves any current Promise with undefined and creates a new current Promise.
   *
   * @template T
   *
   * @param {object} opts - Options.
   *
   * @param {boolean}  [opts.reuse=false] - When true if there is an existing live Promise it is returned immediately.
   *
   * @returns {Promise<T>} The new current managed Promise.
   */
  create({ reuse = false } = {}) {
    if (typeof reuse !== "boolean") {
      throw new TypeError(`[TRL] ManagedPromise.create error: 'reuse' is not a boolean.`);
    }
    if (reuse && this.#current !== void 0 && this.#current.promise instanceof Promise) {
      if (ManagedPromise.#logging) {
        console.warn(`[TRL] ManagedPromise.create info: Reusing / returning existing managed Promise.`);
      }
      return this.#current.promise;
    }
    if (this.#current !== void 0) {
      if (ManagedPromise.#logging) {
        console.warn(
          `[TRL] ManagedPromise.create info: Creating a new Promise and resolving existing immediately.`
        );
      }
      this.#current.resolve(void 0);
      this.#current = void 0;
    }
    const promise2 = new Promise((resolve, reject) => {
      this.#current = {
        isProcessing: false,
        reject,
        resolve
      };
    });
    this.#current.promise = promise2;
    return promise2;
  }
  /**
   * Gets the current Promise if any.
   *
   * @returns {Promise<any>} Current Promise.
   */
  get() {
    return this.#current ? this.#current.promise : void 0;
  }
  /**
   * Rejects the current Promise if applicable.
   *
   * @param {*}  [result] - Result to reject.
   *
   * @returns {boolean} Was the promise rejected.
   */
  reject(result = void 0) {
    if (this.#current !== void 0 && this.#current.isProcessing) {
      if (ManagedPromise.#logging) {
        console.warn(`[TRL] ManagedPromise.reject info: Currently processing promise.`);
      }
      return true;
    }
    if (this.#current !== void 0) {
      this.#current.isProcessing = true;
      if (result instanceof Promise) {
        result.then((value) => {
          this.#current.reject(value);
          this.#current = void 0;
        }).catch((err) => {
          this.#current.reject(err);
          this.#current = void 0;
        });
      } else {
        this.#current.reject(result);
        this.#current = void 0;
      }
      return true;
    } else {
      if (ManagedPromise.#logging) {
        console.warn(`[TRL] ManagedPromise.reject warning: No current managed Promise to reject.`);
      }
      return false;
    }
  }
  /**
   * Resolves the current Promise if applicable.
   *
   * @param {*}  [result] - Result to resolve.
   *
   * @returns {boolean} Was the promise resolved.
   */
  resolve(result = void 0) {
    if (this.#current !== void 0 && this.#current.isProcessing) {
      if (ManagedPromise.#logging) {
        console.warn(`[TRL] ManagedPromise.resolve info: Currently processing promise.`);
      }
      return true;
    }
    if (this.#current !== void 0) {
      if (result instanceof Promise) {
        this.#current.isProcessing = true;
        result.then((value) => {
          this.#current.resolve(value);
          this.#current = void 0;
        }).catch((err) => {
          this.#current.reject(err);
          this.#current = void 0;
        });
      } else {
        this.#current.resolve(result);
        this.#current = void 0;
      }
      return true;
    } else {
      if (ManagedPromise.#logging) {
        console.warn(`[TRL] ManagedPromise.resolve warning: No current managed Promise to resolve.`);
      }
      return false;
    }
  }
}
const s_UUIDV4_REGEX = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;
function uuidv4() {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^ (globalThis.crypto || globalThis.msCrypto).getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
}
uuidv4.isValid = (uuid) => s_UUIDV4_REGEX.test(uuid);
function normalizeString(query) {
  return query.trim().normalize("NFD").replace(/[\x00-\x1F]/gm, "");
}
function getStackingContext(node) {
  if (!node || node.nodeName === "HTML") {
    return { node: document.documentElement, reason: "root" };
  }
  if (node.nodeName === "#document-fragment") {
    return getStackingContext(node.host);
  }
  const computedStyle = globalThis.getComputedStyle(node);
  if (computedStyle.position === "fixed" || computedStyle.position === "sticky") {
    return { node, reason: `position: ${computedStyle.position}` };
  }
  if (computedStyle.zIndex !== "auto" && computedStyle.position !== "static") {
    return { node, reason: `position: ${computedStyle.position}; z-index: ${computedStyle.zIndex}` };
  }
  if (computedStyle.opacity !== "1") {
    return { node, reason: `opacity: ${computedStyle.opacity}` };
  }
  if (computedStyle.transform !== "none") {
    return { node, reason: `transform: ${computedStyle.transform}` };
  }
  if (computedStyle.mixBlendMode !== "normal") {
    return { node, reason: `mixBlendMode: ${computedStyle.mixBlendMode}` };
  }
  if (computedStyle.filter !== "none") {
    return { node, reason: `filter: ${computedStyle.filter}` };
  }
  if (computedStyle.perspective !== "none") {
    return { node, reason: `perspective: ${computedStyle.perspective}` };
  }
  if (computedStyle.clipPath !== "none") {
    return { node, reason: `clip-path: ${computedStyle.clipPath} ` };
  }
  const mask = computedStyle.mask || computedStyle.webkitMask;
  if (mask !== "none" && mask !== void 0) {
    return { node, reason: `mask:  ${mask}` };
  }
  const maskImage = computedStyle.maskImage || computedStyle.webkitMaskImage;
  if (maskImage !== "none" && maskImage !== void 0) {
    return { node, reason: `mask-image: ${maskImage}` };
  }
  const maskBorder = computedStyle.maskBorder || computedStyle.webkitMaskBorder;
  if (maskBorder !== "none" && maskBorder !== void 0) {
    return { node, reason: `mask-border: ${maskBorder}` };
  }
  if (computedStyle.isolation === "isolate") {
    return { node, reason: `isolation: ${computedStyle.isolation}` };
  }
  if (computedStyle.willChange === "transform" || computedStyle.willChange === "opacity") {
    return { node, reason: `willChange: ${computedStyle.willChange}` };
  }
  if (computedStyle.webkitOverflowScrolling === "touch") {
    return { node, reason: "-webkit-overflow-scrolling: touch" };
  }
  if (computedStyle.zIndex !== "auto") {
    const parentStyle = globalThis.getComputedStyle(node.parentNode);
    if (parentStyle.display === "flex" || parentStyle.display === "inline-flex") {
      return { node, reason: `flex-item; z-index: ${computedStyle.zIndex}` };
    } else if (parentStyle.grid !== "none / none / none / row / auto / auto") {
      return { node, reason: `child of grid container; z-index: ${computedStyle.zIndex}` };
    }
  }
  const contain = computedStyle.contain;
  if (["layout", "paint", "strict", "content"].indexOf(contain) > -1 || contain.indexOf("paint") > -1 || contain.indexOf("layout") > -1) {
    return { node, reason: `contain: ${contain}` };
  }
  return getStackingContext(node.parentNode);
}
class StyleManager {
  /** @type {CSSStyleRule} */
  #cssRule;
  /** @type {string} */
  #docKey;
  /** @type {string} */
  #selector;
  /** @type {HTMLStyleElement} */
  #styleElement;
  /** @type {number} */
  #version;
  /**
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.docKey - Required key providing a link to a specific style sheet element.
   *
   * @param {string}   [opts.selector=:root] - Selector element.
   *
   * @param {Document} [opts.document] - Target document to load styles into.
   *
   * @param {number}   [opts.version] - An integer representing the version / level of styles being managed.
   *
   */
  constructor({ docKey, selector = ":root", document: document2 = globalThis.document, version } = {}) {
    if (typeof docKey !== "string") {
      throw new TypeError(`StyleManager error: 'docKey' is not a string.`);
    }
    if (typeof selector !== "string") {
      throw new TypeError(`StyleManager error: 'selector' is not a string.`);
    }
    if (version !== void 0 && !Number.isSafeInteger(version) && version < 1) {
      throw new TypeError(`StyleManager error: 'version' is defined and is not a positive integer >= 1.`);
    }
    this.#selector = selector;
    this.#docKey = docKey;
    this.#version = version;
    if (document2[this.#docKey] === void 0) {
      this.#styleElement = document2.createElement("style");
      document2.head.append(this.#styleElement);
      this.#styleElement._STYLE_MANAGER_VERSION = version;
      this.#styleElement.sheet.insertRule(`${selector} {}`, 0);
      this.#cssRule = this.#styleElement.sheet.cssRules[0];
      document2[docKey] = this.#styleElement;
    } else {
      this.#styleElement = document2[docKey];
      this.#cssRule = this.#styleElement.sheet.cssRules[0];
      if (version) {
        const existingVersion = this.#styleElement._STYLE_MANAGER_VERSION ?? 0;
        if (version > existingVersion) {
          this.#cssRule.style.cssText = "";
        }
      }
    }
  }
  /**
   * @returns {string} Provides an accessor to get the `cssText` for the style sheet.
   */
  get cssText() {
    return this.#cssRule.style.cssText;
  }
  /**
   * @returns {number} Returns the version of this instance.
   */
  get version() {
    return this.#version;
  }
  /**
   * Provides a copy constructor to duplicate an existing StyleManager instance into a new document.
   *
   * Note: This is used to support the `PopOut` module.
   *
   * @param {Document} [document] Target browser document to clone into.
   *
   * @returns {StyleManager} New style manager instance.
   */
  clone(document2 = globalThis.document) {
    const newStyleManager = new StyleManager({
      selector: this.#selector,
      docKey: this.#docKey,
      document: document2,
      version: this.#version
    });
    newStyleManager.#cssRule.style.cssText = this.#cssRule.style.cssText;
    return newStyleManager;
  }
  get() {
    const cssText = this.#cssRule.style.cssText;
    const result = {};
    if (cssText !== "") {
      for (const entry of cssText.split(";")) {
        if (entry !== "") {
          const values = entry.split(":");
          result[values[0].trim()] = values[1];
        }
      }
    }
    return result;
  }
  /**
   * Gets a particular CSS variable.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @returns {string} Returns CSS variable value.
   */
  getProperty(key) {
    if (typeof key !== "string") {
      throw new TypeError(`StyleManager error: 'key' is not a string.`);
    }
    return this.#cssRule.style.getPropertyValue(key);
  }
  /**
   * Set rules by property / value; useful for CSS variables.
   *
   * @param {Object<string, string>}  rules - An object with property / value string pairs to load.
   *
   * @param {boolean}                 [overwrite=true] - When true overwrites any existing values.
   */
  setProperties(rules, overwrite = true) {
    if (!isObject(rules)) {
      throw new TypeError(`StyleManager error: 'rules' is not an object.`);
    }
    if (typeof overwrite !== "boolean") {
      throw new TypeError(`StyleManager error: 'overwrite' is not a boolean.`);
    }
    if (overwrite) {
      for (const [key, value] of Object.entries(rules)) {
        this.#cssRule.style.setProperty(key, value);
      }
    } else {
      for (const [key, value] of Object.entries(rules)) {
        if (this.#cssRule.style.getPropertyValue(key) === "") {
          this.#cssRule.style.setProperty(key, value);
        }
      }
    }
  }
  /**
   * Sets a particular property.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @param {string}   value - CSS variable value.
   *
   * @param {boolean}  [overwrite=true] - Overwrite any existing value.
   */
  setProperty(key, value, overwrite = true) {
    if (typeof key !== "string") {
      throw new TypeError(`StyleManager error: 'key' is not a string.`);
    }
    if (typeof value !== "string") {
      throw new TypeError(`StyleManager error: 'value' is not a string.`);
    }
    if (typeof overwrite !== "boolean") {
      throw new TypeError(`StyleManager error: 'overwrite' is not a boolean.`);
    }
    if (overwrite) {
      this.#cssRule.style.setProperty(key, value);
    } else {
      if (this.#cssRule.style.getPropertyValue(key) === "") {
        this.#cssRule.style.setProperty(key, value);
      }
    }
  }
  /**
   * Removes the property keys specified. If `keys` is an iterable list then all property keys in the list are removed.
   *
   * @param {Iterable<string>} keys - The property keys to remove.
   */
  removeProperties(keys) {
    if (!isIterable(keys)) {
      throw new TypeError(`StyleManager error: 'keys' is not an iterable list.`);
    }
    for (const key of keys) {
      if (typeof key === "string") {
        this.#cssRule.style.removeProperty(key);
      }
    }
  }
  /**
   * Removes a particular CSS variable.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @returns {string} CSS variable value when removed.
   */
  removeProperty(key) {
    if (typeof key !== "string") {
      throw new TypeError(`StyleManager error: 'key' is not a string.`);
    }
    return this.#cssRule.style.removeProperty(key);
  }
}
const s_REGEX = /(\d+)\s*px/;
function styleParsePixels(value) {
  if (typeof value !== "string") {
    return void 0;
  }
  const isPixels = s_REGEX.test(value);
  const number = parseInt(value);
  return isPixels && Number.isFinite(number) ? number : void 0;
}
const applicationShellContract = ["elementRoot"];
Object.freeze(applicationShellContract);
function isApplicationShell(component) {
  if (component === null || component === void 0) {
    return false;
  }
  let compHasContract = true;
  let protoHasContract = true;
  for (const accessor of applicationShellContract) {
    const descriptor = Object.getOwnPropertyDescriptor(component, accessor);
    if (descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0) {
      compHasContract = false;
    }
  }
  const prototype = Object.getPrototypeOf(component);
  for (const accessor of applicationShellContract) {
    const descriptor = Object.getOwnPropertyDescriptor(prototype, accessor);
    if (descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0) {
      protoHasContract = false;
    }
  }
  return compHasContract || protoHasContract;
}
function isHMRProxy(comp) {
  const instanceName = comp?.constructor?.name;
  if (typeof instanceName === "string" && (instanceName.startsWith("Proxy<") || instanceName === "ProxyComponent")) {
    return true;
  }
  const prototypeName = comp?.prototype?.constructor?.name;
  return typeof prototypeName === "string" && (prototypeName.startsWith("Proxy<") || prototypeName === "ProxyComponent");
}
function isSvelteComponent(comp) {
  if (comp === null || comp === void 0 || typeof comp !== "function") {
    return false;
  }
  const prototypeName = comp?.prototype?.constructor?.name;
  if (typeof prototypeName === "string" && (prototypeName.startsWith("Proxy<") || prototypeName === "ProxyComponent")) {
    return true;
  }
  return typeof window !== void 0 ? typeof comp.prototype.$destroy === "function" && typeof comp.prototype.$on === "function" : (
    // client-side
    typeof comp.render === "function"
  );
}
async function outroAndDestroy(instance2) {
  return new Promise((resolve) => {
    if (instance2.$$.fragment && instance2.$$.fragment.o) {
      group_outros();
      transition_out(instance2.$$.fragment, 0, 0, () => {
        instance2.$destroy();
        resolve();
      });
      check_outros();
    } else {
      instance2.$destroy();
      resolve();
    }
  });
}
function parseSvelteConfig(config, thisArg = void 0) {
  if (typeof config !== "object") {
    throw new TypeError(`parseSvelteConfig - 'config' is not an object:
${JSON.stringify(config)}.`);
  }
  if (!isSvelteComponent(config.class)) {
    throw new TypeError(
      `parseSvelteConfig - 'class' is not a Svelte component constructor for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.hydrate !== void 0 && typeof config.hydrate !== "boolean") {
    throw new TypeError(
      `parseSvelteConfig - 'hydrate' is not a boolean for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.intro !== void 0 && typeof config.intro !== "boolean") {
    throw new TypeError(
      `parseSvelteConfig - 'intro' is not a boolean for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.target !== void 0 && typeof config.target !== "string" && !(config.target instanceof HTMLElement) && !(config.target instanceof ShadowRoot) && !(config.target instanceof DocumentFragment)) {
    throw new TypeError(
      `parseSvelteConfig - 'target' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.anchor !== void 0 && typeof config.anchor !== "string" && !(config.anchor instanceof HTMLElement) && !(config.anchor instanceof ShadowRoot) && !(config.anchor instanceof DocumentFragment)) {
    throw new TypeError(
      `parseSvelteConfig - 'anchor' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.context !== void 0 && typeof config.context !== "function" && !(config.context instanceof Map) && typeof config.context !== "object") {
    throw new TypeError(
      `parseSvelteConfig - 'context' is not a Map, function or object for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.selectorTarget !== void 0 && typeof config.selectorTarget !== "string") {
    throw new TypeError(
      `parseSvelteConfig - 'selectorTarget' is not a string for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.options !== void 0 && typeof config.options !== "object") {
    throw new TypeError(
      `parseSvelteConfig - 'options' is not an object for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.options !== void 0) {
    if (config.options.injectApp !== void 0 && typeof config.options.injectApp !== "boolean") {
      throw new TypeError(
        `parseSvelteConfig - 'options.injectApp' is not a boolean for config:
${JSON.stringify(config)}.`
      );
    }
    if (config.options.injectEventbus !== void 0 && typeof config.options.injectEventbus !== "boolean") {
      throw new TypeError(
        `parseSvelteConfig - 'options.injectEventbus' is not a boolean for config:
${JSON.stringify(config)}.`
      );
    }
    if (config.options.selectorElement !== void 0 && typeof config.options.selectorElement !== "string") {
      throw new TypeError(
        `parseSvelteConfig - 'selectorElement' is not a string for config:
${JSON.stringify(config)}.`
      );
    }
  }
  const svelteConfig = { ...config };
  delete svelteConfig.options;
  let externalContext = {};
  if (typeof svelteConfig.context === "function") {
    const contextFunc = svelteConfig.context;
    delete svelteConfig.context;
    const result = contextFunc.call(thisArg);
    if (isObject(result)) {
      externalContext = { ...result };
    } else {
      throw new Error(`parseSvelteConfig - 'context' is a function that did not return an object for config:
${JSON.stringify(config)}`);
    }
  } else if (svelteConfig.context instanceof Map) {
    externalContext = Object.fromEntries(svelteConfig.context);
    delete svelteConfig.context;
  } else if (isObject(svelteConfig.context)) {
    externalContext = svelteConfig.context;
    delete svelteConfig.context;
  }
  svelteConfig.props = s_PROCESS_PROPS(svelteConfig.props, thisArg, config);
  if (Array.isArray(svelteConfig.children)) {
    const children2 = [];
    for (let cntr = 0; cntr < svelteConfig.children.length; cntr++) {
      const child = svelteConfig.children[cntr];
      if (!isSvelteComponent(child.class)) {
        throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for child[${cntr}] for config:
${JSON.stringify(config)}`);
      }
      child.props = s_PROCESS_PROPS(child.props, thisArg, config);
      children2.push(child);
    }
    if (children2.length > 0) {
      externalContext.children = children2;
    }
    delete svelteConfig.children;
  } else if (isObject(svelteConfig.children)) {
    if (!isSvelteComponent(svelteConfig.children.class)) {
      throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for children object for config:
${JSON.stringify(config)}`);
    }
    svelteConfig.children.props = s_PROCESS_PROPS(svelteConfig.children.props, thisArg, config);
    externalContext.children = [svelteConfig.children];
    delete svelteConfig.children;
  }
  if (!(svelteConfig.context instanceof Map)) {
    svelteConfig.context = /* @__PURE__ */ new Map();
  }
  svelteConfig.context.set("#external", externalContext);
  return svelteConfig;
}
function s_PROCESS_PROPS(props, thisArg, config) {
  if (typeof props === "function") {
    const result = props.call(thisArg);
    if (isObject(result)) {
      return result;
    } else {
      throw new Error(`parseSvelteConfig - 'props' is a function that did not return an object for config:
${JSON.stringify(config)}`);
    }
  } else if (isObject(props)) {
    return props;
  } else if (props !== void 0) {
    throw new Error(
      `parseSvelteConfig - 'props' is not a function or an object for config:
${JSON.stringify(config)}`
    );
  }
  return {};
}
function debounce(callback, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      callback.apply(this, args);
    }, delay);
  };
}
function hasGetter(object, accessor) {
  if (object === null || object === void 0) {
    return false;
  }
  const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);
  if (iDescriptor !== void 0 && iDescriptor.get !== void 0) {
    return true;
  }
  for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o)) {
    const descriptor = Object.getOwnPropertyDescriptor(o, accessor);
    if (descriptor !== void 0 && descriptor.get !== void 0) {
      return true;
    }
  }
  return false;
}
function hasPrototype(target2, Prototype) {
  if (typeof target2 !== "function") {
    return false;
  }
  if (target2 === Prototype) {
    return true;
  }
  for (let proto = Object.getPrototypeOf(target2); proto; proto = Object.getPrototypeOf(proto)) {
    if (proto === Prototype) {
      return true;
    }
  }
  return false;
}
function set(obj2, key, val) {
  if (typeof val.value === "object")
    val.value = klona(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj2, key, val);
  } else
    obj2[key] = val.value;
}
function klona(x) {
  if (typeof x !== "object")
    return x;
  var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);
  if (str === "[object Object]") {
    tmp = Object.create(x.__proto__ || null);
  } else if (str === "[object Array]") {
    tmp = Array(x.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x.forEach(function(val) {
      tmp.add(klona(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x.forEach(function(val, key) {
      tmp.set(klona(key), klona(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x.source, x.flags);
  } else if (str === "[object DataView]") {
    tmp = new x.constructor(klona(x.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x.slice(0);
  } else if (str.slice(-6) === "Array]") {
    tmp = new x.constructor(x);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {
      set(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));
    }
    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {
      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k])
        continue;
      set(tmp, k, Object.getOwnPropertyDescriptor(x, k));
    }
  }
  return tmp || x;
}
function getUUIDFromDataTransfer(data2, { actor = true, compendium = true, world = true, types = void 0 } = {}) {
  if (typeof data2 !== "object") {
    return void 0;
  }
  if (Array.isArray(types) && !types.includes(data2.type)) {
    return void 0;
  }
  let uuid = void 0;
  if (typeof data2.uuid === "string") {
    const isCompendium = data2.uuid.startsWith("Compendium");
    if (isCompendium && compendium) {
      uuid = data2.uuid;
    } else if (world) {
      uuid = data2.uuid;
    }
  } else {
    if (actor && world && data2.actorId && data2.type) {
      uuid = `Actor.${data2.actorId}.${data2.type}.${data2.data._id}`;
    } else if (typeof data2.id === "string") {
      if (compendium && typeof data2.pack === "string") {
        uuid = `Compendium.${data2.pack}.${data2.id}`;
      } else if (world) {
        uuid = `${data2.type}.${data2.id}`;
      }
    }
  }
  return uuid;
}
async function version01(flags) {
  const oldFlags = flags || {};
  const type = oldFlags.animType;
  const data2 = {
    killAnim: oldFlags.killAnim ?? false,
    below: oldFlags.animLevel ?? false,
    override: oldFlags.override ?? false,
    //animType: 'function here',
    //animation: 'animation function here',
    //color: 'color funciton here',
    //'options.repeat': type === 't8' ? oldFlags.templates?.tempLoop || 1 : oldFlags.options?.loops || 1,
    //'options.delay': type === 't8' ? oldFlags.templates?.loopDelay || 250 : oldFlags.options?.loopDelay || 250,
    //'options.scale': oldFlags.options?.scale ?? 1,
    //enableCustom: 'function here',
    //customPath: 'function here',
    targetToken: oldFlags.targetToken?.enable ? oldFlags.targetToken : { enable: false },
    sourceToken: oldFlags.sourceToken?.enable ? oldFlags.sourceToken : { enable: false },
    allSounds: oldFlags.allSounds ?? {},
    autoOverride: oldFlags.options?.overrideAuto ? await overrideAuto() : { enable: false },
    version: 1
  };
  if (oldFlags.override) {
    switch (type) {
      case "t2":
        data2.animType = "melee";
        data2.animation = replaceName(oldFlags.animName);
        data2.color = replaceName(oldFlags.color);
        data2.meleeSwitch = oldFlags.meleeSwitch?.switchType === "custom" ? await rangeSwitch() : { switchType: oldFlags.meleeSwitch?.switchType ?? "on" };
        data2.explosions = oldFlags.explosion ? await explosions() : { enable: false };
        data2.options = {
          meleeType: "weapon",
          variant: oldFlags.uaStrikeType ?? "01",
          repeat: oldFlags.options?.loops || 1,
          delay: oldFlags.options?.loopDelay || 250,
          scale: oldFlags.options?.scale ?? 1,
          enableCustom: oldFlags.options?.enableCustom01 ?? false,
          customPath: oldFlags.options?.customPath01 ?? ""
        };
        break;
      case "t3":
        let genericList = ["flurryofblows", "unarmedstrike"];
        data2.animation = replaceName(oldFlags.animName);
        data2.animType = "melee";
        data2.color = replaceName(oldFlags.color);
        data2.meleeSwitch = oldFlags.meleeSwitch?.switchType === "custom" ? await rangeSwitch() : { switchType: oldFlags.meleeSwitch?.switchType ?? "on" };
        data2.explosions = oldFlags.explosion ? await explosions() : { enable: false };
        data2.options = {
          meleeType: genericList.includes(data2.animation) ? "weapon" : "generic",
          variant: oldFlags.uaStrikeType ?? "01",
          repeat: oldFlags.options?.loops || 1,
          delay: oldFlags.options?.loopDelay || 250,
          scale: oldFlags.options?.scale ?? 1,
          enableCustom: oldFlags.options?.enableCustom01 ?? false,
          customPath: oldFlags.options?.customPath01 ?? ""
        };
        break;
      case "t4":
        let t4VariantSwitch = function(name) {
          switch (name) {
            case "bolt":
            case "bullet":
            case "arrow":
              return oldFlags.rangedOptions?.rangeDmgType ?? "01";
            case "lasersword":
            case "dagger":
            case "handaxe":
            case "chakram":
              return oldFlags.dtvar ?? "01";
            default:
              return "01";
          }
        };
        data2.animType = "range";
        data2.animation = replaceName(oldFlags.animName);
        data2.color = replaceName(oldFlags.color);
        data2.explosions = oldFlags.explosion ? await explosions() : { enable: false };
        data2.options = {
          rangeType: "weapon",
          variant: t4VariantSwitch(replaceName(oldFlags.animName)),
          repeat: oldFlags.options?.loops || 1,
          delay: oldFlags.options?.loopDelay || 250
        };
        break;
      case "t5":
        data2.animType = "static";
        data2.animation = replaceName(oldFlags.animName);
        data2.color = replaceName(oldFlags.color);
        data2.explosions = oldFlags.explosion ? await explosions() : { enable: false };
        data2.options = {
          staticType: "target",
          staticOptions: "creature",
          variant: "01",
          repeat: oldFlags.options?.loops || 1,
          delay: oldFlags.options?.loopDelay || 250,
          scale: oldFlags.options?.scale ?? 1,
          enableCustom: oldFlags.options?.enableCustom01 ?? false,
          customPath: oldFlags.options?.customPath01 ?? ""
        };
        break;
      case "t6":
        data2.animType = "range";
        data2.animation = replaceName(oldFlags.animName);
        data2.color = replaceName(oldFlags.color);
        data2.explosions = oldFlags.explosion ? await explosions() : { enable: false };
        data2.options = {
          rangeType: "spell",
          variant: oldFlags.spellVar ?? "01",
          repeat: oldFlags.options?.loops || 1,
          delay: oldFlags.options?.loopDelay || 250
        };
        break;
      case "t7":
        data2.animType = "static";
        data2.animation = replaceName(oldFlags.animName);
        data2.color = replaceName(oldFlags.color);
        data2.explosions = oldFlags.explosion ? await explosions() : { enable: false };
        data2.options = {
          staticType: "targetDefault",
          staticOptions: "staticSpells",
          variant: oldFlags.spellVar ?? "01",
          repeat: oldFlags.options?.loops || 1,
          delay: oldFlags.options?.loopDelay || 250,
          scale: oldFlags.options?.scale ?? 1,
          enableCustom: oldFlags.options?.enableCustom01 ?? false,
          customPath: oldFlags.options?.customPath01 ?? ""
        };
        break;
      case "t8":
        const tempAnimVar = await templateAnimation2();
        data2.animType = "template";
        data2.animation = tempAnimVar.name;
        data2.color = replaceName(oldFlags.templates?.tempColor);
        data2.options = {
          tempType: oldFlags.templates?.tempType,
          variant: tempAnimVar.variant,
          removeTemplate: oldFlags.templates?.removeTemplate ?? false,
          enableCustom: oldFlags.templates?.customAnim ?? false,
          customPath: oldFlags.templates?.customPath ?? "",
          persistent: oldFlags.templates?.persistent ?? false,
          persistType: oldFlags.templates?.persistent && oldFlags.templates?.overhead ? "overheadtile" : "sequencerground",
          opacity: oldFlags.templates?.opacity ?? 0.75,
          overhead: oldFlags.templates?.overhead ?? false,
          occlusionMode: oldFlags.templates?.occlusionMode ?? "03",
          occlusionAlpha: oldFlags.templates?.occlusionAlpha ?? 0.75,
          repeat: oldFlags.templates?.tempLoop || 1,
          delay: oldFlags.templates?.loopDelay || 250
        };
        break;
      case "t9":
      case "t10":
        data2.animType = "static";
        data2.animation = replaceName(oldFlags.explodeVariant);
        data2.color = replaceName(oldFlags.explodeColor);
        data2.explosions = { enable: false };
        data2.options = {
          staticType: type === "t9" ? "target" : "source",
          staticOptions: "explosion",
          variant: oldFlags.options?.variant ?? "01",
          repeat: oldFlags.explodeLoop || 1,
          delay: oldFlags.explodeDelay || 250,
          scale: oldFlags.options?.scale ?? 1,
          enableCustom: oldFlags.options?.enableCustomExplosion ?? false,
          customPath: oldFlags.options?.customExplosion ?? ""
        };
        break;
      case "t11":
        data2.animType = "aura";
        data2.animation = replaceName(oldFlags.animName);
        data2.color = replaceName(oldFlags.color);
        data2.options = {
          variant: "01",
          enableCustom: oldFlags.options?.enableCustom01 ?? false,
          customPath: oldFlags.options?.customPath01 ?? "",
          auraRadius: oldFlags.selfRadius ?? 3.5,
          opacity: oldFlags.auraOpacity ?? 0.75,
          ignoreTarget: oldFlags.ignoreTarget ?? false
        };
        break;
      case "t12":
        data2.animType = "preset";
        data2.animation = "teleportation";
        data2.color = replaceName(oldFlags.color);
        data2.options = {
          name: replaceName(oldFlags.animName),
          variant: "01",
          teleDist: oldFlags.teleDist ?? 30,
          scale: oldFlags.options?.scale ?? 1,
          hideTemplate: oldFlags.options?.hideTemplate ?? false,
          enableCustom: oldFlags.options?.enableCustom01 ?? false,
          customPath: oldFlags.options?.customPath01 ?? ""
        };
        break;
      case "t13":
        const presetName = replaceName(oldFlags.animName);
        data2.animType = "preset";
        data2.animation = presetName;
        data2.color = replaceName(oldFlags.color);
        switch (presetName) {
          case "shieldspell":
            data2.options = {
              variant: oldFlags.spellVar ?? "01",
              shieldVar: oldFlags.shieldVar ?? "outro_explode"
            };
            break;
          case "bardicinspiration":
            data2.bards = oldFlags.bards;
            break;
          case "huntersmark":
            data2.options = {
              variant: replaceName(oldFlags.hmAnim),
              persistent: oldFlags.ctaOption ?? false
            };
            break;
          case "sneakattack":
            data2.options = {
              variant: "01"
            };
            break;
          case "bless":
            data2.options = {
              variant: "01",
              persistent: oldFlags.options.addCTA ?? false
            };
            break;
        }
        break;
    }
  }
  async function overrideAuto() {
    const auto = oldFlags.options ?? {};
    const data3 = {
      enable: true,
      variant: auto.autoVariant ?? "01",
      color: auto.autoColor ?? "",
      repeat: auto.autoRepeat ?? 1,
      endEffect: auto.endEffect ?? "outro_explode",
      delay: auto.autoDelay ?? 250,
      scale: auto.autoScale ?? 1,
      fireball: auto.autoFireball ?? {}
    };
    return data3;
  }
  async function explosions() {
    const explosion = {
      enable: true,
      below: oldFlags.exAnimLevel ?? false,
      radius: oldFlags.explodeRadius ?? 2,
      delay: oldFlags.explodeDelay ?? 500,
      animation: replaceName(oldFlags.explodeVariant) ?? "",
      variant: "01",
      color: replaceName(oldFlags.explodeColor),
      enableCustom: oldFlags.options?.enableCustomExplosion ?? false,
      customPath: oldFlags.options?.customExplosion ?? ""
    };
    return explosion;
  }
  async function rangeSwitch() {
    const data3 = {
      animation: oldFlags.meleeSwitch?.animName ?? "",
      variant: switchVariants(replaceName(oldFlags.animName)),
      switchType: "custom",
      color: oldFlags.meleeSwitch?.color ?? "white",
      detect: oldFlags.meleeSwitch?.detect ?? "auto",
      range: oldFlags.meleeSwitch?.detect === "custom" ? oldFlags.meleeSwitch?.range ?? 2 : 2,
      returning: oldFlags.meleeSwitch?.returning ?? false
    };
    function switchVariants(name) {
      switch (name) {
        case "bolt":
        case "bullet":
        case "arrow":
          return oldFlags.meleeSwitch?.rangeDmgType ?? "01";
        case "lasersword":
        case "dagger":
        case "handaxe":
          return oldFlags.meleeSwitch?.rangeVar ?? "01";
        default:
          return "01";
      }
    }
    return data3;
  }
  async function templateAnimation2() {
    switch (oldFlags.templates?.tempType) {
      case "cone":
        switch (oldFlags.templates?.tempAnim) {
          case "coneofcold":
            return { name: "coneofcold", variant: "01" };
          case "burninghands01":
            return { name: "burninghands", variant: "01" };
          case "burninghands02":
            return { name: "burninghands", variant: "02" };
          default:
            return { name: "breathweaponcone", variant: oldFlags.templates?.tempAnim };
        }
      case "ray":
        switch (oldFlags.templates?.tempAnim) {
          case "lightningbolt01":
            return { name: "lightningbolt", variant: "01" };
          case "lightningbolt02":
            return { name: "lightningbolt", variant: "02" };
          default:
            return { name: "breathweaponline", variant: oldFlags.templates?.tempAnim };
        }
      case "circle":
        switch (oldFlags.templates?.tempAnim) {
          case "snowflake":
            return { name: "snowflake", variant: "01" };
          case "outpulse01":
            return { name: "outpulse01", variant: "01" };
          case "outpulse02":
            return { name: "outpulse02", variant: "01" };
          case "shatter":
            return { name: "shatter", variant: "01" };
          case "fogcloud":
            return { name: "fogcloud", variant: "01" };
          case "darkness":
            return { name: "darkness", variant: "01" };
          case "calllightning":
            return { name: "calllightning", variant: "01" };
          case "sleetstorm":
            return { name: "sleetstorm", variant: "01" };
          case "cloudofdaggers":
            return { name: "cloudofdaggers", variant: "01" };
          case "cloudofkunais":
            return { name: "cloudofdaggers", variant: "02" };
          default:
            return { name: "explosion", variant: "01" };
        }
      case "rect":
        switch (oldFlags.templates?.tempAnim) {
          case "entangle":
            return { name: "entangle", variant: "01" };
          case "thunderwave":
            return { name: "thunderwave", variant: "01" };
          default:
            return { name: "web", variant: "01" };
        }
      default:
        return {};
    }
  }
  function replaceName(name) {
    if (!name) {
      return "";
    }
    const newName = name.replace(/\s+/g, "").toLowerCase();
    return newName;
  }
  return data2;
}
async function version02(flags) {
  const v2Flags = flags || {};
  const allSounds = v2Flags.allSounds || {};
  v2Flags.audio = {
    a01: {
      enable: allSounds.item?.enableAudio ?? false,
      file: allSounds.item?.file ?? "",
      delay: allSounds.item?.delay ?? 0,
      volume: allSounds.item?.volume ?? 0.25
    },
    e01: {
      enable: allSounds.explosion?.audioExplodeEnabled || false,
      file: allSounds.explosion?.file ?? "",
      delay: allSounds.explosion?.delay ?? 0,
      volume: allSounds.explosion?.volume ?? 0.25
    }
  };
  v2Flags.version = 2;
  return v2Flags;
}
async function version03(flags) {
  const v3Flags = flags || {};
  if (v3Flags.killAnim) {
    v3Flags.version = 3;
    return v3Flags;
  }
  if (v3Flags.override) {
    if (v3Flags.animType === "template") {
      v3Flags.options.scaleX = v3Flags.options.scale || 1;
      v3Flags.options.scaleY = v3Flags.options.scale || 1;
    }
    if (v3Flags.animType === "preset") {
      if (v3Flags.animation === "teleportation") {
        v3Flags.options.measureType = "alternating";
        v3Flags.options.hideFromPlayers = v3Flags.options?.hideTemplate === true ? true : false;
        v3Flags.options.enableCustom02 = v3Flags.options?.enableCustom ? true : false;
        v3Flags.options.customPath02 = v3Flags.options?.enableCustom ? v3Flags.options?.customPath : "";
        v3Flags.options.name02 = v3Flags.options?.name ?? "mistystep";
        v3Flags.options.variant02 = "02";
        v3Flags.color02 = v3Flags.color || "blue";
        v3Flags.options.scale02 = v3Flags.options?.scale ?? 1;
      }
    }
    v3Flags.version = 3;
    return v3Flags;
  }
}
async function version04(flags) {
  const v4Flags = flags || {};
  const options2 = v4Flags.options || {};
  if (v4Flags.killAnim) {
    v4Flags.version = 4;
    return v4Flags;
  }
  if (v4Flags.sourceToken?.enable) {
    await convertExtraFX(v4Flags.sourceToken);
  }
  if (v4Flags.sourceToken?.enable) {
    await convertExtraFX(v4Flags.targetToken);
  }
  if (v4Flags.override) {
    const section2 = v4Flags.animType;
    switch (section2) {
      case "melee":
        options2.menuType = options2.meleeType;
        if (v4Flags.explosions?.enable) {
          await convertExplosion(v4Flags.explosions);
        }
        delete options2.meleeType;
        break;
      case "range":
        const genericRange = ["energyconduitsquare", "energyconduitcircle", "energybeam", "heart", "iceshard", "musicnote", "skull", "energystrand"];
        if (genericRange.some((el) => v4Flags.animation === el)) {
          options2.menuType = "generic";
          if (v4Flags.animation === "energyconduitcircle") {
            v4Flags.animation = "conduit";
            options2.variant = "circle";
          }
          if (v4Flags.animation === "energyconduitsquare") {
            v4Flags.animation = "conduit";
            options2.variant = "square";
          }
        } else {
          options2.menuType = options2.rangeType;
        }
        if (v4Flags.explosions?.enable) {
          await convertExplosion(v4Flags.explosions);
        }
        delete options2.rangeType;
        break;
      case "static":
        const conditions = ["drop", "fear", "heart", "horror", "light", "poison", "runes", "shields", "crackedshield", "skull", "snowflakes", "stun", "dizzystars"];
        const creature = ["bite", "claw"];
        const energy = ["energyfield", "dodecahedron", "shimmer", "sparkles"];
        const fire = ["eruption", "groundcrack", "fireworks"];
        const generic = ["boulderimpact", "explosion", "impact", "outpulse01", "outpulse02", "vortex", "whirl"];
        const ice = ["icespikes", "snowflake"];
        const lightning = ["lightningball", "staticelectricity"];
        const liquid = ["liquidsplash"];
        const magicsign = ["magicSign"];
        const marker = ["marker", "circleofstars", "energystrand"];
        const shieldfx = ["energyfieldtop", "shieldfiretop", "shieldicetop", "shieldearthtop", "shieldeldritchwebtop"];
        const tokenborder = ["staticborder", "spinningborder"];
        const fireball = ["fireballexplode"];
        switch (true) {
          case conditions.some((el) => v4Flags.animation === el):
            options2.menuType = "conditions";
            break;
          case creature.some((el) => v4Flags.animation === el):
            options2.menuType = "creature";
            break;
          case energy.some((el) => v4Flags.animation === el):
            options2.menuType = "energy";
            break;
          case fire.some((el) => v4Flags.animation === el):
            options2.menuType = "fire";
            break;
          case generic.some((el) => v4Flags.animation === el):
            options2.menuType = "generic";
            if (v4Flags.animation?.includes("outpulse")) {
              options2.variant = v4Flags.animation === "outpulse02" ? "02" : "01";
              v4Flags.animation = "outpulse";
            }
            break;
          case ice.some((el) => v4Flags.animation === el):
            options2.menuType = "ice";
            break;
          case lightning.some((el) => v4Flags.animation === el):
            options2.menuType = "lightning";
            break;
          case liquid.some((el) => v4Flags.animation === el):
            options2.menuType = "liquid";
            v4Flags.animation = "splash";
            break;
          case magicsign.some((el) => v4Flags.animation === el):
            options2.menuType = "magicsign";
            break;
          case marker.some((el) => v4Flags.animation === el):
            options2.menuType = "marker";
            if (v4Flags.animation === "circleofstars")
              ;
            else if (v4Flags.animation === "energystrand") {
              v4Flags.animation = "energystrand";
            } else {
              switch (v4Flags.variant) {
                case "03":
                  v4Flags.animation = "music";
                  v4Flags.variant = "01";
                  break;
                case "bubble":
                  v4Flags.animation = "bubble";
                  v4Flags.variant = "01";
                  break;
                case "energystrand":
                  v4Flags.animation = "energystrands";
                  v4Flags.variant = "01";
                  break;
                default:
                  v4Flags.animation = "standard";
                  v4Flags.variant = "01";
              }
            }
            break;
          case shieldfx.some((el) => v4Flags.animation === el):
            options2.menuType = "shieldfx";
            switch (v4Flags.animation) {
              case "energyfieldtop":
                v4Flags.animation = "energyfield";
                break;
              case "shieldfiretop":
                v4Flags.animation = "fire";
                break;
              case "shieldicetop":
                v4Flags.animation = "ice";
                break;
              case "shieldearthtop":
                v4Flags.animation = "earth";
                break;
              case "shieldeldritchwebtop":
                v4Flags.animation = "eldritchweb";
                break;
            }
            break;
          case tokenborder.some((el) => v4Flags.animation === el):
            options2.menuType = "tokenborder";
            if (v4Flags.animation === "staticborder") {
              v4Flags.animation = "static";
            } else {
              v4Flags.animation = "spinning";
            }
            break;
          case fireball.some((el) => v4Flags.animation === el):
            options2.menuType = "spell";
            v4Flags.animation = "fireball";
            options2.variant = "explode";
            break;
          default:
            options2.menuType = "spell";
        }
        if (v4Flags.explosions?.enable) {
          await convertExplosion(v4Flags.explosions);
        }
        delete options2.staticOptions;
        break;
      case "template":
        options2.menuType = options2.tempType === "rect" ? "square" : options2.tempType;
        switch (options2.menuType) {
          case "cone":
            if (v4Flags.animation === "breathweaponcone") {
              v4Flags.animation = "breathweapon";
            }
            break;
          case "circle":
            const circleTypes = ["dropct", "fearct", "heartct", "horrorct", "poisonct", "runesct", "shieldsct", "crackedshieldct", "skullct", "snowflakesct", "musicnotect"];
            if (circleTypes.some((el) => v4Flags.animation === el)) {
              v4Flags.animation = v4Flags.animation.replace("ct", "");
            }
            switch (v4Flags.animation) {
              case "outpulse01":
                v4Flags.animation = "outpulse";
                options2.variant = "01";
                break;
              case "outpulse02":
                v4Flags.animation = "outpulse";
                options2.variant = "02";
                break;
              case "fireballloop":
                v4Flags.animation = "fireball";
                options2.variant = options2.variant === "nodebris" ? "nodebris" : "loop";
                break;
              case "fireballexplode":
                v4Flags.animation = "fireball";
                options2.variant = "explode";
                break;
            }
            break;
          case "square":
            const squareTypes = ["dropct", "fearct", "heartct", "horrorct", "poisonct", "runesct", "shieldsct", "crackedshieldct", "skullct", "snowflakesct"];
            if (squareTypes.some((el) => v4Flags.animation === el)) {
              v4Flags.animation = v4Flags.animation.replace("ct", "");
            } else if (v4Flags.animation === "musicnotest") {
              v4Flags.animation = "musicnote";
            }
            break;
          case "ray":
            if (v4Flags.animation === "breathweaponline") {
              v4Flags.animation = "breathweapon";
            }
            break;
        }
        break;
      case "aura":
        switch (v4Flags.animation) {
          case "energystrand":
            options2.menuType = "marker";
            break;
          case "dodecahedron":
            options2.menuType = "energy";
            break;
          case "staticelectricity":
            options2.menuType = "lightning";
            break;
          default:
            options2.menuType = "spell";
        }
        break;
      case "preset":
        switch (v4Flags.animation) {
          case "teleportation":
            options2.menuType = "spell";
            options2.menuType02 = "spell";
            break;
          case "dualattach":
            switch (options2.name) {
              case "energystrand":
              case "energybeam":
                options2.menuType = "generic";
                break;
              default:
                options2.menuType = "spell";
            }
            break;
          case "fireball":
            const fire2 = ["eruption"];
            const generic2 = ["boulderimpact", "explosion", "impact", "outpulse01", "outpulse02"];
            const ice2 = ["snowflake"];
            const liquid2 = ["liquidsplash"];
            const fireball2 = ["fireballexplode"];
            const fireSettings = v4Flags.fireball || {};
            switch (fireSettings.projectile) {
              case "energystrand":
              case "energybeam":
                fireSettings.rangeType = "generic";
                break;
              default:
                fireSettings.rangeType = "spell";
            }
            if (fireSettings.explosion01) {
              switch (true) {
                case fire2.some((el) => fireSettings.explosion01 === el):
                  fireSettings.ex01Type = "fire";
                  break;
                case generic2.some((el) => fireSettings.explosion01 === el):
                  fireSettings.ex01Type = "generic";
                  if (fireSettings.explosion01?.includes("outpulse")) {
                    fireSettings.explosion01 = "outpulse";
                    fireSettings.explosion01Variant = fireSettings.explosion01Variant === "outpulse02" ? "02" : "01";
                  }
                  break;
                case ice2.some((el) => fireSettings.explosion01 === el):
                  fireSettings.ex01Type = "ice";
                  break;
                case liquid2.some((el) => fireSettings.explosion01 === el):
                  fireSettings.ex01Type = "liquid";
                  fireSettings.explosion01 = "splash";
                  break;
                case fireball2.some((el) => fireSettings.explosion01 === el):
                  fireSettings.ex01Type = "spell";
                  fireSettings.explosion01 = "fireball";
                  fireSettings.explosion01Variant = "explode";
                  break;
                default:
                  if (fireSettings.explosion01 === "a1" || !fireSettings.explosion01) {
                    fireSettings.ex01Type === "";
                  } else {
                    fireSettings.ex01Type = "spell";
                  }
              }
            }
            if (fireSettings.explosion02) {
              switch (true) {
                case fire2.some((el) => fireSettings.explosion02 === el):
                  fireSettings.ex02Type = "fire";
                  break;
                case generic2.some((el) => fireSettings.explosion02 === el):
                  fireSettings.ex02Type = "generic";
                  if (fireSettings.explosion02?.includes("outpulse")) {
                    fireSettings.explosion02 = "outpulse";
                    fireSettings.explosion02Variant = fireSettings.explosion02Variant === "outpulse02" ? "02" : "01";
                  }
                  break;
                case ice2.some((el) => fireSettings.explosion02 === el):
                  fireSettings.ex02Type = "ice";
                  break;
                case liquid2.some((el) => fireSettings.explosion02 === el):
                  fireSettings.ex02Type = "liquid";
                  fireSettings.explosion02 = "splash";
                  break;
                case fireball2.some((el) => fireSettings.explosion02 === el):
                  fireSettings.ex02Type = "spell";
                  fireSettings.explosion02 = "fireball";
                  fireSettings.explosion02Variant = "explode";
                  break;
                default:
                  if (fireSettings.explosion02 === "a1" || !fireSettings.explosion02) {
                    fireSettings.ex02Type === "";
                  } else {
                    fireSettings.ex02Type = "spell";
                  }
              }
            }
            break;
        }
        break;
    }
    async function convertExplosion(flags2) {
      if (flags2.enableCustom) {
        return;
      } else {
        const fire = ["eruption"];
        const generic = ["boulderimpact", "explosion", "impact", "outpulse01", "outpulse02"];
        const ice = ["snowflake"];
        const liquid = ["liquidsplash"];
        const fireball = ["fireballexplode"];
        switch (true) {
          case fire.some((el) => flags2.animation === el):
            flags2.menuType = "fire";
            break;
          case generic.some((el) => flags2.animation === el):
            flags2.menuType = "generic";
            if (flags2.animation?.includes("outpulse")) {
              flags2.animation = "outpulse";
              flags2.variant = flags2.variant === "outpulse02" ? "02" : "01";
            }
            break;
          case ice.some((el) => flags2.animation === el):
            flags2.menuType = "ice";
            break;
          case liquid.some((el) => flags2.animation === el):
            flags2.menuType = "liquid";
            flags2.animation = "splash";
            break;
          case fireball.some((el) => flags2.animation === el):
            flags2.menuType = "spell";
            flags2.animation = "fireball";
            flags2.variant = "explode";
            break;
          default:
            if (flags2.animation === "a1" || !flags2.animation) {
              flags2.menuType === "";
            } else {
              flags2.menuType = "spell";
            }
        }
      }
      return flags2;
    }
  }
  async function convertExtraFX(flags2) {
    const generic = ["explosion", "impact"];
    const ice = ["icespikes", "snowflake"];
    const fireball = ["fireballexplode"];
    switch (true) {
      case flags2.name?.includes("dizzystars"):
        flags2.menuType = "conditions";
        break;
      case flags2.name?.includes("eruption"):
        flags2.menuType = "fire";
        break;
      case generic.some((el) => flags2.name === el):
        flags2.menuType = "generic";
        break;
      case ice.some((el) => flags2.name === el):
        flags2.menuType = "ice";
        break;
      case flags2.name?.includes("liquidsplash"):
        flags2.menuType = "liquid";
        flags2.name = "splash";
        break;
      case flags2.name?.includes("magicSign"):
        flags2.menuType = "magicsign";
        switch (flags2.color) {
          case "blue":
            flags2.name = "abjuration";
            break;
          case "yellow":
            flags2.name = "conjuration";
            break;
          default:
            flags2.name = "divination";
        }
        flags2.variant = "01";
        break;
      case flags2.name?.includes("marker"):
        flags2.menuType = "marker";
        if (flags2.name === "circleofstars")
          ;
        else if (flags2.name === "energystrand") {
          flags2.name = "energystrand";
        } else {
          switch (flags2.variant) {
            case "03":
              flags2.name = "music";
              flags2.variant = "01";
              break;
            case "bubble":
              flags2.name = "bubble";
              flags2.variant = "01";
              break;
            case "energystrand":
              flags2.name = "energystrands";
              flags2.variant = "01";
              break;
            default:
              flags2.name = "standard";
              flags2.variant = "01";
          }
        }
        break;
      case fireball.some((el) => flags2.name === el):
        flags2.menuType = "spell";
        flags2.name = "fireball";
        flags2.variant = "explode";
        break;
      default:
        flags2.menuType = "spell";
    }
  }
  v4Flags.version = 4;
  return v4Flags;
}
async function version05(flags, isActiveEffect) {
  if (!flags) {
    console.error("Automated Animations | Critical A-A Flag Errors found in version 05 merge. Removing A-A flags from item");
    await item.update({ "flags.-=autoanimations": null });
    return;
  }
  const v4Flags = flags || {};
  if (v4Flags.killAnim && !v4Flags.macro?.enable && !v4Flags.audio?.a01?.enable) {
    const v5Flags = {
      isEnabled: false,
      isCustomized: false,
      fromAmmo: false,
      version: 5
    };
    custom_warning("Item is Disabled, and no Macro or Sound is set to play");
    return v5Flags;
  } else if (!v4Flags.killAnim && !v4Flags.override) {
    custom_warning("Item is enabled but not customized, delete flags");
    return void 0;
  } else if (v4Flags.override && v4Flags.animType !== "preset" && !v4Flags.options?.enableCustom && (!v4Flags.animType || !v4Flags.options?.menuType || !v4Flags.animation || !v4Flags.options?.variant || !v4Flags.color)) {
    custom_warning("Item is customized but has critical errors in the Primary Animation settings. Delete flags");
    return void 0;
  } else if (v4Flags.autoOverride?.enable) {
    custom_warning("Item was set to old Auto-Override, delete flags");
    return void 0;
  } else if (v4Flags.killAnim && (v4Flags.macro?.enable || v4Flags.audio?.a01?.enable)) {
    const v5Flags = {};
    await convertV6(v4Flags, v5Flags, "melee");
    if (v4Flags.macro?.enable) {
      v5Flags.macro.playWhen = "2";
    }
    if (v4Flags.audio?.a01?.enable) {
      v5Flags.soundOnly.sound = v5Flags.primary.sound;
    }
    custom_warning("Item was Disabled and either a Macro or Sound is set to play, reorganizing flags");
    return v5Flags;
  } else {
    const type = v4Flags.animType === "static" ? "ontoken" : v4Flags.animType === "template" ? "templatefx" : v4Flags.animType;
    const v5Flags = {};
    if (isActiveEffect) {
      await routeActiveEffect(v4Flags, v5Flags);
    } else {
      switch (type) {
        case "preset":
          await routePreset(v4Flags, v5Flags);
          break;
        default:
          await convertV6(v4Flags, v5Flags, type);
          break;
      }
    }
    v5Flags.version = 5;
    custom_warning(`Automated Animations | Version 5 Flag Migration Complete`, false, v5Flags);
    return v5Flags;
  }
  async function convertV6(oldMO, newMO, type) {
    let {
      animLevel,
      animType,
      animation,
      audio,
      autoOverride,
      color,
      explosions,
      killAnim,
      levels3d: levels3d2,
      macro: macro2,
      meleeSwitch: meleeSwitch2,
      options: options2,
      override,
      preview,
      sourceToken,
      targetToken
    } = oldMO;
    newMO.id = uuidv4();
    newMO.isEnabled = true;
    newMO.isCustomized = true;
    newMO.fromAmmo = options2?.ammo ?? false;
    if (type !== "aura" && type !== "templatefx") {
      newMO.levels3d = await new3d(oldMO);
    }
    newMO.macro = macro2 || {};
    if (type === "melee") {
      newMO.meleeSwitch = compileMeleeSwitch(oldMO);
    }
    newMO.menu = type;
    newMO.primary = {
      options: convertOptionsV6(oldMO, type),
      sound: setSound(audio, "a01"),
      video: {
        dbSection: setDBSection(type),
        menuType: options2?.menuType,
        animation,
        variant: options2?.variant,
        color,
        enableCustom: options2?.enableCustom ?? false,
        customPath: options2?.customPath ?? ""
      }
    };
    newMO.secondary = await convertExplosionV6(explosions, audio, oldMO);
    const primaryVideo = newMO.primary.video;
    if (!primaryVideo.menuType || !primaryVideo.animation || !primaryVideo.variant || !primaryVideo.color) {
      resetVideo(newMO.primary.video, type);
    }
    newMO.soundOnly = {
      sound: setSound({}, "a01", true)
    };
    newMO.source = convertSourceFX(sourceToken, audio);
    newMO.target = convertTargetFX(targetToken, audio);
    return newMO;
  }
  function setSound(audio = {}, section2 = "a01", rebase = false) {
    if (rebase) {
      return {
        delay: 0,
        enable: false,
        file: "",
        startTime: 0,
        repeat: 1,
        repeatDelay: 250,
        volume: 1
      };
    } else {
      return {
        delay: audio?.[section2]?.delay ?? 0,
        enable: audio?.[section2]?.enable ?? false,
        file: audio?.[section2]?.file ?? "",
        startTime: audio?.[section2]?.startTime ?? 0,
        volume: audio?.[section2]?.volume ?? 1,
        repeat: 1,
        repeatDelay: 250
      };
    }
  }
  function setDBSection(type) {
    return type === "aura" || type === "ontoken" ? "static" : type;
  }
  function convertSourceFX(extraFX, audio, section2) {
    const oldData = extraFX || {};
    const data2 = {
      enable: oldData.enable ?? false,
      options: {
        addTokenWidth: false,
        anchor: "0.5",
        delay: oldData.delayAfter ?? 0,
        elevation: oldData.animLevel ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isWait: true,
        isMasked: false,
        isRadius: false,
        opacity: oldData.opacity ?? 1,
        repeat: oldData.loops ?? 1,
        repeatDelay: oldData.loopDelay ?? 250,
        size: oldData.scale ?? 1,
        zIndex: 1
      },
      sound: setSound(audio, "s01"),
      video: {
        dbSection: "static",
        menuType: oldData.menuType,
        animation: oldData.name,
        variant: oldData.variant,
        color: oldData.color,
        enableCustom: oldData.enableCustom ?? false,
        customPath: oldData.customPath ?? ""
      }
    };
    let video2 = data2.video;
    if (!video2.menuType || !video2.animation || !video2.variant || !video2.color) {
      resetVideo(data2.video, "static");
    }
    return data2;
  }
  function convertTargetFX(extraFX, audio, section2) {
    const oldData = extraFX || {};
    const data2 = {
      enable: oldData.enable ?? false,
      options: {
        addTokenWidth: false,
        anchor: "0.5",
        delay: oldData.delayStart ?? 0,
        elevation: oldData.animLevel ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: false,
        isRadius: false,
        opacity: oldData.opacity ?? 1,
        persistent: oldData.persistent ?? false,
        repeat: oldData.loops ?? 1,
        repeatDelay: oldData.loopDelay ?? 250,
        size: oldData.scale ?? 1,
        unbindAlpha: false,
        unbindVisibility: false,
        zIndex: 1
      },
      sound: setSound(audio, "t01"),
      video: {
        dbSection: "static",
        menuType: oldData.menuType,
        animation: oldData.name,
        variant: oldData.variant,
        color: oldData.color,
        enableCustom: oldData.enableCustom ?? false,
        customPath: oldData.customPath ?? ""
      }
    };
    let video2 = data2.video;
    if (!video2.menuType || !video2.animation || !video2.variant || !video2.color) {
      resetVideo(data2.video, "static");
    }
    return data2;
  }
  function compileMeleeSwitch(oldMO) {
    let oldData = oldMO.meleeSwitch || {};
    let audio = oldMO.audio || {};
    const data2 = {
      video: {
        dbSection: "range",
        menuType: oldData.menuType,
        animation: oldData.animation,
        variant: oldData.variant,
        color: oldData.color,
        enableCustom: false,
        customPath: ""
      },
      sound: setSound(audio, "a02"),
      options: {
        detect: oldData.detect || "automatic",
        range: oldData.range || 2,
        isReturning: oldData.returning ?? false,
        switchType: oldData.switchType || "on"
      }
    };
    const switchVideo = data2.video;
    if (!switchVideo.menuType || !switchVideo.animation || !switchVideo.variant || !switchVideo.color) {
      resetVideo(data2.video, "range");
    }
    return data2;
  }
  function convertOptionsV6(oldMO, type) {
    const data2 = {};
    const options2 = oldMO.options || {};
    switch (type) {
      case "melee":
        data2.delay = 0;
        data2.elevation = oldMO.animLevel ? 0 : 1e3;
        data2.isWait = false;
        data2.opacity = 1;
        data2.repeat = options2.repeat ?? 1;
        data2.repeatDelay = options2.delay ?? 0;
        data2.size = options2.scale ?? 1;
        data2.zIndex = 1;
        break;
      case "range":
        data2.delay = 0;
        data2.elevation = oldMO.below ? 0 : 1e3;
        data2.isReturning = false;
        data2.isWait = false;
        data2.onlyX = options2.onlyX ?? false;
        data2.opacity = options2.opacity ?? 1;
        data2.repeat = options2.repeat ?? 1;
        data2.repeatDelay = options2.delay ?? 0;
        data2.zIndex = options2.zIndex ?? 1;
        break;
      case "ontoken":
        data2.addTokenWidth = false;
        data2.anchor = "0.5";
        data2.delay = 0;
        data2.elevation = oldMO.below ? 0 : 1e3;
        data2.fadeIn = 250;
        data2.fadeOut = 500;
        data2.isMasked = false;
        data2.isRadius = false;
        data2.isWait = false;
        data2.opacity = options2.opacity ?? 1;
        data2.persistent = options2.persistent ?? false;
        data2.playOn = options2.staticType === "targetDefault" ? "default" : options2.staticType === "sourceTarget" ? "both" : !options2.staticType ? "default" : options2.staticType;
        data2.repeat = options2.repeat ?? 1;
        data2.repeatDelay = options2.delay ?? 0;
        data2.size = options2.scale ?? 1;
        data2.unbindAlpha = options2.unbindAlpha ?? false;
        data2.unbindVisibility = options2.unbindVisibility ?? false;
        data2.zIndex = options2.zIndex ?? 1;
        break;
      case "templatefx":
        data2.delay = 0;
        data2.elevation = oldMO.below ? 0 : 1e3;
        data2.isMasked = false;
        data2.isWait = false;
        data2.occlusionAlpha = options2.occlusionAlpha ?? 0;
        data2.occlusionMode = options2.occlusionMode ?? 0;
        data2.opacity = options2.opacity ?? 1;
        data2.persistent = options2.persistent ?? false;
        data2.persistType = options2.persistType || "sequencerground";
        data2.removeTemplate = options2.removeTemplate ?? 1;
        data2.repeat = options2.repeat ?? 1;
        data2.repeatDelay = options2.delay ?? 0;
        data2.rotate = 0;
        data2.scale = `${options2.scaleX ?? 1}, ${options2.scaleY ?? 1}`;
        data2.zIndex = options2.zIndex ?? 1;
        break;
      case "aura":
        data2.addTokenWidth = options2.addTokenWidth ?? false;
        data2.alpha = false, data2.alphaMax = 0.5, data2.alphaMin = -0.5, data2.alphaDuration = 1e3, data2.breath = false, data2.breathMax = 1.05, data2.breathMin = 0.95, data2.breathDuration = 1e3, data2.delay = 0;
        data2.elevation = options2.below ? 0 : 1e3;
        data2.fadeIn = 250;
        data2.fadeOut = 500;
        data2.playOn = options2.ignoreTarget ? "source" : "default";
        data2.isRadius = true;
        data2.isWait = false;
        data2.opacity = options2.opacity ?? 1;
        data2.size = options2.auraRadius ?? 3;
        data2.tint = false, data2.tintColor = "#FFFFFF", data2.tintSaturate = 0, data2.unbindAlpha = options2.unbindAlpha ?? false;
        data2.unbindVisibility = options2.unbindVisibility ?? false;
        data2.zIndex = options2.zIndex ?? 1;
        break;
    }
    return data2;
  }
  async function new3d(oldData) {
    let newData = oldData.levels3d || {};
    let { type, addExplosion, ...rest } = newData;
    const data3d = {
      enable: type ? true : false,
      type: type || "",
      data: rest || {},
      secondary: {
        enable: addExplosion?.enable ?? false,
        data: addExplosion || {}
      },
      sound: setSound({}, "a01", true)
    };
    return data3d;
  }
  function resetVideo(data2, type) {
    switch (type) {
      case "melee":
        data2.menuType = "weapon";
        data2.animation = "dagger";
        data2.variant = "01";
        data2.color = "white";
        break;
      case "range":
        data2.menuType = "weapon";
        data2.animation = "arrow";
        data2.variant = "regular";
        data2.color = "regular";
        break;
      case "templatefx":
        data2.menuType = "circle";
        data2.animation = "calllightning";
        data2.variant = "01";
        data2.color = "blue";
        break;
      default:
        data2.menuType = "spell";
        data2.animation = "curewounds";
        data2.variant = "01";
        data2.color = "blue";
    }
  }
  async function convertExplosionV6(exp, audio, oldMO) {
    let data2 = {
      enable: exp?.enable ?? false,
      options: {
        addTokenWidth: false,
        anchor: "0.5",
        delay: exp?.delay ?? 250,
        elevation: exp?.below ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: exp?.isMasked ?? false,
        isRadius: true,
        isWait: false,
        opacity: 1,
        repeat: oldMO.options?.repeat ?? 1,
        repeatDelay: oldMO.delay ?? 0,
        size: exp?.radius ?? 1.5,
        zIndex: 1
      },
      sound: setSound(audio, "e01"),
      video: {
        dbSection: "static",
        menuType: exp?.menuType,
        animation: exp?.animation,
        variant: exp?.variant,
        color: exp?.color,
        enableCustom: exp?.enableCustom ?? false,
        customPath: exp?.customPath ?? ""
      }
    };
    const video2 = data2.video;
    if (!video2.menuType || !video2.animation || !video2.variant || !video2.color) {
      data2.video.menuType = "spell";
      data2.video.animation = "curewounds";
      data2.video.variant = "01";
      data2.video.color = "blue";
    }
    return data2;
  }
  async function routePreset(oldMO, newMO) {
    let current;
    switch (oldMO.animation) {
      case "teleportation":
        current = await updateTele(oldMO, newMO);
        return current;
      case "dualattach":
        current = await updateDAttach(oldMO, newMO);
        return current;
      case "fireball":
        current = await updateFireball(oldMO, newMO);
        return current;
      case "thunderwave":
        current = await updateThunderwave(oldMO, newMO);
        return current;
      default:
        return "deleteFlags";
    }
  }
  async function updateDAttach(oldData, newData) {
    let { animLevel, animType, animation, audio, color, killAnim, macro: macro2, options: options2, override, sourceToken, targetToken } = oldData;
    newData.id = uuidv4();
    newData.isEnabled = true;
    newData.isCustomized = true;
    newData.fromAmmo = options2?.ammo ?? false;
    newData.menu = "preset";
    newData.presetType = "dualattach";
    newData.macro = macro2 || {};
    newData.data = {
      video: {
        dbSection: "range",
        menuType: options2?.menuType,
        animation: options2?.name,
        variant: options2?.variant,
        color,
        enableCustom: options2?.enableCustom ?? false,
        customPath: options2?.customPath ?? ""
      },
      options: {
        playbackRate: options2?.playbackRate,
        onlyX: options2?.onlyX ?? false,
        elevation: animLevel ? 0 : 1e3,
        opacity: 1
      },
      sound: setSound(audio, "a01")
    };
    if (!newData.data.video.menuType || !newData.data.video.animation || !newData.data.video.variant || !newData.data.video.color) {
      resetVideo(newData.data.video, "range");
    }
    newData.soundOnly = {
      sound: setSound({}, "a01", true)
    };
    return newData;
  }
  async function updateFireball(oldData, newData) {
    newData.data = {};
    const root = newData.data;
    let { animLevel, animType, animation, audio, killAnim, macro: macro2, options: options2, override, sourceToken, targetToken } = oldData;
    let fireballData = oldData.fireball || {};
    let {
      afterEffect,
      afterEffectPath,
      ex01Type,
      ex02Type,
      explosion01,
      explosion01Color,
      explosion01Delay,
      explosion01Repeat,
      explosion01Scale,
      explosion01Variant,
      explosion02,
      explosion02Color,
      explosion02Delay,
      explosion02Repeat,
      explosion02Scale,
      explosion02Variant,
      projectile,
      projectileColor,
      projectileDelay,
      projectileRepeat,
      projectileVariant,
      rangeType,
      wait01,
      wait02,
      wait03
    } = fireballData;
    newData.id = uuidv4();
    newData.isEnabled = true;
    newData.isCustomized = true;
    newData.fromAmmo = options2?.ammo ?? false;
    newData.menu = "preset";
    newData.presetType = "proToTemp";
    newData.macro = macro2 || {};
    root.projectile = {
      dbSection: "range",
      menuType: rangeType,
      animation: projectile,
      variant: projectileVariant,
      color: projectileColor,
      options: {
        repeat: projectileRepeat ?? 1,
        repeatDelay: projectileDelay ?? 250,
        wait: wait01,
        elevation: animLevel ? 0 : 1e3,
        removeTemplate: oldData?.options?.removeTemplate ?? false
      },
      sound: setSound(audio, "a01")
    };
    if (!root.projectile.menuType || !root.projectile.animation || !root.projectile.variant || !root.projectile.color) {
      resetVideo(root.projectile, "range");
    }
    root.preExplosion = {
      dbSection: "static",
      menuType: ex01Type,
      animation: explosion01,
      variant: explosion01Variant,
      color: explosion01Color,
      options: {
        repeat: explosion01Repeat,
        repeatDelay: explosion01Delay,
        scale: explosion01Scale,
        wait: wait02,
        elevation: animLevel ? 0 : 1e3
      },
      sound: setSound(audio, "e01")
    };
    if (!root.preExplosion.menuType || !root.preExplosion.animation || !root.preExplosion.variant || !root.preExplosion.color) {
      root.preExplosion.enable = false;
      resetVideo(root.preExplosion, "static");
    } else {
      root.preExplosion.enable = true;
    }
    root.explosion = {
      dbSection: "static",
      menuType: ex02Type,
      animation: explosion02,
      variant: explosion02Variant,
      color: explosion02Color,
      options: {
        elevation: animLevel ? 0 : 1e3,
        repeat: explosion02Repeat,
        repeatDelay: explosion02Delay,
        scale: explosion02Scale,
        wait: -500
      },
      sound: setSound(audio, "e02")
    };
    if (!root.explosion.menuType || !root.explosion.animation || !root.explosion.variant || !root.explosion.color) {
      resetVideo(root.explosion, "static");
    }
    root.afterImage = {
      enable: afterEffect,
      customPath: afterEffectPath,
      options: {
        elevation: 0,
        persistent: false,
        scale: 1
      }
    };
    newData.soundOnly = {
      sound: setSound({}, "a01", true)
    };
    newData.secondary = {
      enable: false,
      options: {
        addTokenWidth: false,
        delay: 250,
        elevation: 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: false,
        isRadius: true,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 0,
        size: 1.5,
        zIndex: 1
      },
      sound: setSound(audio, "e01"),
      video: {
        dbSection: "static",
        menuType: "spell",
        animation: "curewounds",
        variant: "01",
        color: "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newData.target = newExtraFX();
    return newData;
  }
  async function updateTele(oldData, newData) {
    newData.data = {};
    const root = newData.data;
    let { animLevel, animType, animation, audio, color, color02, killAnim, macro: macro2, options: options2, override } = oldData;
    newData.id = uuidv4();
    newData.isEnabled = true;
    newData.isCustomized = true;
    newData.fromAmmo = options2?.ammo ?? false;
    newData.menu = "preset";
    newData.presetType = "teleportation";
    newData.macro = macro2 || {};
    root.options = {
      alpha: 0,
      delayFade: 750,
      delayMove: 1e3,
      delayReturn: options2?.delay ?? 250,
      hideFromPlayers: options2?.hideFromPlayers ?? false,
      measureType: options2?.measureType ?? "alternating",
      range: options2?.teleDist ?? 30,
      speed: 120,
      teleport: true
    };
    root.sound = setSound(audio, "a01");
    root.start = {
      dbSection: "static",
      enable: true,
      menuType: options2?.menuType,
      animation: options2?.name,
      variant: options2?.variant,
      color,
      enableCustom: options2.enableCustom ?? false,
      customPath: options2.customPath ?? "",
      options: {
        delay: 0,
        elevation: animLevel ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 250,
        isMasked: false,
        opacity: 1,
        isRadius: false,
        size: options2?.scale || 1.5
      }
    };
    root.between = {
      dbSection: "range",
      enable: false,
      menuType: "weapon",
      animation: "arrow",
      variant: "regular",
      color: "regular",
      options: {
        delay: 0,
        enable: false,
        elevation: 1e3,
        opacity: 1,
        playbackRate: 1
      }
    };
    root.end = {
      dbSection: "static",
      enable: true,
      menuType: options2?.menuType02,
      animation: options2?.name02,
      variant: options2?.variant02,
      color: color02,
      enableCustom: options2?.enableCustom02 ?? false,
      customPath: options2?.customPath02 ?? "",
      options: {
        delay: 500,
        elevation: animLevel ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 250,
        isMasked: false,
        isRadius: false,
        opacity: 1,
        size: options2?.scale02 ?? 1
      }
    };
    if (!root.start.menuType || !root.start.animation || !root.start.variant || !root.start.color) {
      resetVideo(root.start, "static");
    }
    if (!root.end.menuType || !root.end.animation || !root.end.variant || !root.end.color) {
      resetVideo(root.end, "static");
    }
    newData.soundOnly = {
      sound: setSound({}, "a01", true)
    };
    return newData;
  }
  async function updateThunderwave(oldData, newData) {
    let { animLevel, animType, animation, audio, color, killAnim, macro: macro2, options: options2, override } = oldData;
    newData.id = uuidv4();
    newData.isEnabled = true;
    newData.isCustomized = true;
    newData.fromAmmo = options2?.ammo ?? false;
    newData.menu = "preset";
    newData.presetType = "thunderwave";
    newData.macro = macro2 || {};
    newData.data = {
      video: {
        dbSection: "templatefx",
        menuType: "square",
        animation: "thunderwave",
        variant: "mid",
        color: color || "blue"
      },
      options: {
        elevation: animLevel ? 0 : 1e3,
        repeat: options2?.repeat ?? 1,
        repeatDelay: options2?.delay ?? 250,
        opacity: options2?.opacity ?? 1,
        removeTemplate: options2?.removeTemplate ?? false
      },
      sound: setSound(audio, "a01")
    };
    newData.soundOnly = {
      sound: setSound({}, "a01", true)
    };
    return newData;
  }
  async function routeActiveEffect(oldMO, newMO) {
    let current;
    switch (oldMO.animType) {
      case "static":
        current = await convertAEOnToken(oldMO, newMO);
        return current;
      case "aura":
        current = await convertAEAura(oldMO, newMO);
        return current;
      case "preset":
        switch (oldMO.animation) {
          case "bless":
            current = await convertAEBless(oldMO, newMO);
            return current;
          case "shieldspell":
            current = await convertAEShield(oldMO, newMO);
            return current;
        }
    }
  }
  function newExtraFX() {
    const data2 = {
      enable: false,
      options: {
        addTokenWidth: false,
        delay: 0,
        elevation: 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: false,
        isRadius: false,
        isWait: true,
        opacity: 1,
        repeat: 1,
        repeatDelay: 250,
        size: 1,
        zIndex: 1
      },
      sound: setSound({}, "a01", true),
      video: {
        dbSection: "static",
        menuType: "spell",
        animation: "curewounds",
        variant: "01",
        color: "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    return data2;
  }
  async function convertAEOnToken(oldMO, newMO) {
    let { animLevel, animation, audio, color, explosions, macro: macro2, options: options2 } = oldMO;
    newMO.id = uuidv4();
    newMO.isEnabled = true;
    newMO.isCustomized = true;
    newMO.activeEffectType = "ontoken";
    newMO.primary = {
      options: {
        addTokenWidth: false,
        elevation: animLevel ? 0 : 1e3,
        delay: 0,
        isMasked: false,
        isRadius: false,
        isWait: false,
        opacity: options2?.opacity ?? 1,
        persistent: options2?.persistent ?? false,
        playOn: "source",
        repeat: options2?.repeat ?? 1,
        repeatDelay: options2?.delay || 250,
        size: options2?.scale || 1,
        unbindAlpha: options2?.unbindAlpha ?? false,
        unbindVisibility: options2?.unbindVisibility ?? false,
        zIndex: 1
      },
      sound: setSound(audio, "a01"),
      video: {
        animation,
        color,
        customPath: options2?.customPath ?? "",
        dbSection: "static",
        enableCustom: options2?.enableCustom ?? false,
        menuType: options2?.menuType,
        variant: options2?.variant
      }
    };
    const newVideo = newMO.primary.video;
    if (!newVideo.menuType || !newVideo.animation || !newVideo.variant || !newVideo.color) {
      resetVideo(newMO.primary.video);
    }
    newMO.macro = macro2 || {};
    newMO.menu = "aefx";
    newMO.secondary = await convertExplosionV6(explosions, audio, oldMO);
    newMO.soundOnly = {
      sound: setSound({}, "a01", true)
    };
    newMO.source = newExtraFX();
    return newMO;
  }
  async function convertAEAura(oldMO, newMO) {
    let { animLevel, animType, animation, audio, color, macro: macro2, options: options2 } = oldMO;
    newMO.id = uuidv4();
    newMO.isEnabled = true;
    newMO.isCustomized = true;
    newMO.activeEffectType = "ontoken";
    newMO.menu = "aefx";
    newMO.secondary = {
      enable: false,
      options: {},
      sound: setSound({}, "a01", true),
      video: {
        dbSection: "static",
        menuType: "spell",
        animation: "curewounds",
        variant: "01",
        color: "blue"
      }
    };
    newMO.primary = {
      options: {
        addTokenWidth: false,
        alpha: false,
        alphaMax: 0.5,
        alphaMin: -0.5,
        alphaDuration: 1e3,
        breath: false,
        breathMax: 1.05,
        breathMin: 0.95,
        breathDuration: 1e3,
        delay: 0,
        elevation: animLevel ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isRadius: true,
        isWait: true,
        opacity: options2?.opacity || 1,
        playOn: "source",
        size: options2?.auraRadius || 3,
        tint: false,
        tintColor: "#FFFFFF",
        tintSaturate: 0,
        unbindAlpha: options2?.unbindAlpha ?? false,
        unbindVisibility: options2?.unbindVisibility ?? false,
        zIndex: 1
      },
      sound: setSound(audio, "a01"),
      video: {
        animation,
        color,
        customPath: options2?.customPath || "",
        dbSection: "static",
        enableCustom: options2?.enableCustom ?? false,
        menuType: options2?.menuType,
        variant: options2?.variant
      }
    };
    const newVideo = newMO.primary.video;
    if (!newVideo.menuType || !newVideo.animation || !newVideo.variant || !newVideo.color) {
      resetVideo(newMO.primary.video);
    }
    newMO.macro = macro2 || {};
    newMO.soundOnly = {
      sound: setSound({}, "a01", true)
    };
    newMO.source = newExtraFX();
    return newMO;
  }
  async function convertAEBless(oldMO, newMO) {
    let { animLevel, animType, animation, audio, color, macro: macro2, options: options2 } = oldMO;
    newMO.id = uuidv4();
    newMO.isEnabled = true;
    newMO.isCustomized = true;
    newMO.activeEffectType = "ontoken";
    newMO.menu = "aefx";
    newMO.macro = macro2 || {};
    newMO.primary = {
      options: {
        addTokenWidth: false,
        delay: 0,
        elevation: animLevel ? 0 : 1e3,
        fadeIn: 0,
        fadeOut: 500,
        isMasked: false,
        isRadius: false,
        isWait: true,
        opacity: 1,
        persistent: options2?.persistent ?? false,
        playOn: "source",
        repeat: 1,
        repeatDelay: 250,
        size: options2?.scale || 1,
        unbindAlpha: options2?.unbindAlpha ?? false,
        unbindVisibility: options2?.unbindVisibility ?? false,
        zIndex: 1
      },
      sound: setSound({}, "a01", true),
      video: {
        dbSection: "static",
        menuType: "spell",
        animation: "bless",
        variant: "loop",
        color: color || "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newMO.secondary = {
      enable: false,
      options: {},
      sound: setSound({}, "a01", true),
      video: {
        dbSection: "static",
        menuType: "spell",
        animation: "curewounds",
        variant: "01",
        color: "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newMO.soundOnly = {
      sound: setSound({}, "a01", true)
    };
    newMO.source = {
      enable: true,
      options: {
        addTokenWidth: false,
        delay: -500,
        elevation: animLevel ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: false,
        isRadius: false,
        isWait: true,
        opacity: 1,
        repeat: 1,
        repeatDelay: 250,
        size: options2?.scale || 1,
        zIndex: 1
      },
      sound: setSound(audio, "a01"),
      video: {
        dbSection: "static",
        menuType: "spell",
        animation: "bless",
        variant: "intro",
        color: color || "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    return newMO;
  }
  async function convertAEShield(oldMO, newMO) {
    let { animLevel, animType, animation, audio, color, macro: macro2, options: options2 } = oldMO;
    newMO.id = uuidv4();
    newMO.isEnabled = true;
    newMO.isCustomized = true;
    newMO.activeEffectType = "ontoken";
    newMO.menu = "aefx";
    newMO.primary = {
      options: {
        isWait: true,
        delay: -1e3,
        elevation: animLevel ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 0,
        isMasked: false,
        isRadius: false,
        opacity: 1,
        persistent: options2?.persistent || false,
        repeat: 1,
        repeatDelay: 250,
        size: options2?.scale ?? 1,
        playOn: "source",
        unbindAlpha: options2?.unbindAlpha ?? false,
        unbindVisibility: options2?.unbindVisibility ?? false,
        zIndex: 1
      },
      sound: setSound({}, "a01", true),
      video: {
        dbSection: "static",
        menuType: "shieldspell",
        animation: "loop",
        variant: options2?.variant || "01",
        color: color || "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newMO.source = {
      enable: true,
      options: {
        delay: -500,
        elevation: animLevel ? 0 : 1e3,
        fadeIn: 500,
        fadeOut: 0,
        isRadius: false,
        isWait: true,
        mask: false,
        repeat: 1,
        repeatDelay: 250,
        size: options2?.scale || 1
      },
      sound: setSound(audio, "a01"),
      video: {
        dbSection: "static",
        menuType: "shieldspell",
        animation: "intro",
        variant: options2?.variant || "01",
        color: color || "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newMO.secondary = {
      enable: true,
      options: {
        delay: 0,
        elevation: animLevel ? 0 : 1e3,
        isMasked: false,
        isRadius: false,
        isWait: false,
        repeat: 1,
        repeatDelay: 250,
        size: options2?.scale || 1,
        opacity: 1,
        zIndex: 1
      },
      sound: setSound({}, "a01", true),
      video: {
        dbSection: "static",
        menuType: "shieldspell",
        animation: options2?.shieldVar || "outro_explode",
        variant: options2?.variant || "01",
        color: color || "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newMO.macro = macro2 || {};
    newMO.soundOnly = {
      sound: setSound({}, "a01", true)
    };
    return newMO;
  }
}
const flagMigrations = {
  async handle(item2, options2 = {}) {
    let flags = item2.flags?.autoanimations;
    if (!flags)
      return;
    if (this.upToDate(flags))
      return flags;
    if (flags.version && isNaN(flags.version)) {
      console.error("Your A-A Item data may be corrupted. Please log this in the Automated Animations GitHub issues");
      return flags;
    }
    let newFlagData = item2.flags.autoanimations;
    for (let [version, migration] of Object.entries(this.migrations)) {
      let flagVersion = item2.flags.autoanimations.version;
      if (flagVersion >= Number(version))
        continue;
      newFlagData = await migration(newFlagData, options2.isActiveEffect);
    }
    if (!newFlagData) {
      await item2.update({ "flags.-=autoanimations": null });
      return void 0;
    } else {
      await item2.update({ "flags.-=autoanimations": null });
      await item2.update({ "flags.autoanimations": newFlagData });
      return newFlagData;
    }
  },
  upToDate(flags) {
    const currentFlagVersion = Object.keys(this.migrations).map((n) => Number(n)).reverse()[0];
    return flags.version >= currentFlagVersion;
  },
  migrations: {
    "1": async (item2) => {
      return await version01(item2);
    },
    "2": async (item2) => {
      return await version02(item2);
    },
    "3": async (item2) => {
      return await version03(item2);
    },
    "4": async (item2) => {
      return await version04(item2);
    },
    "5": async (item2, isActiveEffect) => {
      return await version05(item2, isActiveEffect);
    }
  }
};
class AAAutorecFunctions {
  static rinseName(oldName) {
    if (!oldName) {
      return;
    }
    const newName = oldName.replace(/\s+/g, "").toLowerCase();
    return newName;
  }
  static sortAndFilterMenus(menus) {
    let combinedMenus = [
      ...menus.melee,
      ...menus.range,
      ...menus.ontoken,
      ...menus.templatefx,
      ...menus.aura,
      ...menus.preset
    ];
    let sortedMenus2 = combinedMenus.sort((a, b) => b.label?.replace(/\s+/g, "").length - a.label?.replace(/\s+/g, "").length);
    return {
      exactMatchMenus: sortedMenus2.filter((x) => x.advanced?.exactMatch),
      bestMatchMenus: sortedMenus2.filter((x) => !x.advanced?.exactMatch)
    };
  }
  static allMenuSearch(menus, rinsedName, trueName) {
    return menus.exactMatchMenus.find((x) => x.label && x.label === trueName) || menus.bestMatchMenus.find(
      (x) => x.advanced?.excludedTerms?.length ? x.label && rinsedName.includes(this.rinseName(x.label)) && !x.advanced.excludedTerms.some((el) => rinsedName.includes(this.rinseName(el))) : x.label && rinsedName.includes(this.rinseName(x.label))
    ) || false;
  }
  /*
      static allMenuSearch(menus, name) {
  
          let combinedMenus = [...menus.melee, ...menus.range, ...menus.ontoken,
              ...menus.templatefx, ...menus.aura, ...menus.preset];
  
          let sortedMenus = combinedMenus.sort((a, b) => b.label?.replace(/\s+/g, '').length - a.label?.replace(/\s+/g, '').length);
  
          return sortedMenus.find(x => x.label && name.includes(this.rinseName(x.label))) || false;
      }
      */
  static allMenuTrueSearch(menus, rinsedName, trueName) {
    return menus.exactMatchMenus.find((x) => x.label && x.label === trueName) || menus.bestMatchMenus.find(
      (x) => x.advanced?.excludedTerms?.length ? x.label && rinsedName.includes(this.rinseName(x.label)) && !x.advanced.excludedTerms.some((el) => rinsedName.includes(this.rinseName(el))) : x.label && rinsedName.includes(this.rinseName(x.label))
    ) || false;
  }
  static sortAndFilterAllMenus(menus) {
    let combinedMenus = [
      ...menus.melee,
      ...menus.range,
      ...menus.ontoken,
      ...menus.templatefx,
      ...menus.aura,
      ...menus.preset,
      ...menus.aefx
    ];
    let sortedMenus2 = combinedMenus.sort((a, b) => b.label?.replace(/\s+/g, "").length - a.label?.replace(/\s+/g, "").length);
    return {
      exactMatchMenus: sortedMenus2.filter((x) => x.advanced?.exactMatch),
      bestMatchMenus: sortedMenus2.filter((x) => !x.advanced?.exactMatch)
    };
  }
  static singleMenuSearch(menu, rinsedName, trueName) {
    if (!rinsedName) {
      custom_warning("No Name was provided for the Global Menu search");
      return;
    }
    let sortedMenu = menu.sort((a, b) => b.label.replace(/\s+/g, "").length - a.label?.replace(/\s+/g, "").length);
    let exactMatchMenus = sortedMenu.filter((x) => x.advanced?.exactMatch);
    let bestMatchMenus = sortedMenu.filter((x) => !x.advanced?.exactMatch);
    return exactMatchMenus.find((x) => x.label && x.label === trueName) || bestMatchMenus.find(
      (x) => x.advanced?.excludedTerms?.length ? x.label && rinsedName.includes(this.rinseName(x.label)) && !x.advanced.excludedTerms.some((el) => rinsedName.includes(this.rinseName(el))) : x.label && rinsedName.includes(this.rinseName(x.label))
    ) || false;
  }
  static singleMenuStrictSearch(menu, name) {
    if (!name) {
      custom_warning("No Name was provided for the Global Menu search");
      return;
    }
    return menu.find((x) => name === this.rinseName(x.label)) || false;
  }
  static getAllLabelsInMenu(menu) {
    const nameArray = [];
    for (var i = 0; i < menu.length; i++) {
      if (!menu[i].label) {
        continue;
      }
      nameArray.push(this.rinseName(menu[i].label));
    }
    return nameArray;
  }
  static sortMenu(menu) {
    menu.sort((a, b) => b.label.replace(/\s+/g, "").length - a.label.replace(/\s+/g, "").length);
    return sortedMenus;
  }
  // If an Autorec section has advanced search features enabled for excluding an Item property, this will check that property against that of the item used
  static checkExcludedProperty(item2, property, path = "") {
    if (!path || !property || !item2) {
      return;
    }
    let value = path.split(".").reduce((a, b) => a[b], item2);
    if (typeof value !== "string") {
      debug("Invalid path for Excluded Item type", path);
      return false;
    }
    return this.rinseName(property) === this.rinseName(value);
  }
}
async function handleItem(data2) {
  if (!data2.item) {
    return;
  }
  const item2 = data2.item;
  const itemName = !data2.activeEffect || game.system.id === "pf2e" ? item2.name : item2.label;
  const rinsedItemName = itemName ? AAAutorecFunctions.rinseName(itemName) : "noitem";
  const ammoItem = data2.ammoItem;
  const rinsedAmmoName = ammoItem?.name ? AAAutorecFunctions.rinseName(ammoItem.name) : "";
  const itemFlags = await flagMigrations.handle(data2.item, { activeEffect: data2.activeEffect }) || {};
  const itemIsEnabled = !!itemFlags.killAnim ? false : itemFlags.isEnabled ?? true;
  if (!itemIsEnabled) {
    return false;
  }
  const ammoFlags = ammoItem ? await flagMigrations.handle(ammoItem, { activeEffect: data2.activeEffect }) || { isEnabled: true } : null;
  let autorecDisabled = game.settings.get("autoanimations", "disableAutoRec");
  if (autorecDisabled) {
    debug$1("Global Automatic Recognition menu is Disabled from the Module Settings");
  }
  const autorecSettings = {
    melee: game.settings.get("autoanimations", "aaAutorec-melee"),
    range: game.settings.get("autoanimations", "aaAutorec-range"),
    ontoken: game.settings.get("autoanimations", "aaAutorec-ontoken"),
    templatefx: game.settings.get("autoanimations", "aaAutorec-templatefx"),
    aura: game.settings.get("autoanimations", "aaAutorec-aura"),
    preset: game.settings.get("autoanimations", "aaAutorec-preset"),
    aefx: game.settings.get("autoanimations", "aaAutorec-aefx")
  };
  let menus = AAAutorecFunctions.sortAndFilterMenus(autorecSettings);
  let autorecObject;
  if (ammoItem && ammoFlags.isEnabled) {
    if (ammoFlags.isCustomized) {
      return ammoFlags;
    } else if (!autorecDisabled) {
      autorecObject = AAAutorecFunctions.allMenuSearch(menus, rinsedAmmoName, ammoItem?.name || "");
    }
    if (autorecObject) {
      return autorecObject;
    }
  }
  if (data2.activeEffect) {
    if (itemFlags.isCustomized) {
      return itemFlags;
    } else if (!autorecDisabled) {
      autorecObject = AAAutorecFunctions.singleMenuSearch(autorecSettings.aefx, rinsedItemName, itemName);
      return autorecObject;
    }
  } else {
    if (itemFlags.isCustomized) {
      return itemFlags;
    } else if (!autorecDisabled) {
      autorecObject = AAAutorecFunctions.allMenuSearch(menus, rinsedItemName, itemName);
      if (!autorecObject && data2.extraNames?.length && !data2.activeEffect) {
        for (const name of data2.extraNames) {
          if (!name) {
            continue;
          }
          const rinsedName = AAAutorecFunctions.rinseName(name);
          autorecObject = AAAutorecFunctions.allMenuSearch(menus, rinsedName, itemName);
          if (autorecObject) {
            data2.rinsedName = rinsedName;
            break;
          }
        }
      }
      if (!autorecObject && data2.isVariant && !data2.isTemplate) {
        let originalItemName = data2.originalItem?.name;
        let originalRinsedName = originalItemName ? AAAutorecFunctions.rinseName(originalItemName) : "noitem";
        autorecObject = AAAutorecFunctions.allMenuSearch(menus, originalRinsedName, originalItemName);
      }
    }
  }
  if (autorecObject && data2.isTemplate && !autorecDisabled) {
    let data3 = autorecObject;
    if (data3.menu === "range" || data3.menu === "melee" || data3.menu === "ontoken") {
      autorecObject = AAAutorecFunctions.singleMenuSearch(autorecSettings.templatefx, rinsedItemName, itemName);
    }
  } else if (data2.isVariant && !autorecObject && data2.isTemplate && !autorecDisabled) {
    let newItemName = data2.originalItem?.name;
    let newRinsedName = newItemName ? AAAutorecFunctions.rinseName(newItemName) : "noitem";
    autorecObject = AAAutorecFunctions.allMenuSearch(menus, newRinsedName, newItemName);
  }
  return autorecObject;
}
function sourceEffect(sourceFX, seq, handler) {
  const options2 = sourceFX.options;
  if (sourceFX.sound) {
    seq.addSequence(sourceFX.sound);
  }
  let thisSeq = seq.effect().file(sourceFX.path.file).anchor({ x: options2.anchor.x, y: options2.anchor.y }).elevation(options2.isAbsolute ? options2.elevation : options2.elevation - 1, { absolute: options2.isAbsolute }).fadeIn(options2.fadeIn).opacity(options2.opacity).origin(handler.itemUuid).playbackRate(options2.playbackRate).repeats(options2.repeat, options2.repeatDelay).size(handler.getSize(options2.isRadius, options2.size, handler.sourceToken, options2.addTokenWidth), { gridUnits: true }).zIndex(options2.zIndex);
  if (options2.tint) {
    thisSeq.tint(options2.tintColor);
    thisSeq.filter("ColorMatrix", { contrast: options2.contrast, saturate: options2.saturation });
  }
  if (options2.animationSource) {
    thisSeq.atLocation({ x: options2.fakeLocation.x, y: options2.fakeLocation.y });
  } else {
    if (options2.persistent) {
      thisSeq.attachTo(handler.sourceToken);
      thisSeq.persist(true, { persistTokenPrototype: true });
    } else {
      thisSeq.attachTo(handler.sourceToken);
    }
  }
  if (options2.isMasked) {
    thisSeq.mask(handler.sourceToken);
  }
  if (handler.systemData.tieToDocuments) {
    thisSeq.tieToDocuments(handler.item);
  }
  if (sourceFX.video.variant === "complete" || sourceFX.video.animation === "complete")
    ;
  else {
    thisSeq.fadeOut(options2.fadeOut);
  }
  if (options2.isWait) {
    thisSeq.waitUntilFinished(options2.delay);
  } else {
    thisSeq.delay(options2.delay);
  }
}
function secondaryEffect(secondary2, seq, targetArray, targetEnabled = false, missable = false, handler) {
  const options2 = secondary2.options;
  if (secondary2.sound) {
    seq.addSequence(secondary2.sound);
  }
  for (let i = 0; i < targetArray.length; i++) {
    let currentTarget = targetArray[i];
    let thisSeq = seq.effect().file(secondary2.path?.file).anchor({ x: options2.anchor.x, y: options2.anchor.y }).atLocation(missable ? `spot ${currentTarget.id}` : currentTarget).elevation(handler.elevation(currentTarget, options2.isAbsolute, options2.elevation), { absolute: options2.isAbsolute }).fadeIn(options2.fadeIn).fadeOut(options2.fadeOut).opacity(options2.opacity).origin(handler.itemUuid).playbackRate(options2.playbackRate).repeats(options2.repeat, options2.repeatDelay).size(handler.getSize(options2.isRadius, options2.size, currentTarget, options2.addTokenWidth), { gridUnits: true }).zIndex(options2.zIndex);
    if (options2.tint) {
      thisSeq.tint(options2.tintColor);
      thisSeq.filter("ColorMatrix", { contrast: options2.contrast, saturate: options2.saturation });
    }
    if (i === handler.allTargets.length - 1 && options2.isWait && targetEnabled) {
      thisSeq.waitUntilFinished(options2.delay);
    } else if (!options2.isWait) {
      thisSeq.delay(options2.delay);
    }
    if (options2.rotateSource) {
      thisSeq.rotateTowards(handler.sourceToken);
      thisSeq.rotate(180);
    }
    if (options2.isMasked) {
      thisSeq.mask(currentTarget);
    }
  }
}
function targetEffect(targetFX, seq, targetArray, missable = false, handler) {
  const options2 = targetFX.options;
  if (targetFX.sound) {
    seq.addSequence(targetFX.sound);
  }
  for (let i = 0; i < targetArray.length; i++) {
    let currentTarget = targetArray[i];
    let checkAnim = Sequencer.EffectManager.getEffects({ object: currentTarget, origin: handler.itemUuid }).length > 0;
    if (checkAnim) {
      continue;
    }
    let thisSeq = seq.effect().file(targetFX.path?.file).anchor({ x: options2.anchor.x, y: options2.anchor.y }).delay(options2.delay).fadeIn(options2.fadeIn).elevation(handler.elevation(currentTarget, options2.isAbsolute, options2.elevation), { absolute: options2.isAbsolute }).opacity(options2.opacity).origin(handler.itemUuid).playbackRate(options2.playbackRate).repeats(options2.repeat, options2.repeatDelay).size(handler.getSize(options2.isRadius, options2.size, currentTarget, options2.addTokenWidth), { gridUnits: true }).zIndex(options2.zIndex);
    if (options2.tint) {
      thisSeq.tint(options2.tintColor);
      thisSeq.filter("ColorMatrix", { contrast: options2.contrast, saturate: options2.saturation });
    }
    if (options2.persistent) {
      thisSeq.persist(true, { persistTokenPrototype: true });
      thisSeq.attachTo(currentTarget, { bindVisibility: !targetFX.unbindVisibility, bindAlpha: !targetFX.unbindAlpha });
    } else {
      thisSeq.atLocation(missable ? `spot ${currentTarget.id}` : currentTarget);
    }
    if (options2.rotateSource) {
      thisSeq.rotateTowards(handler.sourceToken);
      thisSeq.rotate(180);
    }
    if (options2.isMasked) {
      thisSeq.mask(currentTarget);
    }
    if (targetFX.video?.variant === "complete" || targetFX.video?.animation === "complete")
      ;
    else {
      thisSeq.fadeOut(options2.fadeOut);
    }
  }
}
function macroSection(seq, macro2, handler) {
  let userData = macro2.args;
  if (isNewerVersion(game.version, 11)) {
    seq.macro(macro2.name, { args: [handler.workflow, handler, userData] });
  } else {
    if (game.modules.get("advanced-macros")?.active) {
      seq.macro(macro2.name, handler.workflow, handler, userData);
    } else {
      seq.macro(macro2.name);
    }
  }
}
let enabled = true;
class AnimationState {
  static get enabled() {
    return enabled;
  }
  static set enabled(newEnabled) {
    enabled = newEnabled;
  }
}
class AAHandler {
  static async make(data2) {
    if (!AnimationState.enabled) {
      custom_notify("Animations are Disabled from the Automated Animations Settings", true);
      return false;
    }
    let clonedData = foundry.utils.deepClone(data2);
    let animationData = await handleItem(clonedData);
    Hooks.callAll("AutomatedAnimations-WorkflowStart", clonedData, animationData);
    if (clonedData.stopWorkflow) {
      debug$1(`Animation Workflow was interrupted by an External Source`, clonedData);
      return;
    }
    let newAnimationData;
    if (clonedData.recheckAnimation) {
      newAnimationData = await handleItem(clonedData);
      if (!newAnimationData) {
        clonedData.item = data2.item;
      }
    }
    if (!animationData && !newAnimationData) {
      debug$1(`No Animation matched for Item`, clonedData);
      return false;
    }
    let finalAnimationData = newAnimationData ? newAnimationData : animationData;
    return new AAHandler({ ...clonedData, finalAnimationData });
  }
  constructor(data2) {
    debug$1("Compiling Automated Animations data");
    this.animationData = data2.finalAnimationData;
    this.isActiveEffect = data2.activeEffect ?? false;
    this.systemId = game.system.id;
    this.workflow = this.isActiveEffect ? "on" : data2.workflow;
    if (this.isActiveEffect) {
      this.workflowBackup = data2.workflow;
    }
    this.sourceToken = data2.token?.isEmbedded ? data2.token?.object : data2.token;
    this.item = data2.ammoItem || data2.item;
    this.itemUuid = this.item?.uuid || uuidv4();
    this.itemName = !this.isActiveEffect || this.systemId === "pf2e" ? this.item.name : this.item.label;
    this.rinsedName = data2.rinsedName || this.itemName ? this.itemName.replace(/\s+/g, "").toLowerCase() : "";
    this.reachCheck = data2.reach || 0;
    this.allTargets = data2.targets;
    this.hitTargets = data2.hitTargets;
    this.hitTargetsId = data2.hitTargets ? Array.from(this.hitTargets.filter((actor) => actor.id).map((actor) => actor.id)) : [];
    this.playOnMiss = data2.playOnMiss ?? (game.modules.get("midi-qol")?.active || game.system.id === "pf2e" ? game.settings.get("autoanimations", "playonmiss") : false) ?? false;
    this.menu = this.animationData.menu;
    this.templateData = data2.templateData;
    this.sequenceData = { moduleName: "Automated Animations", softFail: !game.settings.get("autoanimations", "debug") };
    this.systemData = data2;
  }
  get isTemplateAnimation() {
    const presetType = this.animationData.presetType;
    return this.menu === "templatefx" || this.menu === "preset" && presetType === "proToTemp" || this.menu === "preset" && presetType === "thunderwave";
  }
  get isAura() {
    return this.menu === "aura";
  }
  get isTeleport() {
    if (this.menu !== "preset") {
      return false;
    }
    return this.animationData.presetType === "teleportation";
  }
  get macroActive() {
    return this.flags.macro?.enable && this.flags.macro?.name;
  }
  // Sets the Elevation of the Effect
  elevation(token = {}, abs = false, level = 0) {
    return abs ? level : level - 1;
  }
  // Sets the Size of the effect
  getSize(isRadius = false, size = 1, token, addToken = false) {
    return isRadius ? addToken ? size * 2 + token.w / canvas.grid.size : size * 2 : token.w / canvas.grid.size * 1.5 * size;
  }
  getDistance(target2) {
    if (this.systemId === "pf1") {
      const scene = game.scenes.active;
      const gridSize = scene.grid.size;
      const left = (token) => token.x;
      const right = (token) => token.x + token.w;
      const top = (token) => token.y;
      const bottom = (token) => token.y + token.h;
      const isLeftOf = right(this.sourceToken) <= left(target2);
      const isRightOf = left(this.sourceToken) >= right(target2);
      const isAbove = bottom(this.sourceToken) <= top(target2);
      const isBelow = top(this.sourceToken) >= bottom(target2);
      let x12 = left(this.sourceToken);
      let x2 = left(target2);
      let y12 = top(this.sourceToken);
      let y2 = top(target2);
      if (isLeftOf) {
        x12 += (this.sourceToken.document.width - 1) * gridSize;
      } else if (isRightOf) {
        x2 += (target2.document.width - 1) * gridSize;
      }
      if (isAbove) {
        y12 += (this.sourceToken.document.height - 1) * gridSize;
      } else if (isBelow) {
        y2 += (target2.document.height - 1) * gridSize;
      }
      const ray = new Ray({ x: x12, y: y12 }, { x: x2, y: y2 });
      const distance2 = canvas.grid.grid.measureDistances([{ ray }], { gridSpaces: true })[0];
      return distance2 / canvas.dimensions.distance;
    } else {
      const t1 = this.sourceToken;
      const noResult = { distance: -1, acBonus: void 0 };
      if (!canvas || !canvas.scene)
        return noResult;
      if (!canvas.grid || !canvas.dimensions)
        ;
      if (!t1 || !target2)
        return noResult;
      if (!canvas || !canvas.grid || !canvas.dimensions)
        return noResult;
      const t1StartX = t1.document.width >= 1 ? 0.5 : t1.document.width / 2;
      const t1StartY = t1.document.height >= 1 ? 0.5 : t1.document.height / 2;
      const t2StartX = target2.document.width >= 1 ? 0.5 : target2.document.width / 2;
      const t2StartY = target2.document.height >= 1 ? 0.5 : target2.document.height / 2;
      var x, x1, y, y1, segments = [], rdistance, distance;
      for (x = t1StartX; x < t1.document.width; x++) {
        for (y = t1StartY; y < t1.document.height; y++) {
          const origin = new PIXI.Point(...canvas.grid.getCenter(Math.round(t1.document.x + canvas.dimensions.size * x), Math.round(t1.document.y + canvas.dimensions.size * y)));
          for (x1 = t2StartX; x1 < target2.document.width; x1++) {
            for (y1 = t2StartY; y1 < target2.document.height; y1++) {
              const dest = new PIXI.Point(...canvas.grid.getCenter(Math.round(target2.document.x + canvas.dimensions.size * x1), Math.round(target2.document.y + canvas.dimensions.size * y1)));
              const r = new Ray(origin, dest);
              segments.push({ ray: r });
            }
          }
        }
      }
      if (segments.length === 0) {
        return noResult;
      }
      rdistance = segments.map((ray) => canvas.grid.measureDistances([ray], { gridSpaces: true })[0]);
      distance = rdistance[0];
      rdistance.forEach((d) => {
        if (d < distance)
          distance = d;
      });
      return distance / canvas.dimensions.distance;
    }
  }
  complileMacroSection(seq, macro2, handler = this) {
    macroSection(seq, macro2, handler);
  }
  runMacro(macro2, handler = this) {
    let userData = macro2.args;
    if (isNewerVersion(game.version, 11)) {
      new Sequence(handler.sequenceData).macro(macro2.name, { args: [handler.workflow, handler, userData] }).play();
    } else {
      if (game.modules.get("advanced-macros")?.active) {
        new Sequence(handler.sequenceData).macro(macro2.name, handler.workflow, handler, userData).play();
      } else {
        new Sequence(handler.sequenceData).macro(macro2.name).play();
      }
    }
  }
  compileSourceEffect(sourceFX, seq, handler = this) {
    sourceEffect(sourceFX, seq, handler);
  }
  compileSecondaryEffect(secondary2, seq, targetArray, targetEnabled = false, missable = false, handler = this) {
    secondaryEffect(secondary2, seq, targetArray, targetEnabled, missable, handler);
  }
  compileTargetEffect(targetFX, seq, targetArray, missable = false, handler = this) {
    targetEffect(targetFX, seq, targetArray, missable, handler);
  }
  // Returns a pseudo Token X/Y for Ranged effects
  fakeSource() {
    let templateSource = Sequencer.EffectManager.getEffects({ sceneId: canvas.scene.id, name: this.rinsedName })[0];
    if (!templateSource) {
      return this.sourceToken;
    }
    let gridSize = canvas.grid.size / 2;
    let tsXmin = templateSource.source.x - templateSource.source.width / 2 + gridSize;
    let tsXmax = templateSource.source.x + templateSource.source.width / 2 - gridSize;
    let tsYmin = templateSource.source.y - templateSource.source.height / 2 + gridSize;
    let txYmax = templateSource.source.y + templateSource.source.height / 2 - gridSize;
    let newX = Sequencer.Helpers.random_int_between(tsXmin, tsXmax);
    let newY = Sequencer.Helpers.random_int_between(tsYmin, txYmax);
    return { x: newX, y: newY };
  }
}
async function buildFile(dbType, video2, custom = true, options2 = {}) {
  const { menuType, animation, variant, color, customPath } = video2;
  if (!dbType && (!customPath || !custom)) {
    return false;
  }
  if (customPath) {
    return { file: customPath, fileData: customPath };
  }
  let cleanType = menuType;
  let cleanAnimation = animation;
  let cleanVariant = variant;
  let cleanColor = color;
  if (!validateVideoPath()) {
    debug$1("Error found while building database path, reverting a default");
    cleanType = getCleanProperty(aaDatabase$1[dbType], menuType);
    cleanAnimation = getCleanProperty(aaDatabase$1[dbType][cleanType], animation);
    cleanVariant = getCleanProperty(aaDatabase$1[dbType][cleanType][cleanAnimation], variant);
    cleanColor = getCleanProperty(aaDatabase$1[dbType][cleanType][cleanAnimation][cleanVariant], color);
  }
  const returnArray = Object.keys(aaDatabase$1.return.weapon);
  return {
    filePath: options2.getTruePath ? filePath() : void 0,
    file: databasePath(),
    returnFile: options2.isReturnable ? returnDatabasePath() : void 0,
    // Cleaned properties. Useful for debugging
    cleanProperties: {
      cleanType,
      cleanAnimation,
      cleanVariant,
      cleanColor
    },
    // Original properties. Useful for debugging
    originalProperties: {
      menuType,
      animation,
      variant,
      color
    }
  };
  function getCleanProperty(path, prop) {
    let newArray = Object.keys(path ?? {});
    return newArray.find((el) => prop === el) ? prop : newArray[0] !== "_markers" ? newArray[0] : newArray[1];
  }
  function validateVideoPath() {
    if (!dbType || !menuType || !animation || !variant || !color) {
      return false;
    }
    let dbPath = color === "random" ? `autoanimations.${dbType}.${[menuType]}.${animation}.${variant}` : `autoanimations.${dbType}.${[menuType]}.${animation}.${variant}.${color}`;
    return !!Sequencer.Database.getEntry(dbPath, { softFail: true });
  }
  function filePath() {
    let colorOptions = Object.keys(aaDatabase$1[dbType][cleanType]?.[cleanAnimation]?.[cleanVariant]);
    return color === "random" ? aaDatabase$1[dbType][cleanType]?.[cleanAnimation]?.[cleanVariant]?.[colorOptions[0]]?.[0] : aaDatabase$1[dbType][cleanType]?.[cleanAnimation]?.[cleanVariant]?.[cleanColor]?.[0];
  }
  function databasePath() {
    return color === "random" ? `autoanimations.${dbType}.${[cleanType]}.${cleanAnimation}.${cleanVariant}` : `autoanimations.${dbType}.${[cleanType]}.${cleanAnimation}.${cleanVariant}.${cleanColor}`;
  }
  function returnDatabasePath() {
    return returnArray.find((el) => cleanAnimation === el) ? color === "random" ? `autoanimations.return.weapon.${cleanAnimation}.${cleanVariant}` : `autoanimations.return.weapon.${cleanAnimation}.${cleanVariant}.${cleanColor}` : false;
  }
}
const particleDefaultValues = {
  explosion: {
    type: "explosion",
    speed: 0,
    repeat: 1,
    delay: 500,
    scale: 2,
    color01: "#FFFFFF",
    color02: "#FFFFFF",
    sprite: "modules/levels-3d-preview/assets/particles/dust.png",
    life: 500,
    emittersize: 1,
    alpha: 0.2,
    mass: 400,
    gravity: 2,
    rate: 10,
    explosion: {},
    onCenter: false,
    autoSize: true
  },
  projectile: {
    type: "projectile",
    speed: 5,
    repeat: 1,
    arc: 2,
    delay: 500,
    scale: 0.7,
    color01: "#FFFFFF",
    color02: "#FFFFFF",
    sprite: "modules/levels-3d-preview/assets/particles/emberssmall.png",
    life: 500,
    emittersize: 1e-4,
    alpha: 0.5,
    mass: 100,
    gravity: 0,
    rate: 10,
    duration: 3e3
  },
  ray: {
    type: "ray",
    speed: 5,
    repeat: 1,
    arc: 2,
    delay: 500,
    scale: 0.7,
    color01: "#FFFFFF",
    color02: "#FFFFFF",
    sprite: "modules/levels-3d-preview/assets/particles/emberssmall.png",
    life: 500,
    emittersize: 1e-4,
    alpha: 0.5,
    mass: 100,
    gravity: 0,
    rate: 10
  },
  sprite: {
    type: "sprite",
    speed: 5,
    repeat: 1,
    delay: 0,
    scale: 0.7,
    color01: "#FFFFFF",
    sprite: "modules/levels-3d-preview/assets/particles/emberssmall.png",
    alpha: 0.7
  },
  token: {
    repeat: 1,
    resetTime: 100
  }
};
class DataSanitizer {
  static async _getAnimationData(handler, flagData) {
    if (!flagData) {
      return;
    }
    let menu = flagData.menu;
    menu = menu === "aefx" ? flagData.activeEffectType : menu;
    const data2 = {};
    data2.primary = menu === "preset" ? await this.compilePreset(flagData) : await this.compilePrimary(flagData, menu, handler), data2.secondary = flagData.secondary ? await this.compileSecondary(flagData, handler) : false, data2.sourceFX = await this.compileSource(flagData, data2.primary), data2.targetFX = flagData.target ? await this.compileTarget(flagData) : false, data2.macro = await this.compileMacro(handler, flagData);
    return data2;
  }
  static async compileMacro(handler, flagData) {
    const macro2 = flagData.macro;
    if (!macro2 || !macro2.enable || !macro2.name) {
      return false;
    }
    const isItemMacro = macro2.name.startsWith("ItemMacro");
    let itemMacro;
    if (isItemMacro) {
      itemMacro = handler.item.getMacro();
    }
    if (isItemMacro && !itemMacro.command) {
      return false;
    }
    const data2 = {
      enable: macro2.enable ?? false,
      name: isItemMacro ? itemMacro : macro2.name,
      args: this.strToObj(macro2.args),
      playWhen: macro2.playWhen ?? "0"
    };
    return data2;
  }
  static strToObj(data) {
    if (!data) {
      return [];
    }
    let obj = {};
    try {
      if (data && typeof data === "string") {
        let objStr = data.replaceAll("\n", "").match(/\{(.)+\}/g);
        eval("obj =" + objStr);
      }
      return obj || data.split(",").map((s) => s.trim());
    } catch (err) {
      return data.split(",").map((s) => s.trim());
    }
  }
  static setSound(data2, addDelay = 0, overrideRepeat = false) {
    const input = {
      enable: data2.enable ?? false,
      file: data2.file,
      delay: data2.delay ?? 0,
      startTime: data2.startTime ?? 0,
      volume: data2.volume ?? 1,
      repeat: overrideRepeat || data2.repeat || 1,
      repeatDelay: data2.repeatDelay ?? 250
    };
    if (!input.enable || !input.file) {
      return false;
    }
    let soundSeq = new Sequence({ moduleName: "Automated Animations", softFail: !game.settings.get("autoanimations", "debug") });
    let section2 = soundSeq.sound();
    section2.file(input.file);
    section2.delay(input.delay + addDelay);
    section2.startTime(input.startTime);
    section2.volume(input.volume);
    section2.repeats(input.repeat, input.repeatDelay);
    return soundSeq;
  }
  static async compilePrimary(flagData, menu, handler) {
    const topLevel = flagData || {};
    const primary2 = topLevel.primary || topLevel.data || {};
    const options2 = primary2.options || {};
    const sound2 = primary2.sound || {};
    const video2 = primary2.video || {};
    const data2 = {
      video: {
        dbSection: video2.dbSection,
        menuType: video2.menuType,
        animation: video2.animation,
        variant: video2.variant,
        color: video2.color,
        customPath: video2.enableCustom && video2.customPath ? video2.customPath : false
      },
      options: this.setPrimaryOptions(options2, menu, handler)
      //sound: this.setSound(sound),
    };
    let addSoundDelay = 0;
    if (!data2.options.isWait) {
      addSoundDelay = data2.options.delay;
    }
    data2.sound = this.setSound(sound2, addSoundDelay, handler.systemData.overrideRepeat);
    if (menu === "melee") {
      data2.meleeSwitch = this.compileMeleeSwitch(topLevel.meleeSwitch);
    }
    if (data2.video.menuType === "shieldfx" && !video2.enableCustom) {
      data2.options.isShieldFX = true;
    }
    let truePathRequired = ["static", "templatefx"];
    let returnable = ["melee", "range"];
    data2.path = await buildFile(data2.video.dbSection, data2.video, data2.video.customPath, { getTruePath: truePathRequired.some((el) => el === data2.video.dbSection), isReturnable: returnable.some((el) => el === data2.video.dbSection) });
    return data2;
  }
  static compileMeleeSwitch(switchData) {
    const topLevel = switchData || {};
    const video2 = topLevel.video || {};
    const options2 = topLevel.options || {};
    const sound2 = topLevel.sound || {};
    const data2 = {
      video: {
        dbSection: "range",
        menuType: video2.menuType,
        animation: video2.animation,
        variant: video2.variant,
        color: video2.color,
        customPath: video2.enableCustom && video2.customPath ? video2.customPath : false
      },
      options: {
        detect: options2.detect || "automatic",
        range: options2.range || 2,
        isReturning: options2.isReturning ?? false,
        switchType: options2.switchType || "on"
      },
      sound: this.setSound(sound2)
    };
    return data2;
  }
  static setPrimaryOptions(data2, type, handler) {
    switch (type) {
      case "melee":
        return {
          contrast: data2.contrast ?? 0,
          delay: data2.delay || 0,
          elevation: data2.elevation ?? 1e3,
          isAbsolute: data2.isAbsolute ?? false,
          isWait: data2.isWait ?? false,
          opacity: data2.opacity ?? 1,
          playbackRate: data2.playbackRate || 1,
          repeat: data2.repeat || 1,
          repeatDelay: data2.repeatDelay ?? 1,
          saturation: data2.saturation ?? 0,
          size: data2.size || 1,
          tint: data2.tint ?? false,
          tintColor: data2.tintColor || "#FFFFFF",
          zIndex: data2.zIndex || 1
        };
      case "range":
        return {
          animationSource: data2.animationSource ?? false,
          contrast: data2.contrast ?? 0,
          fakeLocation: handler.fakeSource(),
          delay: data2.delay || 0,
          elevation: data2.elevation ?? 1e3,
          isAbsolute: data2.isAbsolute ?? false,
          isReturning: data2.isReturning ?? false,
          isWait: data2.isWait ?? false,
          onlyX: data2.onlyX ?? false,
          opacity: data2.opacity ?? 1,
          playbackRate: data2.playbackRate || 1,
          randomOffset: data2.randomOffset ?? false,
          repeat: handler.systemData.overrideRepeat || data2.repeat || 1,
          repeatDelay: data2.repeatDelay ?? 1,
          reverse: data2.reverse ?? false,
          saturation: data2.saturation ?? 0,
          tint: data2.tint ?? false,
          tintColor: data2.tintColor || "#FFFFFF",
          zIndex: data2.zIndex || 1
        };
      case "ontoken":
        return {
          addTokenWidth: data2.addTokenWidth ?? false,
          anchor: this.convertToXY(data2.anchor, true),
          contrast: data2.contrast ?? 0,
          delay: data2.delay ?? 1,
          elevation: data2.elevation ?? 1e3,
          isAbsolute: data2.isAbsolute ?? false,
          fadeIn: data2.fadeIn ?? 250,
          fadeOut: data2.fadeOut ?? 500,
          isMasked: data2.isMasked ?? false,
          isRadius: data2.isRadius ?? false,
          isWait: data2.isWait ?? false,
          opacity: data2.opacity ?? 1,
          persistent: data2.persistent ?? false,
          playbackRate: data2.playbackRate || 1,
          playOn: data2.playOn || "default",
          repeat: data2.repeat || 1,
          repeatDelay: data2.repeatDelay ?? 1,
          saturation: data2.saturation ?? 0,
          size: data2.size || 1,
          tint: data2.tint ?? false,
          tintColor: data2.tintColor || "#FFFFFF",
          unbindAlpha: data2.unbindAlpha ?? false,
          unbindVisibility: data2.unbindVisibility ?? false,
          zIndex: data2.zIndex || 1
        };
      case "templatefx":
        return {
          aboveTemplate: data2.aboveTemplate ?? false,
          anchor: data2.anchor,
          contrast: data2.contrast ?? 0,
          delay: data2.delay ?? 1,
          elevation: data2.elevation ?? 1e3,
          isAbsolute: data2.isAbsolute ?? false,
          isMasked: data2.isMasked ?? false,
          isWait: data2.isWait ?? false,
          occlusionMode: data2.occlusionMode || "3",
          occlusionAlpha: data2.occlusionAlpha ?? 1,
          opacity: data2.opacity ?? 1,
          persistent: data2.persistent ?? false,
          persistType: data2.persistType || "sequencerground",
          playbackRate: data2.playbackRate || 1,
          removeTemplate: data2.removeTemplate ?? false,
          repeat: data2.repeat || 1,
          repeatDelay: data2.repeatDelay ?? 1,
          rotate: data2.rotate ?? 0,
          saturation: data2.saturation ?? 0,
          scale: this.convertToXY(data2.scale),
          tint: data2.tint ?? false,
          tintColor: data2.tintColor || "#FFFFFF",
          scaleX: data2.scaleX || 1,
          scaleY: data2.scaleY || 1,
          zIndex: data2.zIndex || 1
        };
      case "aura":
        return {
          addTokenWidth: data2.addTokenWidth ?? false,
          alpha: data2.alpha ?? false,
          alphaDuration: data2.alphaDuration || 1e3,
          alphaMax: data2.alphaMax ?? 0.5,
          alphaMin: data2.alphaMin ?? -0.5,
          breath: data2.breath ?? false,
          breathDuration: data2.breathDuration || 1e3,
          breathMax: data2.breathMax ?? 1.05,
          breathMin: data2.breathMin ?? 0.95,
          contrast: data2.contrast ?? 0,
          delay: data2.delay || 1,
          elevation: data2.elevation ?? 1e3,
          isAbsolute: data2.isAbsolute ?? false,
          fadeIn: data2.fadeIn ?? 250,
          fadeOut: data2.fadeOut ?? 500,
          isWait: data2.isWait ?? false,
          opacity: data2.opacity ?? 1,
          playbackRate: data2.playbackRate || 1,
          playOn: data2.playOn || "source",
          size: data2.size || 3,
          tint: data2.tint ?? false,
          tintColor: data2.tintColor || "#FFFFFF",
          tintSaturate: data2.tintSaturate ?? 0,
          unbindAlpha: data2.unbindAlpha ?? false,
          unbindVisibility: data2.unbindVisibility ?? false,
          zIndex: data2.zIndex || 1
        };
    }
  }
  static convertToXY(input, isAnchor) {
    let dNum = isAnchor ? 0.5 : 1;
    if (!input) {
      return { x: dNum, y: dNum };
    }
    let parsedInput = input.split(",").map((s) => s.trim());
    let posX = Number(parsedInput[0]);
    let posY = Number(parsedInput[1]);
    if (parsedInput.length === 2) {
      return { x: isNaN(posX) ? dNum : posX, y: isNaN(posY) ? dNum : posY };
    } else if (parsedInput.length === 1) {
      return { x: isNaN(posX) ? dNum : posX, y: isNaN(posX) ? dNum : posX };
    } else {
      return { x: dNum, y: dNum };
    }
  }
  static async compileSecondary(flagData, handler) {
    const topLevel = flagData || {};
    const secondary2 = topLevel.secondary || {};
    if (!secondary2.enable) {
      return false;
    }
    const video2 = secondary2.video || {};
    const options2 = secondary2.options || {};
    const sound2 = secondary2.sound || {};
    const data2 = {
      enable: secondary2.enable ?? false,
      video: {
        dbSection: "static",
        menuType: video2.menuType,
        animation: video2.animation,
        variant: video2.variant,
        color: video2.color,
        customPath: video2.enableCustom && video2.customPath ? video2.customPath : false
      },
      options: {
        addTokenWidth: options2.addTokenWidth ?? false,
        anchor: this.convertToXY(options2.anchor, true),
        contrast: options2.contrast ?? 0,
        delay: options2.delay ?? 0,
        elevation: options2.elevation ?? 1e3,
        isAbsolute: options2.isAbsolute ?? false,
        fadeIn: options2.fadeIn ?? 250,
        fadeOut: options2.fadeOut ?? 250,
        isMasked: options2.isMasked ?? false,
        isRadius: options2.isRadius ?? false,
        isWait: options2.isWait ?? false,
        opacity: options2.opacity || 1,
        playbackRate: options2.playbackRate || 1,
        repeat: handler.systemData.overrideRepeat || options2.repeat || 1,
        repeatDelay: options2.repeatDelay ?? 250,
        rotateSource: options2.rotateSource ?? false,
        saturation: options2.saturation ?? 0,
        size: options2.size || 1,
        tint: options2.tint ?? false,
        tintColor: options2.tintColor || "#FFFFFF",
        zIndex: options2.zIndex || 1
      }
      //sound: this.setSound(sound, topLevel.primary.options),
    };
    let addSoundDelay = 0;
    if (!data2.options.isWait) {
      addSoundDelay = data2.options.delay;
    }
    data2.sound = this.setSound(sound2, addSoundDelay, handler.systemData.overrideRepeat);
    data2.path = secondary2.enable ? await buildFile("static", data2.video, data2.video.customPath) : "";
    return data2;
  }
  static async compileSource(flagData, primary2) {
    const topLevel = flagData || {};
    const source2 = topLevel.source || {};
    const video2 = source2.video || {};
    const options2 = source2.options || {};
    const sound2 = source2.sound || {};
    if (!source2.enable) {
      return false;
    }
    const data2 = {
      enable: source2.enable ?? false,
      video: {
        dbSection: "static",
        menuType: video2.menuType,
        animation: video2.animation,
        variant: video2.variant,
        color: video2.color,
        customPath: video2.enableCustom && video2.customPath ? video2.customPath : false
      },
      options: {
        animationSource: primary2?.options?.animationSource ?? false,
        fakeLocation: primary2?.options?.fakeLocation,
        addTokenWidth: options2.addTokenWidth ?? false,
        anchor: this.convertToXY(options2.anchor, true),
        contrast: options2.contrast ?? 0,
        delay: options2.delay ?? 0,
        elevation: options2.elevation ?? 1e3,
        isAbsolute: options2.isAbsolute ?? false,
        fadeIn: options2.fadeIn ?? 250,
        fadeOut: options2.fadeOut ?? 500,
        isMasked: options2.isMasked ?? false,
        isRadius: options2.isRadius ?? false,
        isWait: options2.isWait ?? false,
        opacity: options2.opacity || 1,
        persistent: options2.persistent ?? false,
        playbackRate: options2.playbackRate || 1,
        repeat: options2.repeat || 1,
        repeatDelay: options2.repeatDelay || 1,
        saturation: options2.saturation ?? 0,
        size: options2.size || 1,
        tint: options2.tint ?? false,
        tintColor: options2.tintColor || "#FFFFFF",
        zIndex: options2.zIndex || 1
      }
      //sound: this.setSound(sound)
    };
    let addSoundDelay = 0;
    if (!data2.options.isWait) {
      addSoundDelay = data2.options.delay;
    }
    data2.sound = this.setSound(sound2, addSoundDelay);
    data2.path = data2.enable ? await buildFile(data2.video.dbSection, data2.video, data2.video.customPath) : "";
    return data2;
  }
  static async compileTarget(flagData) {
    const topLevel = flagData || {};
    const target2 = topLevel.target || {};
    const video2 = target2.video || {};
    const options2 = target2.options || {};
    const sound2 = target2.sound || {};
    if (!target2.enable) {
      return false;
    }
    const data2 = {
      enable: target2.enable ?? false,
      video: {
        dbSection: "static",
        menuType: video2.menuType,
        animation: video2.animation,
        variant: video2.variant,
        color: video2.color,
        customPath: video2.enableCustom && video2.customPath ? video2.customPath : false
      },
      options: {
        addTokenWidth: options2.addTokenWidth ?? false,
        anchor: this.convertToXY(options2.anchor, true),
        contrast: options2.contrast ?? 0,
        delay: options2.delay ?? 0,
        elevation: options2.elevation ?? 1e3,
        fadeIn: options2.fadeIn ?? 250,
        fadeOut: options2.fadeOut ?? 250,
        isAbsolute: options2.isAbsolute ?? false,
        isMasked: options2.isMasked ?? false,
        //isWait: options.isWait ?? false,
        isRadius: options2.isRadius ?? false,
        opacity: options2.opacity || 1,
        playbackRate: options2.playbackRate || 1,
        persistent: options2.persistent ?? false,
        repeat: options2.repeat || 1,
        repeatDelay: options2.repeatDelay ?? 250,
        rotateSource: options2.rotateSource ?? false,
        saturation: options2.saturation ?? 0,
        size: options2.size || 1,
        tint: options2.tint ?? false,
        tintColor: options2.tintColor || "#FFFFFF",
        unbindAlpha: options2.unbindAlpha ?? false,
        unbindVisibility: options2.unbindVisibility ?? false,
        zIndex: options2.zIndex || 1
      },
      sound: this.setSound(sound2, options2.delay ?? 0)
    };
    data2.path = data2.enable ? await buildFile("static", data2.video, data2.video.customPath) : "";
    return data2;
  }
  static _targetSequence(targetFX, target2, handler, addDelay = 0) {
    if (handler.playOnMiss) {
      handler.hitTargetsId.includes(target2.id) ? true : false;
    }
    const targetTokenGS = targetFX.options.isRadius ? targetFX.options.size * 2 : target2.w / canvas.grid.size * 1.5 * targetFX.options.size;
    targetFX.targetSeq = new Sequence();
    let targetEffect2 = targetFX.targetSeq.effect();
    targetEffect2.delay(targetFX.options.delay + addDelay);
    targetEffect2.file(targetFX.path?.file, true);
    targetEffect2.atLocation(target2);
    targetEffect2.size(targetTokenGS * 1.5 * targetFX.options.size, { gridUnits: true });
    targetEffect2.repeats(targetFX.options.repeat, targetFX.options.repeatDelay);
    targetEffect2.elevation(targetFX.options.elevation);
    if (targetFX.options.isMasked) {
      targetEffect2.mask(target2);
    }
    targetEffect2.persist(targetFX.options.persistent);
    targetEffect2.fadeOut(500);
    targetEffect2.opacity(targetFX.options.opacity);
    targetEffect2.zIndex(targetFX.options.zIndex);
    return targetFX;
  }
  static howToDelete(type) {
    if (game.settings.get("autoanimations", "noTips")) {
      return;
    }
    let disableTips = "You can disabled these tips in the Automated Animations module settings";
    switch (type) {
      case "overheadtile":
        custom_notify(`This is an OVERHEAD Tile. Use the Tile Foreground Layer to remove the Animation. ${disableTips}`);
        break;
      case "groundtile":
        custom_notify(`This is an GROUND Tile. Use the Tile Layer to remove the Animation. ${disableTips}`);
        break;
      case "sequencerground":
        custom_notify(`This is a SEQUENCER Persistent Effect. Use the Sequencer Effect Manager to remove the Animation. ${disableTips}`);
        break;
    }
  }
  static async compileParticleData(animationData) {
    const options3d = animationData.levels3d;
    if (!options3d.enable) {
      return false;
    }
    const type = options3d.type;
    const options2 = options3d.data || {};
    const tokens = options3d.tokens || {};
    const secondary2 = options3d.secondary || {};
    const defaults = particleDefaultValues[type] ?? particleDefaultValues["projectile"];
    const data2 = {
      type,
      alpha: options2.alpha ?? defaults.alpha,
      animationType: options2.animationType ?? "twirl",
      arc: options2.arc ?? defaults.arc,
      color01: options2.color01 ?? defaults.color01,
      color02: options2.color02 ?? defaults.color02,
      delay: options2.delay ?? defaults.delay,
      emittersize: options2.emittersize ?? defaults.emittersize,
      gravity: options2.gravity ?? defaults.gravity,
      life: options2.life ?? defaults.life,
      duration: options2.duration ?? defaults.duration,
      mass: options2.mass ?? defaults.mass,
      playOn: options2.playOn ?? "source",
      rate: options2.rate ?? defaults.rate,
      repeat: options2.repeat ?? defaults.repeat,
      resetTime: options2.resetTime ?? 100,
      rotateTowards: options2.rotateTowards ?? false,
      rotationX: options2.rotationX ?? 0,
      rotationY: options2.rotationY ?? 0,
      rotationZ: options2.rotationZ ?? 0,
      scale: options2.scale ?? defaults.scale,
      speed: options2.speed ?? defaults.speed,
      sprite: options2.spritePath ?? defaults.sprite,
      autoSize: options2.autoSize ?? defaults.autoSize,
      onCenter: options2.onCenter ?? defaults.onCenter,
      sound: this.setSound(options3d.sound),
      tokenAnimation: {
        enable: tokens.enable ?? false,
        source: tokens.source ?? false,
        sourceType: tokens.sourceType ?? "twirl",
        sourceStart: tokens.sourcePlay !== "end" ? true : false,
        sourceEnd: tokens.sourcePlay !== "start" ? true : false,
        target: tokens.target ?? false,
        targetType: tokens.targetType ?? "shake",
        targetStart: tokens.targetPlay !== "end" ? true : false,
        targetEnd: tokens.targetPlay !== "start" ? true : false
      },
      secondary: {
        enable: secondary2.enable || false,
        alpha: secondary2.data?.alpha ?? 0.5,
        color01: secondary2.data?.color01 ?? "#FFFFFF",
        color02: secondary2.data?.color02 ?? "#FFFFFF",
        emittersize: secondary2.data?.emittersize ?? 1,
        gravity: secondary2.data?.gravity ?? 2,
        life: secondary2.data?.life ?? 500,
        mass: secondary2.data?.mass ?? 100,
        rate: secondary2.data?.rate ?? 10,
        scale: secondary2.data?.scale ?? 1,
        speed: secondary2.data?.speed ?? 1,
        autoSize: secondary2.data?.autoSize ?? false,
        onCenter: secondary2.data?.onCenter ?? false,
        duration: secondary2.data?.duration ?? 3e3,
        type: secondary2.data?.type ?? "explosion",
        sprite: secondary2.data?.spritePath ?? particleDefaultValues.explosion.sprite
      }
    };
    return data2;
  }
  static async compilePreset(flagData) {
    const topLevel = flagData || {};
    const presetType = topLevel.presetType;
    switch (presetType) {
      case "proToTemp":
        return await proToTemp2();
      case "teleportation":
        return teleportation2();
      case "dualattach":
        return dualAttach();
      case "thunderwave":
        return thunderwave2();
    }
    async function proToTemp2() {
      const flags = topLevel.data || {};
      const projectile = flags.projectile || {};
      const projectileOptions = projectile.options || {};
      const projectileSound = projectile.sound || {};
      const preExplosion = flags.preExplosion || {};
      const preExplosionOptions = preExplosion.options || {};
      const preExplosionSound = preExplosion.sound || {};
      const explosion = flags.explosion || {};
      const explosionOptions = explosion.options || {};
      const explosionSound = explosion.sound || {};
      const afterImage = flags.afterImage || {};
      const afterImageOptions = afterImage.options || {};
      const data2 = {
        projectile: {
          dbSection: "range",
          menuType: projectile.menuType,
          animation: projectile.animation,
          variant: projectile.variant,
          color: projectile.color,
          customPath: projectile.enableCustom && projectile.customPath ? projectile.customPath : false,
          options: {
            elevation: projectileOptions.elevation || 1e3,
            isAbsolute: projectileOptions.isAbsolute ?? false,
            playbackRate: projectileOptions.playbackRate || 1,
            randomOffset: projectileOptions.randomOffset ?? false,
            repeat: projectileOptions.repeat || 1,
            repeatDelay: projectileOptions.repeatDelay || 250,
            removeTemplate: projectileOptions.removeTemplate ?? false,
            wait: projectileOptions.wait ?? -500,
            opacity: projectileOptions.opacity ?? 1
          },
          sound: setSound(projectileSound)
        },
        preExplosion: {
          dbSection: "static",
          enable: preExplosion.enable || false,
          menuType: preExplosion.menuType,
          animation: preExplosion.animation,
          variant: preExplosion.variant,
          color: preExplosion.color,
          customPath: preExplosion.enableCustom && preExplosion.customPath ? preExplosion.customPath : false,
          options: {
            aboveTemplate: preExplosionOptions.aboveTemplate ?? false,
            elevation: preExplosionOptions.elevation ?? 1e3,
            isAbsolute: preExplosionOptions.isAbsolute ?? false,
            playbackRate: preExplosionOptions.playbackRate || 1,
            repeat: preExplosionOptions.repeat || 1,
            repeatDelay: preExplosionOptions.repeatDelay || 250,
            scale: preExplosionOptions.scale || 1,
            wait: preExplosionOptions.wait ?? -500,
            opacity: preExplosionOptions.opacity ?? 1
          },
          sound: setSound(preExplosionSound)
        },
        explosion: {
          dbSection: "static",
          menuType: explosion.menuType,
          animation: explosion.animation,
          variant: explosion.variant,
          color: explosion.color,
          customPath: explosion.enableCustom && explosion.customPath ? explosion.customPath : false,
          options: {
            aboveTemplate: explosionOptions.aboveTemplate ?? false,
            elevation: explosionOptions.elevation ?? 1e3,
            isAbsolute: explosionOptions.isAbsolute ?? false,
            playbackRate: explosionOptions.playbackRate || 1,
            repeat: explosionOptions.repeat || 1,
            repeatDelay: explosionOptions.repeatDelay || 250,
            scale: explosionOptions.scale || 1,
            wait: explosionOptions.wait ?? -500,
            opacity: explosionOptions.opacity ?? 1
          },
          sound: setSound(explosionSound)
        },
        afterImage: {
          customPath: afterImage.enable && afterImage.customPath ? afterImage.customPath : false,
          enable: afterImage.enable ?? false,
          options: {
            elevation: afterImageOptions.elevation ?? 1e3,
            isAbsolute: afterImageOptions.isAbsolute ?? false,
            persistent: afterImageOptions.persistent ?? false,
            scale: afterImageOptions.scale || 1
          }
        },
        soundOnly: {
          enable: false
        }
      };
      data2.projectile.path = await buildFile(data2.projectile.dbSection, data2.projectile, data2.projectile.customPath);
      data2.preExplosion.path = await buildFile(data2.preExplosion.dbSection, data2.preExplosion, data2.preExplosion.customPath);
      data2.explosion.path = await buildFile(data2.explosion.dbSection, data2.explosion, data2.explosion.customPath);
      return data2;
    }
    function teleportation2() {
      const flags = topLevel.data || {};
      const start = flags.start || {};
      const startOptions = start.options || {};
      const between = flags.between || {};
      const betweenOptions = between.options || {};
      const end = flags.end || {};
      const endOptions = end.options || {};
      const options2 = flags.options || {};
      const sound2 = flags.sound || {};
      const data2 = {
        start: !start.enable ? false : {
          menuType: start.menuType,
          animation: start.animation,
          variant: start.variant,
          color: start.color,
          customPath: start.enableCustom && start.customPath ? start.customPath : false,
          options: {
            //alpha: startOptions.alpha ?? 0,
            delay: startOptions.delay ?? 0,
            elevation: startOptions.elevation ?? 1e3,
            isAbsolute: startOptions.isAbsolute ?? false,
            fadeIn: startOptions.fadeIn ?? 250,
            fadeOut: startOptions.fadeOut ?? 500,
            isMasked: startOptions.isMasked ?? false,
            isRadius: startOptions.isRadius ?? false,
            opacity: startOptions.opacity ?? 1,
            playbackRate: startOptions.playbackRate || 1,
            size: startOptions.size ?? 1
          }
        },
        between: !between.enable ? false : {
          menuType: between.menuType,
          animation: between.animation,
          variant: between.variant,
          color: between.color,
          customPath: between.enableCustom && between.customPath ? between.customPath : false,
          options: {
            delay: betweenOptions.delay ?? 0,
            elevation: betweenOptions.elevation ?? 1e3,
            isAbsolute: betweenOptions.isAbsolute ?? false,
            opacity: betweenOptions.opacity ?? 1,
            playbackRate: betweenOptions.playbackRate ?? 1
          }
        },
        end: !end.enable ? false : {
          menuType: end.menuType,
          animation: end.animation,
          variant: end.variant,
          color: end.color,
          customPath: end.enableCustom && end.customPath ? end.customPath : false,
          options: {
            delay: endOptions.delay ?? 0,
            elevation: endOptions.elevation ?? 1e3,
            isAbsolute: endOptions.isAbsolute ?? false,
            fadeIn: startOptions.fadeIn ?? 250,
            fadeOut: startOptions.fadeOut ?? 500,
            isMasked: endOptions.isMasked ?? false,
            isRadius: endOptions.isRadius ?? false,
            opacity: endOptions.opacity ?? 1,
            playbackRate: endOptions.playbackRate || 1,
            size: endOptions.size ?? 1
          }
        },
        options: {
          measureType: options2.measureType || "alternating",
          hideFromPlayers: options2.hideFromPlayers ?? false,
          range: options2.range ?? 30,
          teleport: options2.teleport ?? false,
          delayMove: options2.delayMove ?? 0,
          speed: options2.speed || 6,
          alpha: options2.alpha ?? 1,
          delayFade: options2.delayFade ?? 0,
          delayReturn: options2.delayReturn ?? 0,
          checkCollision: options2.checkCollision ?? false
        },
        sound: setSound(sound2)
      };
      return data2;
    }
    function dualAttach() {
      const flags = topLevel.data || {};
      const video2 = flags.video || {};
      const options2 = flags.options || {};
      const sound2 = flags.sound || {};
      const data2 = {
        video: {
          menuType: video2.menuType,
          animation: video2.animation,
          variant: video2.variant,
          color: video2.color,
          customPath: video2.enableCustom && video2.customPath ? video2.customPath : false
        },
        options: {
          elevation: options2.elevation ?? 1e3,
          isAbsolute: options2.isAbsolute ?? false,
          onlyX: options2.onlyX ?? false,
          opacity: options2.opacity ?? 1,
          playbackRate: options2.playbackRate
        },
        sound: setSound(sound2)
      };
      return data2;
    }
    function thunderwave2() {
      const flags = topLevel.data || {};
      const options2 = flags.options || {};
      const sound2 = flags.sound || {};
      const data2 = {
        color: flags.color || "blue",
        options: {
          elevation: options2.elevation ?? 1e3,
          isAbsolute: options2.isAbsolute ?? false,
          opacity: options2.opacity ?? 1,
          repeat: options2.repeat || 1,
          repeatDelay: options2.repeatDelay ?? 250,
          removeTemplate: options2.removeTemplate ?? false
        },
        sound: setSound(sound2)
      };
      return data2;
    }
    function setSound(data2, addDelay = 0) {
      const input = {
        enable: data2.enable ?? false,
        file: data2.file,
        delay: data2.delay ?? 0,
        startTime: data2.startTime ?? 0,
        volume: data2.volume ?? 1,
        repeat: data2.repeat || 1,
        repeatDelay: data2.repeatDelay ?? 250
      };
      if (!input.enable || !input.file) {
        return false;
      }
      let soundSeq = new Sequence();
      let section2 = soundSeq.sound();
      section2.file(input.file);
      section2.delay(input.delay + addDelay);
      section2.startTime(input.startTime);
      section2.volume(input.volume);
      section2.repeats(input.repeat, input.repeatDelay);
      return soundSeq;
    }
  }
}
Hooks.once("aa.ready", async (jb2a) => {
  await menuOptions(jb2a);
});
let aaReturnWeapons;
let aaRangeWeapons;
const newTypeMenu = {};
const newNameMenu = {};
const newVariantMenu = {};
const newColorMenu = {};
async function menuOptions(database) {
  aaReturnWeapons = Object.keys(database.return.weapon);
  aaRangeWeapons = Object.keys(database.range.weapon);
  const jb2a = database;
  const menuSets = ["range", "return", "melee", "static", "templatefx"];
  for (let section2 of menuSets) {
    newTypeMenu[section2] = [];
    let currentTypeArray = [];
    Object.keys(jb2a[section2]).forEach(
      function(a) {
        currentTypeArray.push(a);
      }
    );
    currentTypeArray.sort((a, b) => a.localeCompare(b));
    currentTypeArray.forEach(function(d) {
      if (!newTypeMenu[section2]) {
        newTypeMenu[section2] = [];
      }
      newTypeMenu[section2].push([d, game.i18n.localize(`autoanimations.menuTypes.${d}`)]);
    });
  }
  for (let section2 of menuSets) {
    newNameMenu[section2] = {};
    let currentNameArray = [];
    Object.keys(jb2a[section2]).forEach(
      function(a) {
        currentNameArray = [];
        Object.keys(jb2a[section2][a]).forEach(function(b) {
          currentNameArray.push(b);
        });
        currentNameArray.sort((a2, b) => a2.localeCompare(b));
        currentNameArray.forEach(function(d) {
          if (!newNameMenu[section2][a]) {
            newNameMenu[section2][a] = [];
          }
          newNameMenu[section2][a].push([d, game.i18n.localize(`autoanimations.animations.${d}`)]);
        });
      }
    );
  }
  for (let section2 of menuSets) {
    newVariantMenu[section2] = {};
    let currentVariantArray = [];
    Object.keys(jb2a[section2]).forEach(
      function(a) {
        Object.keys(jb2a[section2][a]).forEach(function(b) {
          if (!newVariantMenu[section2][a]) {
            newVariantMenu[section2][a] = {};
          }
          currentVariantArray = [];
          Object.keys(jb2a[section2][a][b]).forEach(function(c) {
            currentVariantArray.push(c);
          });
          currentVariantArray.sort((a2, b2) => a2.localeCompare(b2));
          currentVariantArray.forEach(function(d) {
            if (!newVariantMenu[section2][a][b]) {
              newVariantMenu[section2][a][b] = [];
            }
            newVariantMenu[section2][a][b].push([d, game.i18n.localize(`autoanimations.variants.${d}`)]);
          });
        });
      }
    );
  }
  for (let section2 of menuSets) {
    newColorMenu[section2] = {};
    let currentColorArray = [];
    Object.keys(jb2a[section2]).forEach(
      function(a) {
        Object.keys(jb2a[section2][a]).forEach(function(b) {
          if (!newColorMenu[section2][a]) {
            newColorMenu[section2][a] = {};
          }
          Object.keys(jb2a[section2][a][b]).forEach(function(c) {
            if (!newColorMenu[section2][a][b]) {
              newColorMenu[section2][a][b] = {};
            }
            currentColorArray = [];
            Object.keys(jb2a[section2][a][b][c]).forEach(function(d) {
              currentColorArray.push(d);
            });
            currentColorArray.sort((a2, b2) => a2.localeCompare(b2));
            currentColorArray.forEach(function(d) {
              if (!newColorMenu[section2][a][b][c]) {
                newColorMenu[section2][a][b][c] = [];
              }
              if (d === "_markers") {
                return;
              }
              newColorMenu[section2][a][b][c].push([d, game.i18n.localize(`autoanimations.colors.${d}`)]);
            });
          });
        });
      }
    );
  }
  newAddRandom();
  async function newAddRandom() {
    Object.keys(newColorMenu).forEach(function(a) {
      Object.keys(newColorMenu[a]).forEach(function(b) {
        Object.keys(newColorMenu[a][b]).forEach(function(c) {
          Object.keys(newColorMenu[a][b][c]).forEach(function(d) {
            newColorMenu[a][b][c][d].push(["random", game.i18n.localize("autoanimations.colors.random")]);
          });
        });
      });
    });
  }
  newTypeMenu.range.splice(0, 1);
  newTypeMenu.return.splice(0, 1);
  delete newNameMenu.range._template;
  delete newNameMenu.return._template;
  delete newVariantMenu.range._template;
  delete newVariantMenu.return._template;
  debug$1("Compiled Select Menus", { newTypeMenu, newNameMenu, newVariantMenu, newColorMenu });
}
async function melee$3(handler, animationData) {
  const data2 = animationData.primary;
  const secondary2 = animationData.secondary;
  const sourceFX = animationData.sourceFX;
  const targetFX = animationData.targetFX;
  const macro2 = animationData.macro;
  const sourceToken = handler.sourceToken;
  let sourceTokenGS = sourceToken.w / canvas.grid.size * 5;
  if (data2.video?.animation === "claw" || data2.video?.animation === "bite") {
    sourceTokenGS = sourceToken.w / canvas.grid.size;
  }
  const switchDisabled = game.settings.get("autoanimations", "rangeSwitch");
  const switchReturn = data2.meleeSwitch.options.switchType === "on" && aaReturnWeapons.includes(data2.video.animation) ? data2.meleeSwitch.options.isReturning : data2.meleeSwitch.options.switchType === "custom" && aaReturnWeapons.includes(data2.meleeSwitch.video.animation) ? data2.meleeSwitch.options.isReturning : false;
  let range2 = {};
  if (data2.meleeSwitch.options.switchType === "on") {
    range2 = aaRangeWeapons.includes(data2.video.animation) && !data2.video.customPath ? await buildFile("range", data2.video, false, { isReturnable: true }) : {};
  } else if (data2.meleeSwitch.options.switchType === "custom") {
    range2 = !data2.meleeSwitch?.video?.customPath ? await buildFile("range", data2.meleeSwitch.video, data2.meleeSwitch.video.customPath, { isReturnable: true }) : {};
  }
  let switchDistance = 5;
  if (handler.systemId === "swade") {
    switchDistance = 1;
  }
  if (handler.systemId === "alienrpg") {
    switchDistance = canvas.grid.distance * 1.5;
  }
  let rangeArray = [];
  let meleeArray = [];
  for (let target2 of handler.allTargets) {
    let distanceTo = handler.getDistance(target2);
    let rangeDistance = data2.meleeSwitch.options.detect === "manual" ? data2.meleeSwitch.options.range : switchDistance / canvas.dimensions.distance + handler.reachCheck;
    let hit = !handler.playOnMiss ? true : handler.hitTargetsId.includes(target2.id) ? true : false;
    if (distanceTo > rangeDistance && range2.file && !switchDisabled) {
      rangeArray.push({
        token: target2,
        hit
      });
    } else {
      meleeArray.push({
        token: target2,
        moveTo: distanceTo > rangeDistance ? true : false,
        hit
      });
    }
  }
  let aaSeq = await new Sequence(handler.sequenceData);
  if (macro2 && macro2.playWhen === "1") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  if (sourceFX) {
    handler.compileSourceEffect(sourceFX, aaSeq);
  }
  if (data2.sound && meleeArray.length > 0) {
    aaSeq.addSequence(data2.sound);
  }
  aaSeq.thenDo(function() {
    Hooks.callAll("aa.animationStart", sourceToken, handler.allTargets);
  });
  if (meleeArray.length) {
    for (let i = 0; i < meleeArray.length; i++) {
      let currentTarget = meleeArray[i];
      let meleeSeq = aaSeq.effect();
      meleeSeq.file(data2.path.file);
      meleeSeq.opacity(data2.options.opacity);
      meleeSeq.atLocation(sourceToken);
      if (currentTarget.moveTo) {
        meleeSeq.moveTowards(currentTarget.token);
      } else {
        meleeSeq.rotateTowards(currentTarget.token);
        meleeSeq.anchor({ x: 0.4, y: 0.5 });
      }
      meleeSeq.size(sourceTokenGS * data2.options.size, { gridUnits: true });
      meleeSeq.repeats(data2.options.repeat, data2.options.repeatDelay);
      meleeSeq.randomizeMirrorY();
      meleeSeq.missed(!currentTarget.hit);
      meleeSeq.name(`spot ${currentTarget.token.id}`);
      meleeSeq.elevation(handler.elevation(sourceToken, data2.options.isAbsolute, data2.options.elevation), { absolute: data2.options.isAbsolute });
      meleeSeq.zIndex(data2.options.zIndex);
      if (data2.options.tint) {
        meleeSeq.tint(data2.options.tintColor);
        meleeSeq.filter("ColorMatrix", { contrast: data2.options.contrast, saturate: data2.options.saturation });
      }
      if (i === meleeArray.length - 1 && data2.options.isWait) {
        meleeSeq.waitUntilFinished(data2.options.delay);
      } else if (!data2.options.isWait) {
        meleeSeq.delay(data2.options.delay);
      }
      meleeSeq.playbackRate(data2.options.playbackRate);
    }
    if (secondary2) {
      handler.compileSecondaryEffect(secondary2, aaSeq, meleeArray.map((e) => e.token), targetFX.enable, true);
    }
    if (targetFX) {
      handler.compileTargetEffect(targetFX, aaSeq, meleeArray.map((e) => e.token), true);
    }
  }
  if (rangeArray.length) {
    if (data2.meleeSwitch?.sound) {
      aaSeq.addSequence(data2.meleeSwitch.sound);
    }
    for (let i = 0; i < rangeArray.length; i++) {
      let currentTarget = rangeArray[i];
      let rangeSeq = aaSeq.effect();
      rangeSeq.file(range2.file);
      rangeSeq.atLocation(sourceToken);
      rangeSeq.stretchTo(currentTarget.token);
      rangeSeq.opacity(data2.options.opacity);
      rangeSeq.zIndex(data2.options.zIndex);
      rangeSeq.repeats(data2.options.repeat, data2.options.repeatDelay);
      rangeSeq.missed(!currentTarget.hit);
      rangeSeq.name(`spot ${currentTarget.token.id}`);
      rangeSeq.elevation(handler.elevation(sourceToken, data2.options.isAbsolute, data2.options.elevation), { absolute: data2.options.isAbsolute });
      rangeSeq.playbackRate(data2.options.playbackRate);
      if (data2.options.tint) {
        rangeSeq.tint(data2.options.tintColor);
        rangeSeq.filter("ColorMatrix", { contrast: data2.options.contrast, saturate: data2.options.saturation });
      }
      if (i === rangeArray.length - 1 && data2.options.isWait) {
        rangeSeq.waitUntilFinished(data2.options.delay);
      } else if (!data2.options.isWait) {
        rangeSeq.delay(data2.options.delay);
      }
    }
    if (switchReturn) {
      for (let i = 0; i < rangeArray.length; i++) {
        let currentTarget = rangeArray[i].token;
        let returnSeq = aaSeq.effect();
        returnSeq.file(range2.returnFile);
        returnSeq.opacity(data2.options.opacity);
        returnSeq.atLocation(sourceToken);
        returnSeq.repeats(data2.options.repeat, data2.options.repeatDelay);
        returnSeq.stretchTo(`spot ${currentTarget.id}`);
        returnSeq.zIndex(data2.options.zIndex);
        returnSeq.playbackRate(data2.options.playbackRate);
        if (data2.options.tint) {
          returnSeq.tint(data2.options.tintColor);
          returnSeq.filter("ColorMatrix", { contrast: data2.options.contrast, saturate: data2.options.saturation });
        }
      }
    }
    if (secondary2) {
      handler.compileSecondaryEffect(secondary2, aaSeq, rangeArray.map((e) => e.token), targetFX.enable, true);
    }
    if (targetFX) {
      handler.compileTargetEffect(targetFX, aaSeq, rangeArray.map((e) => e.token), true);
    }
  }
  if (macro2 && macro2.playWhen === "0") {
    handler.runMacro(macro2);
  }
  if (macro2 && macro2.playWhen === "3") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  aaSeq.play();
}
const wait$3 = (delay) => new Promise((resolve) => setTimeout(resolve, delay));
async function range$3(handler, animationData) {
  const data2 = animationData.primary;
  const secondary2 = animationData.secondary;
  const sourceFX = animationData.sourceFX;
  const targetFX = animationData.targetFX;
  const macro2 = animationData.macro;
  const sourceToken = handler.sourceToken;
  const onlyX = data2.enableCustom ? data2.onlyX : false;
  const switchReturn = aaReturnWeapons.includes(data2.video.animation) && !data2.video.enableCustom ? data2.options.isReturning : false;
  switch (true) {
    case data2.video.animation.includes("dagger"):
    case data2.video.animation.includes("hammer"):
      break;
  }
  let aaSeq = await new Sequence(handler.sequenceData);
  if (macro2 && macro2.playWhen === "1") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  if (sourceFX) {
    handler.compileSourceEffect(sourceFX, aaSeq);
  }
  if (data2.sound) {
    aaSeq.addSequence(data2.sound);
  }
  aaSeq.thenDo(function() {
    Hooks.callAll("aa.animationStart", sourceToken, handler.allTargets);
  });
  for (let i = 0; i < handler.allTargets.length; i++) {
    let currentTarget = handler.allTargets[i];
    let hit;
    if (handler.playOnMiss) {
      hit = handler.hitTargetsId.includes(currentTarget.id) ? true : false;
    } else {
      hit = true;
    }
    let nextSeq = aaSeq.effect();
    nextSeq.file(data2.path.file);
    if (data2.options.animationSource) {
      nextSeq.atLocation({ x: data2.options.fakeLocation.x, y: data2.options.fakeLocation.y });
    } else {
      if (data2.options.reverse) {
        nextSeq.atLocation(currentTarget);
      } else {
        nextSeq.atLocation(sourceToken);
      }
    }
    if (data2.options.reverse) {
      nextSeq.stretchTo(sourceToken, { onlyX, randomOffset: data2.options.randomOffset });
    } else {
      nextSeq.stretchTo(currentTarget, { onlyX, randomOffset: data2.options.randomOffset });
    }
    nextSeq.randomizeMirrorY();
    nextSeq.repeats(data2.options.repeat, data2.options.repeatDelay);
    nextSeq.opacity(data2.options.opacity);
    nextSeq.missed(!hit || handler.systemData.forceMiss || false);
    nextSeq.name(`spot ${currentTarget.id}`);
    nextSeq.elevation(handler.elevation(sourceToken, data2.options.isAbsolute, data2.options.elevation), { absolute: data2.options.isAbsolute });
    nextSeq.zIndex(data2.options.zIndex);
    if (data2.options.tint) {
      nextSeq.tint(data2.options.tintColor);
      nextSeq.filter("ColorMatrix", { contrast: data2.options.contrast, saturate: data2.options.saturation });
    }
    if (i === handler.allTargets.length - 1 && data2.options.isWait) {
      nextSeq.waitUntilFinished(data2.options.delay);
    } else if (!data2.options.isWait) {
      nextSeq.delay(data2.options.delay);
    }
    nextSeq.playbackRate(data2.options.playbackRate);
  }
  if (switchReturn) {
    for (let i = 0; i < handler.allTargets.length; i++) {
      let currentTarget = handler.allTargets[i];
      let returnSeq = aaSeq.effect();
      returnSeq.file(data2.path.returnFile);
      returnSeq.opacity(data2.options.opacity);
      returnSeq.atLocation(sourceToken);
      returnSeq.repeats(data2.options.repeat, data2.options.repeatDelay);
      returnSeq.stretchTo(`spot ${currentTarget.id}`);
      returnSeq.zIndex(data2.options.zIndex);
      returnSeq.playbackRate(data2.options.playbackRate);
      if (data2.options.tint) {
        returnSeq.tint(data2.options.tintColor);
        returnSeq.filter("ColorMatrix", { contrast: data2.options.contrast, saturate: data2.options.saturation });
      }
    }
  }
  if (secondary2) {
    handler.compileSecondaryEffect(secondary2, aaSeq, handler.allTargets, targetFX.enable, true);
  }
  if (targetFX) {
    handler.compileTargetEffect(targetFX, aaSeq, handler.allTargets, true);
  }
  if (macro2 && macro2.playWhen === "0") {
    handler.runMacro(macro2);
  }
  if (macro2 && macro2.playWhen === "3") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  aaSeq.play();
  await wait$3(handler.animEnd);
  Hooks.callAll("aa.animationEnd", sourceToken, handler.allTargets);
}
async function ontoken$3(handler, animationData) {
  const sourceToken = handler.sourceToken;
  const data2 = animationData.primary;
  const secondary2 = animationData.secondary;
  const sourceFX = animationData.sourceFX;
  const targetFX = animationData.targetFX;
  const macro2 = animationData.macro;
  const sourceSize = handler.getSize(data2.options.isRadius, data2.options.size, sourceToken, data2.options.addTokenWidth);
  const aaSeq = await new Sequence(handler.sequenceData);
  const bottomAnim = data2.path.filePath?.replace("Above", "Below");
  let newTargetArray = [];
  for (let target2 of handler.allTargets) {
    let checkAnim = Sequencer.EffectManager.getEffects({ object: target2, origin: handler.itemUuid }).length > 0;
    if (!checkAnim) {
      newTargetArray.push(target2);
    }
  }
  if (macro2 && macro2.playWhen === "1") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  if (sourceFX) {
    handler.compileSourceEffect(sourceFX, aaSeq);
  }
  if (data2.sound) {
    aaSeq.addSequence(data2.sound);
  }
  aaSeq.thenDo(function() {
    Hooks.callAll("aa.animationStart", sourceToken, handler.allTargets);
  });
  if (data2.options.playOn === "source" || data2.options.playOn === "default" && handler.allTargets.length < 1) {
    const sourceCheckAnim = Sequencer.EffectManager.getEffects({ object: sourceToken, origin: handler.itemUuid }).length > 0;
    if (sourceCheckAnim) {
      return;
    }
    if (data2.options.isShieldFX) {
      let bottomEffect2 = aaSeq.effect();
      if (handler.isActiveEffect) {
        bottomEffect2.name(handler.itemName + `${sourceToken.id}`);
      } else {
        bottomEffect2.name(`spot ${sourceToken.id}`);
      }
      setBottom(sourceToken, sourceSize, bottomEffect2);
      let topEffect = aaSeq.effect();
      if (handler.isActiveEffect) {
        topEffect.name(handler.itemName + `${sourceToken.id}`);
      } else {
        topEffect.name(`spot ${sourceToken.id}`);
      }
      setTop(sourceToken, sourceSize, topEffect);
      if (data2.options.isWait) {
        topEffect.waitUntilFinished(data2.options.wait);
      }
    } else {
      let aaEffect = aaSeq.effect();
      if (handler.isActiveEffect) {
        aaEffect.name(handler.itemName + `${sourceToken.id}`);
      } else {
        aaEffect.name(`spot ${sourceToken.id}`);
      }
      setPrimary(sourceToken, sourceSize, aaEffect);
      if (data2.options.isWait) {
        aaEffect.waitUntilFinished(data2.options.delay);
      }
    }
    if (secondary2) {
      handler.compileSecondaryEffect(secondary2, aaSeq, [sourceToken], false, false);
    }
  }
  if ((data2.options.playOn === "target" || data2.options.playOn === "default") && handler.allTargets.length > 0) {
    if (newTargetArray.length < 1) {
      return;
    }
    for (let i = 0; i < newTargetArray.length; i++) {
      let currentTarget = newTargetArray[i];
      let targetSize = handler.getSize(data2.options.isRadius, data2.options.size, currentTarget, data2.options.addTokenWidth);
      if (handler.playOnMiss) {
        handler.hitTargetsId.includes(currentTarget.id) ? true : false;
      }
      if (data2.options.isShieldFX) {
        let bottomEffect2 = aaSeq.effect();
        bottomEffect2.name(`spot ${currentTarget.id}`);
        setBottom(currentTarget, targetSize, bottomEffect2);
        let topEffect = aaSeq.effect();
        topEffect.name(`spot ${currentTarget.id}`);
        setTop(currentTarget, targetSize, topEffect);
        if (i === newTargetArray.length - 1 && data2.options.isWait) {
          topEffect.waitUntilFinished(data2.options.delay);
        } else if (!data2.options.isWait) {
          topEffect.delay(data2.options.delay);
        }
      } else {
        let aaEffect = aaSeq.effect();
        aaEffect.name(`spot ${currentTarget.id}`);
        setPrimary(currentTarget, targetSize, aaEffect);
        if (i === newTargetArray.length - 1 && data2.options.isWait) {
          aaEffect.waitUntilFinished(data2.options.delay);
        } else if (!data2.options.isWait) {
          aaEffect.delay(data2.options.delay);
        }
      }
    }
    if (secondary2) {
      handler.compileSecondaryEffect(secondary2, aaSeq, newTargetArray, targetFX.enable, true);
    }
    if (targetFX) {
      handler.compileTargetEffect(targetFX, aaSeq, handler.allTargets, true);
    }
  }
  if (data2.options.playOn === "both") {
    const sourceCheckAnim = Sequencer.EffectManager.getEffects({ object: sourceToken, origin: handler.itemUuid }).length > 0;
    let newTargetArray2 = [];
    for (let target2 of handler.allTargets) {
      let checkAnim = Sequencer.EffectManager.getEffects({ object: target2, origin: handler.itemUuid }).length > 0;
      if (!checkAnim) {
        newTargetArray2.push(target2);
      }
    }
    if (sourceCheckAnim && newTargetArray2.length < 1) {
      return;
    }
    if (!sourceCheckAnim) {
      if (data2.options.isShieldFX) {
        let bottomEffect2 = aaSeq.effect();
        bottomEffect2.name(`spot ${sourceToken.id}`);
        setBottom(sourceToken, sourceSize, bottomEffect2);
        let topEffect = aaSeq.effect();
        topEffect.name(`spot ${sourceToken.id}`);
        setTop(sourceToken, sourceSize, topEffect);
        if (newTargetArray2.length < 1 && data2.options.isWait) {
          topEffect.waitUntilFinished(data2.options.delay);
        } else if (!data2.options.isWait) {
          topEffect.delay(data2.options.delay);
        }
      } else {
        let aaEffect = aaSeq.effect();
        aaEffect.name(`spot ${sourceToken.id}`);
        setPrimary(sourceToken, sourceSize, aaEffect);
        if (newTargetArray2.length < 1 && data2.options.isWait) {
          aaEffect.waitUntilFinished(data2.options.delay);
        } else if (!data2.options.isWait) {
          aaEffect.delay(data2.options.delay);
        }
      }
    }
    if (newTargetArray2.length) {
      for (let i = 0; i < newTargetArray2.length; i++) {
        let currentTarget = newTargetArray2[i];
        let targetSize = handler.getSize(data2.options.isRadius, data2.options.size, currentTarget, data2.options.addTokenWidth);
        if (handler.playOnMiss) {
          handler.hitTargetsId.includes(currentTarget.id) ? true : false;
        }
        if (data2.options.isShieldFX) {
          let bottomEffect2 = aaSeq.effect();
          bottomEffect2.name(`spot ${currentTarget.id}`);
          setBottom(currentTarget, targetSize, bottomEffect2);
          let topEffect = aaSeq.effect();
          topEffect.name(`spot ${currentTarget.id}`);
          setTop(currentTarget, targetSize, topEffect);
          if (i === newTargetArray2.length - 1 && data2.options.isWait) {
            topEffect.waitUntilFinished(data2.options.delay);
          } else if (!data2.options.isWait) {
            topEffect.delay(data2.options.delay);
          }
        } else {
          let aaEffect = aaSeq.effect();
          aaEffect.name(`spot ${currentTarget.id}`);
          setPrimary(currentTarget, targetSize, aaEffect);
          if (i === newTargetArray2.length - 1 && data2.options.isWait) {
            aaEffect.waitUntilFinished(data2.options.delay);
          } else if (!data2.options.isWait) {
            aaEffect.delay(data2.options.delay);
          }
        }
      }
    }
    if (secondary2 && !sourceCheckAnim) {
      handler.compileSecondaryEffect(secondary2, aaSeq, [sourceToken], false, false);
    }
    if (newTargetArray2.length) {
      if (secondary2) {
        handler.compileSecondaryEffect(secondary2, aaSeq, newTargetArray2, targetFX.enable, true);
      }
      if (targetFX) {
        handler.compileTargetEffect(targetFX, aaSeq, handler.allTargets, true);
      }
    }
  }
  function setBottom(token, size, seq) {
    seq.file(bottomAnim);
    seq.opacity(data2.options.opacity);
    seq.size(size, { gridUnits: true });
    seq.elevation(token.document?.elevation - 1);
    if (data2.options.isMasked) {
      bottomEffect.mask(token);
    }
    seq.rotate(180);
    seq.fadeIn(250);
    seq.fadeOut(500);
    if (data2.options.tint) {
      seq.tint(data2.options.tintColor);
      seq.filter("ColorMatrix", { contrast: data2.options.contrast, saturate: data2.options.saturation });
    }
    if (!data2.options.persistent) {
      seq.atLocation(token);
      seq.repeats(data2.options.repeat, data2.options.repeatDelay);
    }
    if (data2.options.persistent) {
      seq.attachTo(token, { bindAlpha: data2.options.unbindAlpha, bindVisibility: data2.options.unbindVisibility });
      seq.persist(true, { persistTokenPrototype: true });
      seq.origin(handler.itemUuid);
    }
    seq.playbackRate(data2.options.playbackRate);
    if (handler.systemData.tieToDocuments) {
      seq.tieToDocuments(handler.item);
    }
  }
  function setTop(token, size, seq) {
    seq.file(data2.path.filePath);
    seq.opacity(data2.options.opacity);
    seq.size(size, { gridUnits: true });
    seq.elevation(token.document?.elevation);
    if (data2.options.isMasked) {
      seq.mask(token);
    }
    seq.fadeIn(250);
    seq.fadeOut(500);
    if (data2.options.tint) {
      seq.tint(data2.options.tintColor);
      seq.filter("ColorMatrix", { contrast: data2.options.contrast, saturate: data2.options.saturation });
    }
    if (!data2.options.persistent) {
      seq.atLocation(token);
      seq.repeats(data2.options.repeat, data2.options.repeatDelay);
    }
    if (data2.options.persistent) {
      seq.attachTo(token, { bindAlpha: data2.options.unbindAlpha, bindVisibility: data2.options.unbindVisibility });
      seq.persist(true, { persistTokenPrototype: true });
      seq.origin(handler.itemUuid);
    }
    seq.playbackRate(data2.options.playbackRate);
    if (handler.systemData.tieToDocuments) {
      seq.tieToDocuments(handler.item);
    }
  }
  function setPrimary(token, size, seq) {
    seq.file(data2.path.file);
    seq.opacity(data2.options.opacity);
    seq.size(size, { gridUnits: true });
    seq.elevation(handler.elevation(token, data2.options.isAbsolute, data2.options.elevation), { absolute: data2.options.isAbsolute });
    if (data2.options.isMasked) {
      seq.mask(token);
    }
    seq.zIndex(data2.options.zIndex);
    if (data2.options.tint) {
      seq.tint(data2.options.tintColor);
      seq.filter("ColorMatrix", { contrast: data2.options.contrast, saturate: data2.options.saturation });
    }
    if (!data2.options.persistent) {
      seq.atLocation(token);
      seq.repeats(data2.options.repeat, data2.options.repeatDelay);
      seq.fadeIn(data2.options.fadeIn);
      seq.fadeOut(data2.options.fadeOut);
    }
    if (data2.options.persistent) {
      seq.fadeIn(data2.options.fadeIn);
      if (data2.video.variant === "complete" || data2.video.animation === "complete")
        ;
      else {
        seq.fadeOut(data2.options.fadeOut);
      }
      seq.attachTo(token, { bindAlpha: data2.options.unbindAlpha, bindVisibility: data2.options.unbindVisibility });
      seq.persist(true, { persistTokenPrototype: true });
      seq.origin(handler.itemUuid);
    }
    seq.anchor({ x: data2.options.anchor.x, y: data2.options.anchor.y });
    seq.playbackRate(data2.options.playbackRate);
    if (handler.systemData.tieToDocuments) {
      seq.tieToDocuments(handler.item);
    }
  }
  if (macro2 && macro2.playWhen === "0") {
    handler.runMacro(macro2);
  }
  if (macro2 && macro2.playWhen === "3") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  aaSeq.play();
  Hooks.callAll("aa.animationEnd", sourceToken, handler.allTargets);
  if (data2.options.persistent) {
    howToDelete("sequencerground");
  }
}
var socketlibSocket = void 0;
let setupSocket = () => {
  if (game.modules.get("socketlib")?.active) {
    socketlibSocket = window.socketlib.registerModule("autoanimations");
    socketlibSocket.register("placeTile", placeTile);
    socketlibSocket.register("removeTile", removeTile);
    socketlibSocket.register("checkSettings", checkSettings);
  }
};
async function placeTile(data2) {
  await canvas.scene.createEmbeddedDocuments("Tile", [data2]);
}
async function removeTile(data2) {
  await canvas.scene.deleteEmbeddedDocuments("Tile", data2);
}
async function checkSettings() {
  let photoSensitive = game.settings.get("core", "photosensitiveMode");
  let sequencerPermissions = game.settings.get("sequencer", "permissions-effect-create");
  let sequencerEffectsEnabled = game.settings.get("sequencer", "effectsEnabled");
  let sequencerSoundsEnabled = game.settings.get("sequencer", "soundsEnabled");
  let aaEffectsEnabled = game.settings.get("autoanimations", "killAllAnim") === "off" ? false : true;
  let aaAutorecDisabled = game.settings.get("autoanimations", "disableAutoRec");
  return {
    coreSettings: { photoSensitive },
    sequencerSettings: { permission: sequencerPermissions, effects: sequencerEffectsEnabled, sounds: sequencerSoundsEnabled },
    aaSettings: { effects: aaEffectsEnabled, autorec: aaAutorecDisabled }
  };
}
const wait$2 = (delay) => new Promise((resolve) => setTimeout(resolve, delay));
async function templatefx$3(handler, animationData, templateDocument) {
  const sourceToken = handler.sourceToken;
  const template = handler.templateData ? handler.templateData : templateDocument;
  const templateType = template?.t;
  const data2 = animationData.primary;
  const secondary2 = animationData.secondary;
  const sourceFX = animationData.sourceFX;
  const targetFX = animationData.targetFX;
  const macro2 = animationData.macro;
  let aaSeq = await new Sequence(handler.sequenceData);
  if (data2.options.persistent && data2.options.persistType !== "attachtemplate" || !data2.options.persistent) {
    aaSeq.thenDo(function() {
      if (data2.options.removeTemplate) {
        canvas.scene.deleteEmbeddedDocuments("MeasuredTemplate", [template.id]);
      }
    });
  }
  if (macro2 && macro2.playWhen === "1" && !macro2?.args?.warpgateTemplate) {
    handler.complileMacroSection(aaSeq, macro2);
  }
  if (sourceFX) {
    handler.compileSourceEffect(sourceFX, aaSeq);
  }
  if (data2.sound) {
    aaSeq.addSequence(data2.sound);
  }
  aaSeq.thenDo(function() {
    Hooks.callAll("aa.animationStart", sourceToken, "no-target");
  });
  if (data2.options.persistent && (data2.options.persistType === "overheadtile" || data2.options.persistType === "groundtile")) {
    let trueSize;
    if (templateType === "rect") {
      trueSize = template.width;
    } else {
      trueSize = template.distance * 2;
    }
    const templateLength = canvas.grid.size * (trueSize / canvas.dimensions.distance);
    const isOverhead = data2.options.persistType === "overheadtile" ? true : false;
    const tileWidth = templateLength * data2.options.scale.x;
    const tileHeight = templateLength * data2.options.scale.y;
    const tileX = templateType === "circle" ? template.x - tileWidth / 2 : template.x + (templateLength - tileWidth) / 2;
    const tileY = templateType === "circle" ? template.y - tileHeight / 2 : template.y + (templateLength - tileHeight) / 2;
    const templateObject = buildTile(tileX, tileY, isOverhead, tileWidth, tileHeight);
    aaSeq.thenDo(function() {
      socketlibSocket.executeAsGM("placeTile", templateObject);
    });
  } else {
    const templateSeq = aaSeq.effect();
    if (templateType === "cone" || templateType === "ray") {
      const trueHeight = templateType === "cone" ? template.distance : template.width * 2;
      setPrimary(templateSeq);
      templateSeq.size({
        width: canvas.grid.size * (template.distance / canvas.dimensions.distance) * data2.options.scale.x,
        height: canvas.grid.size * (trueHeight / canvas.dimensions.distance) * data2.options.scale.y
      });
      if (data2.options.isMasked) {
        templateSeq.mask(template);
      }
      if (data2.options.persistent) {
        templateSeq.persist(true);
        if (data2.options.persistType === "attachtemplate") {
          templateSeq.attachTo(template);
          templateSeq.rotateTowards(template, { attachTo: true });
        } else {
          templateSeq.atLocation(template, { cacheLocation: true });
          templateSeq.rotateTowards(template, { cacheLocation: true });
        }
      } else {
        templateSeq.atLocation(template, { cacheLocation: true });
        templateSeq.repeats(data2.options.repeat, data2.options.repeatDelay);
        templateSeq.rotateTowards(template, { cacheLocation: true });
      }
      if (!data2.options.isWait) {
        templateSeq.delay(data2.options.delay);
      }
    }
    if (templateType === "circle" || templateType === "rect") {
      let trueSize;
      if (templateType === "rect") {
        trueSize = Math.sqrt(Math.pow(template.distance, 2) / 2);
      } else {
        trueSize = template.distance * 2;
      }
      setPrimary(templateSeq);
      templateSeq.size({
        width: canvas.grid.size * (trueSize / canvas.dimensions.distance) * data2.options.scale.x,
        height: canvas.grid.size * (trueSize / canvas.dimensions.distance) * data2.options.scale.y
      });
      if (data2.options.persistent) {
        templateSeq.persist(true);
        if (data2.options.persistType === "attachtemplate") {
          templateSeq.attachTo(template, { followRotation: true });
        } else {
          templateSeq.atLocation(template, { cacheLocation: true });
          templateSeq.persist();
        }
      } else {
        templateSeq.atLocation(template, { cacheLocation: true });
        templateSeq.repeats(data2.options.repeat, data2.options.repeatDelay);
      }
      if (!data2.options.isWait) {
        templateSeq.delay(data2.options.delay);
      }
    }
  }
  if (handler.allTargets.length > 0 && data2.options.isWait) {
    aaSeq.wait(data2.options.delay || 250);
  }
  if (secondary2) {
    handler.compileSecondaryEffect(secondary2, aaSeq, handler.allTargets, targetFX.enable, false);
  }
  if (targetFX) {
    handler.compileTargetEffect(targetFX, aaSeq, handler.allTargets, false);
  }
  if (macro2 && macro2.playWhen === "0" && !macro2?.args?.warpgateTemplate) {
    handler.runMacro(macro2);
  }
  if (macro2 && macro2.playWhen === "3") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  aaSeq.play();
  if (data2.options.persistent) {
    switch (data2.options.persistType) {
      case "overheadtile":
        howToDelete("overheadtile");
        break;
      case "groundtile":
        howToDelete("groundtile");
        break;
      case "sequencerground":
        howToDelete("sequencerground");
        break;
    }
  }
  await wait$2(500);
  Hooks.callAll("aa.animationEnd", sourceToken, "no-target");
  function setPrimary(seq) {
    seq.anchor(convertToXY(data2.options.anchor));
    seq.file(data2.path.file);
    seq.opacity(data2.options.opacity);
    seq.origin(handler.itemUuid);
    seq.elevation(handler.elevation(sourceToken, data2.options.isAbsolute, data2.options.elevation), { absolute: data2.options.isAbsolute });
    seq.zIndex(data2.options.zIndex);
    seq.rotate(data2.options.rotate);
    if (data2.options.isMasked) {
      seq.mask(template);
    }
    seq.playbackRate(data2.options.playbackRate);
    seq.name(handler.rinsedName);
    seq.aboveLighting(data2.options.aboveTemplate);
    if (data2.options.tint) {
      seq.tint(data2.options.tintColor);
      seq.filter("ColorMatrix", { contrast: data2.options.contrast, saturate: data2.options.saturation });
    }
    function convertToXY(input) {
      let menuType = data2.video.menuType;
      let templateType2 = template.t;
      let defaultAnchor = templateType2 === "circle" || templateType2 === "rect" ? { x: 0.5, y: 0.5 } : { x: 0, y: 0.5 };
      if (!input) {
        return defaultAnchor;
      }
      let dNum = menuType === "cone" || menuType === "ray" ? input || "0, 0.5" : input || "0.5, 0.5";
      let parsedInput = dNum.split(",").map((s) => s.trim());
      let posX = Number(parsedInput[0]);
      let posY = Number(parsedInput[1]);
      if (parsedInput.length === 2) {
        return { x: posX, y: posY };
      } else if (parsedInput.length === 1) {
        return { x: posX, y: posX };
      }
    }
  }
  function buildTile(tileX, tileY, isOverhead, tileWidth, tileHeight) {
    return {
      alpha: data2.options.opacity,
      width: tileWidth,
      height: tileHeight,
      img: data2.path.filePath,
      overhead: isOverhead,
      // false sets Tile in canvas.background. true sets Tile to canvas.foreground
      occlusion: {
        alpha: `${data2.options.occlusionAlpha}`,
        mode: data2.options.occlusionMode
      },
      video: {
        autoplay: true,
        loop: true,
        volume: 0
      },
      flags: {
        autoanimations: {
          origin: handler.itemUuid
        }
      },
      x: tileX,
      y: tileY,
      z: 100
    };
  }
}
async function aura$3(handler, animationData) {
  const data2 = animationData.primary;
  const secondary2 = animationData.secondary;
  const sourceFX = animationData.sourceFX;
  const targetFX = animationData.targetFX;
  const macro2 = animationData.macro;
  const sourceToken = handler.sourceToken;
  for (let target2 of handler.allTargets) {
    Sequencer.EffectManager.getEffects({ object: target2, origin: handler.itemUuid }).length > 0;
  }
  let aaSeq = new Sequence(handler.sequenceData);
  if (macro2 && macro2.playWhen === "1") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  if (sourceFX) {
    handler.compileSourceEffect(sourceFX, aaSeq);
  }
  if (data2.sound) {
    aaSeq.addSequence(data2.sound);
  }
  aaSeq.thenDo(function() {
    Hooks.callAll("aa.animationStart", handler);
  });
  if (data2.options.playOn === "source" || data2.options.playOn === "default" && handler.allTargets.length < 1) {
    const sourceCheckAnim = Sequencer.EffectManager.getEffects({ object: sourceToken, origin: handler.itemUuid }).length > 0;
    if (sourceCheckAnim) {
      return;
    }
    let aaEffect = aaSeq.effect();
    if (handler.isActiveEffect) {
      aaEffect.name(handler.itemName + `${sourceToken.id}`);
    } else {
      aaEffect.name(`spot ${sourceToken.id}`);
    }
    setPrimary(sourceToken, aaEffect);
    if (data2.options.isWait) {
      aaEffect.waitUntilFinished(data2.options.delay);
    }
    if (secondary2) {
      handler.compileSecondaryEffect(secondary2, aaSeq, [sourceToken], false, false);
    }
  }
  if ((data2.options.playOn === "target" || data2.options.playOn === "default") && handler.allTargets.length > 0) {
    let newTargetArray = [];
    for (let target2 of handler.allTargets) {
      let checkAnim = Sequencer.EffectManager.getEffects({ object: target2, origin: handler.itemUuid }).length > 0;
      if (!checkAnim) {
        newTargetArray.push(target2);
      }
    }
    if (newTargetArray.length < 1) {
      return;
    }
    for (let i = 0; i < newTargetArray.length; i++) {
      let currentTarget = newTargetArray[i];
      let aaEffect = aaSeq.effect();
      setPrimary(currentTarget, aaEffect);
      if (i === newTargetArray.length - 1 && data2.options.isWait) {
        aaEffect.waitUntilFinished(data2.options.delay);
      } else if (!data2.options.isWait) {
        aaEffect.delay(data2.options.delay);
      }
    }
    if (secondary2) {
      handler.compileSecondaryEffect(secondary2, aaSeq, newTargetArray, targetFX.enable, false);
    }
    if (targetFX) {
      handler.compileTargetEffect(targetFX, aaSeq, newTargetArray, false);
    }
  }
  if (data2.options.playOn === "both") {
    const sourceCheckAnim = Sequencer.EffectManager.getEffects({ object: sourceToken, origin: handler.itemUuid }).length > 0;
    let newTargetArray = [];
    for (let target2 of handler.allTargets) {
      let checkAnim = Sequencer.EffectManager.getEffects({ object: target2, origin: handler.itemUuid }).length > 0;
      if (!checkAnim) {
        newTargetArray.push(target2);
      }
    }
    if (sourceCheckAnim && newTargetArray.length < 1) {
      return;
    }
    if (!sourceCheckAnim) {
      let aaEffect = aaSeq.effect();
      setPrimary(sourceToken, aaEffect);
      if (handler.allTargets.length < 1 && data2.options.isWait) {
        aaEffect.waitUntilFinished(data2.options.delay);
      } else if (!data2.options.isWait) {
        aaEffect.delay(data2.options.delay);
      }
    }
    if (newTargetArray.length > 0) {
      for (let i = 0; i < newTargetArray.length; i++) {
        let currentTarget = newTargetArray[i];
        let aaEffect = aaSeq.effect();
        setPrimary(currentTarget, aaEffect);
        if (i === newTargetArray.length - 1 && data2.options.isWait) {
          aaEffect.waitUntilFinished(data2.options.delay);
        } else if (!data2.options.isWait) {
          aaEffect.delay(data2.options.delay);
        }
      }
    }
    if (secondary2) {
      handler.compileSecondaryEffect(secondary2, aaSeq, [sourceToken], false, false);
    }
    if (newTargetArray.length > 0) {
      if (secondary2) {
        handler.compileSecondaryEffect(secondary2, aaSeq, newTargetArray, targetFX.enable, false);
      }
      if (targetFX) {
        handler.compileTargetEffect(targetFX, aaSeq, newTargetArray, false);
      }
    }
  }
  function setPrimary(token, seq) {
    const size = handler.getSize(true, data2.options.size, token, data2.options.addTokenWidth);
    seq.file(data2.path.file);
    seq.persist(true, { persistTokenPrototype: true });
    seq.origin(handler.itemUuid);
    if (data2.options.tint) {
      seq.tint(data2.options.tintColor);
      seq.filter("ColorMatrix", { saturate: data2.options.tintSaturate });
    }
    seq.size(size, { gridUnits: true });
    seq.elevation(handler.elevation(token, data2.options.isAbsolute, data2.options.elevation), { absolute: data2.options.isAbsolute });
    seq.attachTo(token, { bindAlpha: data2.options.unbindAlpha, bindVisibility: data2.options.unbindVisibility });
    seq.opacity(data2.options.opacity);
    seq.fadeIn(data2.options.fadeIn);
    if (data2.video.variant === "complete" || data2.video.animation === "complete")
      ;
    else {
      seq.fadeOut(data2.options.fadeOut);
    }
    seq.zIndex(data2.options.zIndex);
    if (data2.options.breath) {
      seq.loopProperty("sprite", "scale.x", { from: data2.options.breathMin, to: data2.options.breathMax, duration: data2.options.breathDuration, pingPong: true, ease: "easeInOutSine", gridUnits: true });
      seq.loopProperty("sprite", "scale.y", { from: data2.options.breathMin, to: data2.options.breathMax, duration: data2.options.breathDuration, pingPong: true, ease: "easeInOutSine", gridUnits: true });
    }
    if (data2.options.alpha) {
      seq.loopProperty("alphaFilter", "alpha", { from: data2.options.alphaMin, to: data2.options.alphaMax, duration: data2.options.alphaDuration, pingPong: true });
    }
    seq.playbackRate(data2.options.playbackRate);
    if (handler.systemData.tieToDocuments) {
      seq.tieToDocuments(handler.item);
    }
  }
  if (macro2 && macro2.playWhen === "0") {
    handler.runMacro(macro2);
  }
  if (macro2 && macro2.playWhen === "3") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  aaSeq.play();
  howToDelete("sequencerground");
}
async function dualattach(handler, animationData) {
  const data2 = animationData.primary;
  const sourceFX = animationData.sourceFX;
  const macro2 = animationData.macro;
  const animFile = await buildFile("range", data2.video, data2.video.customPath);
  const onlyX = data2.video.customPath ? data2.options.onlyX : false;
  const sourceToken = handler.sourceToken;
  let effectExists = Sequencer.EffectManager.getEffects({ object: sourceToken, origin: handler.itemUuid });
  async function cast() {
    let aaSeq = await new Sequence(handler.sequenceData);
    if (macro2 && macro2.playWhen === "1" && !macro2?.args?.warpgateTemplate) {
      handler.complileMacroSection(aaSeq, macro2);
    }
    if (sourceFX) {
      handler.compileSourceEffect(sourceFX, aaSeq);
    }
    if (data2.sound) {
      aaSeq.addSequence(data2.sound);
    }
    aaSeq.thenDo(function() {
      Hooks.callAll("aa.animationStart", sourceToken, handler.allTargets);
    });
    for (let target2 of handler.allTargets) {
      let checkTarget = effectExists.filter((i) => i.data.target.includes(target2.id)).length > 0;
      if (!checkTarget) {
        aaSeq.effect().file(animFile.file).attachTo(sourceToken).stretchTo(target2, { attachTo: true, onlyX }).persist(true).playbackRate(data2.options.playbackRate).origin(handler.itemUuid).elevation(handler.elevation(sourceToken, data2.options.isAbsolute, data2.options.elevation), { absolute: data2.options.isAbsolute });
      }
    }
    if (macro2 && macro2.playWhen === "0" && !macro2?.args?.warpgateTemplate) {
      handler.runMacro(macro2);
    }
    if (macro2 && macro2.playWhen === "3") {
      handler.complileMacroSection(aaSeq, macro2);
    }
    aaSeq.play();
  }
  cast();
}
async function proToTemp(handler, animationData, templateDocument) {
  const data2 = animationData.primary;
  const sourceFX = animationData.sourceFX;
  const secondary2 = animationData.secondary;
  const targetFX = animationData.targetFX;
  const macro2 = animationData.macro;
  const template = handler.templateData ? handler.templateData : templateDocument;
  const sourceToken = handler.sourceToken;
  let aaSeq = await new Sequence(handler.sequenceData);
  if (data2.projectile.options.removeTemplate) {
    aaSeq.thenDo(function() {
      canvas.scene.deleteEmbeddedDocuments("MeasuredTemplate", [template.id]);
    });
  }
  if (macro2 && macro2.playWhen === "1" && !macro2?.args?.warpgateTemplate) {
    handler.complileMacroSection(aaSeq, macro2);
  }
  if (sourceFX) {
    handler.compileSourceEffect(sourceFX, aaSeq);
  }
  if (data2.projectile.sound) {
    aaSeq.addSequence(data2.projectile.sound);
  }
  aaSeq.effect().file(data2.projectile.path.file).atLocation(sourceToken).stretchTo(template, { cacheLocation: true, randomOffset: data2.projectile.options.randomOffset }).elevation(handler.elevation(sourceToken, data2.projectile.options.isAbsolute, data2.projectile.options.elevation), { absolute: data2.projectile.options.isAbsolute }).repeats(data2.projectile.options.repeat, data2.projectile.options.repeatDelay).playbackRate(data2.projectile.options.playbackRate).waitUntilFinished(data2.projectile.options.wait);
  if (data2.preExplosion.sound) {
    aaSeq.addSequence(data2.preExplosion.sound);
  }
  if (data2.preExplosion.enable) {
    aaSeq.effect().file(data2.preExplosion.path.file).atLocation(template, { cacheLocation: true }).elevation(handler.elevation(sourceToken, data2.preExplosion.options.isAbsolute, data2.preExplosion.options.elevation), { absolute: data2.preExplosion.options.isAbsolute }).scaleToObject(data2.preExplosion.options.scale).repeats(data2.preExplosion.options.repeat, data2.preExplosion.options.repeatDelay).playbackRate(data2.preExplosion.options.playbackRate).waitUntilFinished(data2.preExplosion.options.wait).aboveLighting(data2.preExplosion.options.aboveTemplate);
  }
  if (data2.explosion.sound) {
    aaSeq.addSequence(data2.explosion.sound);
  }
  aaSeq.effect().file(data2.explosion.path.file).atLocation(template, { cacheLocation: true }).elevation(handler.elevation(sourceToken, data2.explosion.options.isAbsolute, data2.explosion.options.elevation), { absolute: data2.explosion.options.isAbsolute }).scaleToObject(data2.explosion.options.scale).repeats(data2.explosion.options.repeat, data2.explosion.options.repeatDelay).zIndex(5).playbackRate(data2.explosion.options.playbackRate).waitUntilFinished(-750 + data2.explosion.options.wait).aboveLighting(data2.explosion.options.aboveTemplate);
  if (data2.afterImage.customPath) {
    aaSeq.effect().file(data2.afterImage.customPath).atLocation(template, { cacheLocation: true }).scaleToObject(data2.afterImage.options.scale).elevation(handler.elevation(sourceToken, data2.afterImage.options.isAbsolute, data2.afterImage.options.elevation), { absolute: data2.afterImage.options.isAbsolute }).persist(data2.afterImage.options.persistent).origin(handler.itemUuid).fadeIn(250).fadeOut(500);
  }
  if (secondary2) {
    handler.compileSecondaryEffect(secondary2, aaSeq, handler.allTargets, targetFX.enable, false);
  }
  if (targetFX) {
    handler.compileTargetEffect(targetFX, aaSeq, handler.allTargets, false);
  }
  if (macro2 && macro2.playWhen === "0" && !macro2?.args?.warpgateTemplate) {
    handler.runMacro(macro2);
  }
  if (data2.afterImage.enable && data2.afterImage.options.persistent) {
    howToDelete("sequencerground");
  }
  if (macro2 && macro2.playWhen === "3") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  aaSeq.play();
}
async function teleportation(handler, animationData) {
  const sourceToken = handler.sourceToken;
  const data2 = animationData.primary;
  const macro2 = animationData.macro;
  const startFile = await buildFile("static", data2.start, data2.start.customPath);
  const endFile = await buildFile("static", data2.end, data2.end.customPath);
  const betweenFile = await buildFile("range", data2.between, data2.between.customPath);
  let sourceTokenGS = sourceToken.w / canvas.grid.size;
  let userIDs = Array.from(game.users).map((user) => user.id);
  let gmIDs = Array.from(game.users).filter((i) => i.isGM).map((user) => user.id);
  const hideBorder = data2.options.hideFromPlayers ? gmIDs : userIDs;
  const delayFade = data2.options.delayFade || 0;
  const delayReturn = data2.options.delayReturn || 0;
  const borderSize = sourceTokenGS / canvas.grid.size + 0.5 + data2.options.range / canvas.dimensions.distance;
  const borderType = data2.options.measureType === "equidistant" ? "roundedRect" : "circle";
  const borderLocation = borderType === "circle" ? {} : { offset: { x: -borderSize, y: -borderSize }, gridUnits: true };
  const borderData = {
    lineSize: 4,
    lineColor: game.user.color,
    radius: borderType === "circle" ? borderSize : 0.25,
    width: borderSize * 2,
    height: borderSize * 2,
    gridUnits: true,
    name: "teleBorder"
  };
  let borderSeq = await new Sequence(handler.sequenceData);
  let borderEffect = borderSeq.effect().fadeIn(500).persist().fadeOut(500).atLocation(sourceToken, borderLocation).shape(borderType, borderData).elevation(sourceToken?.document?.elevation - 1).forUsers(hideBorder).name("teleportation").opacity(0.75);
  if (borderType === "circle") {
    borderEffect.loopProperty("shapes.teleBorder", "scale.x", { from: 0.98, to: 1.02, duration: 1500, pingPong: true, ease: "easeInOutSine" });
    borderEffect.loopProperty("shapes.teleBorder", "scale.y", { from: 0.98, to: 1.02, duration: 1500, pingPong: true, ease: "easeInOutSine" });
  }
  borderSeq.play();
  let pos;
  if (game.Levels3DPreview?._active) {
    let getPositionFrom3D = function() {
      game.Levels3DPreview.CONFIG.entityClass.Template3D.drawPreview(new MeasuredTemplateDocument(templateData), false).then((response) => {
        if (!response)
          return getPositionFrom3D();
        pos = {
          x: response.x,
          y: response.y,
          elevation: parseFloat(response.flags.levels.elevation)
        };
        let topLeft = canvas.grid.getTopLeft(pos.x, pos.y);
        if (canvas.grid.measureDistance(sourceToken, { x: topLeft[0], y: topLeft[1] }, { gridSpaces: true }) <= data2.options.range) {
          if (data2.options.checkCollision && testCollision(pos)) {
            ui.notifications.error("Your Path is Blocked!! Try Again");
            return getPositionFrom3D();
          } else {
            circle3d?.remove();
            deleteTemplatesAndMove();
          }
        } else {
          ui.notifications.error(game.i18n.format("autoanimations.settings.teleport"));
          return getPositionFrom3D();
        }
      });
    };
    const circle3d = data2.options.range ? new game.Levels3DPreview.CONFIG.entityClass.RangeRingEffect(sourceToken, data2.options.range, game.user.color) : null;
    const templateData = { t: "circle", user: game.user.id, distance: 5, x: 0, y: 0, fillColor: "#ffffff", width: 1, texture: "", direction: 0 };
    getPositionFrom3D();
  }
  canvas.app.stage.addListener("pointerdown", (event) => {
    if (event.data.button !== 0) {
      return;
    }
    pos = event.data.getLocalPosition(canvas.app.stage);
    let topLeft = canvas.grid.getTopLeft(pos.x, pos.y);
    if (canvas.grid.measureDistance(sourceToken, { x: topLeft[0], y: topLeft[1] }, { gridSpaces: true }) <= data2.options.range) {
      if (data2.options.checkCollision && testCollision(pos)) {
        ui.notifications.error("Your Path is Blocked!! Try Again");
      } else {
        deleteTemplatesAndMove();
        canvas.app.stage.removeListener("pointerdown");
      }
    } else {
      ui.notifications.error(game.i18n.format("autoanimations.settings.teleport"));
    }
  });
  function testCollision(pos2) {
    let pointerCenter = {
      x: canvas.grid.getCenter(pos2.x, pos2.y)[0],
      y: canvas.grid.getCenter(pos2.x, pos2.y)[1]
    };
    return sourceToken.checkCollision(pointerCenter);
  }
  async function deleteTemplatesAndMove() {
    let gridPos = canvas.grid.getTopLeft(pos.x, pos.y);
    let centerPos;
    if (canvas.scene.gridType === 0) {
      centerPos = [gridPos[0] + sourceToken.w, gridPos[1] + sourceToken.w];
    } else {
      centerPos = canvas.grid.getCenter(pos.x, pos.y);
    }
    Sequencer.EffectManager.endEffects({ name: "teleportation" });
    let aaSeq = new Sequence(handler.sequenceData);
    if (macro2 && macro2.playWhen === "1" && !macro2?.args?.warpgateTemplate) {
      handler.complileMacroSection(aaSeq, macro2);
    }
    let startX = sourceToken.center?.x;
    let startY = sourceToken.center?.y;
    if (data2.sound) {
      aaSeq.addSequence(data2.sound);
    }
    if (data2.start) {
      let startEffect = aaSeq.effect();
      startEffect.file(startFile.file);
      startEffect.atLocation({ x: startX, y: startY });
      startEffect.elevation(handler.elevation(sourceToken, data2.start.options.isAbsolute, data2.start.options.elevation), { absolute: data2.start.options.isAbsolute });
      startEffect.size(sourceTokenGS * 1.5 * data2.start.options.size, { gridUnits: true });
      startEffect.opacity(data2.start.options.opacity);
      startEffect.fadeIn(data2.start.options.fadeIn);
      startEffect.fadeOut(data2.start.options.fadeOut);
      startEffect.delay(data2.start.options.delay);
      startEffect.playbackRate(data2.start.options.playbackRate);
      if (data2.start.options.isMasked) {
        startEffect.mask(sourceToken);
      }
    }
    if (data2.between) {
      let betweenEffect = aaSeq.effect();
      betweenEffect.file(betweenFile.file);
      betweenEffect.atLocation({ x: startX, y: startY });
      betweenEffect.delay(data2.between.options.delay);
      betweenEffect.elevation(handler.elevation(sourceToken, data2.between.options.isAbsolute, data2.between.options.elevation), { absolute: data2.between.options.isAbsolute });
      betweenEffect.opacity(data2.between.options.opacity);
      betweenEffect.stretchTo({ x: centerPos[0], y: centerPos[1] });
      betweenEffect.playbackRate(data2.between.options.playbackRate);
    }
    if (data2.end) {
      let endEffect = aaSeq.effect();
      endEffect.file(endFile.file);
      endEffect.atLocation({ x: centerPos[0], y: centerPos[1] });
      endEffect.delay(data2.end.options.delay);
      endEffect.elevation(handler.elevation(sourceToken, data2.end.options.isAbsolute, data2.end.options.elevation), { absolute: data2.end.options.isAbsolute });
      endEffect.size(sourceTokenGS * 1.5 * data2.end.options.size, { gridUnits: true });
      endEffect.fadeIn(data2.end.options.fadeIn);
      endEffect.fadeOut(data2.end.options.fadeOut);
      endEffect.playbackRate(data2.end.options.playbackRate);
      if (data2.end.options.isMasked) {
        endEffect.mask(sourceToken);
      }
    }
    if (data2.options.alpha < 1) {
      let fadeSeq = aaSeq.animation();
      fadeSeq.on(sourceToken);
      fadeSeq.opacity(data2.options.alpha);
      fadeSeq.delay(delayFade);
    }
    let animSeq = aaSeq.animation();
    animSeq.on(sourceToken);
    animSeq.delay(data2.options.delayMove);
    if (data2.options.teleport) {
      animSeq.teleportTo({ x: gridPos[0], y: gridPos[1], elevation: pos.elevation });
    } else {
      animSeq.moveTowards({ x: gridPos[0], y: gridPos[1], elevation: pos.elevation });
      animSeq.moveSpeed(data2.options.speed);
    }
    if (data2.options.alpha < 1) {
      let tokenSeq = aaSeq.animation();
      tokenSeq.on(sourceToken);
      tokenSeq.opacity(1);
      tokenSeq.delay(delayFade + delayReturn);
    }
    if (macro2 && macro2.playWhen === "0" && !macro2?.args?.warpgateTemplate) {
      handler.runMacro(macro2);
    }
    if (macro2 && macro2.playWhen === "3") {
      handler.complileMacroSection(aaSeq, macro2);
    }
    aaSeq.play();
  }
}
const wait$1 = (delay) => new Promise((resolve) => setTimeout(resolve, delay));
async function thunderwave(handler, animationData, config) {
  const sourceToken = handler.sourceToken;
  const data2 = animationData.primary;
  const sourceFX = animationData.sourceFX;
  const macro2 = animationData.macro;
  let color = data2.color;
  const template = config ? config : canvas.templates.placeables[canvas.templates.placeables.length - 1];
  const templateData = config ? config || {} : template.document || {};
  Math.sqrt(Math.pow(templateData.distance, 2) / 2);
  const getPosition = getRelativePosition(sourceToken, templateData);
  const angle = getPosition.angle;
  const databasePath = color === "random" ? `autoanimations.templatefx.square.thunderwave.${getPosition.type}` : `autoanimations.templatefx.square.thunderwave.${getPosition.type}.${color}`;
  canvas.scene.data.grid.size;
  let aaSeq = await new Sequence(handler.sequenceData);
  if (macro2 && macro2.playWhen === "1") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  if (sourceFX) {
    handler.compileSourceEffect(sourceFX, aaSeq);
  }
  if (data2.sound) {
    aaSeq.addSequence(data2.sound);
  }
  aaSeq.thenDo(function() {
    Hooks.callAll("aa.animationStart", sourceToken, "no-target");
  });
  aaSeq.effect().file(databasePath).atLocation(template, { cacheLocation: true }).anchor({ x: 0.5, y: 0.5 }).rotate(angle).opacity(data2.options.opacity).size(3, { gridUnits: true }).elevation(handler.elevation(sourceToken, data2.options.isAbsolute, data2.options.elevation), { absolute: data2.options.isAbsolute }).repeats(data2.options.repeat, data2.options.repeatDelay);
  if (macro2 && macro2.playWhen === "0") {
    handler.runMacro(macro2);
  }
  if (data2.options.removeTemplate) {
    canvas.scene.deleteEmbeddedDocuments("MeasuredTemplate", [template.id]);
  }
  if (macro2 && macro2.playWhen === "3") {
    handler.complileMacroSection(aaSeq, macro2);
  }
  aaSeq.play();
  await wait$1(500);
  Hooks.callAll("aa.animationEnd", sourceToken, "no-target");
  function getRelativePosition(token, template2) {
    const xPos = token.x;
    const yPos = token.y;
    const tempY = template2.y;
    const tempX = template2.x;
    const gridSize = canvas.scene.data.grid.size;
    let type;
    let angle2;
    switch (true) {
      case (xPos >= tempX && xPos <= tempX + gridSize * 2 && (yPos >= tempY && yPos <= tempY + gridSize * 2)):
        type = "center";
        angle2 = 0;
        break;
      case (xPos >= tempX - gridSize && xPos <= tempX - gridSize * 0.5 && (yPos >= tempY - gridSize && yPos <= tempY - gridSize * 0.5)):
        type = "left";
        angle2 = 270;
        break;
      case (xPos >= tempX + gridSize * 2.5 && xPos <= tempX + gridSize * 3 && (yPos >= tempY - gridSize && yPos <= tempY - gridSize * 0.5)):
        type = "left";
        angle2 = 180;
        break;
      case (xPos >= tempX + gridSize * 2.5 && xPos <= tempX + gridSize * 3 && (yPos <= tempY + gridSize * 3 && yPos >= tempY + gridSize * 2.5)):
        type = "left";
        angle2 = 90;
        break;
      case (xPos <= tempX - gridSize * 0.5 && xPos >= tempX - gridSize && (yPos <= tempY + gridSize * 3 && yPos >= tempY + gridSize * 2.5)):
        type = "left";
        angle2 = 0;
        break;
      case (xPos >= tempX + gridSize * 2.5 && (yPos >= tempY && yPos <= tempY + gridSize * 2)):
        type = "mid";
        angle2 = 90;
        break;
      case (xPos >= tempX && xPos <= tempX + gridSize * 2 && (yPos >= tempY - gridSize && yPos <= tempY - gridSize * 0.5)):
        type = "mid";
        angle2 = 180;
        break;
      case (xPos >= tempX - gridSize && xPos <= tempX - gridSize * 0.5 && (yPos >= tempY && yPos <= tempY + gridSize * 2)):
        type = "mid";
        angle2 = 270;
        break;
      default:
        type = "mid";
        angle2 = 0;
    }
    return { type, angle: angle2 };
  }
}
async function particleEffects(handler, animationData = {}) {
  const data2 = await DataSanitizer.compileParticleData(animationData);
  if (!data2) {
    return;
  }
  const secondary2 = data2.secondary;
  const tokenAnim = data2.tokenAnimation;
  const sourceToken = handler.sourceToken;
  const targets2 = handler.allTargets;
  if (data2.sound) {
    const audio = data2.sound;
    audio.play();
  }
  const tokenAnimationData = {};
  function compileTokenAnimationData() {
    if (tokenAnim.source) {
      tokenAnimationData.from = {
        id: tokenAnim.sourceType,
        options: {
          start: tokenAnim.sourceStart,
          end: tokenAnim.sourceEnd
        }
      };
    }
    if (tokenAnim.target) {
      tokenAnimationData.to = {
        id: tokenAnim.targetType,
        options: {
          start: tokenAnim.targetStart,
          end: tokenAnim.targetEnd
        }
      };
    }
    return tokenAnimationData;
  }
  class ParticleFunctions {
    static particle(data3, sourceToken2, targets3) {
      const spriteData = new Particle3D(data3.type);
      spriteData.from(sourceToken2);
      spriteData.to(targets3);
      spriteData.speed(data3.speed);
      spriteData.repeat(data3.repeat);
      spriteData.arc(data3.arc);
      spriteData.delay(data3.delay);
      spriteData.color(data3.color01, data3.color02);
      spriteData.scale(data3.scale);
      spriteData.sprite(data3.sprite);
      spriteData.life(data3.life);
      spriteData.emitterSize(data3.emittersize);
      spriteData.alpha(data3.alpha);
      spriteData.mass(data3.mass);
      spriteData.gravity(data3.gravity);
      spriteData.rotateTowards(data3.rotateTowards);
      spriteData.rotation(data3.rotationX, data3.rotationY, data3.rotationZ);
      spriteData.duration(data3.duration);
      spriteData.onCenter(data3.onCenter);
      spriteData.autoSize(data3.autoSize);
      spriteData.rate(data3.rate, 1);
      spriteData.presetIntensity(data3.rate);
      if (tokenAnim.enable && (tokenAnim.source || tokenAnim.target)) {
        spriteData.playAnimation(compileTokenAnimationData());
      }
      if (secondary2.enable) {
        spriteData.onEnd(
          new Particle3D(secondary2.type ?? "e").sprite(secondary2.sprite).speed(secondary2.speed).color(secondary2.color01, secondary2.color02).scale(secondary2.scale).gravity(secondary2.gravity).life(secondary2.life).rate(secondary2.rate, 1).presetIntensity(secondary2.rate).emitterSize(secondary2.emittersize).duration(secondary2.duration).onCenter(secondary2.onCenter).autoSize(secondary2.autoSize).alpha(secondary2.alpha).mass(secondary2.mass)
        );
      }
      spriteData.start();
    }
    static token() {
      let tokens;
      switch (data2.playOn) {
        case "target":
          tokens = targets2;
          break;
        case "default":
          if (targets2.length) {
            tokens = targets2;
          } else {
            tokens = sourceToken;
          }
          break;
        case "both":
          if (targets2.length) {
            tokens = [sourceToken, ...targets2];
          } else {
            tokens = sourceToken;
          }
          break;
        default:
          tokens = sourceToken;
      }
      let options2 = {
        repeats: data2.repeat,
        resetTime: data2.resetTime
      };
      game.Levels3DPreview.playTokenAnimation(tokens, data2.animationType, options2);
    }
  }
  data2.type == "token" ? ParticleFunctions.token(data2, sourceToken, targets2) : ParticleFunctions.particle(data2, sourceToken, targets2);
}
const animate = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aura: aura$3,
  dualattach,
  melee: melee$3,
  ontoken: ontoken$3,
  particleEffects,
  proToTemp,
  range: range$3,
  teleportation,
  templatefx: templatefx$3,
  thunderwave
}, Symbol.toStringTag, { value: "Module" }));
const wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay));
async function trafficCop$1(handler) {
  if (!handler) {
    return;
  }
  const data2 = foundry.utils.deepClone(handler.animationData);
  if (data2.advanced?.excludedType?.enabled && data2.advanced?.excludedType?.path && data2.advanced?.excludedType?.property) {
    if (AAAutorecFunctions.checkExcludedProperty(handler.item, data2.advanced?.excludedType?.property, data2.advanced?.excludedType?.path)) {
      return;
    }
  }
  Hooks.callAll("aa.preDataSanitize", handler, data2);
  const sanitizedData = await DataSanitizer._getAnimationData(handler, data2);
  Hooks.callAll("aa.preAnimationStart", sanitizedData);
  let globalDelay = game.settings.get("autoanimations", "globaldelay");
  await wait(globalDelay);
  let aaTemplateHook;
  if (sanitizedData.macro && sanitizedData.macro.enable && sanitizedData.macro.playWhen === "2") {
    let playMacro = function() {
      handler.runMacro(sanitizedData.macro);
    };
    if (handler.isTemplateAnimation) {
      switch (game.system.id) {
        case "a5e":
        case "sw5e":
        case "tormenta20":
        case "swade":
          aaTemplateHook = Hooks.once("createMeasuredTemplate", async (template) => {
            await wait(500);
            handler.templateData = template;
            playMacro();
          });
          setTimeout(killHook, 3e4);
          break;
        default:
          await wait(500);
          handler.templateData = canvas.templates?.placeables?.[canvas.templates.placeables.length - 1]?.document;
          playMacro();
      }
    } else {
      playMacro();
    }
    return;
  }
  if (data2.soundOnly?.sound?.enable && data2.soundOnly?.sound?.file) {
    const sound2 = {
      file: data2.soundOnly?.sound?.file ?? "",
      volume: data2.soundOnly?.sound?.volume ?? 0.75,
      delay: data2.soundOnly?.sound?.delay ?? 0,
      startTime: data2.soundOnly?.sound?.startTime ?? 0,
      repeat: data2.soundOnly?.sound?.repeat ?? 1,
      repeatDelay: data2.soundOnly?.sound?.repeatDelay ?? 250
    };
    new Sequence(handler.sequenceData).sound().file(sound2.file).volume(sound2.volume).delay(sound2.delay).startTime(sound2.startTime).repeats(sound2.repeat, sound2.repeatDelay).play();
    return;
  }
  if (data2.levels3d?.type && game.Levels3DPreview?._active) {
    particleEffects(handler, data2);
    return;
  }
  const animationType = data2.menu === "preset" ? data2.presetType : data2.menu === "aefx" ? data2.activeEffectType : data2.menu;
  const targets2 = handler.allTargets?.length;
  if (animationType === "templatefx" || animationType === "proToTemp") {
    if (animationType === "proToTemp" && !handler.sourceToken) {
      debug$1("Failed to initialize a Source Token");
      return;
    }
    debug$1(`${animationType} Animation Start"`, handler, sanitizedData);
    if (handler.templateData) {
      await wait(500);
      animate[animationType](handler, sanitizedData);
      return;
    }
    if (sanitizedData?.macro && sanitizedData?.macro?.args?.warpgateTemplate) {
      if (isNewerVersion(game.version, 11)) {
        new Sequence().macro(sanitizedData.macro.name, { args: [handler.workflow, handler, sanitizedData.macro.args] }).play();
      } else {
        if (game.modules.get("advanced-macros")?.active) {
          new Sequence().macro(sanitizedData.macro.name, handler.workflow, handler, sanitizedData.macro.args).play();
        } else {
          new Sequence().macro(sanitizedData.macro.name).play();
        }
      }
      aaTemplateHook = Hooks.once("createMeasuredTemplate", async (template) => {
        await wait(500);
        animate[animationType](handler, sanitizedData, template);
      });
      setTimeout(killHook, 3e4);
      return;
    }
    switch (game.system.id) {
      case "a5e":
      case "pf2e":
      case "sw5e":
      case "tormenta20":
      case "swade":
        aaTemplateHook = Hooks.once("createMeasuredTemplate", async (template2) => {
          await wait(500);
          animate[animationType](handler, sanitizedData, template2);
        });
        setTimeout(killHook, 3e4);
        break;
      default:
        await wait(500);
        let template = canvas.templates?.placeables?.[canvas.templates.placeables.length - 1]?.document;
        if (!template) {
          debug$1("No template found for the Template animaiton, existing early");
          return;
        }
        animate[animationType](handler, sanitizedData, template);
    }
    return;
  } else {
    if (!handler.sourceToken || targets2 < 1 && (animationType === "melee" || animationType === "range")) {
      Hooks.callAll("aa.animationEnd", handler.sourceToken, "no-target");
      debug$1(`${animationType} Animation End", "NO TARGETS`);
      return;
    }
    debug$1(`${animationType} Animation Start"`, sanitizedData);
    animate[animationType](handler, sanitizedData);
    return;
  }
  function killHook() {
    Hooks.off("createMeasuredTemplate", aaTemplateHook);
  }
}
class AutoAnimations {
  static async playAnimation(sourceToken, targets2, item2, options2 = {}) {
    custom_warning("AutoAnimations.playAnimation is deprecated in favor of AutomatedAnimations.PlayAnimation. This will be removed in Version 5");
    if (!Array.isArray(targets2)) {
      targets2 = Array.from(targets2);
    }
    const data2 = {
      token: sourceToken,
      targets: targets2,
      item: item2,
      ...options2
    };
    const handler = await AAHandler.make(data2);
    trafficCop$1(handler);
  }
}
async function playAnimation(sourceToken, item2, options2 = {}) {
  if (!item2) {
    return;
  }
  let targets2;
  if (options2.targets) {
    if (options2.targets instanceof Set) {
      targets2 = Array.from(options2.targets);
    } else if (options2.targets instanceof Array) {
      targets2 = options2.targets;
    } else {
      targets2 = [options2.targets];
    }
  } else {
    targets2 = Array.from(game.user.targets);
  }
  const data2 = {
    token: sourceToken,
    targets: targets2,
    item: item2,
    ...options2
  };
  const handler = await AAHandler.make(data2);
  trafficCop$1(handler);
  return handler;
}
async function mergeVersion01(data2) {
  let currentAutorec = data2;
  const staticObject = currentAutorec.static;
  if (staticObject) {
    const staticLength = Object.keys(staticObject).length;
    for (var i = 0; i < staticLength; i++) {
      switch (staticObject[i].animation) {
        case "curewounds":
        case "generichealing":
        case "tollthedead":
          staticObject[i].staticOptions = "staticSpells";
          break;
        case "bite":
        case "claw":
          staticObject[i].staticOptions = "creature";
          break;
        default:
          staticObject[i].staticOptions = "explosion";
      }
    }
  }
  const templates = currentAutorec.templates;
  if (templates) {
    const templateLength = Object.keys(templates).length;
    for (var i = 0; i < templateLength; i++) {
      switch (true) {
        case templates[i].persist:
          if (templates[i].overhead) {
            templates[i].persistType = "overheadtile";
          } else {
            templates[i].persistType = "sequencerground";
          }
          break;
      }
    }
  }
  currentAutorec.version = 1;
  return currentAutorec;
}
async function mergeVersion02(data2) {
  let currentAutorec = data2;
  const meleeObject = currentAutorec.melee;
  if (meleeObject) {
    const meleeLength = Object.keys(meleeObject).length;
    for (var i = 0; i < meleeLength; i++) {
      meleeObject[i].meleeType = "weapon";
    }
  }
  currentAutorec.version = 2;
  return currentAutorec;
}
async function mergeVersion03(data2) {
  let currentAutorec = data2;
  const templateObject = currentAutorec.templates;
  if (templateObject) {
    const templateLength = Object.keys(templateObject).length;
    for (var i = 0; i < templateLength; i++) {
      templateObject[i].scaleX = templateObject[i].scale || 1;
      templateObject[i].scaleY = templateObject[i].scale || 1;
    }
  }
  const presetObject = currentAutorec.preset;
  if (presetObject) {
    const presetLength = Object.keys(presetObject).length;
    for (var i = 0; i < presetLength; i++) {
      if (presetObject[i].animation === "teleportation") {
        presetObject[i].measureType = "alternating";
        presetObject[i].custom02 = presetObject[i].custom ? true : false;
        presetObject[i].customPath02 = presetObject[i].custom ? presetObject[i].customPath : "";
        presetObject[i].subAnimation02 = presetObject[i].subAnimation ?? "mistystep";
        presetObject[i].variant = "01";
        presetObject[i].variant02 = "02";
        presetObject[i].color02 = presetObject[i].color ?? "blue";
        presetObject[i].scale02 = presetObject[i].scale || 1;
      }
    }
  }
  currentAutorec.version = 3;
  return currentAutorec;
}
async function mergeVersion04(data2) {
  let currentAutorec = data2;
  const meleeObject = currentAutorec.melee;
  const rangeObject = currentAutorec.range;
  const staticObject = currentAutorec.static;
  const templateObject = currentAutorec.templates;
  const auraObject = currentAutorec.auras;
  const presetObject = currentAutorec.preset;
  if (meleeObject) {
    const generic = ["1hs", "2hs", "1hp", "2hp", "1hb", "2hb"];
    const meleeLength = Object.keys(meleeObject).length;
    for (var i = 0; i < meleeLength; i++) {
      let co = meleeObject[i];
      if (co.custom)
        ;
      else {
        if (generic.some((el) => co.animation === el)) {
          co.menuType = "generic";
        } else {
          co.menuType = co.meleeType;
        }
      }
      if (co.switchType === "custom") {
        co.switchMenuType = "weapon";
      }
      if (co.explosion?.enable && !co.explosion.custom) {
        const fire = ["eruption"];
        const generic2 = ["boulderimpact", "explosion", "impact", "outpulse01", "outpulse02"];
        const ice = ["snowflake"];
        const liquid = ["liquidsplash"];
        const fireball = ["fireballexplode"];
        switch (true) {
          case fire.some((el) => co.explosion.animation === el):
            co.explosion.menuType = "fire";
            break;
          case generic2.some((el) => co.explosion.animation === el):
            co.explosion.menuType = "generic";
            if (co.explosion.animation.includes("outpulse")) {
              co.explosion.animation = "outpulse";
              co.explosion.variant = co.explosion.variant === "outpulse02" ? "02" : "01";
            }
            break;
          case ice.some((el) => co.explosion.animation === el):
            co.explosion.menuType = "ice";
            break;
          case liquid.some((el) => co.explosion.animation === el):
            co.explosion.menuType = "liquid";
            co.explosion.animation = "splash";
            break;
          case fireball.some((el) => co.explosion.animation === el):
            co.explosion.menuType = "spell";
            co.explosion.animation = "fireball";
            co.explosion.variant = "explode";
            break;
          default:
            co.explosion.menuType = "spell";
        }
      }
    }
  }
  if (rangeObject) {
    const generic = ["energyconduitsquare", "energyconduitcircle", "energybeam", "heart", "iceshard", "musicnote", "skull", "energystrand"];
    const rangeLength = Object.keys(rangeObject).length;
    for (var i = 0; i < rangeLength; i++) {
      let ro = rangeObject[i];
      if (generic.some((el) => ro.animation === el)) {
        ro.menuType = "generic";
        if (ro.animation === "energyconduitcircle") {
          ro.animation = "conduit";
          ro.variant = "circle";
        }
        if (ro.animation === "energyconduitsquare") {
          ro.animation = "conduit";
          ro.variant = "square";
        }
      } else {
        ro.menuType = ro.type;
      }
      if (ro.explosion?.enable && !ro.explosion.custom) {
        const fire = ["eruption"];
        const generic2 = ["boulderimpact", "explosion", "impact", "outpulse01", "outpulse02"];
        const ice = ["snowflake"];
        const liquid = ["liquidsplash"];
        const fireball = ["fireballexplode"];
        switch (true) {
          case fire.some((el) => ro.explosion.animation === el):
            ro.explosion.menuType = "fire";
            break;
          case generic2.some((el) => ro.explosion.animation === el):
            ro.explosion.menuType = "generic";
            if (ro.explosion.animation.includes("outpulse")) {
              ro.explosion.animation = "outpulse";
              ro.explosion.variant = ro.explosion.variant === "outpulse02" ? "02" : "01";
            }
            break;
          case ice.some((el) => ro.explosion.animation === el):
            ro.explosion.menuType = "ice";
            break;
          case liquid.some((el) => ro.explosion.animation === el):
            ro.explosion.menuType = "liquid";
            ro.explosion.animation = "splash";
            break;
          case fireball.some((el) => ro.explosion.animation === el):
            ro.explosion.menuType = "spell";
            ro.explosion.animation = "fireball";
            ro.explosion.variant = "explode";
            break;
          default:
            ro.explosion.menuType = "spell";
        }
      }
    }
  }
  if (staticObject) {
    const conditions = ["drop", "fear", "heart", "horror", "light", "poison", "runes", "shields", "crackedshield", "skull", "snowflakes", "stun", "dizzystars"];
    const creature = ["bite", "claw"];
    const energy = ["energyfield", "dodecahedron", "shimmer", "sparkles"];
    const fire = ["eruption", "groundcrack", "fireworks"];
    const generic = ["boulderimpact", "explosion", "impact", "outpulse01", "outpulse02", "vortex", "whirl"];
    const ice = ["icespikes", "snowflake"];
    const lightning = ["lightningball", "staticelectricity"];
    const liquid = ["liquidsplash"];
    const magicsign = ["magicSign"];
    const marker = ["marker", "circleofstars", "energystrand"];
    const shieldfx = ["energyfieldtop", "shieldfiretop", "shieldicetop", "shieldearthtop", "shieldeldritchwebtop"];
    const tokenborder = ["staticborder", "spinningborder"];
    const fireball = ["fireballexplode"];
    const staticLength = Object.keys(staticObject).length;
    for (var i = 0; i < staticLength; i++) {
      let so = staticObject[i];
      switch (true) {
        case conditions.some((el) => so.animation === el):
          so.menuType = "conditions";
          break;
        case creature.some((el) => so.animation === el):
          so.menuType = "creature";
          break;
        case energy.some((el) => so.animation === el):
          so.menuType = "energy";
          break;
        case fire.some((el) => so.animation === el):
          so.menuType = "fire";
          break;
        case generic.some((el) => so.animation === el):
          so.menuType = "generic";
          if (so.animation.includes("outpulse")) {
            so.variant = so.animation === "outpulse02" ? "02" : "01";
            so.animation = "outpulse";
          }
          break;
        case ice.some((el) => so.animation === el):
          so.menuType = "ice";
          break;
        case lightning.some((el) => so.animation === el):
          so.menuType = "lightning";
          break;
        case liquid.some((el) => so.animation === el):
          so.menuType = "liquid";
          so.animation = "splash";
          break;
        case magicsign.some((el) => so.animation === el):
          so.menuType = "magicsign";
          break;
        case marker.some((el) => so.animation === el):
          so.menuType = "marker";
          if (so.animation === "circleofstars")
            ;
          else if (so.animation === "energystrand") {
            so.animation = "energystrand";
          } else {
            switch (so.variant) {
              case "03":
                so.animation = "music";
                so.variant = "01";
                break;
              case "bubble":
                so.animation = "bubble";
                so.variant = "01";
                break;
              case "energystrand":
                so.animation = "energystrands";
                so.variant = "01";
                break;
              default:
                so.animation = "standard";
                so.variant = "01";
            }
          }
          break;
        case shieldfx.some((el) => so.animation === el):
          so.menuType = "shieldfx";
          switch (so.animation) {
            case "energyfieldtop":
              so.animation = "energyfield";
              break;
            case "shieldfiretop":
              so.animation = "fire";
              break;
            case "shieldicetop":
              so.animation = "ice";
              break;
            case "shieldearthtop":
              so.animation = "earth";
              break;
            case "shieldeldritchwebtop":
              so.animation = "eldritchweb";
              break;
          }
          break;
        case tokenborder.some((el) => so.animation === el):
          so.menuType = "tokenborder";
          if (so.animation === "staticborder") {
            so.animation = "static";
          } else {
            so.animation = "spinning";
          }
          break;
        case fireball.some((el) => so.animation === el):
          so.menuType = "spell";
          so.animation = "fireball";
          so.variant = "explode";
          break;
        default:
          so.menuType = "spell";
      }
      if (so.explosion?.enable && !so.explosion.custom) {
        const fire2 = ["eruption"];
        const generic2 = ["boulderimpact", "explosion", "impact", "outpulse01", "outpulse02"];
        const ice2 = ["snowflake"];
        const liquid2 = ["liquidsplash"];
        const fireball2 = ["fireballexplode"];
        switch (true) {
          case fire2.some((el) => so.explosion.animation === el):
            so.explosion.menuType = "fire";
            break;
          case generic2.some((el) => so.explosion.animation === el):
            so.explosion.menuType = "generic";
            if (so.explosion.animation.includes("outpulse")) {
              so.explosion.animation = "outpulse";
              so.explosion.variant = so.explosion.variant === "outpulse02" ? "02" : "01";
            }
            break;
          case ice2.some((el) => so.explosion.animation === el):
            so.explosion.menuType = "ice";
            break;
          case liquid2.some((el) => so.explosion.animation === el):
            so.explosion.menuType = "liquid";
            so.explosion.animation = "splash";
            break;
          case fireball2.some((el) => so.explosion.animation === el):
            so.explosion.menuType = "spell";
            so.explosion.animation = "fireball";
            so.explosion.variant = "explode";
            break;
          default:
            so.explosion.menuType = "spell";
        }
      }
    }
  }
  if (templateObject) {
    const templateLength = Object.keys(templateObject).length;
    for (var i = 0; i < templateLength; i++) {
      let to = templateObject[i];
      to.menuType = to.type === "rect" ? "square" : to.type;
      switch (to.menuType) {
        case "cone":
          if (to.animation === "breathweaponcone") {
            to.animation = "breathweapon";
          }
          break;
        case "circle":
          const circleTypes = ["dropct", "fearct", "heartct", "horrorct", "poisonct", "runesct", "shieldsct", "crackedshieldct", "skullct", "snowflakesct", "musicnotect"];
          if (circleTypes.some((el) => to.animation === el)) {
            to.animation = to.animation.replace("ct", "");
          }
          switch (to.animation) {
            case "outpulse01":
              to.animation = "outpulse";
              to.variant = "01";
              break;
            case "outpulse02":
              to.animation = "outpulse";
              to.variant = "02";
              break;
            case "fireballloop":
              to.animation = "fireball";
              to.variant = to.variant === "nodebris" ? "nodebris" : "loop";
              break;
            case "fireballexplode":
              to.animation = "fireball";
              to.variant = "explode";
              break;
          }
          break;
        case "square":
          const squareTypes = ["dropct", "fearct", "heartct", "horrorct", "poisonct", "runesct", "shieldsct", "crackedshieldct", "skullct", "snowflakesct"];
          if (squareTypes.some((el) => to.animation === el)) {
            to.animation = to.animation.replace("ct", "");
          } else if (to.animation === "musicnotest") {
            to.animation = "musicnote";
          }
          break;
        case "ray":
          if (to.animation === "breathweaponline") {
            to.animation = "breathweapon";
          }
          break;
      }
    }
  }
  if (auraObject) {
    const auraLength = Object.keys(auraObject).length;
    for (var i = 0; i < auraLength; i++) {
      let ao = auraObject[i];
      switch (ao.animation) {
        case "energystrand":
          ao.menuType = "marker";
          break;
        case "dodecahedron":
          ao.menuType = "energy";
          break;
        case "staticelectricity":
          ao.menuType = "lightning";
          break;
        default:
          ao.menuType = "spell";
      }
    }
  }
  if (presetObject) {
    const presetLength = Object.keys(presetObject).length;
    for (var i = 0; i < presetLength; i++) {
      let po = presetObject[i];
      switch (po.animation) {
        case "teleportation":
          po.menuType = "spell";
          po.menuType02 = "spell";
          break;
        case "dualattach":
          switch (po.subAnimation) {
            case "energystrand":
            case "energybeam":
              po.menuType = "generic";
              break;
            default:
              po.menuType = "spell";
          }
          break;
        case "fireball":
          const fire = ["eruption"];
          const generic = ["boulderimpact", "explosion", "impact", "outpulse01", "outpulse02"];
          const ice = ["snowflake"];
          const liquid = ["liquidsplash"];
          const fireball = ["fireballexplode"];
          switch (po.projectile) {
            case "energystrand":
            case "energybeam":
              po.rangeType = "generic";
              break;
            default:
              po.rangeType = "spell";
          }
          if (po.explosion01) {
            switch (true) {
              case fire.some((el) => po.explosion01 === el):
                po.ex01Type = "fire";
                break;
              case generic.some((el) => po.explosion01 === el):
                po.ex01Type = "generic";
                if (po.explosion01.includes("outpulse")) {
                  po.explosion01 = "outpulse";
                  po.explosion01Variant = po.explosion01Variant === "outpulse02" ? "02" : "01";
                }
                break;
              case ice.some((el) => po.explosion01 === el):
                po.ex01Type = "ice";
                break;
              case liquid.some((el) => po.explosion01 === el):
                po.ex01Type = "liquid";
                po.explosion01 = "splash";
                break;
              case fireball.some((el) => po.explosion01 === el):
                po.ex01Type = "spell";
                po.explosion01 = "fireball";
                po.explosion01Variant = "explode";
                break;
              default:
                po.ex01Type = "spell";
            }
          }
          if (po.explosion02) {
            switch (true) {
              case fire.some((el) => po.explosion02 === el):
                po.ex02Type = "fire";
                break;
              case generic.some((el) => po.explosion02 === el):
                po.ex02Type = "generic";
                if (po.explosion01.includes("outpulse")) {
                  po.explosion01 = "outpulse";
                  po.explosion01Variant = po.explosion01Variant === "outpulse02" ? "02" : "01";
                }
                break;
              case ice.some((el) => po.explosion02 === el):
                po.ex02Type = "ice";
                break;
              case liquid.some((el) => po.explosion02 === el):
                po.ex02Type = "liquid";
                po.explosion02 = "splash";
                break;
              case fireball.some((el) => po.explosion02 === el):
                po.ex02Type = "spell";
                po.explosion02 = "fireball";
                po.explosion02Variant = "explode";
                break;
              default:
                po.ex02Type = "spell";
            }
          }
          break;
      }
    }
  }
  currentAutorec.version = 4;
  return currentAutorec;
}
async function mergeVersion05(data2) {
  let currentAutorec = data2;
  const meleeObject = currentAutorec.melee;
  const rangeObject = currentAutorec.range;
  const staticObject = currentAutorec.static;
  const templateObject = currentAutorec.templates;
  const auraObject = currentAutorec.auras;
  const presetObject = currentAutorec.preset;
  const aefxObject = currentAutorec.aefx;
  const newMenu = {
    melee: [],
    range: [],
    ontoken: [],
    templatefx: [],
    aura: [],
    preset: [],
    aefx: [],
    version: 5
  };
  if (meleeObject) {
    const dataLength = Object.keys(meleeObject).length;
    for (var i = 0; i < dataLength; i++) {
      const oldMO = meleeObject[i];
      let newMO = {};
      let current = await convertV6(oldMO, newMO, "melee");
      newMenu.melee.push(current);
    }
  }
  if (rangeObject) {
    const dataLength = Object.keys(rangeObject).length;
    for (var i = 0; i < dataLength; i++) {
      const oldMO = rangeObject[i];
      let newMO = {};
      let current = await convertV6(oldMO, newMO, "range");
      newMenu.range.push(current);
    }
  }
  if (staticObject) {
    const dataLength = Object.keys(staticObject).length;
    for (var i = 0; i < dataLength; i++) {
      const oldMO = staticObject[i];
      let newMO = {};
      let current = await convertV6(oldMO, newMO, "ontoken");
      newMenu.ontoken.push(current);
    }
  }
  if (templateObject) {
    const dataLength = Object.keys(templateObject).length;
    for (var i = 0; i < dataLength; i++) {
      const oldMO = templateObject[i];
      let newMO = {};
      let current = await convertV6(oldMO, newMO, "templatefx");
      let thunderwaveVariants = ["left", "mid", "center"];
      if (current.primary.video.animation === "thunderwave") {
        if (thunderwaveVariants.some((el) => !current.primary.video.variant.includes(el))) {
          current.primary.video.variant = "center";
        }
      }
      if (current.primary.options?.persistent && current.primary.options?.persistType === "attachtemplate" && current.primary.options?.removeTemplate) {
        current.primary.options.removeTemplate = false;
      }
      newMenu.templatefx.push(current);
    }
  }
  if (auraObject) {
    const dataLength = Object.keys(auraObject).length;
    for (var i = 0; i < dataLength; i++) {
      const oldMO = auraObject[i];
      let newMO = {};
      let current = await convertV6(oldMO, newMO, "aura");
      newMenu.aura.push(current);
    }
  }
  if (presetObject) {
    const presetLength = Object.keys(presetObject).length;
    for (var i = 0; i < presetLength; i++) {
      const oldMO = presetObject[i];
      let newMO = {};
      let current;
      switch (oldMO.animation) {
        case "bardicinspiration":
        case "bless":
        case "shieldspell":
        case "huntersmark":
        case "sneakattack":
          break;
        case "teleportation":
          current = await updateTele(oldMO, newMO);
          current.menu = "preset";
          newMenu.preset.push(current);
          break;
        case "dualattach":
          current = await updateDAttach(oldMO, newMO);
          current.menu = "preset";
          newMenu.preset.push(current);
          break;
        case "fireball":
          current = await updateFireball(oldMO, newMO);
          current.menu = "preset";
          newMenu.preset.push(current);
          break;
        default:
          current = await updateThunderwave(oldMO, newMO);
          current.menu = "preset";
          newMenu.preset.push(current);
      }
    }
  }
  if (aefxObject) {
    const aefxLength = Object.keys(aefxObject).length;
    for (var i = 0; i < aefxLength; i++) {
      const oldMO = aefxObject[i];
      let newMO = {};
      let current;
      switch (oldMO.aeType) {
        case "auras":
          current = await convertAEAura(oldMO, newMO);
          current.activeEffectType = "aura";
          newMenu.aefx.push(current);
          break;
        case "preset":
          switch (oldMO.menuType) {
            case "bless":
              current = await convertAEBless(oldMO, newMO);
              current.activeEffectType = "ontoken";
              newMenu.aefx.push(current);
              break;
            case "shieldspell":
              current = await convertAEShield(oldMO, newMO);
              current.activeEffectType = "ontoken";
              newMenu.aefx.push(current);
              break;
          }
          break;
        default:
          current = await convertAEOnToken(oldMO, newMO);
          current.activeEffectType = "ontoken";
          newMenu.aefx.push(current);
      }
    }
  }
  async function new3d(oldData) {
    let newData = oldData || {};
    let { type, addExplosion, ...rest } = newData;
    const data3d = {
      enable: type ? true : false,
      type: type || "",
      data: rest || {},
      secondary: {
        enable: addExplosion?.enable ?? false,
        data: addExplosion || {}
      },
      sound: setSound({}, "a01", true)
    };
    return data3d;
  }
  function setSound(audio = {}, section2 = "a01", rebase = false) {
    if (rebase) {
      return {
        delay: 0,
        enable: false,
        file: "",
        startTime: 0,
        repeat: 1,
        repeatDelay: 250,
        volume: 1
      };
    } else {
      return {
        delay: audio?.[section2]?.delay ?? 0,
        enable: audio?.[section2]?.enable ?? false,
        file: audio?.[section2]?.file ?? "",
        startTime: audio?.[section2]?.startTime ?? 0,
        volume: audio?.[section2]?.volume ?? 1,
        repeat: 1,
        repeatDelay: 250
      };
    }
  }
  async function convertExplosionV6(exp, audio, oldMO) {
    let data3 = {
      enable: exp?.enable ?? false,
      options: {
        addTokenWidth: false,
        anchor: "0.5",
        delay: exp?.delay ?? 250,
        elevation: exp?.below ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: exp?.isMasked ?? false,
        isRadius: true,
        isWait: false,
        opacity: exp?.opacity ?? 1,
        repeat: oldMO.repeat ?? 1,
        repeatDelay: oldMO.delay ?? 0,
        size: exp?.radius ?? 1.5,
        zIndex: exp?.zIndex ?? 1
      },
      sound: setSound(audio, "e01"),
      video: {
        dbSection: "static",
        menuType: exp?.menuType,
        animation: exp?.animation,
        variant: exp?.variant,
        color: exp?.color,
        enableCustom: exp?.enableCustom ?? false,
        customPath: exp?.customPath ?? ""
      }
    };
    const video2 = data3.video;
    if (!video2.menuType || !video2.animation || !video2.variant || !video2.color) {
      data3.video.menuType = "spell";
      data3.video.animation = "curewounds";
      data3.video.variant = "01";
      data3.video.color = "blue";
    }
    return data3;
  }
  async function convertV6(oldMO, newMO, type) {
    let {
      menuType,
      variant,
      custom,
      customPath,
      name,
      animation,
      color,
      audio,
      macro: macro2,
      soundOnly,
      explosion,
      levels3d: levels3d2,
      meleeSwitch: meleeSwitch2,
      ...rest
    } = oldMO;
    newMO.id = uuidv4();
    newMO.label = name;
    if (type !== "aura" && type !== "templatefx") {
      newMO.levels3d = await new3d(levels3d2);
    }
    newMO.macro = macro2 || {};
    if (type === "melee") {
      newMO.meleeSwitch = compileMeleeSwitch(oldMO);
    }
    newMO.menu = type;
    newMO.primary = {
      options: convertOptionsV6(oldMO, type),
      sound: setSound(audio, "a01"),
      video: {
        dbSection: setDBSection(type),
        menuType,
        animation,
        variant,
        color,
        enableCustom: custom,
        customPath
      }
    };
    newMO.secondary = await convertExplosionV6(explosion, audio, oldMO);
    const primaryVideo = newMO.primary.video;
    if (!primaryVideo.menuType || !primaryVideo.animation || !primaryVideo.variant || !primaryVideo.color) {
      resetVideo(newMO.primary.video, type);
    }
    newMO.soundOnly = {
      sound: {
        enable: soundOnly?.enable || false,
        delay: oldMO.audio?.a01?.delay ?? 0,
        startTime: oldMO.audio?.a01?.startTime ?? 0,
        volume: oldMO.audio?.a01?.volume ?? 1,
        file: oldMO.audio?.a01?.file,
        repeat: 1,
        repeatDelay: 250
      }
    };
    newMO.source = newExtraFX();
    newMO.target = newExtraFX(true);
    return newMO;
  }
  function compileMeleeSwitch(oldMO) {
    let oldData = oldMO || {};
    const data3 = {
      video: {
        dbSection: "range",
        menuType: oldData.switchMenuType,
        animation: oldData.switchAnimation,
        variant: oldData.switchVariant,
        color: oldData.switchColor,
        enableCustom: false,
        customPath: ""
      },
      sound: setSound(oldMO?.audio, "a02"),
      options: {
        detect: oldData.detect || "automatic",
        range: oldData.range || 2,
        isReturning: oldData.return ?? false,
        switchType: oldData.switchType || "on"
      }
    };
    const switchVideo = data3.video;
    if (!switchVideo.menuType || !switchVideo.animation || !switchVideo.variant || !switchVideo.color) {
      resetVideo(data3.video, "range");
    }
    return data3;
  }
  function resetVideo(data3, type) {
    switch (type) {
      case "melee":
        data3.menuType = "weapon";
        data3.animation = "dagger";
        data3.variant = "01";
        data3.color = "white";
        break;
      case "range":
        data3.menuType = "weapon";
        data3.animation = "arrow";
        data3.variant = "regular";
        data3.color = "regular";
        break;
      case "templatefx":
        data3.menuType = "circle";
        data3.animation = "calllightning";
        data3.variant = "01";
        data3.color = "blue";
        break;
      default:
        data3.menuType = "spell";
        data3.animation = "curewounds";
        data3.variant = "01";
        data3.color = "blue";
    }
  }
  function convertOptionsV6(oldMO, type) {
    const data3 = {};
    switch (type) {
      case "melee":
        data3.delay = 0;
        data3.elevation = oldMO.below ? 0 : 1e3;
        data3.isWait = false;
        data3.opacity = oldMO.opacity ?? 1;
        data3.repeat = oldMO.repeat ?? 1;
        data3.repeatDelay = oldMO.delay ?? 0;
        data3.size = oldMO.scale ?? 1;
        data3.zIndex = oldMO.zIndex ?? 1;
        break;
      case "range":
        data3.delay = 0;
        data3.elevation = oldMO.below ? 0 : 1e3;
        data3.isReturning = false;
        data3.isWait = false;
        data3.onlyX = oldMO.onlyX ?? false;
        data3.opacity = oldMO.opacity ?? 1;
        data3.repeat = oldMO.repeat ?? 1;
        data3.repeatDelay = oldMO.delay ?? 0;
        data3.zIndex = oldMO.zIndex ?? 1;
        break;
      case "ontoken":
        data3.addTokenWidth = false;
        data3.anchor = "0.5";
        data3.delay = 0;
        data3.elevation = oldMO.below ? 0 : 1e3;
        data3.fadeIn = 250;
        data3.fadeOut = 500;
        data3.isMasked = oldMO.isMasked ?? false;
        data3.isRadius = false;
        data3.isWait = false;
        data3.opacity = oldMO.opacity ?? 1;
        data3.persistent = oldMO.persistent ?? false;
        data3.playOn = oldMO.type === "targetDefault" ? "default" : oldMO.type === "sourceTarget" ? "both" : !oldMO.type ? "default" : oldMO.type;
        data3.repeat = oldMO.repeat ?? 1;
        data3.repeatDelay = oldMO.delay ?? 0;
        data3.size = oldMO.scale ?? 1;
        data3.unbindAlpha = oldMO.unbindAlpha ?? false;
        data3.unbindVisibility = oldMO.unbindVisibility ?? false;
        data3.zIndex = oldMO.zIndex ?? 1;
        break;
      case "templatefx":
        data3.delay = 0;
        data3.elevation = oldMO.below ? 0 : 1e3;
        data3.isMasked = oldMO.isMasked ?? false;
        data3.isWait = false;
        data3.occlusionAlpha = oldMO.occlusionAlpha ?? 0;
        data3.occlusionMode = oldMO.occlusionMode ?? 0;
        data3.opacity = oldMO.opacity ?? 1;
        data3.persistent = oldMO.persist ?? false;
        data3.persistType = oldMO.persistType || "sequencerground";
        data3.removeTemplate = oldMO.removeTemplate ?? 1;
        data3.repeat = oldMO.repeat ?? 1;
        data3.repeatDelay = oldMO.delay ?? 0;
        data3.rotate = 0;
        data3.scale = `${oldMO.scaleX ?? 1}, ${oldMO.scaleY ?? 1}`;
        data3.zIndex = oldMO.zIndex ?? 1;
        break;
      case "aura":
        data3.addTokenWidth = oldMO.addTokenWidth ?? false;
        data3.alpha = false, data3.alphaMax = 0.5, data3.alphaMin = -0.5, data3.alphaDuration = 1e3, data3.breath = false, data3.breathMax = 1.05, data3.breathMin = 0.95, data3.breathDuration = 1e3, data3.delay = 0;
        data3.elevation = oldMO.below ? 0 : 1e3;
        data3.fadeIn = 250;
        data3.fadeOut = 500;
        data3.playOn = oldMO.ignoretargets ? "source" : "default";
        data3.isRadius = true;
        data3.isWait = false;
        data3.opacity = oldMO.opacity ?? 1;
        data3.size = oldMO.scale ?? 3;
        data3.tint = false, data3.tintColor = "#FFFFFF", data3.tintSaturate = 0, data3.unbindAlpha = oldMO.unbindAlpha ?? false;
        data3.unbindVisibility = oldMO.unbindVisibility ?? false;
        data3.zIndex = oldMO.zIndex ?? 1;
        break;
    }
    return data3;
  }
  function newExtraFX(target2 = false) {
    if (target2) {
      return {
        enable: false,
        options: {
          addTokenWidth: false,
          anchor: "0.5",
          delay: 0,
          elevation: 1e3,
          fadeIn: 250,
          fadeOut: 500,
          isMasked: false,
          isWait: false,
          isRadius: false,
          opacity: 1,
          persistent: false,
          repeat: 1,
          repeatDelay: 250,
          size: 1,
          unbindAlpha: false,
          unbindVisibility: false,
          zIndex: 1
        },
        sound: setSound({}, "t01", true),
        video: {
          dbSection: "static",
          menuType: "spell",
          animation: "curewounds",
          variant: "01",
          color: "blue",
          enableCustom: false,
          customPath: ""
        }
      };
    } else {
      return {
        enable: false,
        options: {
          addTokenWidth: false,
          anchor: "0.5",
          delay: 0,
          elevation: 1e3,
          fadeIn: 250,
          fadeOut: 500,
          isMasked: false,
          isRadius: false,
          isWait: true,
          opacity: 1,
          repeat: 1,
          repeatDelay: 250,
          size: 1,
          zIndex: 1
        },
        sound: setSound({}, "s01", true),
        video: {
          dbSection: "static",
          menuType: "spell",
          animation: "curewounds",
          variant: "01",
          color: "blue",
          enableCustom: false,
          customPath: ""
        }
      };
    }
  }
  function setDBSection(type) {
    return type === "aura" || type === "ontoken" ? "static" : type;
  }
  async function updateTele(oldData, newData) {
    newData.id = uuidv4();
    newData.data = {};
    const root = newData.data;
    let {
      menuType,
      subAnimation,
      variant,
      color,
      below,
      custom,
      customPath,
      hideTemplate,
      name,
      range: range2,
      measureType,
      scale,
      menuType02,
      subAnimation02,
      variant02,
      color02,
      scale02,
      custom02,
      customPath02,
      macro: macro2,
      delay,
      audio,
      soundOnly
    } = oldData;
    newData.macro = macro2 || {};
    newData.presetType = "teleportation";
    newData.label = name;
    root.options = {
      alpha: 0,
      delayFade: 750,
      delayMove: 1e3,
      delayReturn: delay ?? 250,
      hideFromPlayers: hideTemplate ?? false,
      measureType: measureType ?? "alternating",
      range: range2 ?? 30,
      speed: 120,
      teleport: true
    };
    root.sound = setSound(audio, "a01");
    root.start = {
      enable: true,
      dbSection: "static",
      menuType,
      animation: subAnimation,
      variant,
      color,
      enableCustom: custom || false,
      customPath,
      options: {
        delay: 0,
        elevation: below ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 250,
        isMasked: false,
        opacity: 1,
        isRadius: false,
        size: scale || 1.5
      }
    };
    root.between = {
      dbSection: "range",
      enable: false,
      menuType: "weapon",
      animation: "arrow",
      variant: "regular",
      color: "regular",
      options: {
        delay: 0,
        elevation: 1e3,
        opacity: 1,
        playbackRate: 1
      }
    };
    root.end = {
      enable: true,
      dbSection: "static",
      menuType: menuType02,
      animation: subAnimation02,
      variant: variant02,
      color: color02,
      enableCustom: custom02 || false,
      customPath: customPath02,
      options: {
        delay: 500,
        elevation: below ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 250,
        isMasked: false,
        isRadius: false,
        opacity: 1,
        size: scale02 ?? 1
      }
    };
    if (!root.start.menuType || !root.start.animation || !root.start.variant || !root.start.color) {
      resetVideo(root.start, "static");
    }
    if (!root.end.menuType || !root.end.animation || !root.end.variant || !root.end.color) {
      resetVideo(root.end, "static");
    }
    newData.soundOnly = {
      sound: {
        enable: soundOnly?.enable || false,
        delay: oldData.audio?.a01?.delay ?? 0,
        startTime: oldData.audio?.a01?.startTime ?? 0,
        volume: oldData.audio?.a01?.volume ?? 1,
        file: oldData.audio?.a01?.file
      }
    };
    return newData;
  }
  async function updateDAttach(oldData, newData) {
    newData.id = uuidv4();
    let { name, below, macro: macro2, audio, menuType, subAnimation, variant, color, custom, customPath, playbackRate, onlyX, soundOnly } = oldData;
    newData.macro = macro2 || {};
    newData.presetType = "dualattach";
    newData.label = name;
    newData.data = {
      video: {
        dbSection: "range",
        menuType,
        animation: subAnimation,
        variant,
        color,
        enableCustom: custom || false,
        customPath: customPath || ""
      },
      options: {
        playbackRate,
        onlyX,
        opacity: 1,
        elevation: below ? 0 : 1e3
      },
      sound: setSound(audio, "a01")
    };
    if (!newData.data.video.menuType || !newData.data.video.animation || !newData.data.video.variant || !newData.data.video.color) {
      resetVideo(newData.data.video, "range");
    }
    newData.soundOnly = {
      sound: {
        enable: soundOnly?.enable || false,
        delay: oldData.audio?.a01?.delay ?? 0,
        startTime: oldData.audio?.a01?.startTime ?? 0,
        volume: oldData.audio?.a01?.volume ?? 1,
        file: oldData.audio?.a01?.file
      }
    };
    return newData;
  }
  async function updateFireball(oldData, newData) {
    newData.id = uuidv4();
    newData.data = {};
    const root = newData.data;
    let {
      audio,
      macro: macro2,
      name,
      below,
      animation,
      rangeType,
      projectile,
      projectilVariant,
      projectileColor,
      projectileRepeat,
      projectileDelay,
      wait01,
      removeTemplate,
      ex01Type,
      explosion01,
      explosion01Variant,
      explosion01Color,
      explosion01Repeat,
      explosion01Delay,
      explosion01Scale,
      wait02,
      ex02Type,
      explosion02,
      explosion02Variant,
      explosion02Color,
      explosion02Repeat,
      explosion02Delay,
      explosion02Scale,
      afterEffect,
      afterEffectPath,
      wait03,
      soundOnly
    } = oldData;
    newData.macro = macro2 || {};
    newData.presetType = "proToTemp";
    newData.label = name;
    root.projectile = {
      dbSection: "range",
      menuType: rangeType,
      animation: projectile,
      variant: projectilVariant,
      color: projectileColor,
      options: {
        repeat: projectileRepeat,
        repeatDelay: projectileDelay,
        wait: wait01,
        elevation: below ? 0 : 1e3,
        removeTemplate
      },
      sound: setSound(audio, "a01")
    };
    if (!root.projectile.menuType || !root.projectile.animation || !root.projectile.variant || !root.projectile.color) {
      resetVideo(root.projectile, "range");
    }
    root.preExplosion = {
      dbSection: "static",
      menuType: ex01Type,
      animation: explosion01,
      variant: explosion01Variant,
      color: explosion01Color,
      options: {
        repeat: explosion01Repeat,
        repeatDelay: explosion01Delay,
        scale: explosion01Scale,
        wait: wait02,
        elevation: below ? 0 : 1e3
      },
      sound: setSound(audio, "e01")
    };
    if (!root.preExplosion.menuType || !root.preExplosion.animation || !root.preExplosion.variant || !root.preExplosion.color) {
      root.preExplosion.enable = false;
      resetVideo(root.preExplosion, "static");
    } else {
      root.preExplosion.enable = true;
    }
    root.explosion = {
      dbSection: "static",
      menuType: ex02Type,
      animation: explosion02,
      variant: explosion02Variant,
      color: explosion02Color,
      options: {
        elevation: below ? 0 : 1e3,
        repeat: explosion02Repeat,
        repeatDelay: explosion02Delay,
        scale: explosion02Scale,
        wait: wait03
      },
      sound: setSound(audio, "e01")
    };
    if (!root.explosion.menuType || !root.explosion.animation || !root.explosion.variant || !root.explosion.color) {
      resetVideo(root.explosion, "range");
    }
    root.afterImage = {
      enable: afterEffect,
      customPath: afterEffectPath,
      options: {
        elevation: 0,
        persistent: false,
        scale: 1
      }
    };
    newData.soundOnly = {
      sound: {
        enable: soundOnly?.enable || false,
        delay: oldData.audio?.a01?.delay ?? 0,
        startTime: oldData.audio?.a01?.startTime ?? 0,
        volume: oldData.audio?.a01?.volume ?? 1,
        file: oldData.audio?.a01?.file
      }
    };
    newData.secondary = {
      enable: false,
      options: {
        addTokenWidth: false,
        delay: 250,
        elevation: 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: false,
        isRadius: true,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 0,
        size: 1.5,
        zIndex: 1
      },
      sound: setSound(audio, "e01"),
      video: {
        dbSection: "static",
        menuType: "spell",
        animation: "curewounds",
        variant: "01",
        color: "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newData.target = newExtraFX(true);
    return newData;
  }
  async function updateThunderwave(oldData, newData) {
    newData.id = uuidv4();
    let { audio, macro: macro2, name, below, color, repeat, delay, scaleX, scaleY, opacity, removeTemplate, persist: persistent, persistType, occlusionMode, occlusionAlpha, soundOnly } = oldData;
    newData.macro = macro2 || {};
    newData.label = name;
    newData.presetType = "thunderwave";
    newData.data = {
      video: {
        dbSection: "templatefx",
        menuType: "square",
        animation: "thunderwave",
        variant: "mid",
        color: color || "blue"
      },
      options: {
        elevation: below ? 0 : 1e3,
        repeat: repeat || 1,
        repeatDelay: delay ?? 250,
        opacity: opacity ?? 1,
        removeTemplate: removeTemplate ?? false
      },
      sound: setSound(audio, "a01")
    };
    newData.soundOnly = {
      sound: {
        enable: soundOnly?.enable || false,
        delay: oldData.audio?.a01?.delay ?? 0,
        startTime: oldData.audio?.a01?.startTime ?? 0,
        volume: oldData.audio?.a01?.volume ?? 1,
        file: oldData.audio?.a01?.file
      }
    };
    return newData;
  }
  async function convertAEOnToken(oldMO, newMO) {
    let {
      aeDelay,
      aeType,
      animation,
      audio,
      below,
      color,
      custom,
      customPath,
      delay,
      explosion,
      macro: macro2,
      menuType,
      name,
      opacity,
      persistent,
      repeat,
      scale,
      soundOnly,
      type,
      unbindAlpha,
      unbindVisibility,
      variant
    } = oldMO;
    newMO.id = uuidv4();
    newMO.label = name;
    newMO.menu = "aefx";
    newMO.secondary = await convertExplosionV6(explosion, audio, oldMO);
    newMO.primary = {
      options: {
        addTokenWidth: false,
        elevation: below ? 0 : 1e3,
        delay: delay || 250,
        isMasked: false,
        isRadius: false,
        isWait: false,
        opacity: opacity || 1,
        persistent: persistent || false,
        playOn: "source",
        repeat: repeat || 1,
        size: scale || 1,
        unbindAlpha: unbindAlpha || false,
        unbindVisibility: unbindVisibility || false,
        zIndex: 1
      },
      sound: setSound(audio, "a01"),
      video: {
        animation,
        color,
        customPath: customPath || "",
        dbSection: "static",
        enableCustom: custom || false,
        menuType,
        variant
      }
    };
    const newVideo = newMO.primary.video;
    if (!newVideo.menuType || !newVideo.animation || !newVideo.variant || !newVideo.color) {
      resetVideo(newMO.primary.video);
    }
    newMO.macro = macro2 || {};
    newMO.soundOnly = {
      sound: {
        delay: audio?.a01?.delay ?? 0,
        enable: soundOnly?.enable ?? false,
        file: audio?.a01?.file ?? "",
        startTime: audio?.a01?.startTime ?? 0,
        volume: audio?.a01?.volume ?? 1
      }
    };
    newMO.source = newExtraFX();
    return newMO;
  }
  async function convertAEAura(oldMO, newMO) {
    let {
      aeDelay,
      aeType,
      animation,
      audio,
      below,
      color,
      custom,
      customPath,
      macro: macro2,
      menuType,
      name,
      opacity,
      scale,
      soundOnly,
      type,
      unbindAlpha,
      unbindVisibility,
      variant
    } = oldMO;
    newMO.id = uuidv4();
    newMO.label = name;
    newMO.menu = "aefx";
    newMO.secondary = {
      enable: false,
      options: {},
      sound: setSound({}, "a01", true),
      video: {
        dbSection: "static",
        menuType: "spell",
        animation: "curewounds",
        variant: "01",
        color: "blue"
      }
    };
    newMO.primary = {
      options: {
        addTokenWidth: false,
        alpha: false,
        alphaMax: 0.5,
        alphaMin: -0.5,
        alphaDuration: 1e3,
        breath: false,
        breathMax: 1.05,
        breathMin: 0.95,
        breathDuration: 1e3,
        delay: 0,
        elevation: below ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isRadius: true,
        isWait: true,
        opacity: opacity || 1,
        playOn: "source",
        size: scale || 1,
        tint: false,
        tintColor: "#FFFFFF",
        tintSaturate: 0,
        unbindAlpha: unbindAlpha || false,
        unbindVisibility: unbindVisibility || false,
        zIndex: 1
      },
      sound: setSound(audio, "a01"),
      video: {
        animation,
        color,
        customPath: customPath || "",
        dbSection: "static",
        enableCustom: custom || false,
        menuType,
        variant
      }
    };
    const newVideo = newMO.primary.video;
    if (!newVideo.menuType || !newVideo.animation || !newVideo.variant || !newVideo.color) {
      resetVideo(newMO.primary.video);
    }
    newMO.macro = macro2 || {};
    newMO.soundOnly = {
      sound: {
        delay: audio?.a01?.delay ?? 0,
        enable: soundOnly?.enable ?? false,
        file: audio?.a01?.file ?? "",
        startTime: audio?.a01?.startTime ?? 0,
        volume: audio?.a01?.volume ?? 1
      }
    };
    newMO.source = newExtraFX();
    return newMO;
  }
  async function convertAEBless(oldMO, newMO) {
    let {
      addCTA,
      aeType,
      animation,
      audio,
      below,
      color,
      custom,
      macro: macro2,
      menuType,
      name,
      scale,
      soundOnly,
      type,
      unbindAlpha,
      unbindVisibility,
      variant
    } = oldMO;
    newMO.id = uuidv4();
    newMO.label = name;
    newMO.menu = "aefx";
    newMO.macro = macro2 || {};
    newMO.primary = {
      options: {
        addTokenWidth: false,
        delay: 0,
        elevation: below ? 0 : 1e3,
        fadeIn: 0,
        fadeOut: 500,
        isMasked: false,
        isRadius: false,
        isWait: true,
        opacity: 1,
        persistent: addCTA || false,
        playOn: "source",
        repeat: 1,
        repeatDelay: 250,
        size: scale || 1,
        unbindAlpha: unbindAlpha || false,
        unbindVisibility: unbindVisibility || false,
        zIndex: 1
      },
      sound: setSound({}, "a01", true),
      video: {
        dbSection: "static",
        menuType: "spell",
        animation: "bless",
        variant: "intro",
        color: color || "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newMO.secondary = {
      enable: false,
      options: {},
      sound: setSound({}, "a01", true),
      video: {
        dbSection: "static",
        menuType: "spell",
        animation: "curewounds",
        variant: "01",
        color: "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newMO.soundOnly = {
      sound: {
        enable: soundOnly?.enable || false,
        delay: oldMO.audio?.a01?.delay ?? 0,
        startTime: oldMO.audio?.a01?.startTime ?? 0,
        volume: oldMO.audio?.a01?.volume ?? 1,
        file: oldMO.audio?.a01?.file
      }
    };
    newMO.source = {
      enable: true,
      options: {
        addTokenWidth: false,
        delay: -500,
        elevation: below ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: false,
        isRadius: false,
        isWait: true,
        opacity: 1,
        repeat: 1,
        repeatDelay: 250,
        size: scale || 1,
        zIndex: 1
      },
      sound: setSound(audio, "a01"),
      video: {
        dbSection: "static",
        menuType: "spell",
        animation: "bless",
        variant: "intro",
        color: color || "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    return newMO;
  }
  async function convertAEShield(oldMO, newMO) {
    let {
      addCTA,
      aeType,
      animation,
      audio,
      below,
      color,
      custom,
      endEffect,
      macro: macro2,
      menuType,
      name,
      scale,
      soundOnly,
      type,
      unbindAlpha,
      unbindVisibility,
      variant
    } = oldMO;
    newMO.id = uuidv4();
    newMO.label = name;
    newMO.menu = "aefx";
    newMO.primary = {
      options: {
        isWait: true,
        delay: -1e3,
        elevation: below ? 0 : 1e3,
        fadeIn: 250,
        fadeOut: 0,
        isMasked: false,
        isRadius: false,
        opacity: 1,
        persistent: addCTA || false,
        repeat: 1,
        repeatDelay: 250,
        size: scale ?? 1,
        playOn: "source",
        unbindAlpha: unbindAlpha ?? false,
        unbindVisibility: unbindVisibility ?? false,
        zIndex: 1
      },
      sound: setSound({}, "a01", true),
      video: {
        dbSection: "static",
        menuType: "shieldspell",
        animation: "loop",
        variant: variant || "01",
        color: color || "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newMO.source = {
      enable: true,
      options: {
        addTokenWidth: false,
        delay: -500,
        elevation: below ? 0 : 1e3,
        fadeIn: 500,
        fadeOut: 0,
        isMasked: false,
        isRadius: false,
        isWait: true,
        opacity: 1,
        repeat: 1,
        repeatDelay: 250,
        size: scale || 1,
        zIndex: 1
      },
      sound: setSound(audio, "a01"),
      video: {
        dbSection: "static",
        menuType: "shieldspell",
        animation: "intro",
        variant: variant || "01",
        color: color || "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newMO.secondary = {
      options: {
        delay: 0,
        elevation: below ? 0 : 1e3,
        isMasked: false,
        isRadius: false,
        isWait: false,
        repeat: 1,
        repeatDelay: 250,
        size: scale || 1,
        opacity: 1,
        zIndex: 1
      },
      sound: setSound({}, "a01", true),
      video: {
        dbSection: "static",
        menuType: "shieldspell",
        animation: endEffect || "outro_explode",
        variant: variant || "01",
        color: color || "blue",
        enableCustom: false,
        customPath: ""
      }
    };
    newMO.macro = macro2 || {};
    newMO.soundOnly = {
      sound: {
        delay: audio?.a01?.delay ?? 0,
        enable: soundOnly?.enable ?? false,
        file: audio?.a01?.file ?? "",
        startTime: audio?.a01?.startTime ?? 0,
        volume: audio?.a01?.volume ?? 1
      }
    };
    return newMO;
  }
  return newMenu;
}
class AutorecSanitizer {
  static getMenu() {
    let menu = AAAutorecManager.getAutorecEntries();
    delete menu.version;
    return menu;
  }
  static async checkForDuplicates() {
    let menu = this.getMenu();
    let menuKeys = Object.keys(menu);
    for (let i = 0; i < menuKeys.length; i++) {
      var valueArr = menu[menuKeys[i]].map(function(item2) {
        return item2.id;
      });
      var isDuplicate = valueArr.some(function(item2, idx) {
        return valueArr.indexOf(item2) != idx;
      });
      if (isDuplicate) {
        custom_error$1(`The ${game.i18n.localize(`autoanimations.animTypes.${menuKeys[i]}`)} Global Menu contains Duplicate ID's, commencing Sanitization`);
        await this.cleanIds(menuKeys[i], menu);
      }
    }
  }
  static async cleanIds(menuId, menu) {
    let sanitizedMenu = menu[menuId];
    sanitizedMenu.forEach((section2) => section2.id = uuidv4());
    game.settings.set("autoanimations", `aaAutorec-${menuId}`, sanitizedMenu);
    custom_error$1(`The ${game.i18n.localize(`autoanimations.animTypes.${menuId}`)} Global Menu has been corrected from catastrophic errors. Please refresh your game world`);
  }
  static newSectionIds(menu) {
    menu.forEach((section2) => section2.id = uuidv4());
    return menu;
  }
}
function currentAutorecVersion() {
  return Object.keys(autoRecMigration.migrations).map((n) => Number(n)).reverse()[0];
}
const autoRecMigration = {
  /**
   * 
   * @param {*} autoObject 
   * @param {
   * shouldSubmit: Boolean (Merges should be submitted), 
   * newSchema: Boolean (Is a new data Schema?), 
   * submitAll: Boolean (A-A ONLY override to submit ALL merged Menus)
   * } options 
   * @returns 
   */
  async handle(autoObject, options2 = {}) {
    if (options2.newSchema) {
      ui.notifications.info("Automated Animations | Exporting your Global Automatic Recognition Menu before running Migration");
      const data2 = game.settings.get("autoanimations", "aaAutorec");
      const filename = `Autorec-Menu-Backup`;
      saveDataToFile(JSON.stringify(data2, null, 2), "text/json", filename);
      autoObject = {
        melee: game.settings.get("autoanimations", "aaAutorec-melee"),
        range: game.settings.get("autoanimations", "aaAutorec-range"),
        ontoken: game.settings.get("autoanimations", "aaAutorec-ontoken"),
        templatefx: game.settings.get("autoanimations", "aaAutorec-templatefx"),
        aura: game.settings.get("autoanimations", "aaAutorec-aura"),
        preset: game.settings.get("autoanimations", "aaAutorec-preset"),
        aefx: game.settings.get("autoanimations", "aaAutorec-aefx"),
        version: game.settings.get("autoanimations", "aaAutorec").version
      };
    }
    if (!autoObject) {
      return;
    }
    if (this.upToDate(autoObject) && !options2.isOverwrite) {
      return autoObject;
    }
    ui.notifications.info("Automated Animations: Updating the Automatic Recognition Menu");
    let currentAutorec = autoObject;
    for (let [version, migration] of Object.entries(this.migrations)) {
      let flagVersion = currentAutorec.version;
      if (flagVersion >= Number(version))
        continue;
      currentAutorec = await migration(currentAutorec);
    }
    if (!options2.shouldSubmit) {
      return currentAutorec;
    } else {
      if (options2.melee || options2.submitAll) {
        let newMelee = AutorecSanitizer.newSectionIds(currentAutorec.melee);
        await game.settings.set("autoanimations", "aaAutorec-melee", newMelee);
      }
      if (options2.range || options2.submitAll) {
        let newRange = AutorecSanitizer.newSectionIds(currentAutorec.range);
        await game.settings.set("autoanimations", "aaAutorec-range", newRange);
      }
      if (options2.ontoken || options2.submitAll) {
        let newOnToken = AutorecSanitizer.newSectionIds(currentAutorec.ontoken);
        await game.settings.set("autoanimations", "aaAutorec-ontoken", newOnToken);
      }
      if (options2.templatefx || options2.submitAll) {
        let newTemplateFx = AutorecSanitizer.newSectionIds(currentAutorec.templatefx);
        await game.settings.set("autoanimations", "aaAutorec-templatefx", newTemplateFx);
      }
      if (options2.aura || options2.submitAll) {
        let newAura = AutorecSanitizer.newSectionIds(currentAutorec.aura);
        await game.settings.set("autoanimations", "aaAutorec-aura", newAura);
      }
      if (options2.preset || options2.submitAll) {
        let newPreset = AutorecSanitizer.newSectionIds(currentAutorec.preset);
        await game.settings.set("autoanimations", "aaAutorec-preset", newPreset);
      }
      if (options2.aefx || options2.submitAll) {
        let newAefx = AutorecSanitizer.newSectionIds(currentAutorec.aefx);
        await game.settings.set("autoanimations", "aaAutorec-aefx", newAefx);
      }
      if (Object.keys(this.migrations).map((n) => Number(n)).reverse()[0] === 5) {
        game.settings.set("autoanimations", "aaAutorec", { version: 5 });
      } else {
        let versionHandler = game.settings.get("autoanimations", "aaAutorec");
        versionHandler.version = Object.keys(this.migrations).map((n) => Number(n)).reverse()[0];
        await game.settings.set("autoanimations", "aaAutorec", versionHandler);
      }
    }
    ui.notifications.info("Automatic Recognition Menu update is Complete!");
  },
  upToDate(autoObject) {
    const currentFlagVersion = Object.keys(this.migrations).map((n) => Number(n)).reverse()[0];
    return autoObject.version >= currentFlagVersion;
  },
  migrations: {
    "1": async (currentAutorec) => {
      return await mergeVersion01(currentAutorec);
    },
    "2": async (currentAutorec) => {
      return await mergeVersion02(currentAutorec);
    },
    "3": async (currentAutorec) => {
      return await mergeVersion03(currentAutorec);
    },
    "4": async (currentAutorec) => {
      return await mergeVersion04(currentAutorec);
    },
    "5": async (currentAutorec) => {
      return await mergeVersion05(currentAutorec);
    }
  }
};
function localize(stringId, data2) {
  const result = typeof data2 !== "object" ? globalThis.game.i18n.localize(stringId) : globalThis.game.i18n.format(stringId, data2);
  return result !== void 0 ? result : "";
}
function sound({ enable = false, delay = 0, file = void 0, startTime = 0, volume = 0.75, repeat = 1, repeatDelay = 250 } = {}) {
  return {
    enable,
    delay,
    file,
    repeat,
    repeatDelay,
    startTime,
    volume
  };
}
function secondary() {
  return {
    enable: false,
    video: { dbSection: "static", menuType: "spell", animation: "curewounds", variant: "01", color: "blue", enableCustom: false, customPath: "" },
    sound: sound(),
    options: {
      addTokenWidth: false,
      anchor: "0.5",
      contrast: 0,
      delay: 0,
      elevation: 1e3,
      fadeIn: 250,
      fadeOut: 500,
      isMasked: false,
      isRadius: true,
      isWait: false,
      opacity: 1,
      repeat: 1,
      repeatDelay: 250,
      saturate: 0,
      size: 1.5,
      tint: false,
      tintColor: "#FFFFFF",
      zIndex: 1
    }
  };
}
function levels3d() {
  return {
    type: "explosion",
    data: {
      alpha: void 0,
      arc: void 0,
      color01: "#FFFFFF",
      color02: "#FFFFFF",
      delay: void 0,
      emittersize: void 0,
      gravity: void 0,
      life: void 0,
      mass: void 0,
      rate: void 0,
      repeat: void 0,
      scale: void 0,
      speed: void 0,
      spritePath: "modules/levels-3d-preview/assets/particles/dust.png"
    },
    sound: { enable: false },
    secondary: {
      enable: false,
      data: {
        alpha: void 0,
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        emittersize: void 0,
        gravity: void 0,
        life: void 0,
        mass: void 0,
        rate: void 0,
        scale: void 0,
        speed: void 0,
        spritePath: "modules/levels-3d-preview/assets/particles/dust.png"
      }
    }
  };
}
function macro() {
  return {
    enable: false,
    name: void 0,
    args: void 0,
    playWhen: void 0
  };
}
function main({ label, soundOnly }) {
  if (typeof label !== "string") {
    throw new TypeError(`'label' is not a string.`);
  }
  return {
    id: uuidv4(),
    label: `autoanimations.animations.${label}`,
    soundOnly: {
      sound: {
        delay: 0,
        enable: false,
        startTime: 0,
        volume: 0.75
      }
    }
  };
}
function video({ menuType, animation, variant, color, enableCustom = false, customPath = "", dbSection } = {}) {
  if (menuType !== void 0 && typeof menuType !== "string") {
    throw new TypeError(`'menuType' is not a string.`);
  }
  if (animation !== void 0 && typeof animation !== "string") {
    throw new TypeError(`'animation' is not a string.`);
  }
  if (variant !== void 0 && typeof variant !== "string") {
    throw new TypeError(`'variant' is not a string.`);
  }
  if (color !== void 0 && typeof color !== "string") {
    throw new TypeError(`'color' is not a string.`);
  }
  if (typeof enableCustom !== "boolean") {
    throw new TypeError(`'enableCustom' is not a boolean.`);
  }
  if (typeof customPath !== "string") {
    throw new TypeError(`'customPath' is not a string.`);
  }
  return {
    dbSection,
    menuType,
    animation,
    variant,
    color,
    enableCustom,
    customPath
  };
}
function primary({ video: video$1 = {}, sound: sound$1 = {}, options: options2 = {}, dbSection = "" } = {}) {
  return {
    video: video(video$1),
    sound: sound(sound$1),
    options: options2
  };
}
function source() {
  return {
    enable: false,
    video: { dbSection: "static", menuType: "spell", animation: "curewounds", variant: "01", color: "blue", enableCustom: false, customPath: "" },
    sound: sound(),
    options: {
      addTokenWidth: false,
      anchor: "0.5",
      contrast: 0,
      delay: 0,
      elevation: 1e3,
      fadeIn: 250,
      fadeOut: 500,
      isMasked: false,
      isRadius: false,
      isWait: true,
      opacity: 1,
      repeat: 1,
      repeatDelay: 250,
      saturate: 0,
      size: 1,
      tint: false,
      tintColor: "#FFFFFF",
      zIndex: 1
    }
  };
}
function target() {
  return {
    enable: false,
    video: { dbSection: "static", menuType: "spell", animation: "curewounds", variant: "01", color: "blue", enableCustom: false, customPath: "" },
    sound: sound(),
    options: {
      addTokenWidth: false,
      anchor: "0.5",
      contrast: 0,
      delay: 0,
      elevation: 1e3,
      fadeIn: 250,
      fadeOut: 500,
      isMasked: false,
      //isWait: false,
      isRadius: false,
      opacity: 1,
      persistent: false,
      repeat: 1,
      repeatDelay: 250,
      saturate: 0,
      size: 1,
      tint: false,
      tintColor: "#FFFFFF",
      unbindAlpha: false,
      unbindVisibility: false,
      zIndex: 1
    }
  };
}
function meleeSwitch() {
  return {
    video: {
      dbSection: "range",
      menuType: "weapon",
      animation: "arrow",
      variant: "regular",
      color: "regular"
    },
    sound: sound(),
    options: {
      detect: "automatic",
      range: 2,
      returning: false,
      switchType: "on"
    }
  };
}
const aefx$2 = [
  {
    ...main({ label: "frightened" }),
    menu: "aefx",
    metaData: { default: true },
    activeEffectType: "ontoken",
    primary: {
      options: {
        addTokenWidth: false,
        delay: 0,
        elevation: 1e3,
        isMasked: false,
        isRadius: true,
        isWait: false,
        opacity: 0.75,
        persistent: true,
        playOn: "source",
        repeat: 1,
        size: 0.75,
        unbindAlpha: false,
        unbindVisibility: false,
        zIndex: 1
      },
      sound: { enable: false },
      video: { dbSection: "static", menuType: "conditions", animation: "horror", variant: "01", color: "purple" }
    },
    source: source(),
    macro: macro(),
    secondary: secondary()
  }
];
const aura$2 = [
  {
    ...main({ label: "spiritguardians" }),
    menu: "aura",
    metaData: { default: true },
    macro: macro(),
    primary: primary({
      video: { dbSection: "static", menuType: "spell", animation: "spiritguardians", variant: "01", color: "yellowblue" },
      options: {
        addTokenWidth: true,
        alpha: false,
        alphaMax: 0.5,
        alphaMin: -0.5,
        alphaDuration: 1e3,
        breath: false,
        breathMax: 1.05,
        breathMin: 0.95,
        breathDuration: 1e3,
        delay: 0,
        elevation: 0,
        fadeIn: 250,
        fadeOut: 500,
        isRadius: true,
        isWait: false,
        opacity: 0.75,
        playOn: "source",
        size: 3,
        tint: false,
        tintColor: "#FFFFFF",
        tintSaturate: 0,
        unbindAlpha: false,
        unbindVisbility: false,
        zIndex: 1
      }
    }),
    secondary: secondary(),
    source: source(),
    target: target()
  }
];
const melee$2 = [
  {
    ...main({ label: "dagger" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "dagger", variant: "01", color: "white" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Dagger.glb",
        animationType: "swipe",
        playOn: "source",
        repeat: 1,
        rotationX: 0,
        rotateTowards: true,
        speed: 2,
        scale: 0.4,
        delay: 0,
        rotationZ: 0,
        rotationY: 270
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: true,
        target: true,
        sourceType: "swipe",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "flurryofblows" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "flurryofblows", variant: "physical", color: "blue" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "token",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/levels-3d-preview/assets/particles/emberssmall.png",
        animationType: "slash",
        playOn: "source",
        repeat: 4,
        resetTime: null
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: false,
        source: false,
        target: false,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "greataxe" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "greataxe", variant: "01", color: "white" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Axe_Double.glb",
        rotateTowards: true,
        rotationY: 90,
        speed: 2
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: false,
        target: true,
        sourceType: "bow",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "greatclub" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "greatclub", variant: "01", color: "white" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Hammer_Double.glb",
        rotationY: 90,
        rotateTowards: true,
        speed: 2,
        scale: 0.5
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: false,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "greatsword" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "greatsword", variant: "01", color: "white" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Sword_big.glb",
        speed: 2,
        rotationY: 90,
        rotateTowards: true,
        scale: 0.6
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: false,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "handaxe" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "handaxe", variant: "01", color: "white" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Axe_small.glb",
        rotationX: null,
        rotationY: 270,
        rotateTowards: true,
        scale: 0.4,
        speed: 2
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: false,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "sword" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "sword", variant: "01", color: "white" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Sword.glb",
        rotateTowards: true,
        speed: 2,
        scale: 0.4,
        rotationY: 90
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: false,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "mace" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "mace", variant: "01", color: "white" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Hammer_Double.glb",
        speed: 2,
        scale: 0.4,
        rotateTowards: true,
        rotationY: 90
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: false,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "maul" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "maul", variant: "01", color: "white" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Hammer_Double.glb",
        speed: 2,
        rotationY: 90,
        rotateTowards: true,
        scale: 0.4
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: false,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "spear" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "spear", variant: "01", color: "white" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/Kenney/Food/chopstick.glb",
        rotationX: 180,
        scale: 3,
        speed: 2
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: false,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "rapier" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "rapier", variant: "01", color: "white" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Dagger.glb",
        rotateTowards: true,
        rotationX: null,
        rotationY: 270
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: false,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "unarmedstrike" }),
    menu: "melee",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "melee", menuType: "weapon", animation: "unarmedstrike", variant: "physical", color: "blue" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "token",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/levels-3d-preview/assets/particles/emberssmall.png",
        animationType: "swipe",
        playOn: "source"
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: false,
        source: false,
        target: false,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    meleeSwitch: meleeSwitch(),
    source: source(),
    target: target()
  }
];
const ontoken$2 = [
  {
    ...main({ label: "curewounds" }),
    menu: "ontoken",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "static", menuType: "spell", animation: "curewounds", variant: "01", color: "blue" },
      options: {
        addTokenWidth: false,
        anchor: "0.5",
        contrast: 0,
        delay: 0,
        elevation: 0,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: false,
        isRadius: false,
        isWait: false,
        opacity: 1,
        persistent: false,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1.5,
        playOn: "default",
        tint: false,
        tintColor: "#FFFFFF",
        unbindAlpha: false,
        unbindVisibility: false,
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "explosion",
      data: {
        color01: "#00ff08",
        color02: "#00ffaa",
        spritePath: "modules/levels-3d-preview/assets/particles/symbol_01.png",
        life: 2e3,
        rate: 1,
        gravity: -50,
        mass: 2e4,
        scale: 0.7,
        speed: 1
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: false,
        source: false,
        target: false,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "itemHealingWord" }),
    menu: "ontoken",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "static", menuType: "spell", animation: "generichealing", variant: "01", color: "blue" },
      options: {
        addTokenWidth: false,
        anchor: "0.5",
        contrast: 0,
        delay: 0,
        elevation: 0,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: false,
        isRadius: false,
        isWait: false,
        opacity: 1,
        persistent: false,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1.5,
        tint: false,
        tintColor: "#FFFFFF",
        playOn: "default",
        unbindAlpha: false,
        unbindVisibility: false,
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "explosion",
      data: {
        color01: "#0091ff",
        color02: "#00fbff",
        spritePath: "modules/levels-3d-preview/assets/particles/symbol_01.png",
        speed: 1,
        gravity: -50,
        mass: 2e4,
        life: 2e3,
        rate: 1,
        scale: 0.1,
        alpha: 1
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: false,
        source: false,
        target: false,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "tollthedead" }),
    menu: "ontoken",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "static", menuType: "spell", animation: "tollthedead", variant: "complete", color: "green" },
      options: {
        addTokenWidth: false,
        anchor: "0.5",
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: false,
        isRadius: false,
        isWait: false,
        opacity: 1,
        persistent: false,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        playOn: "target",
        tint: false,
        tintColor: "#FFFFFF",
        unbindAlpha: false,
        unbindVisibility: false,
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "explosion",
      data: {
        color01: "#9900ff",
        color02: "#4400ff",
        spritePath: "modules/levels-3d-preview/assets/particles/magic_02.png",
        rate: 1,
        life: 2e3,
        gravity: 0,
        mass: 2e4,
        scale: 0.6,
        alpha: 1
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: false,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "debuff",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "bite" }),
    menu: "ontoken",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "static", menuType: "creature", animation: "bite", variant: "01", color: "red" },
      options: {
        addTokenWidth: false,
        anchor: "0.5",
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: false,
        isRadius: false,
        isWait: false,
        opacity: 1,
        persistent: false,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        playOn: "target",
        tint: false,
        tintColor: "#FFFFFF",
        unbindAlpha: false,
        unbindVisibility: false,
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "token",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/levels-3d-preview/assets/particles/emberssmall.png",
        animationType: "charge",
        playOn: "source"
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: false,
        source: false,
        target: false,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "claw" }),
    menu: "ontoken",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "static", menuType: "creature", animation: "claw", variant: "01", color: "red" },
      options: {
        addTokenWidth: false,
        anchor: "0.5",
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        fadeIn: 250,
        fadeOut: 500,
        isMasked: false,
        isRadius: false,
        isWait: false,
        opacity: 1,
        persistent: false,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        size: 1,
        playOn: "target",
        tint: false,
        tintColor: "#FFFFFF",
        unbindAlpha: false,
        unbindVisibility: false,
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "token",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/levels-3d-preview/assets/particles/emberssmall.png",
        animationType: "swipe",
        playOn: "source"
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: false,
        source: false,
        target: false,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  }
];
const preset$1 = [
  {
    ...main({ label: "mistystep" }),
    menu: "preset",
    metaData: { default: true },
    presetType: "teleportation",
    macro: macro(),
    data: {
      options: {
        range: 30,
        hideFromPlayers: false,
        measureType: "alternating",
        teleport: true,
        speed: 120,
        delayMove: 1e3,
        alpha: 0,
        delayFade: 750,
        delayReturn: 250,
        checkCollision: true
      },
      start: {
        dbSection: "static",
        enable: true,
        menuType: "spell",
        animation: "mistystep",
        variant: "01",
        color: "blue",
        customPath: "",
        enableCustom: false,
        options: {
          delay: 0,
          elevation: 1e3,
          fadeIn: 250,
          fadeOut: 250,
          isMasked: false,
          opacity: 1,
          isRadius: false,
          size: 1.5
        }
      },
      end: {
        dbSection: "static",
        enable: true,
        menuType: "spell",
        animation: "mistystep",
        variant: "02",
        color: "blue",
        customPath: "",
        enableCustom: false,
        options: {
          delay: 500,
          elevation: 1e3,
          fadeIn: 250,
          fadeOut: 250,
          isMasked: false,
          isRadius: false,
          opacity: 1,
          size: 1.5
        }
      },
      between: {
        dbSection: "range",
        enable: false,
        menuType: "spell",
        animation: "chainlightning",
        variant: "primary",
        color: "blue",
        enableCustom: false,
        customPath: "",
        options: {
          delay: 0,
          elevation: 1e3,
          opacity: 1,
          playbackRate: 1
        }
      },
      sound: sound()
    }
  },
  {
    ...main({ label: "fireball" }),
    menu: "preset",
    metaData: { default: true },
    presetType: "proToTemp",
    macro: macro(),
    data: {
      projectile: {
        dbSection: "range",
        menuType: "spell",
        animation: "fireballbeam",
        variant: "01",
        color: "orange",
        customPath: "",
        enableCustom: false,
        options: {
          elevation: 1e3,
          opacity: 1,
          removeTemplate: false,
          repeat: 1,
          repeatDelay: 250,
          wait: -1800
        },
        sound: sound()
      },
      preExplosion: {
        enable: false,
        dbSection: "static",
        menuType: "spell",
        animation: "curewounds",
        variant: "01",
        color: "blue",
        customPath: "",
        enableCustom: false,
        options: {
          elevation: 1e3,
          opacity: 1,
          repeat: 1,
          repeatDelay: 250,
          scale: 1.5,
          wait: 0
        },
        sound: sound()
      },
      explosion: {
        dbSection: "static",
        menuType: "spell",
        animation: "fireball",
        variant: "explode",
        color: "orange",
        enableCustom: false,
        customPath: "",
        options: {
          elevation: 1e3,
          opacity: 1,
          repeat: 1,
          repeatDelay: 250,
          scale: 1.25,
          wait: -1e3
        },
        sound: sound()
      },
      afterImage: {
        enable: false,
        customPath: "",
        options: {
          elevation: 0,
          persistent: false,
          scale: 1
        }
      }
    },
    secondary: secondary(),
    target: target()
  }
];
const range$2 = [
  {
    ...main({ label: "crossbow" }),
    menu: "range",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "range", menuType: "weapon", animation: "bolt", variant: "physical", color: "orange" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isReturning: false,
        isWait: false,
        onlyX: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Arrow.glb",
        rotationY: 0,
        rotationX: 90,
        speed: 10,
        scale: 0.5
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: true,
        target: true,
        sourceType: "bow",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "bow" }),
    menu: "range",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "range", menuType: "weapon", animation: "arrow", variant: "regular", color: "regular" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isReturning: false,
        isWait: false,
        onlyX: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "sprite",
      data: {
        color01: "#FFFFFF",
        color02: "#FFFFFF",
        spritePath: "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Arrow.glb",
        speed: 10,
        rotationX: 90,
        scale: 0.5
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: true,
        target: true,
        sourceType: "bow",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "disintegrate" }),
    menu: "range",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "range", menuType: "spell", animation: "disintegrate", variant: "01", color: "green" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isReturning: false,
        isWait: false,
        onlyX: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "ray",
      data: {
        color01: "#00ff08",
        color02: "#d4ff00",
        spritePath: "modules/levels-3d-preview/assets/particles/emberssmall.png",
        speed: 1,
        life: 2e3,
        rate: 50
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: true,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "debuff",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "eldritchblast" }),
    menu: "range",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "range", menuType: "spell", animation: "eldritchblast", variant: "01", color: "purple" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isReturning: false,
        isWait: false,
        onlyX: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "ray",
      data: {
        color01: "#4e16a2",
        color02: "#1e00ff",
        spritePath: "modules/levels-3d-preview/assets/particles/emberssmall.png",
        life: 2e3,
        rate: 50
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: true,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "firebolt" }),
    menu: "range",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "range", menuType: "spell", animation: "firebolt", variant: "01", color: "orange" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isReturning: false,
        isWait: false,
        onlyX: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "projectile",
      data: {
        color01: "#ff0000",
        color02: "#fff70a",
        spritePath: "modules/levels-3d-preview/assets/particles/emberssmall.png",
        arc: 1
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: true,
        data: {
          color01: "#ff0000",
          color02: "#ffda24",
          life: 400,
          speed: 0.1,
          mass: 1e3,
          scale: 1,
          rate: 1
        }
      },
      tokens: {
        enable: true,
        source: true,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "guidingbolt" }),
    menu: "range",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "range", menuType: "spell", animation: "guidingbolt", variant: "01", color: "yellowblue" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isReturning: false,
        isWait: false,
        onlyX: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "projectile",
      data: {
        color01: "#eeff00",
        color02: "#00d9ff",
        spritePath: "modules/levels-3d-preview/assets/particles/emberssmall.png",
        speed: 5,
        arc: 1,
        life: 2e3
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: true,
        data: {
          color01: "#fff700",
          color02: "#0adaff",
          mass: 1e3,
          life: 300,
          gravity: -10,
          speed: 1,
          alpha: 0.2,
          rate: 30
        }
      },
      tokens: {
        enable: true,
        source: true,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "magicmissile" }),
    menu: "range",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "range", menuType: "spell", animation: "magicmissile", variant: "01", color: "purple" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isReturning: false,
        isWait: false,
        onlyX: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "projectile",
      data: {
        color01: "#002aff",
        color02: "#aabacf",
        spritePath: "modules/levels-3d-preview/assets/particles/emberssmall.png",
        repeat: 3,
        scale: 0.5,
        life: 800
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: true,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "rayoffrost" }),
    menu: "range",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "range", menuType: "spell", animation: "rayoffrost", variant: "01", color: "blue" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isReturning: false,
        isWait: false,
        onlyX: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "ray",
      data: {
        color01: "#002aff",
        color02: "#0400ff",
        spritePath: "modules/levels-3d-preview/assets/particles/star_07.png",
        life: 2e3,
        rate: 60,
        scale: 0.6
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: true,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "scorchingray" }),
    menu: "range",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "range", menuType: "spell", animation: "scorchingray", variant: "01", color: "orange" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isReturning: false,
        isWait: false,
        onlyX: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "ray",
      data: {
        color01: "#ff0000",
        color02: "#ff9500",
        spritePath: "modules/levels-3d-preview/assets/particles/scorch_01.png",
        life: 2e3,
        rate: 60,
        scale: 0.7
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: true,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "witchbolt" }),
    menu: "range",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "range", menuType: "spell", animation: "witchbolt", variant: "01", color: "blue" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isReturning: false,
        isWait: false,
        onlyX: false,
        opacity: 1,
        repeat: 1,
        repeatDelay: 500,
        saturate: 0,
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    secondary: secondary(),
    levels3d: {
      type: "ray",
      data: {
        color01: "#00e1ff",
        color02: "#4138c2",
        spritePath: "modules/levels-3d-preview/assets/particles/emberssmall.png",
        life: 2e3,
        rate: 60,
        scale: 0.6
      },
      sound: {
        enable: false
      },
      secondary: {
        enable: false,
        data: {
          color01: "#FFFFFF",
          color02: "#FFFFFF"
        }
      },
      tokens: {
        enable: true,
        source: true,
        target: true,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      enable: true
    },
    macro: macro(),
    source: source(),
    target: target()
  }
];
const templatefx$2 = [
  {
    ...main({ label: "calllightning" }),
    menu: "templatefx",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "templatefx", menuType: "circle", animation: "calllightning", variant: "01", color: "blueorange" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isMasked: false,
        isWait: false,
        occlusionAlpha: 0.7,
        occlusionMode: "3",
        opacity: 0.75,
        persistType: "overheadtile",
        persistent: true,
        removeTemplate: true,
        repeat: 1,
        repeatDelay: 500,
        rotate: 0,
        saturate: 0,
        scale: "1",
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    macro: macro(),
    secondary: secondary(),
    source: source(),
    target: target()
  },
  {
    ...main({ label: "fogcloud" }),
    menu: "templatefx",
    metaData: { default: true },
    primary: primary({
      video: { dbSection: "templatefx", menuType: "circle", animation: "fogcloud", variant: "01", color: "white" },
      options: {
        contrast: 0,
        delay: 0,
        elevation: 1e3,
        isWait: false,
        isMasked: false,
        occlusionAlpha: 0.65,
        occlusionMode: "3",
        opacity: 0.75,
        persistType: "overheadtile",
        persistent: true,
        removeTemplate: true,
        repeat: 1,
        repeatDelay: 500,
        rotate: 0,
        saturate: 0,
        scale: "1",
        tint: false,
        tintColor: "#FFFFFF",
        zIndex: 1
      }
    }),
    macro: macro(),
    secondary: secondary(),
    source: source(),
    target: target()
  }
];
function loadDefault(type) {
  let data2;
  switch (type) {
    case "aefx":
      data2 = aefx$2;
      break;
    case "aura":
      data2 = aura$2;
      break;
    case "melee":
      data2 = melee$2;
      break;
    case "ontoken":
      data2 = ontoken$2;
      break;
    case "preset":
      data2 = preset$1;
      break;
    case "range":
      data2 = range$2;
      break;
    case "templatefx":
      data2 = templatefx$2;
      break;
    default:
      throw new Error(`Unknown type: '${type}'.`);
  }
  return data2.reduce((array, entry) => {
    entry.label = localize(entry.label);
    array.push(entry);
    return array;
  }, []);
}
function defaultData() {
  let defaultMenu = {
    melee: loadDefault("melee"),
    range: loadDefault("range"),
    ontoken: loadDefault("ontoken"),
    templatefx: loadDefault("templatefx"),
    aura: loadDefault("aura"),
    preset: loadDefault("preset"),
    aefx: loadDefault("aefx")
  };
  return {
    melee: newMenuIDs(foundry.utils.deepClone(defaultMenu.melee)),
    range: newMenuIDs(foundry.utils.deepClone(defaultMenu.range)),
    ontoken: newMenuIDs(foundry.utils.deepClone(defaultMenu.ontoken)),
    templatefx: newMenuIDs(foundry.utils.deepClone(defaultMenu.templatefx)),
    aura: newMenuIDs(foundry.utils.deepClone(defaultMenu.aura)),
    preset: newMenuIDs(foundry.utils.deepClone(defaultMenu.preset)),
    aefx: newMenuIDs(foundry.utils.deepClone(defaultMenu.aefx))
  };
}
function newMenuIDs(menu) {
  let newMenu = AutorecSanitizer.newSectionIds(menu);
  return newMenu;
}
class AAAutorecManager {
  static async restoreDefault() {
    let restoredMenu = defaultData();
    await game.settings.set("autoanimations", "aaAutorec", void 0);
    await game.settings.set("autoanimations", "aaAutorec-aefx", restoredMenu.aefx);
    await game.settings.set("autoanimations", "aaAutorec-aura", restoredMenu.aura);
    await game.settings.set("autoanimations", "aaAutorec-melee", restoredMenu.melee);
    await game.settings.set("autoanimations", "aaAutorec-preset", restoredMenu.preset);
    await game.settings.set("autoanimations", "aaAutorec-range", restoredMenu.range);
    await game.settings.set("autoanimations", "aaAutorec-ontoken", restoredMenu.ontoken);
    await game.settings.set("autoanimations", "aaAutorec-templatefx", restoredMenu.templatefx);
  }
  // Returns the current Global Automatic Recognition Menus with Version
  static getAutorecEntries() {
    let menu = {
      melee: game.settings.get("autoanimations", "aaAutorec-melee"),
      range: game.settings.get("autoanimations", "aaAutorec-range"),
      ontoken: game.settings.get("autoanimations", "aaAutorec-ontoken"),
      templatefx: game.settings.get("autoanimations", "aaAutorec-templatefx"),
      aura: game.settings.get("autoanimations", "aaAutorec-aura"),
      preset: game.settings.get("autoanimations", "aaAutorec-preset"),
      aefx: game.settings.get("autoanimations", "aaAutorec-aefx"),
      version: game.settings.get("autoanimations", "aaAutorec").version
    };
    return menu;
  }
  /**
   * 
   * @param {Object} data // Expects an Object containing all MetaData to tag on the Menu Entries 
   * @param {Object} options // Limit the Menus in which to tag with MetaData. Ex: {melee: true} will ONLY tag the Melee Menu entries with MetaData
   * @returns 
   */
  static async addMetaData(data2, options2) {
    if (!data2) {
      return;
    }
    let addAll = false;
    if (!options2) {
      addAll = true;
    }
    let metaData = data2 || {};
    let exportData = {
      melee: await game.settings.get("autoanimations", "aaAutorec-melee"),
      range: await game.settings.get("autoanimations", "aaAutorec-range"),
      ontoken: await game.settings.get("autoanimations", "aaAutorec-ontoken"),
      templatefx: await game.settings.get("autoanimations", "aaAutorec-templatefx"),
      aura: await game.settings.get("autoanimations", "aaAutorec-aura"),
      preset: await game.settings.get("autoanimations", "aaAutorec-preset"),
      aefx: await game.settings.get("autoanimations", "aaAutorec-aefx"),
      version: await game.settings.get("autoanimations", "aaAutorec").version
    };
    if (exportData.melee.length && (options2?.melee || addAll)) {
      let newMelee = setMeta(exportData.melee);
      await game.settings.set("autoanimations", "aaAutorec-melee", newMelee);
    }
    if (exportData.range.length && (options2?.range || addAll)) {
      let newRange = setMeta(exportData.range);
      await game.settings.set("autoanimations", "aaAutorec-range", newRange);
    }
    if (exportData.ontoken.length && (options2?.ontoken || addAll)) {
      let newOnToken = setMeta(exportData.ontoken);
      await game.settings.set("autoanimations", "aaAutorec-ontoken", newOnToken);
    }
    if (exportData.templatefx.length && (options2?.templatefx || addAll)) {
      let newTemplateFx = setMeta(exportData.templatefx);
      await game.settings.set("autoanimations", "aaAutorec-templatefx", newTemplateFx);
    }
    if (exportData.aura.length && (options2?.aura || addAll)) {
      let newAura = setMeta(exportData.aura);
      await game.settings.set("autoanimations", "aaAutorec-aura", newAura);
    }
    if (exportData.preset.length && (options2?.preset || addAll)) {
      let newPreset = setMeta(exportData.preset);
      await game.settings.set("autoanimations", "aaAutorec-preset", newPreset);
    }
    if (exportData.aefx.length && (options2?.aefx || addAll)) {
      let newAefx = setMeta(exportData.aefx);
      await game.settings.set("autoanimations", "aaAutorec-aefx", newAefx);
    }
    function setMeta(menu) {
      let newMenu = foundry.utils.deepClone(menu);
      newMenu = AutorecSanitizer.newSectionIds(newMenu);
      newMenu.forEach((a) => a.metaData = metaData);
      return newMenu;
    }
  }
  // Exports ALL Global Automatic Recognition Menus
  static async exportMenu(string = "") {
    const exportData = {
      melee: await game.settings.get("autoanimations", "aaAutorec-melee"),
      range: await game.settings.get("autoanimations", "aaAutorec-range"),
      ontoken: await game.settings.get("autoanimations", "aaAutorec-ontoken"),
      templatefx: await game.settings.get("autoanimations", "aaAutorec-templatefx"),
      aura: await game.settings.get("autoanimations", "aaAutorec-aura"),
      preset: await game.settings.get("autoanimations", "aaAutorec-preset"),
      aefx: await game.settings.get("autoanimations", "aaAutorec-aefx"),
      version: await game.settings.get("autoanimations", "aaAutorec").version
    };
    const filename = `fvtt-AutomatedAnimations-GlobalMenu${string}.json`;
    saveDataToFile(JSON.stringify(exportData, null, 2), "text/json", filename);
  }
  /**
   * 
   * @param {Object} menu // Expects a valid  Global Automatic Recognition Menu export
   * @param {*} options // Limit the Menus in which to perform the Merge. Ex: {melee: true} will ONLY merge the Melee Menus
   */
  static async mergeMenus(menu, options2 = {}) {
    const currentVersion = currentAutorecVersion();
    if (menu.version > currentVersion) {
      custom_error$1("You are attempting to import a menu that is from a newer version of Automated Animations. Please update your module and try again", true);
      return;
    }
    custom_warning("Merging the requested Menus", false, menu, options2);
    const updatedImport = await autoRecMigration.handle(menu, { ...options2 });
    let currentMenu = {
      melee: await game.settings.get("autoanimations", "aaAutorec-melee"),
      range: await game.settings.get("autoanimations", "aaAutorec-range"),
      ontoken: await game.settings.get("autoanimations", "aaAutorec-ontoken"),
      templatefx: await game.settings.get("autoanimations", "aaAutorec-templatefx"),
      aura: await game.settings.get("autoanimations", "aaAutorec-aura"),
      preset: await game.settings.get("autoanimations", "aaAutorec-preset"),
      aefx: await game.settings.get("autoanimations", "aaAutorec-aefx")
    };
    let mergeMenu = updatedImport;
    let mergeList = [];
    if (options2.melee) {
      mergeList.push("melee");
    }
    if (options2.range) {
      mergeList.push("range");
    }
    if (options2.ontoken) {
      mergeList.push("ontoken");
    }
    if (options2.templatefx) {
      mergeList.push("templatefx");
    }
    if (options2.aura) {
      mergeList.push("aura");
    }
    if (options2.preset) {
      mergeList.push("preset");
    }
    if (options2.aefx) {
      mergeList.push("aefx");
    }
    for (var i = 0; i < mergeList.length; i++) {
      let existingMenu = currentMenu[mergeList[i]];
      let incomingMenu = mergeMenu[mergeList[i]];
      for (var a = 0; a < incomingMenu.length; a++) {
        let incomingSectionLabel = incomingMenu[a].label.replace(/\s+/g, "").toLowerCase();
        let newSection = existingMenu.find((section2) => {
          return section2.label?.replace(/\s+/g, "")?.toLowerCase() === incomingSectionLabel;
        });
        if (!newSection) {
          incomingMenu[a].id = uuidv4();
          currentMenu[mergeList[i]].push(incomingMenu[a]);
        }
      }
      custom_notify(`${game.i18n.localize(`autoanimations.animTypes.${mergeList[i]}`)} Menu has been successfully merged`);
      game.settings.set("autoanimations", `aaAutorec-${mergeList[i]}`, currentMenu[mergeList[i]]);
    }
  }
  /**
   * 
   * @param {Object} menu // Expects a valid  Global Automatic Recognition Menu export
   * @param {*} options // Limit the Menus in which to perform the Overwrite. Ex: {melee: true} will ONLY overwrite the Melee Menus
   */
  static async overwriteMenus(menu, options2 = {}) {
    let isValid = this._validateJson(menu);
    if (!isValid) {
      custom_error$1("You did not provide a valid JSON!");
      return;
    }
    const menuData = JSON.parse(menu);
    const currentVersion = currentAutorecVersion();
    if (menuData.version > currentVersion) {
      custom_error$1("You are attempting to import a menu that is from a newer version of Automated Animations. Please update your module and try again", true);
      return;
    }
    await autoRecMigration.handle(menuData, { isOverwrite: true, shouldSubmit: true, ...options2 });
  }
  static _validateJson(json) {
    try {
      JSON.parse(json);
      return true;
    } catch (e) {
      return false;
    }
  }
}
async function createActiveEffects(effect) {
  if (effect.disabled) {
    return;
  }
  if (!AnimationState.enabled) {
    return;
  }
  const aeToken = effect.parent?.token || canvas.tokens.placeables.find((token) => token.actor?.effects?.get(effect.id));
  if (!aeToken) {
    debug$1("Failed to find the Token for the Active Effect");
    return;
  }
  const aeNameField = effect.label + `${aeToken.id}`;
  const checkAnim = Sequencer.EffectManager.getEffects({ object: aeToken, name: aeNameField }).length > 0;
  if (checkAnim) {
    debug$1("Animation is already present on the Token, returning.");
    return;
  }
  const data2 = {
    token: aeToken,
    targets: [aeToken],
    item: effect,
    activeEffect: true,
    tieToDocuments: true
  };
  let handler = await AAHandler.make(data2);
  if (!handler) {
    return;
  }
  if (!handler.item || !handler.sourceToken) {
    debug$1("Failed to find the Item or Source Token", handler);
    return;
  }
  trafficCop$1(handler);
}
async function deleteActiveEffects(effect, shouldDelete = false) {
  const token = effect.parent?.token || canvas.tokens.placeables.find((token2) => token2.actor?.effects?.get(effect.id));
  const data2 = {
    token,
    targets: [],
    item: effect,
    activeEffect: true
  };
  const handler = await AAHandler.make(data2);
  if (!handler) {
    return;
  }
  const flagData = handler.animationData;
  const macro2 = await DataSanitizer.compileMacro(handler, flagData);
  if (macro2) {
    if (isNewerVersion(game.version, 11)) {
      new Sequence().macro(macro2.name, { args: ["off", handler, macro2.args] }).play();
    } else {
      if (game.modules.get("advanced-macros")?.active) {
        new Sequence().macro(macro2.name, "off", handler, macro2.args).play();
      } else {
        new Sequence().macro(macro2.name).play();
      }
    }
  }
  if (shouldDelete) {
    let aaEffects = Sequencer.EffectManager.getEffects({ origin: effect.uuid });
    if (aaEffects.length > 0) {
      let currentEffect = aaEffects.filter((i) => effect.uuid.includes(i.source?.actor?.id));
      currentEffect = currentEffect.length < 1 ? aaEffects.filter((i) => effect.uuid.includes(i.source?.id)) : currentEffect;
      if (currentEffect.length < 0) {
        return;
      }
      if (!handler.sourceToken) {
        handler.sourceToken = currentEffect[0].source;
      }
      Sequencer.EffectManager.endEffects({ origin: effect.uuid, object: handler.sourceToken });
    }
  }
}
async function toggleActiveEffects(effect, toggle) {
  if (toggle.disabled === true) {
    deleteActiveEffects(effect, true);
  } else if (toggle.disabled === false) {
    createActiveEffects(effect);
  }
}
async function checkConcentration(effect) {
  const label = effect.label || "";
  if (label.toLowerCase() !== "concentrating") {
    return;
  }
  const origin = effect.origin;
  if (!origin) {
    debug$1("Failed to find an Origin for Concentration");
    return;
  }
  const tiles = canvas.tiles.placeables.filter((i) => i.document.flags?.autoanimations?.origin === origin);
  if (tiles.length < 1) {
    debug$1("Failed to find any Tiles tied to Concentration");
    return;
  }
  let tileIdArray = [];
  if (tiles.length) {
    for (let tile of tiles) {
      tileIdArray.push(tile.id);
    }
    socketlibSocket.executeAsGM("removeTile", tileIdArray);
  }
}
async function createRuleElementPF2e(item2) {
  const aePF2eTypes = ["condition", "effect"];
  if (!aePF2eTypes.includes(item2.type)) {
    return;
  }
  if (!AnimationState.enabled) {
    return;
  }
  const itemId = item2.id;
  const aeToken = canvas.tokens.placeables.find((token) => token.actor?.items?.get(itemId) != null);
  if (!aeToken) {
    debug$1("Failed to find the Token for the Active Effect");
    return;
  }
  if (game.settings.get("autoanimations", "disableGrantedAuraEffects")) {
    let tactorId = aeToken.actor.id;
    let origin = item2.flags?.pf2e?.aura?.origin;
    if (origin) {
      let idSplit = origin.split(".");
      let id = idSplit[idSplit.length - 1];
      if (tactorId !== id) {
        debug$1("This is a Granted Ruleset, exiting early");
        return;
      }
    }
  }
  const aeNameField = item2.name.replace(/[^A-Za-z0-9 .*_-]/g, "") + `${aeToken.id}`;
  const checkAnim = await Sequencer.EffectManager.getEffects({ object: aeToken, name: aeNameField }).length > 0;
  if (checkAnim) {
    debug$1("Animation is already present on the Token, returning.");
    return;
  }
  const data2 = {
    token: aeToken,
    targets: [],
    item: item2,
    activeEffect: true,
    tieToDocuments: true
  };
  let handler = await AAHandler.make(data2);
  if (!handler) {
    return;
  }
  if (!handler.item || !handler.sourceToken) {
    debug$1("Failed to find the Item or Source Token", handler);
    return;
  }
  trafficCop$1(handler);
}
async function deleteRuleElementPF2e(itemData = {}) {
  const data2 = {
    token: itemData.token,
    targets: [],
    item: itemData.item,
    activeEffect: true
  };
  const handler = await AAHandler.make(data2);
  if (!handler) {
    return;
  }
  const flagData = handler.animationData;
  const macro2 = await DataSanitizer.compileMacro(handler, flagData);
  if (macro2) {
    if (isNewerVersion(game.version, 11)) {
      new Sequence().macro(macro2.name, { args: ["off", handler, macro2.args] }).play();
    } else {
      if (game.modules.get("advanced-macros")?.active) {
        new Sequence().macro(macro2.name, "off", handler, macro2.args).play();
      } else {
        new Sequence().macro(macro2.name).play();
      }
    }
  }
}
const pf2eDeletedItems = /* @__PURE__ */ new Map();
function registerActiveEffectHooks() {
  switch (game.system.id) {
    case "pf2e":
      let shouldContinue = function(item2, userId) {
        if (game.user.id !== userId) {
          return false;
        }
        if (!["condition", "effect", "feat"].includes(item2.type)) {
          return false;
        }
        return true;
      };
      Hooks.on("createItem", (item2, data2, userId) => {
        if (game.settings.get("autoanimations", "disableAEAnimations")) {
          debug$1(`Active Effect Animations are Disabled`);
          return;
        }
        if (game.user.id !== userId) {
          return;
        }
        const aePF2eTypes = ["condition", "effect", "feat"];
        if (!aePF2eTypes.includes(item2.type)) {
          debug$1("This is not a PF2e Ruleset, exiting early");
          return;
        }
        if (item2.system?.references?.parent && game.settings.get("autoanimations", "disableNestedEffects")) {
          debug$1("This is a nested Ruleset, exiting early");
          return;
        }
        createRuleElementPF2e(item2);
      });
      Hooks.on("preDeleteItem", (item2, data2, userId) => {
        if (shouldContinue(item2, userId)) {
          pf2eDeletedItems.set(item2.id, {
            item: item2,
            token: item2.parent?.token || canvas.tokens.placeables.find((token) => token.actor?.items?.get(item2.id) != null)
          });
        }
      });
      Hooks.on("deleteItem", (item2, data2, userId) => {
        if (shouldContinue(item2, userId)) {
          let itemData = pf2eDeletedItems.get(item2.id);
          if (!itemData) {
            return;
          }
          deleteRuleElementPF2e(itemData);
        }
      });
      break;
    case "sfrpg":
      Hooks.on("updateItem", (item2, diff, action, userId) => {
        if (game.user.id !== userId) {
          return;
        }
        Hooks.once("updateToken", async (token, actor, updates, userId2) => {
          if (game.user.id !== userId2) {
            return;
          }
          if (item2.type !== "feat") {
            return;
          }
          if (!diff.isActive) {
            deleteActiveEffects(item2, token);
          } else {
            const sfrpgData = {
              item: item2,
              token,
              targets: game.user.targets
            };
            const handler = await AAHandler.make(sfrpgData);
            trafficCop(handler);
          }
        });
      });
    case "dnd5e":
      Hooks.on("updateActiveEffect", (data2, toggle, other, userId) => {
        if (game.settings.get("autoanimations", "disableAEAnimations")) {
          debug$1(`Active Effect Animations are Disabled`);
          return;
        }
        if (game.user.id !== userId) {
          return;
        }
        toggleActiveEffects(data2, toggle);
      });
    case "pf1":
    case "wfrp4e":
      Hooks.on("createActiveEffect", (effect, data2, userId) => {
        if (game.settings.get("autoanimations", "disableAEAnimations")) {
          debug$1(`Active Effect Animations are Disabled`);
          return;
        }
        if (game.user.id !== userId) {
          return;
        }
        createActiveEffects(effect);
      });
      Hooks.on("preDeleteActiveEffect", (effect, data2, userId) => {
        if (game.user.id !== userId) {
          return;
        }
        deleteActiveEffects(effect);
        if (game.modules.get("midi-qol")?.active) {
          checkConcentration(effect);
        }
      });
      break;
    default:
      Hooks.on("updateActiveEffect", (data2, toggle, other, userId) => {
        if (game.settings.get("autoanimations", "disableAEAnimations")) {
          debug$1(`Active Effect Animations are Disabled`);
          return;
        }
        if (game.user.id !== userId) {
          return;
        }
        toggleActiveEffects(data2, toggle);
      });
      Hooks.on("createActiveEffect", (effect, data2, userId) => {
        if (game.settings.get("autoanimations", "disableAEAnimations")) {
          debug$1(`Active Effect Animations are Disabled`);
          return;
        }
        if (game.user.id !== userId) {
          return;
        }
        createActiveEffects(effect);
      });
      Hooks.on("preDeleteActiveEffect", (effect, data2, userId) => {
        if (game.user.id !== userId) {
          return;
        }
        deleteActiveEffects(effect);
        if (game.modules.get("midi-qol")?.active) {
          checkConcentration(effect);
        }
      });
  }
}
const subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable$1(value, start).subscribe
  };
}
function writable$1(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set2);
      if (auto) {
        set2(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
      values[i] = value;
      pending &= ~(1 << i);
      if (started) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
class DynReducerUtils {
  /**
   * Checks for array equality between two arrays of numbers.
   *
   * @param a - Array A
   *
   * @param b - Array B
   *
   * @returns Arrays are equal.
   */
  static arrayEquals(a, b) {
    if (a === b) {
      return true;
    }
    if (a === null || b === null) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let cntr = a.length; --cntr >= 0; ) {
      if (a[cntr] !== b[cntr]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Provides a solid string hashing algorithm.
   *
   * Sourced from: https://stackoverflow.com/a/52171480
   *
   * @param str - String to hash.
   *
   * @param seed - A seed value altering the hash.
   *
   * @returns Hash code.
   */
  static hashString(str, seed = 0) {
    let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
    for (let ch, i = 0; i < str.length; i++) {
      ch = str.charCodeAt(i);
      h1 = Math.imul(h1 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
  }
  /**
   * Converts an unknown value for hashing purposes in {@link AdapterIndexer.calcHashUpdate}.
   *
   * Currently objects / Map w/ object keys is not supported. Potentially can include `object-hash` to handle this
   * case, but it is not common to use objects as keys in Maps.
   *
   * @param value - An unknown value to convert to a number.
   */
  static hashUnknown(value) {
    if (value === null || value === void 0) {
      return 0;
    }
    let result = 0;
    switch (typeof value) {
      case "boolean":
        result = value ? 1 : 0;
        break;
      case "bigint":
        result = Number(BigInt.asIntN(64, value));
        break;
      case "function":
        result = this.hashString(value.name);
        break;
      case "number":
        result = Number.isFinite(value) ? value : 0;
        break;
      case "object":
        break;
      case "string":
        result = this.hashString(value);
        break;
      case "symbol":
        result = this.hashString(Symbol.keyFor(value));
        break;
    }
    return result;
  }
  /**
   * @param target -
   *
   * @param Prototype -
   *
   * @returns target constructor function has Prototype.
   */
  static hasPrototype(target2, Prototype) {
    if (typeof target2 !== "function") {
      return false;
    }
    if (target2 === Prototype) {
      return true;
    }
    for (let proto = Object.getPrototypeOf(target2); proto; proto = Object.getPrototypeOf(proto)) {
      if (proto === Prototype) {
        return true;
      }
    }
    return false;
  }
  /**
   * Provides a utility method to determine if the given data is iterable / implements iterator protocol.
   *
   * @param data - Data to verify as iterable.
   *
   * @returns Is data iterable.
   */
  static isIterable(data2) {
    return data2 !== null && data2 !== void 0 && typeof data2 === "object" && typeof data2[Symbol.iterator] === "function";
  }
}
class AdapterDerived {
  #hostData;
  #DerivedReducerCtor;
  #parentIndex;
  #derived = /* @__PURE__ */ new Map();
  #destroyed = false;
  /**
   * @param hostData - Hosted data structure.
   *
   * @param parentIndex - Any associated parent index API.
   *
   * @param DerivedReducerCtor - The default derived reducer constructor function.
   */
  constructor(hostData, parentIndex, DerivedReducerCtor) {
    this.#hostData = hostData;
    this.#parentIndex = parentIndex;
    this.#DerivedReducerCtor = DerivedReducerCtor;
    Object.freeze(this);
  }
  /**
   * Creates a new derived reducer.
   *
   * @param options - Options defining the new derived reducer.
   *
   * @returns Newly created derived reducer.
   */
  create(options2) {
    if (this.#destroyed) {
      throw Error(`AdapterDerived.create error: this instance has been destroyed.`);
    }
    let name;
    let rest = {};
    let ctor;
    const DerivedReducerCtor = this.#DerivedReducerCtor;
    if (typeof options2 === "string") {
      name = options2;
      ctor = DerivedReducerCtor;
    } else if (typeof options2 === "function" && DynReducerUtils.hasPrototype(options2, DerivedReducerCtor)) {
      ctor = options2;
    } else if (typeof options2 === "object" && options2 !== null) {
      ({ name, ctor = DerivedReducerCtor, ...rest } = options2);
    } else {
      throw new TypeError(`AdapterDerived.create error: 'options' does not conform to allowed parameters.`);
    }
    if (!DynReducerUtils.hasPrototype(ctor, DerivedReducerCtor)) {
      throw new TypeError(`AdapterDerived.create error: 'ctor' is not a '${DerivedReducerCtor?.name}'.`);
    }
    name = name ?? ctor?.name;
    if (typeof name !== "string") {
      throw new TypeError(`AdapterDerived.create error: 'name' is not a string.`);
    }
    const derivedReducer = new ctor(this.#hostData, this.#parentIndex, rest);
    this.#derived.set(name, derivedReducer);
    return derivedReducer;
  }
  /**
   * Removes all derived reducers and associated subscriptions.
   */
  clear() {
    if (this.#destroyed) {
      return;
    }
    for (const reducer of this.#derived.values()) {
      reducer.destroy();
    }
    this.#derived.clear();
  }
  /**
   * Deletes and destroys a derived reducer by name.
   *
   * @param name - Name of the derived reducer.
   */
  delete(name) {
    if (this.#destroyed) {
      throw Error(`AdapterDerived.delete error: this instance has been destroyed.`);
    }
    const reducer = this.#derived.get(name);
    if (reducer) {
      reducer.destroy();
    }
    return this.#derived.delete(name);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    if (this.#destroyed) {
      return;
    }
    this.clear();
    this.#hostData = [null];
    this.#parentIndex = null;
    this.#destroyed = true;
  }
  /**
   * Returns an existing derived reducer.
   *
   * @param name - Name of derived reducer.
   */
  get(name) {
    if (this.#destroyed) {
      throw Error(`AdapterDerived.get error: this instance has been destroyed.`);
    }
    return this.#derived.get(name);
  }
  /**
   * Updates all managed derived reducer indexes.
   *
   * @param [force] - Force an update to subscribers.
   */
  update(force = false) {
    if (this.#destroyed) {
      return;
    }
    for (const reducer of this.#derived.values()) {
      reducer.index.update(force);
    }
  }
}
class AdapterFilters {
  #filtersData;
  #indexUpdate;
  #mapUnsubscribe = /* @__PURE__ */ new Map();
  /**
   * @param indexUpdate - update function for the indexer.
   *
   * @param filtersAdapter - Stores the filter function data.
   */
  constructor(indexUpdate, filtersAdapter) {
    this.#indexUpdate = indexUpdate;
    this.#filtersData = filtersAdapter;
    Object.freeze(this);
  }
  /**
   * @returns Returns the length of the filter data.
   */
  get length() {
    return this.#filtersData.filters.length;
  }
  /**
   * Provides an iterator for filters.
   *
   * @returns Generator / iterator of filters.
   * @yields {DataFilter<T>}
   */
  *[Symbol.iterator]() {
    if (this.#filtersData.filters.length === 0) {
      return;
    }
    for (const entry of this.#filtersData.filters) {
      yield { ...entry };
    }
  }
  /**
   * @param filters -
   */
  add(...filters) {
    let subscribeCount = 0;
    for (const filter of filters) {
      const filterType = typeof filter;
      if (filterType !== "function" && (filterType !== "object" || filter === null)) {
        throw new TypeError(`AdapterFilters error: 'filter' is not a function or object.`);
      }
      let data2 = void 0;
      let subscribeFn = void 0;
      if (filterType === "function") {
        data2 = {
          id: void 0,
          filter,
          weight: 1
        };
        subscribeFn = filter.subscribe;
      } else if (filterType === "object") {
        if ("filter" in filter) {
          if (typeof filter.filter !== "function") {
            throw new TypeError(`AdapterFilters error: 'filter' attribute is not a function.`);
          }
          if (filter.weight !== void 0 && typeof filter.weight !== "number" || (filter.weight < 0 || filter.weight > 1)) {
            throw new TypeError(`AdapterFilters error: 'weight' attribute is not a number between '0 - 1' inclusive.`);
          }
          data2 = {
            id: filter.id !== void 0 ? filter.id : void 0,
            filter: filter.filter,
            weight: filter.weight || 1
          };
          subscribeFn = filter.filter.subscribe ?? filter.subscribe;
        } else {
          throw new TypeError(`AdapterFilters error: 'filter' attribute is not a function.`);
        }
      }
      const index = this.#filtersData.filters.findIndex((value) => {
        return data2.weight < value.weight;
      });
      if (index >= 0) {
        this.#filtersData.filters.splice(index, 0, data2);
      } else {
        this.#filtersData.filters.push(data2);
      }
      if (typeof subscribeFn === "function") {
        const unsubscribe = subscribeFn(this.#indexUpdate);
        if (typeof unsubscribe !== "function") {
          throw new TypeError("AdapterFilters error: Filter has subscribe function, but no unsubscribe function is returned.");
        }
        if (this.#mapUnsubscribe.has(data2.filter)) {
          throw new Error("AdapterFilters error: Filter added already has an unsubscribe function registered.");
        }
        this.#mapUnsubscribe.set(data2.filter, unsubscribe);
        subscribeCount++;
      }
    }
    if (subscribeCount < filters.length) {
      this.#indexUpdate();
    }
  }
  /**
   * Clears and removes all filters.
   */
  clear() {
    this.#filtersData.filters.length = 0;
    for (const unsubscribe of this.#mapUnsubscribe.values()) {
      unsubscribe();
    }
    this.#mapUnsubscribe.clear();
    this.#indexUpdate();
  }
  /**
   * @param filters -
   */
  remove(...filters) {
    const length = this.#filtersData.filters.length;
    if (length === 0) {
      return;
    }
    for (const data2 of filters) {
      const actualFilter = typeof data2 === "function" ? data2 : data2 !== null && typeof data2 === "object" ? data2.filter : void 0;
      if (!actualFilter) {
        continue;
      }
      for (let cntr = this.#filtersData.filters.length; --cntr >= 0; ) {
        if (this.#filtersData.filters[cntr].filter === actualFilter) {
          this.#filtersData.filters.splice(cntr, 1);
          let unsubscribe = void 0;
          if (typeof (unsubscribe = this.#mapUnsubscribe.get(actualFilter)) === "function") {
            unsubscribe();
            this.#mapUnsubscribe.delete(actualFilter);
          }
        }
      }
    }
    if (length !== this.#filtersData.filters.length) {
      this.#indexUpdate();
    }
  }
  /**
   * Remove filters by the provided callback. The callback takes 3 parameters: `id`, `filter`, and `weight`.
   * Any truthy value returned will remove that filter.
   *
   * @param callback - Callback function to evaluate each filter entry.
   */
  removeBy(callback) {
    const length = this.#filtersData.filters.length;
    if (length === 0) {
      return;
    }
    if (typeof callback !== "function") {
      throw new TypeError(`AdapterFilters error: 'callback' is not a function.`);
    }
    this.#filtersData.filters = this.#filtersData.filters.filter((data2) => {
      const remove = callback.call(callback, { ...data2 });
      if (remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data2.filter)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data2.filter);
        }
      }
      return !remove;
    });
    if (length !== this.#filtersData.filters.length) {
      this.#indexUpdate();
    }
  }
  /**
   * @param ids - Removes filters by ID.
   */
  removeById(...ids) {
    const length = this.#filtersData.filters.length;
    if (length === 0) {
      return;
    }
    this.#filtersData.filters = this.#filtersData.filters.filter((data2) => {
      let remove = 0;
      for (const id of ids) {
        remove |= data2.id === id ? 1 : 0;
      }
      if (!!remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data2.filter)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data2.filter);
        }
      }
      return !remove;
    });
    if (length !== this.#filtersData.filters.length) {
      this.#indexUpdate();
    }
  }
}
class AdapterIndexer {
  derivedAdapter;
  filtersData;
  hostData;
  hostUpdate;
  indexData;
  sortData;
  sortFn;
  destroyed = false;
  /**
   * @param hostData - Hosted data structure.
   *
   * @param hostUpdate - Host update function invoked on index updates.
   *
   * @param [parentIndexer] - Any associated parent index API.
   *
   * @returns Indexer adapter instance.
   */
  constructor(hostData, hostUpdate, parentIndexer) {
    this.hostData = hostData;
    this.hostUpdate = hostUpdate;
    this.indexData = { index: null, hash: null, reversed: false, parent: parentIndexer };
  }
  /**
   * @returns Returns whether the index is active.
   */
  get active() {
    return this.filtersData.filters.length > 0 || this.sortData.compareFn !== null || this.indexData.parent?.active === true;
  }
  /**
   * @returns Returns length of reduced index.
   */
  get length() {
    return this.indexData.index ? this.indexData.index.length : 0;
  }
  /* c8 ignore start */
  /**
   * @returns Returns reversed state.
   */
  get reversed() {
    return this.indexData.reversed;
  }
  /* c8 ignore end */
  /**
   * @param reversed - New reversed state.
   */
  set reversed(reversed) {
    this.indexData.reversed = reversed;
  }
  // -------------------------------------------------------------------------------------------------------------------
  /**
   * Calculates a new hash value for the new index array if any. If the new index array is null then the hash value
   * is set to null. Set calculated new hash value to the index adapter hash value.
   *
   * After hash generation compare old and new hash values and perform an update if they are different. If they are
   * equal check for array equality between the old and new index array and perform an update if they are not equal.
   *
   * @param oldIndex - Old index array.
   *
   * @param oldHash - Old index hash value.
   *
   * @param [force=false] - When true forces an update to subscribers.
   */
  calcHashUpdate(oldIndex, oldHash, force = false) {
    const actualForce = typeof force === "boolean" ? force : (
      /* c8 ignore next */
      false
    );
    let newHash = null;
    const newIndex = this.indexData.index;
    if (newIndex) {
      for (let cntr = newIndex.length; --cntr >= 0; ) {
        newHash ^= DynReducerUtils.hashUnknown(newIndex[cntr]) + 2654435769 + (newHash << 6) + (newHash >> 2);
      }
    }
    this.indexData.hash = newHash;
    if (actualForce || (oldHash === newHash ? !DynReducerUtils.arrayEquals(oldIndex, newIndex) : true)) {
      this.hostUpdate();
    }
  }
  /**
   * Destroys all resources.
   */
  destroy() {
    if (this.destroyed) {
      return;
    }
    this.indexData.index = null;
    this.indexData.hash = null;
    this.indexData.reversed = null;
    this.indexData.parent = null;
    this.destroyed = true;
  }
  /**
   * Store associated filter and sort data that are constructed after the indexer.
   *
   * @param filtersData - Associated AdapterFilters instance.
   *
   * @param sortData - Associated AdapterSort instance.
   *
   * @param derivedAdapter - Associated AdapterDerived instance.
   */
  initAdapters(filtersData, sortData, derivedAdapter) {
    this.filtersData = filtersData;
    this.sortData = sortData;
    this.derivedAdapter = derivedAdapter;
    this.sortFn = this.createSortFn();
  }
}
class AdapterSort {
  #sortData;
  #indexUpdate;
  #unsubscribe;
  /**
   * @param indexUpdate - Function to update indexer.
   *
   * @param sortData - Storage for compare function.
   */
  constructor(indexUpdate, sortData) {
    this.#indexUpdate = indexUpdate;
    this.#sortData = sortData;
    Object.freeze(this);
  }
  /**
   * Clears & removes any assigned sort function and triggers an index update.
   */
  clear() {
    const oldCompareFn = this.#sortData.compareFn;
    this.#sortData.compareFn = null;
    if (typeof this.#unsubscribe === "function") {
      this.#unsubscribe();
      this.#unsubscribe = void 0;
    }
    if (typeof oldCompareFn === "function") {
      this.#indexUpdate();
    }
  }
  /**
   * @param data - A callback function that compares two values. Return > 0 to sort b before a;
   * < 0 to sort a before b; or 0 to keep original order of a & b.
   *
   * Note: You can set a compare function that also has a subscribe function attached as the `subscribe` attribute.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#parameters
   */
  set(data2) {
    if (typeof this.#unsubscribe === "function") {
      this.#unsubscribe();
      this.#unsubscribe = void 0;
    }
    let compareFn = void 0;
    let subscribeFn = void 0;
    switch (typeof data2) {
      case "function":
        compareFn = data2;
        subscribeFn = data2.subscribe;
        break;
      case "object":
        if (data2 === null) {
          break;
        }
        if (typeof data2.compare !== "function") {
          throw new TypeError(`AdapterSort error: 'compare' attribute is not a function.`);
        }
        compareFn = data2.compare;
        subscribeFn = data2.compare.subscribe ?? data2.subscribe;
        break;
    }
    if (typeof compareFn === "function") {
      this.#sortData.compareFn = compareFn;
    } else {
      const oldCompareFn = this.#sortData.compareFn;
      this.#sortData.compareFn = null;
      if (typeof oldCompareFn === "function") {
        this.#indexUpdate();
      }
      return;
    }
    if (typeof subscribeFn === "function") {
      this.#unsubscribe = subscribeFn(this.#indexUpdate);
      if (typeof this.#unsubscribe !== "function") {
        throw new Error(`AdapterSort error: sort has 'subscribe' function, but no 'unsubscribe' function is returned.`);
      }
    } else {
      this.#indexUpdate();
    }
  }
}
class IndexerAPI {
  #indexData;
  /**
   * Provides a getter to determine if the index is active.
   */
  active;
  /**
   * Provides length of reduced / indexed elements.
   */
  length;
  /**
   * Manually invoke an update of the index.
   *
   * @param force - Force update to any subscribers.
   */
  update;
  constructor(adapterIndexer) {
    this.#indexData = adapterIndexer.indexData;
    this.update = adapterIndexer.update.bind(adapterIndexer);
    Object.defineProperties(this, {
      active: { get: () => adapterIndexer.active },
      length: { get: () => adapterIndexer.length }
    });
    Object.freeze(this);
  }
  /**
   * - Current hash value of the index.
   */
  get hash() {
    return this.#indexData.hash;
  }
  /**
   * Provides an iterator over the index array.
   *
   * @returns Iterator / generator
   * @yields {K}
   */
  *[Symbol.iterator]() {
    const indexData = this.#indexData;
    if (!indexData.index) {
      return;
    }
    const reversed = indexData.reversed;
    const length = indexData.index.length;
    if (reversed) {
      for (let cntr = length; --cntr >= 0; ) {
        yield indexData.index[cntr];
      }
    } else {
      for (let cntr = 0; cntr < length; cntr++) {
        yield indexData.index[cntr];
      }
    }
  }
}
class DerivedAPI {
  /**
   * Removes all derived reducers and associated subscriptions.
   */
  clear;
  /**
   * @param options - Options for creating a reducer.
   *
   * @returns Newly created derived reducer.
   */
  create;
  /**
   * Deletes and destroys a derived reducer.
   *
   * @param name - Name of the derived reducer
   */
  delete;
  /**
   * Removes all derived reducers, associated subscriptions, and cleans up all resources.
   */
  destroy;
  /**
   * Returns an existing derived reducer.
   *
   * @param name - Name of derived reducer.
   */
  get;
  constructor(adapterDerived) {
    this.clear = adapterDerived.clear.bind(adapterDerived);
    this.create = adapterDerived.create.bind(adapterDerived);
    this.delete = adapterDerived.delete.bind(adapterDerived);
    this.destroy = adapterDerived.destroy.bind(adapterDerived);
    this.get = adapterDerived.get.bind(adapterDerived);
    Object.freeze(this);
  }
}
class Indexer$1 extends AdapterIndexer {
  /**
   * @inheritDoc
   */
  createSortFn() {
    return (a, b) => this.sortData.compareFn(this.hostData[0][a], this.hostData[0][b]);
  }
  /**
   * Provides the custom filter / reduce step that is ~25-40% faster than implementing with `Array.reduce`.
   *
   * Note: Other loop unrolling techniques like Duff's Device gave a slight faster lower bound on large data sets,
   * but the maintenance factor is not worth the extra complication.
   *
   * @returns New filtered index array.
   */
  reduceImpl() {
    const data2 = [];
    const array = this.hostData[0];
    if (!array) {
      return data2;
    }
    const filters = this.filtersData.filters;
    let include = true;
    const parentIndex = this.indexData.parent;
    if (DynReducerUtils.isIterable(parentIndex) && parentIndex.active) {
      for (const adjustedIndex of parentIndex) {
        const value = array[adjustedIndex];
        include = true;
        for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {
          if (!filters[filCntr].filter(value)) {
            include = false;
            break;
          }
        }
        if (include) {
          data2.push(adjustedIndex);
        }
      }
    } else {
      for (let cntr = 0, length = array.length; cntr < length; cntr++) {
        include = true;
        for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {
          if (!filters[filCntr].filter(array[cntr])) {
            include = false;
            break;
          }
        }
        if (include) {
          data2.push(cntr);
        }
      }
    }
    return data2;
  }
  /**
   * Update the reducer indexes. If there are changes subscribers are notified. If data order is changed externally
   * pass in true to force an update to subscribers.
   *
   * @param [force=false] - When true forces an update to subscribers.
   */
  update(force = false) {
    if (this.destroyed) {
      return;
    }
    const oldIndex = this.indexData.index;
    const oldHash = this.indexData.hash;
    const array = this.hostData[0];
    const parentIndex = this.indexData.parent;
    if (this.filtersData.filters.length === 0 && !this.sortData.compareFn || this.indexData.index && array?.length !== this.indexData.index.length) {
      this.indexData.index = null;
    }
    if (this.filtersData.filters.length > 0) {
      this.indexData.index = this.reduceImpl();
    }
    if (!this.indexData.index && parentIndex?.active) {
      this.indexData.index = [...parentIndex];
    }
    if (this.sortData.compareFn && Array.isArray(array)) {
      if (!this.indexData.index) {
        this.indexData.index = [...Array(array.length).keys()];
      }
      this.indexData.index.sort(this.sortFn);
    }
    this.calcHashUpdate(oldIndex, oldHash, force);
    this.derivedAdapter?.update(force);
  }
}
class DerivedArrayReducer {
  #array;
  #derived;
  #derivedPublicAPI;
  #filters;
  #filtersData = { filters: [] };
  #index;
  #indexPublicAPI;
  #reversed = false;
  #sort;
  #sortData = { compareFn: null };
  #subscriptions = [];
  #destroyed = false;
  /**
   * @param array - Data host array.
   *
   * @param parentIndex - Parent indexer.
   *
   * @param options - Any filters and sort functions to apply.
   */
  constructor(array, parentIndex, options2) {
    this.#array = array;
    this.#index = new Indexer$1(this.#array, this.#updateSubscribers.bind(this), parentIndex);
    this.#indexPublicAPI = new IndexerAPI(this.#index);
    this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);
    this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);
    this.#derived = new AdapterDerived(this.#array, this.#indexPublicAPI, DerivedArrayReducer);
    this.#derivedPublicAPI = new DerivedAPI(this.#derived);
    this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);
    let filters = void 0;
    let sort = void 0;
    if (options2 !== void 0 && ("filters" in options2 || "sort" in options2)) {
      if (options2.filters !== void 0) {
        if (DynReducerUtils.isIterable(options2.filters)) {
          filters = options2.filters;
        } else {
          throw new TypeError(`DerivedArrayReducer error (DataDerivedOptions): 'filters' attribute is not iterable.`);
        }
      }
      if (options2.sort !== void 0) {
        if (typeof options2.sort === "function") {
          sort = options2.sort;
        } else if (typeof options2.sort === "object" && options2.sort !== null) {
          sort = options2.sort;
        } else {
          throw new TypeError(`DerivedArrayReducer error (DataDerivedOptions): 'sort' attribute is not a function or object.`);
        }
      }
    }
    if (filters) {
      this.filters.add(...filters);
    }
    if (sort) {
      this.sort.set(sort);
    }
    this.initialize();
  }
  /**
   * Returns the internal data of this instance. Be careful!
   *
   * Note: if an array is set as initial data then that array is used as the internal data. If any changes are
   * performed to the data externally do invoke {@link IndexerAPI.update} with `true` to recalculate the index and
   * notify all subscribers.
   *
   * @returns The internal data.
   */
  get data() {
    return this.#array[0];
  }
  /**
   * @returns Derived public API.
   */
  get derived() {
    return this.#derivedPublicAPI;
  }
  /**
   * @returns The filters adapter.
   */
  get filters() {
    return this.#filters;
  }
  /**
   * Returns the Indexer public API.
   *
   * @returns Indexer API - is also iterable.
   */
  get index() {
    return this.#indexPublicAPI;
  }
  /**
   * Returns whether this derived reducer is destroyed.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   * @returns Main data / items length or indexed length.
   */
  get length() {
    const array = this.#array[0];
    return this.#index.active ? this.index.length : array ? array.length : 0;
  }
  /**
   * @returns Gets current reversed state.
   */
  get reversed() {
    return this.#reversed;
  }
  /**
   * @returns The sort adapter.
   */
  get sort() {
    return this.#sort;
  }
  /**
   * Sets reversed state and notifies subscribers.
   *
   * @param reversed - New reversed state.
   */
  set reversed(reversed) {
    if (typeof reversed !== "boolean") {
      throw new TypeError(`DerivedArrayReducer.reversed error: 'reversed' is not a boolean.`);
    }
    this.#reversed = reversed;
    this.#index.reversed = reversed;
    this.index.update(true);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    this.#destroyed = true;
    this.#array = [null];
    this.#index.update(true);
    this.#subscriptions.length = 0;
    this.#derived.destroy();
    this.#index.destroy();
    this.#filters.clear();
    this.#sort.clear();
  }
  /**
   * Provides a callback for custom derived reducers to initialize any data / custom configuration. This allows
   * child classes to avoid implementing the constructor.
   *
   * @protected
   */
  initialize() {
  }
  /**
   * Provides an iterator for data stored in DerivedArrayReducer.
   *
   * @returns Generator / iterator of all data.
   */
  *[Symbol.iterator]() {
    const array = this.#array[0];
    if (this.#destroyed || array === null || array?.length === 0) {
      return;
    }
    if (this.#index.active) {
      for (const entry of this.index) {
        yield array[entry];
      }
    } else {
      if (this.reversed) {
        for (let cntr = array.length; --cntr >= 0; ) {
          yield array[cntr];
        }
      } else {
        for (let cntr = 0; cntr < array.length; cntr++) {
          yield array[cntr];
        }
      }
    }
  }
  // -------------------------------------------------------------------------------------------------------------------
  /**
   * Subscribe to this DerivedArrayReducer.
   *
   * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.
   *
   * @returns Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  /**
   * Updates subscribers on changes.
   */
  #updateSubscribers() {
    for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) {
      this.#subscriptions[cntr](this);
    }
  }
}
class DynArrayReducer {
  #array = [null];
  #derived;
  #derivedPublicAPI;
  #filters;
  #filtersData = { filters: [] };
  #index;
  #indexPublicAPI;
  #reversed = false;
  #sort;
  #sortData = { compareFn: null };
  #subscriptions = [];
  #destroyed = false;
  /**
   * Initializes DynArrayReducer. Any iterable is supported for initial data. Take note that if `data` is an array it
   * will be used as the host array and not copied. All non-array iterables otherwise create a new array / copy.
   *
   * @param [data] - Data iterable to store if array or copy otherwise.
   */
  constructor(data2) {
    let dataIterable = void 0;
    let filters = void 0;
    let sort = void 0;
    if (data2 === null) {
      throw new TypeError(`DynArrayReducer error: 'data' is not iterable.`);
    }
    if (data2 !== void 0 && typeof data2 !== "object" && !DynReducerUtils.isIterable(data2)) {
      throw new TypeError(`DynArrayReducer error: 'data' is not iterable.`);
    }
    if (data2 !== void 0 && Symbol.iterator in data2) {
      dataIterable = data2;
    } else if (data2 !== void 0 && ("data" in data2 || "filters" in data2 || "sort" in data2)) {
      if (data2.data !== void 0 && !DynReducerUtils.isIterable(data2.data)) {
        throw new TypeError(`DynArrayReducer error (DataDynArray): 'data' attribute is not iterable.`);
      }
      dataIterable = data2.data;
      if (data2.filters !== void 0) {
        if (DynReducerUtils.isIterable(data2.filters)) {
          filters = data2.filters;
        } else {
          throw new TypeError(`DynArrayReducer error (DataDynArray): 'filters' attribute is not iterable.`);
        }
      }
      if (data2.sort !== void 0) {
        if (typeof data2.sort === "function") {
          sort = data2.sort;
        } else if (typeof data2.sort === "object" && data2.sort !== null) {
          sort = data2.sort;
        } else {
          throw new TypeError(`DynArrayReducer error (DataDynArray): 'sort' attribute is not a function or object.`);
        }
      }
    }
    if (dataIterable) {
      this.#array[0] = Array.isArray(dataIterable) ? dataIterable : [...dataIterable];
    }
    this.#index = new Indexer$1(this.#array, this.#updateSubscribers.bind(this));
    this.#indexPublicAPI = new IndexerAPI(this.#index);
    this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);
    this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);
    this.#derived = new AdapterDerived(this.#array, this.#indexPublicAPI, DerivedArrayReducer);
    this.#derivedPublicAPI = new DerivedAPI(this.#derived);
    this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);
    if (filters) {
      this.filters.add(...filters);
    }
    if (sort) {
      this.sort.set(sort);
    }
    this.initialize();
  }
  /**
   * Returns the internal data of this instance. Be careful!
   *
   * Note: if an array is set as initial data then that array is used as the internal data. If any changes are
   * performed to the data externally do invoke {@link AdapterIndexer.index.update} with `true` to recalculate the
   * index and notify all subscribers.
   *
   * @returns The internal data.
   */
  get data() {
    return this.#array[0];
  }
  /**
   * @returns Derived public API.
   */
  get derived() {
    return this.#derivedPublicAPI;
  }
  /**
   * @returns The filters adapter.
   */
  get filters() {
    return this.#filters;
  }
  /**
   * @returns Returns the Indexer public API.
   */
  get index() {
    return this.#indexPublicAPI;
  }
  /**
   * Returns whether this instance is destroyed.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   * Gets the main data / items length.
   *
   * @returns {number} Main data / items length.
   */
  get length() {
    const array = this.#array[0];
    return this.#index.active ? this.#indexPublicAPI.length : array ? array.length : 0;
  }
  /**
   * Gets current reversed state.
   *
   * @returns {boolean} Reversed state.
   */
  get reversed() {
    return this.#reversed;
  }
  /**
   * @returns The sort adapter.
   */
  get sort() {
    return this.#sort;
  }
  /**
   * Sets reversed state and notifies subscribers.
   *
   * @param reversed - New reversed state.
   */
  set reversed(reversed) {
    if (typeof reversed !== "boolean") {
      throw new TypeError(`DynArrayReducer.reversed error: 'reversed' is not a boolean.`);
    }
    this.#reversed = reversed;
    this.#index.reversed = reversed;
    this.index.update(true);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    if (this.#destroyed) {
      return;
    }
    this.#destroyed = true;
    this.#derived.destroy();
    this.#array = [null];
    this.index.update(true);
    this.#subscriptions.length = 0;
    this.#index.destroy();
    this.#filters.clear();
    this.#sort.clear();
  }
  /**
   * Provides a callback for custom reducers to initialize any data / custom configuration. This allows
   * child classes to avoid implementing the constructor.
   *
   * @protected
   */
  initialize() {
  }
  /**
   * Removes internal data and pushes new data. This does not destroy any initial array set to internal data unless
   * `replace` is set to true.
   *
   * @param data - New data to set to internal data.
   *
   * @param replace=false - New data to set to internal data.
   */
  setData(data2, replace = false) {
    if (data2 !== null && !DynReducerUtils.isIterable(data2)) {
      throw new TypeError(`DynArrayReducer.setData error: 'data' is not iterable.`);
    }
    if (typeof replace !== "boolean") {
      throw new TypeError(`DynArrayReducer.setData error: 'replace' is not a boolean.`);
    }
    const array = this.#array[0];
    if (!Array.isArray(array) || replace) {
      if (data2) {
        this.#array[0] = Array.isArray(data2) ? data2 : [...data2];
      }
    } else {
      if (data2) {
        array.length = 0;
        array.push(...data2);
      } else {
        this.#array[0] = null;
      }
    }
    this.index.update(true);
  }
  /**
   * Add a subscriber to this DynArrayReducer instance.
   *
   * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.
   *
   * @returns Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  /**
   * Updates subscribers on changes.
   */
  #updateSubscribers() {
    for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) {
      this.#subscriptions[cntr](this);
    }
  }
  /**
   * Provides an iterator for data stored in DynArrayReducer.
   *
   * @returns Generator / iterator of all data.
   * @yields {T}
   */
  *[Symbol.iterator]() {
    const array = this.#array[0];
    if (this.#destroyed || array === null || array?.length === 0) {
      return;
    }
    if (this.#index.active) {
      for (const entry of this.index) {
        yield array[entry];
      }
    } else {
      if (this.reversed) {
        for (let cntr = array.length; --cntr >= 0; ) {
          yield array[cntr];
        }
      } else {
        for (let cntr = 0; cntr < array.length; cntr++) {
          yield array[cntr];
        }
      }
    }
  }
}
class Indexer extends AdapterIndexer {
  /**
   * @inheritDoc
   */
  createSortFn() {
    return (a, b) => this.sortData.compareFn(this.hostData[0].get(a), this.hostData[0].get(b));
  }
  /**
   * Provides the custom filter / reduce step that is ~25-40% faster than implementing with `Array.reduce`.
   *
   * Note: Other loop unrolling techniques like Duff's Device gave a slight faster lower bound on large data sets,
   * but the maintenance factor is not worth the extra complication.
   *
   * @returns New filtered index array.
   */
  reduceImpl() {
    const data2 = [];
    const map = this.hostData[0];
    if (!map) {
      return data2;
    }
    const filters = this.filtersData.filters;
    let include = true;
    const parentIndex = this.indexData.parent;
    if (DynReducerUtils.isIterable(parentIndex) && parentIndex.active) {
      for (const key of parentIndex) {
        const value = map.get(key);
        include = true;
        for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {
          if (!filters[filCntr].filter(value)) {
            include = false;
            break;
          }
        }
        if (include) {
          data2.push(key);
        }
      }
    } else {
      for (const key of map.keys()) {
        include = true;
        const value = map.get(key);
        for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {
          if (!filters[filCntr].filter(value)) {
            include = false;
            break;
          }
        }
        if (include) {
          data2.push(key);
        }
      }
    }
    return data2;
  }
  /**
   * Update the reducer indexes. If there are changes subscribers are notified. If data order is changed externally
   * pass in true to force an update to subscribers.
   *
   * @param [force=false] - When true forces an update to subscribers.
   */
  update(force = false) {
    if (this.destroyed) {
      return;
    }
    const oldIndex = this.indexData.index;
    const oldHash = this.indexData.hash;
    const map = this.hostData[0];
    const parentIndex = this.indexData.parent;
    if (this.filtersData.filters.length === 0 && !this.sortData.compareFn || this.indexData.index && map?.size !== this.indexData.index.length) {
      this.indexData.index = null;
    }
    if (this.filtersData.filters.length > 0) {
      this.indexData.index = this.reduceImpl();
    }
    if (!this.indexData.index && parentIndex?.active) {
      this.indexData.index = [...parentIndex];
    }
    if (this.sortData.compareFn && map instanceof Map) {
      if (!this.indexData.index) {
        this.indexData.index = this.indexData.index = [...map.keys()];
      }
      this.indexData.index.sort(this.sortFn);
    }
    this.calcHashUpdate(oldIndex, oldHash, force);
    this.derivedAdapter?.update(force);
  }
}
class DerivedMapReducer {
  #map;
  #derived;
  #derivedPublicAPI;
  #filters;
  #filtersData = { filters: [] };
  #index;
  #indexPublicAPI;
  #reversed = false;
  #sort;
  #sortData = { compareFn: null };
  #subscriptions = [];
  #destroyed = false;
  /**
   * @param map - Data host Map.
   *
   * @param parentIndex - Parent indexer.
   *
   * @param options - Any filters and sort functions to apply.
   */
  constructor(map, parentIndex, options2) {
    this.#map = map;
    this.#index = new Indexer(this.#map, this.#updateSubscribers.bind(this), parentIndex);
    this.#indexPublicAPI = new IndexerAPI(this.#index);
    this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);
    this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);
    this.#derived = new AdapterDerived(this.#map, this.#indexPublicAPI, DerivedMapReducer);
    this.#derivedPublicAPI = new DerivedAPI(this.#derived);
    this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);
    let filters = void 0;
    let sort = void 0;
    if (options2 !== void 0 && ("filters" in options2 || "sort" in options2)) {
      if (options2.filters !== void 0) {
        if (DynReducerUtils.isIterable(options2.filters)) {
          filters = options2.filters;
        } else {
          throw new TypeError(`DerivedMapReducer error (DataDerivedOptions): 'filters' attribute is not iterable.`);
        }
      }
      if (options2.sort !== void 0) {
        if (typeof options2.sort === "function") {
          sort = options2.sort;
        } else if (typeof options2.sort === "object" && options2.sort !== null) {
          sort = options2.sort;
        } else {
          throw new TypeError(`DerivedMapReducer error (DataDerivedOptions): 'sort' attribute is not a function or object.`);
        }
      }
    }
    if (filters) {
      this.filters.add(...filters);
    }
    if (sort) {
      this.sort.set(sort);
    }
    this.initialize();
  }
  /**
   * Returns the internal data of this instance. Be careful!
   *
   * Note: The returned map is the same map set by the main reducer. If any changes are performed to the data
   * externally do invoke {@link IndexerAPI.update} with `true` to recalculate the index and notify all subscribers.
   *
   * @returns The internal data.
   */
  get data() {
    return this.#map[0];
  }
  /**
   * @returns Derived public API.
   */
  get derived() {
    return this.#derivedPublicAPI;
  }
  /**
   * @returns The filters adapter.
   */
  get filters() {
    return this.#filters;
  }
  /**
   * Returns the Indexer public API.
   *
   * @returns Indexer API - is also iterable.
   */
  get index() {
    return this.#indexPublicAPI;
  }
  /**
   * Returns whether this derived reducer is destroyed.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   * @returns Main data / items length or indexed length.
   */
  get length() {
    const map = this.#map[0];
    return this.#index.active ? this.index.length : map ? map.size : 0;
  }
  /**
   * @returns Gets current reversed state.
   */
  get reversed() {
    return this.#reversed;
  }
  /**
   * @returns The sort adapter.
   */
  get sort() {
    return this.#sort;
  }
  /**
   * Sets reversed state and notifies subscribers.
   *
   * @param reversed - New reversed state.
   */
  set reversed(reversed) {
    if (typeof reversed !== "boolean") {
      throw new TypeError(`DerivedMapReducer.reversed error: 'reversed' is not a boolean.`);
    }
    this.#reversed = reversed;
    this.#index.reversed = reversed;
    this.index.update(true);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    this.#destroyed = true;
    this.#map = [null];
    this.#index.update(true);
    this.#subscriptions.length = 0;
    this.#derived.destroy();
    this.#index.destroy();
    this.#filters.clear();
    this.#sort.clear();
  }
  /**
   * Provides a callback for custom derived reducers to initialize any data / custom configuration. This allows
   * child classes to avoid implementing the constructor.
   *
   * @protected
   */
  initialize() {
  }
  /**
   * Provides an iterator for data stored in DerivedMapReducer.
   *
   * @returns Generator / iterator of all data.
   */
  *[Symbol.iterator]() {
    const map = this.#map[0];
    if (this.#destroyed || map === null || map?.size === 0) {
      return;
    }
    if (this.#index.active) {
      for (const key of this.index) {
        yield map.get(key);
      }
    } else {
      if (this.reversed) {
        const values = [...map.values()];
        for (let cntr = values.length; --cntr >= 0; ) {
          yield values[cntr];
        }
      } else {
        for (const value of map.values()) {
          yield value;
        }
      }
    }
  }
  // -------------------------------------------------------------------------------------------------------------------
  /**
   * Subscribe to this DerivedMapReducer.
   *
   * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.
   *
   * @returns Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  /**
   * Updates subscribers on changes.
   */
  #updateSubscribers() {
    for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) {
      this.#subscriptions[cntr](this);
    }
  }
}
class DynMapReducer {
  #map = [null];
  #derived;
  #derivedPublicAPI;
  #filters;
  #filtersData = { filters: [] };
  #index;
  #indexPublicAPI;
  #reversed = false;
  #sort;
  #sortData = { compareFn: null };
  #subscriptions = [];
  #destroyed = false;
  /**
   * Initializes DynMapReducer. Any iterable is supported for initial data. Take note that if `data` is an array it
   * will be used as the host array and not copied. All non-array iterables otherwise create a new array / copy.
   *
   * @param [data] - Data iterable to store if array or copy otherwise.
   */
  constructor(data2) {
    let dataMap = void 0;
    let filters = void 0;
    let sort = void 0;
    if (data2 === null) {
      throw new TypeError(`DynMapReducer error: 'data' is not an object or Map.`);
    }
    if (data2 !== void 0 && typeof data2 !== "object" && !(data2 instanceof Map)) {
      throw new TypeError(`DynMapReducer error: 'data' is not an object or Map.`);
    }
    if (data2 !== void 0 && data2 instanceof Map) {
      dataMap = data2;
    } else if (data2 !== void 0 && ("data" in data2 || "filters" in data2 || "sort" in data2)) {
      if (data2.data !== void 0 && !(data2.data instanceof Map)) {
        throw new TypeError(`DynMapReducer error (DataDynMap): 'data' attribute is not a Map.`);
      }
      dataMap = data2.data;
      if (data2.filters !== void 0) {
        if (DynReducerUtils.isIterable(data2.filters)) {
          filters = data2.filters;
        } else {
          throw new TypeError(`DynMapReducer error (DataDynMap): 'filters' attribute is not iterable.`);
        }
      }
      if (data2.sort !== void 0) {
        if (typeof data2.sort === "function") {
          sort = data2.sort;
        } else if (typeof data2.sort === "object" && data2.sort !== null) {
          sort = data2.sort;
        } else {
          throw new TypeError(`DynMapReducer error (DataDynMap): 'sort' attribute is not a function or object.`);
        }
      }
    }
    if (dataMap) {
      this.#map[0] = dataMap;
    }
    this.#index = new Indexer(this.#map, this.#updateSubscribers.bind(this));
    this.#indexPublicAPI = new IndexerAPI(this.#index);
    this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);
    this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);
    this.#derived = new AdapterDerived(this.#map, this.#indexPublicAPI, DerivedMapReducer);
    this.#derivedPublicAPI = new DerivedAPI(this.#derived);
    this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);
    if (filters) {
      this.filters.add(...filters);
    }
    if (sort) {
      this.sort.set(sort);
    }
    this.initialize();
  }
  /**
   * Returns the internal data of this instance. Be careful!
   *
   * Note: When a map is set as data then that map is used as the internal data. If any changes are
   * performed to the data externally do invoke {@link AdapterIndexer.index.update} with `true` to recalculate the
   * index and notify all subscribers.
   *
   * @returns The internal data.
   */
  get data() {
    return this.#map[0];
  }
  /**
   * @returns Derived public API.
   */
  get derived() {
    return this.#derivedPublicAPI;
  }
  /**
   * @returns The filters adapter.
   */
  get filters() {
    return this.#filters;
  }
  /**
   * @returns Returns the Indexer public API.
   */
  get index() {
    return this.#indexPublicAPI;
  }
  /**
   * Returns whether this instance is destroyed.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   * Gets the main data / items length.
   *
   * @returns {number} Main data / items length.
   */
  get length() {
    const map = this.#map[0];
    return this.#index.active ? this.#indexPublicAPI.length : map ? map.size : 0;
  }
  /**
   * Gets current reversed state.
   *
   * @returns {boolean} Reversed state.
   */
  get reversed() {
    return this.#reversed;
  }
  /**
   * @returns The sort adapter.
   */
  get sort() {
    return this.#sort;
  }
  /**
   * Sets reversed state and notifies subscribers.
   *
   * @param reversed - New reversed state.
   */
  set reversed(reversed) {
    if (typeof reversed !== "boolean") {
      throw new TypeError(`DynMapReducer.reversed error: 'reversed' is not a boolean.`);
    }
    this.#reversed = reversed;
    this.#index.reversed = reversed;
    this.index.update(true);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    if (this.#destroyed) {
      return;
    }
    this.#destroyed = true;
    this.#derived.destroy();
    this.#map = [null];
    this.index.update(true);
    this.#subscriptions.length = 0;
    this.#index.destroy();
    this.#filters.clear();
    this.#sort.clear();
  }
  /**
   * Provides a callback for custom reducers to initialize any data / custom configuration. This allows
   * child classes to avoid implementing the constructor.
   *
   * @protected
   */
  initialize() {
  }
  /**
   * Removes internal data and pushes new data. This does not destroy any initial array set to internal data unless
   * `replace` is set to true.
   *
   * @param data - New data to set to internal data.
   *
   * @param replace=false - New data to set to internal data.
   */
  setData(data2, replace = false) {
    if (data2 !== null && !(data2 instanceof Map)) {
      throw new TypeError(`DynMapReducer.setData error: 'data' is not iterable.`);
    }
    if (typeof replace !== "boolean") {
      throw new TypeError(`DynMapReducer.setData error: 'replace' is not a boolean.`);
    }
    const map = this.#map[0];
    if (!(map instanceof Map) || replace) {
      this.#map[0] = data2 instanceof Map ? data2 : null;
    } else if (data2 instanceof Map && map instanceof Map) {
      const removeKeySet = new Set(map.keys());
      for (const key of data2.keys()) {
        map.set(key, data2.get(key));
        if (removeKeySet.has(key)) {
          removeKeySet.delete(key);
        }
      }
      for (const key of removeKeySet) {
        map.delete(key);
      }
    } else if (data2 === null) {
      this.#map[0] = null;
    }
    this.index.update(true);
  }
  /**
   * Add a subscriber to this DynMapReducer instance.
   *
   * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.
   *
   * @returns Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  /**
   * Updates subscribers on changes.
   */
  #updateSubscribers() {
    for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) {
      this.#subscriptions[cntr](this);
    }
  }
  /**
   * Provides an iterator for data stored in DynMapReducer.
   *
   * @returns Generator / iterator of all data.
   * @yields {T}
   */
  *[Symbol.iterator]() {
    const map = this.#map[0];
    if (this.#destroyed || map === null || map?.size === 0) {
      return;
    }
    if (this.#index.active) {
      for (const key of this.index) {
        yield map.get(key);
      }
    } else {
      if (this.reversed) {
        const values = [...map.values()];
        for (let cntr = values.length; --cntr >= 0; ) {
          yield values[cntr];
        }
      } else {
        for (const value of map.values()) {
          yield value;
        }
      }
    }
  }
}
function isSimpleDeriver(deriver) {
  return deriver.length < 2;
}
function generator(storage2) {
  function readable2(key, value, start) {
    return {
      subscribe: writable2(key, value, start).subscribe
    };
  }
  function writable2(key, value, start = noop) {
    function wrap_start(ogSet) {
      return start(function wrap_set(new_value) {
        if (storage2) {
          storage2.setItem(key, JSON.stringify(new_value));
        }
        return ogSet(new_value);
      });
    }
    if (storage2) {
      const storageValue = storage2.getItem(key);
      try {
        if (storageValue) {
          value = JSON.parse(storageValue);
        }
      } catch (err) {
      }
      storage2.setItem(key, JSON.stringify(value));
    }
    const ogStore = writable$1(value, start ? wrap_start : void 0);
    function set2(new_value) {
      if (storage2) {
        storage2.setItem(key, JSON.stringify(new_value));
      }
      ogStore.set(new_value);
    }
    function update2(fn) {
      set2(fn(get_store_value(ogStore)));
    }
    function subscribe2(run2, invalidate = noop) {
      return ogStore.subscribe(run2, invalidate);
    }
    return { set: set2, update: update2, subscribe: subscribe2 };
  }
  function derived2(key, stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single ? [stores] : stores;
    if (storage2 && storage2.getItem(key)) {
      try {
        initial_value = JSON.parse(storage2.getItem(key));
      } catch (err) {
      }
    }
    return readable2(key, initial_value, (set2) => {
      let inited = false;
      const values = [];
      let pending = 0;
      let cleanup = noop;
      const sync = () => {
        if (pending) {
          return;
        }
        cleanup();
        const input = single ? values[0] : values;
        if (isSimpleDeriver(fn)) {
          set2(fn(input));
        } else {
          const result = fn(input, set2);
          cleanup = is_function(result) ? result : noop;
        }
      };
      const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {
        values[i] = value;
        pending &= ~(1 << i);
        if (inited) {
          sync();
        }
      }, () => {
        pending |= 1 << i;
      }));
      inited = true;
      sync();
      return function stop() {
        run_all(unsubscribers);
        cleanup();
      };
    });
  }
  return {
    readable: readable2,
    writable: writable2,
    derived: derived2,
    get: get_store_value
  };
}
var storage = typeof window !== "undefined" ? window.sessionStorage : void 0;
var g = generator(storage);
var writable = g.writable;
class TJSSessionStorage {
  /**
   * @type {Map<string, import('svelte/store').Writable>}
   */
  #stores = /* @__PURE__ */ new Map();
  /**
   * Creates a new store for the given key.
   *
   * @param {string}   key - Key to lookup in stores map.
   *
   * @param {boolean}  [defaultValue] - A default value to set for the store.
   *
   * @returns {import('svelte/store').Writable} The new store.
   */
  static #createStore(key, defaultValue = void 0) {
    try {
      const value = sessionStorage.getItem(key);
      if (value !== null) {
        defaultValue = value === "undefined" ? void 0 : JSON.parse(value);
      }
    } catch (err) {
    }
    return writable(key, defaultValue);
  }
  /**
   * Gets a store from the `stores` Map or creates a new store for the key and a given default value.
   *
   * @param {string}               key - Key to lookup in stores map.
   *
   * @param {boolean}              [defaultValue] - A default value to set for the store.
   *
   * @returns {import('svelte/store').Writable} The store for the given key.
   */
  #getStore(key, defaultValue = void 0) {
    let store = this.#stores.get(key);
    if (store === void 0) {
      store = TJSSessionStorage.#createStore(key, defaultValue);
      this.#stores.set(key, store);
    }
    return store;
  }
  /**
   * Get value from the sessionStorage.
   *
   * @param {string}   key - Key to lookup in sessionStorage.
   *
   * @param {*}        [defaultValue] - A default value to return if key not present in session storage.
   *
   * @returns {*} Value from session storage or if not defined any default value provided.
   */
  getItem(key, defaultValue) {
    let value = defaultValue;
    const storageValue = sessionStorage.getItem(key);
    if (storageValue !== null) {
      try {
        value = storageValue === "undefined" ? void 0 : JSON.parse(storageValue);
      } catch (err) {
        value = defaultValue;
      }
    } else if (defaultValue !== void 0) {
      try {
        const newValue = JSON.stringify(defaultValue);
        sessionStorage.setItem(key, newValue === "undefined" ? void 0 : newValue);
      } catch (err) {
      }
    }
    return value;
  }
  /**
   * Returns the backing Svelte store for the given key; potentially sets a default value if the key
   * is not already set.
   *
   * @param {string}   key - Key to lookup in sessionStorage.
   *
   * @param {*}        [defaultValue] - A default value to return if key not present in session storage.
   *
   * @returns {import('svelte/store').Writable} The Svelte store for this key.
   */
  getStore(key, defaultValue) {
    return this.#getStore(key, defaultValue);
  }
  /**
   * Sets the value for the given key in sessionStorage.
   *
   * @param {string}   key - Key to lookup in sessionStorage.
   *
   * @param {*}        value - A value to set for this key.
   */
  setItem(key, value) {
    const store = this.#getStore(key);
    store.set(value);
  }
  /**
   * Convenience method to swap a boolean value stored in session storage.
   *
   * @param {string}   key - Key to lookup in sessionStorage.
   *
   * @param {boolean}  [defaultValue] - A default value to return if key not present in session storage.
   *
   * @returns {boolean} The boolean swap for the given key.
   */
  swapItemBoolean(key, defaultValue) {
    const store = this.#getStore(key, defaultValue);
    let currentValue = false;
    try {
      currentValue = !!JSON.parse(sessionStorage.getItem(key));
    } catch (err) {
    }
    const newValue = typeof currentValue === "boolean" ? !currentValue : false;
    store.set(newValue);
    return newValue;
  }
}
function isReadableStore(store) {
  if (store === null || store === void 0) {
    return false;
  }
  switch (typeof store) {
    case "function":
    case "object":
      return typeof store.subscribe === "function";
  }
  return false;
}
function isUpdatableStore(store) {
  if (store === null || store === void 0) {
    return false;
  }
  switch (typeof store) {
    case "function":
    case "object":
      return typeof store.subscribe === "function" && typeof store.update === "function";
  }
  return false;
}
function isWritableStore(store) {
  if (store === null || store === void 0) {
    return false;
  }
  switch (typeof store) {
    case "function":
    case "object":
      return typeof store.subscribe === "function" && typeof store.set === "function";
  }
  return false;
}
function subscribeIgnoreFirst(store, update2) {
  let firedFirst = false;
  return store.subscribe((value) => {
    if (!firedFirst) {
      firedFirst = true;
    } else {
      update2(value);
    }
  });
}
function subscribeFirstRest(store, first, update2) {
  let firedFirst = false;
  return store.subscribe((value) => {
    if (!firedFirst) {
      firedFirst = true;
      first(value);
    } else {
      update2(value);
    }
  });
}
function writableDerived(origins, derive, reflect, initial) {
  var childDerivedSetter, originValues, blockNextDerive = false;
  var reflectOldValues = reflect.length >= 2;
  var wrappedDerive = (got, set2) => {
    childDerivedSetter = set2;
    if (reflectOldValues) {
      originValues = got;
    }
    if (!blockNextDerive) {
      let returned = derive(got, set2);
      if (derive.length < 2) {
        set2(returned);
      } else {
        return returned;
      }
    }
    blockNextDerive = false;
  };
  var childDerived = derived(origins, wrappedDerive, initial);
  var singleOrigin = !Array.isArray(origins);
  function doReflect(reflecting) {
    var setWith = reflect(reflecting, originValues);
    if (singleOrigin) {
      blockNextDerive = true;
      origins.set(setWith);
    } else {
      setWith.forEach((value, i) => {
        blockNextDerive = true;
        origins[i].set(value);
      });
    }
    blockNextDerive = false;
  }
  var tryingSet = false;
  function update2(fn) {
    var isUpdated, mutatedBySubscriptions, oldValue, newValue;
    if (tryingSet) {
      newValue = fn(get_store_value(childDerived));
      childDerivedSetter(newValue);
      return;
    }
    var unsubscribe = childDerived.subscribe((value) => {
      if (!tryingSet) {
        oldValue = value;
      } else if (!isUpdated) {
        isUpdated = true;
      } else {
        mutatedBySubscriptions = true;
      }
    });
    newValue = fn(oldValue);
    tryingSet = true;
    childDerivedSetter(newValue);
    unsubscribe();
    tryingSet = false;
    if (mutatedBySubscriptions) {
      newValue = get_store_value(childDerived);
    }
    if (isUpdated) {
      doReflect(newValue);
    }
  }
  return {
    subscribe: childDerived.subscribe,
    set(value) {
      update2(() => value);
    },
    update: update2
  };
}
function propertyStore(origin, propName) {
  if (!Array.isArray(propName)) {
    return writableDerived(
      origin,
      (object) => object[propName],
      (reflecting, object) => {
        object[propName] = reflecting;
        return object;
      }
    );
  } else {
    let props = propName.concat();
    return writableDerived(
      origin,
      (value) => {
        for (let i = 0; i < props.length; ++i) {
          value = value[props[i]];
        }
        return value;
      },
      (reflecting, object) => {
        let target2 = object;
        for (let i = 0; i < props.length - 1; ++i) {
          target2 = target2[props[i]];
        }
        target2[props[props.length - 1]] = reflecting;
        return object;
      }
    );
  }
}
class EmbeddedStoreManager {
  /**
   * RegExp for detecting CRUD updates for renderContext.
   *
   * @type {RegExp}
   */
  static #renderContextRegex = /(?<action>create|delete|update)(?<sep>\.?)(?<name>\w+)/;
  /**
   * @type {Map<string, EmbeddedCollectionData>}
   */
  #name = /* @__PURE__ */ new Map();
  /**
   * @type {foundry.abstract.Document[]}
   */
  #document;
  /**
   * @type {Map<string, string>}
   */
  #collectionToDocName = /* @__PURE__ */ new Map();
  /**
   * @type {Set<string>}
   */
  #embeddedNames = /* @__PURE__ */ new Set();
  /**
   * @param {foundry.abstract.Document[]} document - The associated document holder.
   */
  constructor(document2) {
    this.#document = document2;
    this.handleDocChange();
    Object.seal(this);
  }
  /**
   * @template T
   *
   * @param {string} embeddedName -
   *
   * @param {import('@typhonjs-fvtt/svelte/store').OptionsDynMapCreate<string, T>} options -
   *
   * @returns {import('@typhonjs-fvtt/svelte/store').DynMapReducer<string, T>} DynMapReducer instance
   */
  create(embeddedName, options2) {
    const doc = this.#document[0];
    let collection = null;
    if (doc) {
      try {
        collection = doc.getEmbeddedCollection(embeddedName);
      } catch (err) {
        console.warn(`EmbeddedStoreManager.create error: No valid embedded collection for: ${embeddedName}`);
      }
    }
    let embeddedData;
    if (!this.#name.has(embeddedName)) {
      embeddedData = {
        collection,
        stores: /* @__PURE__ */ new Map()
      };
      this.#name.set(embeddedName, embeddedData);
    } else {
      embeddedData = this.#name.get(embeddedName);
    }
    let name;
    let rest = {};
    let ctor;
    if (typeof options2 === "string") {
      name = options2;
      ctor = DynMapReducer;
    } else if (typeof options2 === "function" && hasPrototype(options2, DynMapReducer)) {
      ctor = options2;
    } else if (isObject(options2)) {
      ({ name, ctor = DynMapReducer, ...rest } = options2);
    } else {
      throw new TypeError(`EmbeddedStoreManager.create error: 'options' does not conform to allowed parameters.`);
    }
    if (!hasPrototype(ctor, DynMapReducer)) {
      throw new TypeError(`EmbeddedStoreManager.create error: 'ctor' is not a 'DynMapReducer'.`);
    }
    name = name ?? ctor?.name;
    if (typeof name !== "string") {
      throw new TypeError(`EmbeddedStoreManager.create error: 'name' is not a string.`);
    }
    if (embeddedData.stores.has(name)) {
      return embeddedData.stores.get(name);
    } else {
      const storeOptions = collection ? { data: collection, ...rest } : { ...rest };
      const store = new ctor(storeOptions);
      embeddedData.stores.set(name, store);
      return store;
    }
  }
  /**
   * Destroys and removes embedded collection stores. Invoking this method with no parameters destroys all stores.
   * Invoking with an embedded name destroys all stores for that particular collection. If you provide an embedded and
   * store name just that particular store is destroyed and removed.
   *
   * @param {string}   [embeddedName] - Specific embedded collection name.
   *
   * @param {string}   [storeName] - Specific store name.
   *
   * @returns {boolean} One or more stores destroyed?
   */
  destroy(embeddedName, storeName) {
    let count = 0;
    if (embeddedName === void 0) {
      for (const embeddedData of this.#name.values()) {
        embeddedData.collection = null;
        for (const store of embeddedData.stores.values()) {
          store.destroy();
          count++;
        }
      }
      this.#name.clear();
    } else if (typeof embeddedName === "string" && storeName === void 0) {
      const embeddedData = this.#name.get(embeddedName);
      if (embeddedData) {
        embeddedData.collection = null;
        for (const store of embeddedData.stores.values()) {
          store.destroy();
          count++;
        }
      }
      this.#name.delete(embeddedName);
    } else if (typeof embeddedName === "string" && storeName === "string") {
      const embeddedData = this.#name.get(embeddedName);
      if (embeddedData) {
        const store = embeddedData.stores.get(storeName);
        if (store) {
          store.destroy();
          count++;
        }
      }
    }
    return count > 0;
  }
  /**
   * @template T
   *
   * @param {string} embeddedName -
   *
   * @param {string} storeName -
   *
   * @returns {import('@typhonjs-fvtt/svelte/store').DynMapReducer<string, T>} DynMapReducer instance.
   */
  get(embeddedName, storeName) {
    if (!this.#name.has(embeddedName)) {
      return void 0;
    }
    return this.#name.get(embeddedName).stores.get(storeName);
  }
  /**
   * Updates all existing embedded collection stores with the associated embedded collection
   */
  handleDocChange() {
    const doc = this.#document[0];
    if (doc instanceof globalThis.foundry.abstract.Document) {
      const existingEmbeddedNames = new Set(this.#name.keys());
      const embeddedNames = Object.entries(doc.constructor?.metadata?.embedded ?? []);
      this.#collectionToDocName.clear();
      this.#embeddedNames.clear();
      for (const [docName, collectionName] of embeddedNames) {
        existingEmbeddedNames.delete(docName);
        this.#embeddedNames.add(`create${docName}`);
        this.#embeddedNames.add(`delete${docName}`);
        this.#embeddedNames.add(`update${docName}`);
        this.#embeddedNames.add(`create.${collectionName}`);
        this.#embeddedNames.add(`delete.${collectionName}`);
        this.#embeddedNames.add(`update.${collectionName}`);
        this.#collectionToDocName.set(docName, docName);
        this.#collectionToDocName.set(collectionName, docName);
        let collection = null;
        try {
          collection = doc.getEmbeddedCollection(docName);
        } catch (err) {
          console.warn(`EmbeddedStoreManager.handleDocUpdate error: No valid embedded collection for: ${docName}`);
        }
        const embeddedData = this.#name.get(docName);
        if (embeddedData) {
          embeddedData.collection = collection;
          for (const store of embeddedData.stores.values()) {
            store.setData(collection, true);
          }
        }
      }
      for (const embeddedName of existingEmbeddedNames) {
        const embeddedData = this.#name.get(embeddedName);
        if (embeddedData) {
          embeddedData.collection = null;
          for (const store of embeddedData.stores.values()) {
            store.setData(null, true);
          }
        }
      }
    } else {
      this.#collectionToDocName.clear();
      this.#embeddedNames.clear();
      for (const embeddedData of this.#name.values()) {
        embeddedData.collection = null;
        for (const store of embeddedData.stores.values()) {
          store.setData(null, true);
        }
      }
    }
  }
  /**
   * Handles updates to embedded stores parsing the render context for valid embedded store types.
   *
   * On create, delete, update parse the type being modified then force index updates for the embedded type.
   *
   * @param {string}   renderContext - render context update from document.
   */
  handleUpdate(renderContext) {
    if (!this.#embeddedNames.has(renderContext)) {
      return;
    }
    const match = EmbeddedStoreManager.#renderContextRegex.exec(renderContext);
    if (match) {
      const docOrCollectionName = match.groups.name;
      const embeddedName = this.#collectionToDocName.get(docOrCollectionName);
      if (!this.#name.has(embeddedName)) {
        return;
      }
      for (const store of this.#name.get(embeddedName).stores.values()) {
        store.index.update(true);
      }
    }
  }
}
class TJSDocument {
  /**
   * @type {foundry.abstract.Document[]}
   */
  #document = [void 0];
  /**
   * @type {EmbeddedStoreManager}
   */
  #embeddedStoreManager;
  #embeddedAPI;
  /**
   * @type {string}
   */
  #uuidv4;
  /**
   * @type {TJSDocumentOptions}
   */
  #options = { delete: void 0, preDelete: void 0 };
  #subscriptions = [];
  #updateOptions;
  /**
   * @param {foundry.abstract.Document | TJSDocumentOptions}  [document] - Document to wrap or TJSDocumentOptions.
   *
   * @param {TJSDocumentOptions}      [options] - TJSDocument options.
   */
  constructor(document2, options2 = {}) {
    this.#uuidv4 = `tjs-document-${uuidv4()}`;
    if (isPlainObject(document2)) {
      this.setOptions(document2);
    } else {
      this.setOptions(options2);
      this.set(document2);
    }
  }
  /**
   * @returns {EmbeddedAPI} Embedded store manager.
   */
  get embedded() {
    if (!this.#embeddedAPI) {
      this.#embeddedStoreManager = new EmbeddedStoreManager(this.#document);
      this.#embeddedAPI = {
        create: (embeddedName, options2) => this.#embeddedStoreManager.create(embeddedName, options2),
        destroy: (embeddedName, storeName) => this.#embeddedStoreManager.destroy(embeddedName, storeName),
        get: (embeddedName, storeName) => this.#embeddedStoreManager.get(embeddedName, storeName)
      };
    }
    return this.#embeddedAPI;
  }
  /**
   * Returns the options passed on last update.
   *
   * @returns {object} Last update options.
   */
  get updateOptions() {
    return this.#updateOptions ?? {};
  }
  /**
   * Returns the UUID assigned to this store.
   *
   * @returns {string} UUID
   */
  get uuidv4() {
    return this.#uuidv4;
  }
  /**
   * Handles cleanup when the document is deleted. Invoking any optional delete function set in the constructor.
   *
   * @returns {Promise<void>}
   */
  async #deleted() {
    const doc = this.#document[0];
    if (doc instanceof globalThis.foundry.abstract.Document && !doc?.collection?.has(doc.id)) {
      delete doc?.apps[this.#uuidv4];
      this.#setDocument(void 0);
      if (typeof this.#options.preDelete === "function") {
        await this.#options.preDelete(doc);
      }
      this.#updateSubscribers(false, { action: "delete", data: void 0 });
      if (typeof this.#options.delete === "function") {
        await this.#options.delete(doc);
      }
      this.#updateOptions = void 0;
    }
  }
  /**
   * Completely removes all internal subscribers, any optional delete callback, and unregisters from the
   * ClientDocumentMixin `apps` tracking object.
   */
  destroy() {
    const doc = this.#document[0];
    if (this.#embeddedStoreManager) {
      this.#embeddedStoreManager.destroy();
      this.#embeddedStoreManager = void 0;
      this.#embeddedAPI = void 0;
    }
    if (doc instanceof globalThis.foundry.abstract.Document) {
      delete doc?.apps[this.#uuidv4];
      this.#setDocument(void 0);
    }
    this.#options.delete = void 0;
    this.#subscriptions.length = 0;
  }
  /**
   * @param {boolean}  [force] - unused - signature from Foundry render function.
   *
   * @param {object}   [options] - Options from render call; will have document update context.
   */
  #updateSubscribers(force = false, options2 = {}) {
    this.#updateOptions = options2;
    const doc = this.#document[0];
    for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) {
      this.#subscriptions[cntr](doc, options2);
    }
    if (this.#embeddedStoreManager) {
      this.#embeddedStoreManager.handleUpdate(options2.renderContext);
    }
  }
  /**
   * @returns {foundry.abstract.Document | undefined} Current document
   */
  get() {
    return this.#document[0];
  }
  /**
   * @param {foundry.abstract.Document | undefined}  document - New document to set.
   *
   * @param {object}         [options] - New document update options to set.
   */
  set(document2, options2 = {}) {
    if (this.#document[0]) {
      delete this.#document[0].apps[this.#uuidv4];
    }
    if (document2 !== void 0 && !(document2 instanceof globalThis.foundry.abstract.Document)) {
      throw new TypeError(`TJSDocument set error: 'document' is not a valid Document or undefined.`);
    }
    if (options2 === null || typeof options2 !== "object") {
      throw new TypeError(`TJSDocument set error: 'options' is not an object.`);
    }
    if (document2 instanceof globalThis.foundry.abstract.Document) {
      document2.apps[this.#uuidv4] = {
        close: this.#deleted.bind(this),
        render: this.#updateSubscribers.bind(this)
      };
    }
    this.#setDocument(document2);
    this.#updateOptions = options2;
    this.#updateSubscribers();
  }
  /**
   *
   * @param {foundry.abstract.Document | undefined} doc -
   */
  #setDocument(doc) {
    this.#document[0] = doc;
    if (this.#embeddedStoreManager) {
      this.#embeddedStoreManager.handleDocChange();
    }
  }
  /**
   * Potentially sets new document from data transfer object.
   *
   * @param {object}   data - Document transfer data.
   *
   * @param {ParseDataTransferOptions & TJSDocumentOptions}   [options] - Optional parameters.
   *
   * @returns {Promise<boolean>} Returns true if new document set from data transfer blob.
   */
  async setFromDataTransfer(data2, options2) {
    return this.setFromUUID(getUUIDFromDataTransfer(data2, options2), options2);
  }
  /**
   * Sets the document by Foundry UUID performing a lookup and setting the document if found.
   *
   * @param {string}   uuid - A Foundry UUID to lookup.
   *
   * @param {TJSDocumentOptions}   [options] - New document update options to set.
   *
   * @returns {Promise<boolean>} True if successfully set document from UUID.
   */
  async setFromUUID(uuid, options2 = {}) {
    if (typeof uuid !== "string" || uuid.length === 0) {
      return false;
    }
    try {
      const doc = await globalThis.fromUuid(uuid);
      if (doc) {
        this.set(doc, options2);
        return true;
      }
    } catch (err) {
    }
    return false;
  }
  /**
   * Sets options for this document wrapper / store.
   *
   * @param {TJSDocumentOptions}   options - Options for TJSDocument.
   */
  setOptions(options2) {
    if (!isObject(options2)) {
      throw new TypeError(`TJSDocument error: 'options' is not a plain object.`);
    }
    if (options2.delete !== void 0 && typeof options2.delete !== "function") {
      throw new TypeError(`TJSDocument error: 'delete' attribute in options is not a function.`);
    }
    if (options2.preDelete !== void 0 && typeof options2.preDelete !== "function") {
      throw new TypeError(`TJSDocument error: 'preDelete' attribute in options is not a function.`);
    }
    if (options2.delete === void 0 || typeof options2.delete === "function") {
      this.#options.delete = options2.delete;
    }
    if (options2.preDelete === void 0 || typeof options2.preDelete === "function") {
      this.#options.preDelete = options2.preDelete;
    }
  }
  /**
   * @param {function(foundry.abstract.Document, object): void} handler - Callback function that is invoked on update / changes.
   *
   * @returns {(function(): void)} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    const updateOptions = { action: "subscribe", data: void 0 };
    handler(this.#document[0], updateOptions);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
}
const storeState = writable$1(void 0);
({
  subscribe: storeState.subscribe,
  get: () => game
});
Hooks.once("ready", () => storeState.set(game));
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
function quintOut(t) {
  return --t * t * t * t * t + 1;
}
function lerp$5(start, end, amount) {
  return (1 - amount) * start + amount * end;
}
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };
function create$6() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function create$5() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone$5(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy$5(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues$5(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set$5(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity$2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert$2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply$5(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate$1(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale$5(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate$1(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len < EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX$3(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY$3(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ$3(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromTranslation$1(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation$1(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  if (len < EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation$1(out, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation$1(out, a, translation);
  return out;
}
function getTranslation$1(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity$2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target2, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target2[0], z1 = eyey - target2[1], z2 = eyez - target2[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str$5(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add$5(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract$3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
function exactEquals$5(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals$5(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul$5 = multiply$5;
var sub$3 = subtract$3;
const mat4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  add: add$5,
  adjoint,
  clone: clone$5,
  copy: copy$5,
  create: create$5,
  determinant,
  equals: equals$5,
  exactEquals: exactEquals$5,
  frob,
  fromQuat,
  fromQuat2,
  fromRotation: fromRotation$1,
  fromRotationTranslation: fromRotationTranslation$1,
  fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin,
  fromScaling,
  fromTranslation: fromTranslation$1,
  fromValues: fromValues$5,
  fromXRotation,
  fromYRotation,
  fromZRotation,
  frustum,
  getRotation,
  getScaling,
  getTranslation: getTranslation$1,
  identity: identity$2,
  invert: invert$2,
  lookAt,
  mul: mul$5,
  multiply: multiply$5,
  multiplyScalar,
  multiplyScalarAndAdd,
  ortho,
  orthoNO,
  orthoZO,
  perspective,
  perspectiveFromFieldOfView,
  perspectiveNO,
  perspectiveZO,
  rotate: rotate$1,
  rotateX: rotateX$3,
  rotateY: rotateY$3,
  rotateZ: rotateZ$3,
  scale: scale$5,
  set: set$5,
  str: str$5,
  sub: sub$3,
  subtract: subtract$3,
  targetTo,
  translate: translate$1,
  transpose
});
function create$4() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone$4(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length$4(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues$4(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy$4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set$4(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add$4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract$2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply$4(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide$2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil$2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor$2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min$2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max$2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round$2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale$4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd$2(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
function distance$2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance$2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength$4(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate$2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse$2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize$4(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
function dot$4(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross$2(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp$4(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random$3(out, scale) {
  scale = scale || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
function transformMat4$2(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3$1(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat$1(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX$2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY$2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ$2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle$1(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot$4(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero$2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str$4(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals$4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals$4(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub$2 = subtract$2;
var mul$4 = multiply$4;
var div$2 = divide$2;
var dist$2 = distance$2;
var sqrDist$2 = squaredDistance$2;
var len$4 = length$4;
var sqrLen$4 = squaredLength$4;
var forEach$2 = function() {
  var vec = create$4();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();
const vec3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  add: add$4,
  angle: angle$1,
  bezier,
  ceil: ceil$2,
  clone: clone$4,
  copy: copy$4,
  create: create$4,
  cross: cross$2,
  dist: dist$2,
  distance: distance$2,
  div: div$2,
  divide: divide$2,
  dot: dot$4,
  equals: equals$4,
  exactEquals: exactEquals$4,
  floor: floor$2,
  forEach: forEach$2,
  fromValues: fromValues$4,
  hermite,
  inverse: inverse$2,
  len: len$4,
  length: length$4,
  lerp: lerp$4,
  max: max$2,
  min: min$2,
  mul: mul$4,
  multiply: multiply$4,
  negate: negate$2,
  normalize: normalize$4,
  random: random$3,
  rotateX: rotateX$2,
  rotateY: rotateY$2,
  rotateZ: rotateZ$2,
  round: round$2,
  scale: scale$4,
  scaleAndAdd: scaleAndAdd$2,
  set: set$4,
  sqrDist: sqrDist$2,
  sqrLen: sqrLen$4,
  squaredDistance: squaredDistance$2,
  squaredLength: squaredLength$4,
  str: str$4,
  sub: sub$2,
  subtract: subtract$2,
  transformMat3: transformMat3$1,
  transformMat4: transformMat4$2,
  transformQuat: transformQuat$1,
  zero: zero$2
});
function create$3() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function normalize$3(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
(function() {
  var vec = create$3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
})();
function create$2() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
var normalize$2 = normalize$3;
(function() {
  var tmpvec3 = create$4();
  var xUnitVec3 = fromValues$4(1, 0, 0);
  var yUnitVec3 = fromValues$4(0, 1, 0);
  return function(out, a, b) {
    var dot = dot$4(a, b);
    if (dot < -0.999999) {
      cross$2(tmpvec3, xUnitVec3, a);
      if (len$4(tmpvec3) < 1e-6)
        cross$2(tmpvec3, yUnitVec3, a);
      normalize$4(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross$2(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize$2(out, out);
    }
  };
})();
(function() {
  var temp1 = create$2();
  var temp2 = create$2();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
(function() {
  var matr = create$6();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize$2(out, fromMat3(out, matr));
  };
})();
function create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
(function() {
  var vec = create();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
})();
class AnimationControl {
  /** @type {object} */
  #animationData;
  /** @type {Promise<void>} */
  #finishedPromise;
  #willFinish;
  /**
   * Defines a static empty / void animation control.
   *
   * @type {AnimationControl}
   */
  static #voidControl = new AnimationControl(null);
  /**
   * Provides a static void / undefined AnimationControl that is automatically resolved.
   *
   * @returns {AnimationControl} Void AnimationControl
   */
  static get voidControl() {
    return this.#voidControl;
  }
  /**
   * @param {object|null} [animationData] - Animation data from {@link AnimationAPI}.
   *
   * @param {boolean}     [willFinish] - Promise that tracks animation finished state.
   */
  constructor(animationData, willFinish = false) {
    this.#animationData = animationData;
    this.#willFinish = willFinish;
    if (isObject(animationData)) {
      animationData.control = this;
    }
  }
  /**
   * Get a promise that resolves when animation is finished.
   *
   * @returns {Promise<void>}
   */
  get finished() {
    if (!(this.#finishedPromise instanceof Promise)) {
      this.#finishedPromise = this.#willFinish ? new Promise((resolve) => this.#animationData.resolve = resolve) : Promise.resolve();
    }
    return this.#finishedPromise;
  }
  /**
   * Returns whether this animation is currently active / animating.
   *
   * Note: a delayed animation may not be started / active yet. Use {@link AnimationControl.isFinished} to determine
   * if an animation is actually finished.
   *
   * @returns {boolean} Animation active state.
   */
  get isActive() {
    return this.#animationData.active;
  }
  /**
   * Returns whether this animation is completely finished.
   *
   * @returns {boolean} Animation finished state.
   */
  get isFinished() {
    return this.#animationData.finished;
  }
  /**
   * Cancels the animation.
   */
  cancel() {
    const animationData = this.#animationData;
    if (animationData === null || animationData === void 0) {
      return;
    }
    animationData.cancelled = true;
  }
}
class AnimationManager {
  /**
   * @type {object[]}
   */
  static activeList = [];
  /**
   * @type {object[]}
   */
  static newList = [];
  /**
   * @type {number}
   */
  static current;
  /**
   * Add animation data.
   *
   * @param {object}   data -
   */
  static add(data2) {
    const now2 = performance.now();
    data2.start = now2 + (AnimationManager.current - now2);
    AnimationManager.newList.push(data2);
  }
  /**
   * Manage all animation
   */
  static animate() {
    const current = AnimationManager.current = performance.now();
    if (AnimationManager.activeList.length === 0 && AnimationManager.newList.length === 0) {
      globalThis.requestAnimationFrame(AnimationManager.animate);
      return;
    }
    if (AnimationManager.newList.length) {
      for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
        const data2 = AnimationManager.newList[cntr];
        if (data2.cancelled) {
          AnimationManager.newList.splice(cntr, 1);
          data2.cleanup(data2);
        }
        if (data2.active) {
          AnimationManager.newList.splice(cntr, 1);
          AnimationManager.activeList.push(data2);
        }
      }
    }
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data2 = AnimationManager.activeList[cntr];
      if (data2.cancelled || data2.el !== void 0 && !data2.el.isConnected) {
        AnimationManager.activeList.splice(cntr, 1);
        data2.cleanup(data2);
        continue;
      }
      data2.current = current - data2.start;
      if (data2.current >= data2.duration) {
        for (let dataCntr = data2.keys.length; --dataCntr >= 0; ) {
          const key = data2.keys[dataCntr];
          data2.newData[key] = data2.destination[key];
        }
        data2.position.set(data2.newData);
        AnimationManager.activeList.splice(cntr, 1);
        data2.cleanup(data2);
        continue;
      }
      const easedTime = data2.ease(data2.current / data2.duration);
      for (let dataCntr = data2.keys.length; --dataCntr >= 0; ) {
        const key = data2.keys[dataCntr];
        data2.newData[key] = data2.interpolate(data2.initial[key], data2.destination[key], easedTime);
      }
      data2.position.set(data2.newData);
    }
    globalThis.requestAnimationFrame(AnimationManager.animate);
  }
  /**
   * Cancels all animations for given Position instance.
   *
   * @param {Position} position - Position instance.
   */
  static cancel(position) {
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data2 = AnimationManager.activeList[cntr];
      if (data2.position === position) {
        AnimationManager.activeList.splice(cntr, 1);
        data2.cancelled = true;
        data2.cleanup(data2);
      }
    }
    for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
      const data2 = AnimationManager.newList[cntr];
      if (data2.position === position) {
        AnimationManager.newList.splice(cntr, 1);
        data2.cancelled = true;
        data2.cleanup(data2);
      }
    }
  }
  /**
   * Cancels all active and delayed animations.
   */
  static cancelAll() {
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data2 = AnimationManager.activeList[cntr];
      data2.cancelled = true;
      data2.cleanup(data2);
    }
    for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
      const data2 = AnimationManager.newList[cntr];
      data2.cancelled = true;
      data2.cleanup(data2);
    }
    AnimationManager.activeList.length = 0;
    AnimationManager.newList.length = 0;
  }
  /**
   * Gets all {@link AnimationControl} instances for a given Position instance.
   *
   * @param {Position} position - Position instance.
   *
   * @returns {AnimationControl[]} All scheduled AnimationControl instances for the given Position instance.
   */
  static getScheduled(position) {
    const results = [];
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data2 = AnimationManager.activeList[cntr];
      if (data2.position === position) {
        results.push(data2.control);
      }
    }
    for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
      const data2 = AnimationManager.newList[cntr];
      if (data2.position === position) {
        results.push(data2.control);
      }
    }
    return results;
  }
}
AnimationManager.animate();
const animateKeys = /* @__PURE__ */ new Set([
  // Main keys
  "left",
  "top",
  "maxWidth",
  "maxHeight",
  "minWidth",
  "minHeight",
  "width",
  "height",
  "rotateX",
  "rotateY",
  "rotateZ",
  "scale",
  "translateX",
  "translateY",
  "translateZ",
  "zIndex",
  // Aliases
  "rotation"
]);
const transformKeys = ["rotateX", "rotateY", "rotateZ", "scale", "translateX", "translateY", "translateZ"];
Object.freeze(transformKeys);
const relativeRegex = /^([-+*])=(-?[\d]*\.?[\d]+)$/;
const numericDefaults = {
  // Other keys
  height: 0,
  left: 0,
  maxHeight: null,
  maxWidth: null,
  minHeight: null,
  minWidth: null,
  top: 0,
  transformOrigin: null,
  width: 0,
  zIndex: null,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  scale: 1,
  translateX: 0,
  translateY: 0,
  translateZ: 0,
  rotation: 0
};
Object.freeze(numericDefaults);
function setNumericDefaults(data2) {
  if (data2.rotateX === null) {
    data2.rotateX = 0;
  }
  if (data2.rotateY === null) {
    data2.rotateY = 0;
  }
  if (data2.rotateZ === null) {
    data2.rotateZ = 0;
  }
  if (data2.translateX === null) {
    data2.translateX = 0;
  }
  if (data2.translateY === null) {
    data2.translateY = 0;
  }
  if (data2.translateZ === null) {
    data2.translateZ = 0;
  }
  if (data2.scale === null) {
    data2.scale = 1;
  }
  if (data2.rotation === null) {
    data2.rotation = 0;
  }
}
const transformKeysBitwise = {
  rotateX: 1,
  rotateY: 2,
  rotateZ: 4,
  scale: 8,
  translateX: 16,
  translateY: 32,
  translateZ: 64
};
Object.freeze(transformKeysBitwise);
const transformOriginDefault = "top left";
const transformOrigins = [
  "top left",
  "top center",
  "top right",
  "center left",
  "center",
  "center right",
  "bottom left",
  "bottom center",
  "bottom right"
];
Object.freeze(transformOrigins);
function convertRelative(positionData, position) {
  for (const key in positionData) {
    if (animateKeys.has(key)) {
      const value = positionData[key];
      if (typeof value !== "string") {
        continue;
      }
      if (value === "auto" || value === "inherit") {
        continue;
      }
      const regexResults = relativeRegex.exec(value);
      if (!regexResults) {
        throw new Error(
          `convertRelative error: malformed relative key (${key}) with value (${value})`
        );
      }
      const current = position[key];
      switch (regexResults[1]) {
        case "-":
          positionData[key] = current - parseFloat(regexResults[2]);
          break;
        case "+":
          positionData[key] = current + parseFloat(regexResults[2]);
          break;
        case "*":
          positionData[key] = current * parseFloat(regexResults[2]);
          break;
      }
    }
  }
}
class AnimationAPI {
  /** @type {PositionData} */
  #data;
  /** @type {Position} */
  #position;
  /**
   * Tracks the number of animation control instances that are active.
   *
   * @type {number}
   */
  #instanceCount = 0;
  /**
   * Provides a bound function to pass as data to AnimationManager to invoke
   *
   * @type {Function}
   * @see {AnimationAPI.#cleanupInstance}
   */
  #cleanup;
  constructor(position, data2) {
    this.#position = position;
    this.#data = data2;
    this.#cleanup = this.#cleanupInstance.bind(this);
  }
  /**
   * Returns whether there are scheduled animations whether active or delayed for this Position.
   *
   * @returns {boolean} Are there active animation instances.
   */
  get isScheduled() {
    return this.#instanceCount > 0;
  }
  /**
   * Adds / schedules an animation w/ the AnimationManager. This contains the final steps common to all tweens.
   *
   * @param {object}      initial -
   *
   * @param {object}      destination -
   *
   * @param {number}      duration -
   *
   * @param {HTMLElement} el -
   *
   * @param {number}      delay -
   *
   * @param {Function}    ease -
   *
   * @param {Function}    interpolate -
   *
   * @returns {AnimationControl} The associated animation control.
   */
  #addAnimation(initial, destination, duration, el, delay, ease, interpolate) {
    setNumericDefaults(initial);
    setNumericDefaults(destination);
    for (const key in initial) {
      if (!Number.isFinite(initial[key])) {
        delete initial[key];
      }
    }
    const keys = Object.keys(initial);
    const newData = Object.assign({ immediateElementUpdate: true }, initial);
    if (keys.length === 0) {
      return AnimationControl.voidControl;
    }
    const animationData = {
      active: true,
      cleanup: this.#cleanup,
      cancelled: false,
      control: void 0,
      current: 0,
      destination,
      duration: duration * 1e3,
      // Internally the AnimationManager works in ms.
      ease,
      el,
      finished: false,
      initial,
      interpolate,
      keys,
      newData,
      position: this.#position,
      resolve: void 0,
      start: void 0
    };
    if (delay > 0) {
      animationData.active = false;
      setTimeout(() => {
        if (!animationData.cancelled) {
          animationData.active = true;
          const now2 = performance.now();
          animationData.start = now2 + (AnimationManager.current - now2);
        }
      }, delay * 1e3);
    }
    this.#instanceCount++;
    AnimationManager.add(animationData);
    return new AnimationControl(animationData, true);
  }
  /**
   * Cancels all animation instances for this Position instance.
   */
  cancel() {
    AnimationManager.cancel(this.#position);
  }
  /**
   * Cleans up an animation instance.
   *
   * @param {object}   data - Animation data for an animation instance.
   */
  #cleanupInstance(data2) {
    this.#instanceCount--;
    data2.active = false;
    data2.finished = true;
    if (typeof data2.resolve === "function") {
      data2.resolve(data2.cancelled);
    }
  }
  /**
   * Returns all currently scheduled AnimationControl instances for this Position instance.
   *
   * @returns {AnimationControl[]} All currently scheduled animation controls for this Position instance.
   */
  getScheduled() {
    return AnimationManager.getScheduled(this.#position);
  }
  /**
   * Provides a tween from given position data to the current position.
   *
   * @param {PositionDataExtended} fromData - The starting position.
   *
   * @param {object}         [opts] - Optional parameters.
   *
   * @param {number}         [opts.delay=0] - Delay in seconds before animation starts.
   *
   * @param {number}         [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}       [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}       [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {AnimationControl}  A control object that can cancel animation and provides a `finished` Promise.
   */
  from(fromData, { delay = 0, duration = 1, ease = cubicOut, interpolate = lerp$5 } = {}) {
    if (!isObject(fromData)) {
      throw new TypeError(`AnimationAPI.from error: 'fromData' is not an object.`);
    }
    const position = this.#position;
    const parent = position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return AnimationControl.voidControl;
    }
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationAPI.from error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.from error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.from error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.from error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data2 = this.#data;
    for (const key in fromData) {
      if (data2[key] !== void 0 && fromData[key] !== data2[key]) {
        initial[key] = fromData[key];
        destination[key] = data2[key];
      }
    }
    convertRelative(initial, data2);
    return this.#addAnimation(initial, destination, duration, el, delay, ease, interpolate);
  }
  /**
   * Provides a tween from given position data to the current position.
   *
   * @param {PositionDataExtended} fromData - The starting position.
   *
   * @param {PositionDataExtended} toData - The ending position.
   *
   * @param {object}         [opts] - Optional parameters.
   *
   * @param {number}         [opts.delay=0] - Delay in seconds before animation starts.
   *
   * @param {number}         [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}       [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}       [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {AnimationControl}  A control object that can cancel animation and provides a `finished` Promise.
   */
  fromTo(fromData, toData, { delay = 0, duration = 1, ease = cubicOut, interpolate = lerp$5 } = {}) {
    if (!isObject(fromData)) {
      throw new TypeError(`AnimationAPI.fromTo error: 'fromData' is not an object.`);
    }
    if (!isObject(toData)) {
      throw new TypeError(`AnimationAPI.fromTo error: 'toData' is not an object.`);
    }
    const parent = this.#position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return AnimationControl.voidControl;
    }
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationAPI.fromTo error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.fromTo error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.fromTo error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.fromTo error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data2 = this.#data;
    for (const key in fromData) {
      if (toData[key] === void 0) {
        console.warn(
          `AnimationAPI.fromTo warning: key ('${key}') from 'fromData' missing in 'toData'; skipping this key.`
        );
        continue;
      }
      if (data2[key] !== void 0) {
        initial[key] = fromData[key];
        destination[key] = toData[key];
      }
    }
    convertRelative(initial, data2);
    convertRelative(destination, data2);
    return this.#addAnimation(initial, destination, duration, el, delay, ease, interpolate);
  }
  /**
   * Provides a tween to given position data from the current position.
   *
   * @param {PositionDataExtended} toData - The destination position.
   *
   * @param {object}         [opts] - Optional parameters.
   *
   * @param {number}         [opts.delay=0] - Delay in seconds before animation starts.
   *
   * @param {number}         [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}       [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}       [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {AnimationControl}  A control object that can cancel animation and provides a `finished` Promise.
   */
  to(toData, { delay = 0, duration = 1, ease = cubicOut, interpolate = lerp$5 } = {}) {
    if (!isObject(toData)) {
      throw new TypeError(`AnimationAPI.to error: 'toData' is not an object.`);
    }
    const parent = this.#position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return AnimationControl.voidControl;
    }
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationAPI.to error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.to error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.to error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.to error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data2 = this.#data;
    for (const key in toData) {
      if (data2[key] !== void 0 && toData[key] !== data2[key]) {
        destination[key] = toData[key];
        initial[key] = data2[key];
      }
    }
    convertRelative(destination, data2);
    return this.#addAnimation(initial, destination, duration, el, delay, ease, interpolate);
  }
  /**
   * Returns a function that provides an optimized way to constantly update a to-tween.
   *
   * @param {Iterable<string>}  keys - The keys for quickTo.
   *
   * @param {object}            [opts] - Optional parameters.
   *
   * @param {number}            [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}          [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}          [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {quickToCallback} quick-to tween function.
   */
  quickTo(keys, { duration = 1, ease = cubicOut, interpolate = lerp$5 } = {}) {
    if (!isIterable(keys)) {
      throw new TypeError(`AnimationAPI.quickTo error: 'keys' is not an iterable list.`);
    }
    const parent = this.#position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      throw new Error(`AnimationAPI.quickTo error: 'parent' is not positionable.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.quickTo error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.quickTo error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.quickTo error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data2 = this.#data;
    for (const key of keys) {
      if (typeof key !== "string") {
        throw new TypeError(`AnimationAPI.quickTo error: key is not a string.`);
      }
      if (!animateKeys.has(key)) {
        throw new Error(`AnimationAPI.quickTo error: key ('${key}') is not animatable.`);
      }
      if (data2[key] !== void 0) {
        destination[key] = data2[key];
        initial[key] = data2[key];
      }
    }
    const keysArray = [...keys];
    Object.freeze(keysArray);
    const newData = Object.assign({ immediateElementUpdate: true }, initial);
    const animationData = {
      active: true,
      cleanup: this.#cleanup,
      cancelled: false,
      control: void 0,
      current: 0,
      destination,
      duration: duration * 1e3,
      // Internally the AnimationManager works in ms.
      ease,
      el: void 0,
      finished: true,
      // Note: start in finished state to add to AnimationManager on first callback.
      initial,
      interpolate,
      keys,
      newData,
      position: this.#position,
      resolve: void 0,
      start: void 0
    };
    const quickToCB = (...args) => {
      const argsLength = args.length;
      if (argsLength === 0) {
        return;
      }
      for (let cntr = keysArray.length; --cntr >= 0; ) {
        const key = keysArray[cntr];
        if (data2[key] !== void 0) {
          initial[key] = data2[key];
        }
      }
      if (isObject(args[0])) {
        const objData = args[0];
        for (const key in objData) {
          if (destination[key] !== void 0) {
            destination[key] = objData[key];
          }
        }
      } else {
        for (let cntr = 0; cntr < argsLength && cntr < keysArray.length; cntr++) {
          const key = keysArray[cntr];
          if (destination[key] !== void 0) {
            destination[key] = args[cntr];
          }
        }
      }
      convertRelative(destination, data2);
      setNumericDefaults(initial);
      setNumericDefaults(destination);
      const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
      animationData.el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
      if (animationData.finished) {
        animationData.finished = false;
        animationData.active = true;
        animationData.current = 0;
        this.#instanceCount++;
        AnimationManager.add(animationData);
      } else {
        const now2 = performance.now();
        animationData.start = now2 + (AnimationManager.current - now2);
        animationData.current = 0;
      }
    };
    quickToCB.keys = keysArray;
    quickToCB.options = ({ duration: duration2, ease: ease2, interpolate: interpolate2 } = {}) => {
      if (duration2 !== void 0 && (!Number.isFinite(duration2) || duration2 < 0)) {
        throw new TypeError(`AnimationAPI.quickTo.options error: 'duration' is not a positive number.`);
      }
      if (ease2 !== void 0 && typeof ease2 !== "function") {
        throw new TypeError(`AnimationAPI.quickTo.options error: 'ease' is not a function.`);
      }
      if (interpolate2 !== void 0 && typeof interpolate2 !== "function") {
        throw new TypeError(`AnimationAPI.quickTo.options error: 'interpolate' is not a function.`);
      }
      if (duration2 >= 0) {
        animationData.duration = duration2 * 1e3;
      }
      if (ease2) {
        animationData.ease = ease2;
      }
      if (interpolate2) {
        animationData.interpolate = interpolate2;
      }
      return quickToCB;
    };
    return quickToCB;
  }
}
class AnimationGroupControl {
  /** @type {AnimationControl[]} */
  #animationControls;
  /** @type {Promise<Awaited<unknown>[]>} */
  #finishedPromise;
  /**
   * Defines a static empty / void animation control.
   *
   * @type {AnimationGroupControl}
   */
  static #voidControl = new AnimationGroupControl(null);
  /**
   * Provides a static void / undefined AnimationGroupControl that is automatically resolved.
   *
   * @returns {AnimationGroupControl} Void AnimationGroupControl
   */
  static get voidControl() {
    return this.#voidControl;
  }
  /**
   * @param {AnimationControl[]} animationControls - An array of AnimationControl instances.
   */
  constructor(animationControls) {
    this.#animationControls = animationControls;
  }
  /**
   * Get a promise that resolves when all animations are finished.
   *
   * @returns {Promise<Awaited<unknown>[]>|Promise<void>} Finished Promise for all animations.
   */
  get finished() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return Promise.resolve();
    }
    if (!(this.#finishedPromise instanceof Promise)) {
      const promises = [];
      for (let cntr = animationControls.length; --cntr >= 0; ) {
        promises.push(animationControls[cntr].finished);
      }
      this.#finishedPromise = Promise.all(promises);
    }
    return this.#finishedPromise;
  }
  /**
   * Returns whether there are active animation instances for this group.
   *
   * Note: a delayed animation may not be started / active yet. Use {@link AnimationGroupControl.isFinished} to
   * determine if all animations in the group are finished.
   *
   * @returns {boolean} Are there active animation instances.
   */
  get isActive() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return false;
    }
    for (let cntr = animationControls.length; --cntr >= 0; ) {
      if (animationControls[cntr].isActive) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns whether all animations in the group are finished.
   *
   * @returns {boolean} Are all animation instances finished.
   */
  get isFinished() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return true;
    }
    for (let cntr = animationControls.length; --cntr >= 0; ) {
      if (!animationControls[cntr].isFinished) {
        return false;
      }
    }
    return false;
  }
  /**
   * Cancels the all animations.
   */
  cancel() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return;
    }
    for (let cntr = this.#animationControls.length; --cntr >= 0; ) {
      this.#animationControls[cntr].cancel();
    }
  }
}
class AnimationGroupAPI {
  /**
   * Checks of the given object is a Position instance by checking for AnimationAPI.
   *
   * @param {*}  object - Any data.
   *
   * @returns {boolean} Is Position.
   */
  static #isPosition(object) {
    return isObject(object) && object.animate instanceof AnimationAPI;
  }
  /**
   * Cancels any animation for given Position data.
   *
   * @param {Position|{position: Position}|Iterable<Position>|Iterable<{position: Position}>} position -
   */
  static cancel(position) {
    if (isIterable(position)) {
      let index = -1;
      for (const entry of position) {
        index++;
        const actualPosition = this.#isPosition(entry) ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.cancel warning: No Position instance found at index: ${index}.`);
          continue;
        }
        AnimationManager.cancel(actualPosition);
      }
    } else {
      const actualPosition = this.#isPosition(position) ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.cancel warning: No Position instance found.`);
        return;
      }
      AnimationManager.cancel(actualPosition);
    }
  }
  /**
   * Cancels all Position animation.
   */
  static cancelAll() {
    AnimationManager.cancelAll();
  }
  /**
   * Gets all animation controls for the given position data.
   *
   * @param {Position|{position: Position}|Iterable<Position>|Iterable<{position: Position}>} position -
   *
   * @returns {{position: Position, data: object|void, controls: AnimationControl[]}[]} Results array.
   */
  static getScheduled(position) {
    const results = [];
    if (isIterable(position)) {
      let index = -1;
      for (const entry of position) {
        index++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.getScheduled warning: No Position instance found at index: ${index}.`);
          continue;
        }
        const controls = AnimationManager.getScheduled(actualPosition);
        results.push({ position: actualPosition, data: isPosition ? void 0 : entry, controls });
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.getScheduled warning: No Position instance found.`);
        return results;
      }
      const controls = AnimationManager.getScheduled(actualPosition);
      results.push({ position: actualPosition, data: isPosition ? void 0 : position, controls });
    }
    return results;
  }
  /**
   * Provides the `from` animation tween for one or more Position instances as a group.
   *
   * @param {Position|{position: Position}|Iterable<Position>|Iterable<{position: Position}>} position -
   *
   * @param {object|Function}   fromData -
   *
   * @param {object|Function}   options -
   *
   * @returns {TJSBasicAnimation} Basic animation control.
   */
  static from(position, fromData, options2) {
    if (!isObject(fromData) && typeof fromData !== "function") {
      throw new TypeError(`AnimationGroupAPI.from error: 'fromData' is not an object or function.`);
    }
    if (options2 !== void 0 && !isObject(options2) && typeof options2 !== "function") {
      throw new TypeError(`AnimationGroupAPI.from error: 'options' is not an object or function.`);
    }
    const animationControls = [];
    let index = -1;
    let callbackOptions;
    const hasDataCallback = typeof fromData === "function";
    const hasOptionCallback = typeof options2 === "function";
    const hasCallback = hasDataCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index, position: void 0, data: void 0 };
    }
    let actualFromData = fromData;
    let actualOptions = options2;
    if (isIterable(position)) {
      for (const entry of position) {
        index++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.from warning: No Position instance found at index: ${index}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : entry;
        }
        if (hasDataCallback) {
          actualFromData = fromData(callbackOptions);
          if (actualFromData === null || actualFromData === void 0) {
            continue;
          }
          if (typeof actualFromData !== "object") {
            throw new TypeError(`AnimationGroupAPI.from error: fromData callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options2(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (typeof actualOptions !== "object") {
            throw new TypeError(`AnimationGroupAPI.from error: options callback function iteration(${index}) failed to return an object.`);
          }
        }
        animationControls.push(actualPosition.animate.from(actualFromData, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.from warning: No Position instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : position;
      }
      if (hasDataCallback) {
        actualFromData = fromData(callbackOptions);
        if (typeof actualFromData !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.from error: fromData callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options2(callbackOptions);
        if (typeof actualOptions !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.from error: options callback function failed to return an object.`
          );
        }
      }
      animationControls.push(actualPosition.animate.from(actualFromData, actualOptions));
    }
    return new AnimationGroupControl(animationControls);
  }
  /**
   * Provides the `fromTo` animation tween for one or more Position instances as a group.
   *
   * @param {Position|{position: Position}|Iterable<Position>|Iterable<{position: Position}>} position -
   *
   * @param {object|Function}   fromData -
   *
   * @param {object|Function}   toData -
   *
   * @param {object|Function}   options -
   *
   * @returns {TJSBasicAnimation} Basic animation control.
   */
  static fromTo(position, fromData, toData, options2) {
    if (!isObject(fromData) && typeof fromData !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'fromData' is not an object or function.`);
    }
    if (!isObject(toData) && typeof toData !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'toData' is not an object or function.`);
    }
    if (options2 !== void 0 && !isObject(options2) && typeof options2 !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'options' is not an object or function.`);
    }
    const animationControls = [];
    let index = -1;
    let callbackOptions;
    const hasFromCallback = typeof fromData === "function";
    const hasToCallback = typeof toData === "function";
    const hasOptionCallback = typeof options2 === "function";
    const hasCallback = hasFromCallback || hasToCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index, position: void 0, data: void 0 };
    }
    let actualFromData = fromData;
    let actualToData = toData;
    let actualOptions = options2;
    if (isIterable(position)) {
      for (const entry of position) {
        index++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.fromTo warning: No Position instance found at index: ${index}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : entry;
        }
        if (hasFromCallback) {
          actualFromData = fromData(callbackOptions);
          if (actualFromData === null || actualFromData === void 0) {
            continue;
          }
          if (typeof actualFromData !== "object") {
            throw new TypeError(`AnimationGroupAPI.fromTo error: fromData callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasToCallback) {
          actualToData = toData(callbackOptions);
          if (actualToData === null || actualToData === void 0) {
            continue;
          }
          if (typeof actualToData !== "object") {
            throw new TypeError(`AnimationGroupAPI.fromTo error: toData callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options2(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (typeof actualOptions !== "object") {
            throw new TypeError(`AnimationGroupAPI.fromTo error: options callback function iteration(${index}) failed to return an object.`);
          }
        }
        animationControls.push(actualPosition.animate.fromTo(actualFromData, actualToData, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.fromTo warning: No Position instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : position;
      }
      if (hasFromCallback) {
        actualFromData = fromData(callbackOptions);
        if (typeof actualFromData !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: fromData callback function failed to return an object.`
          );
        }
      }
      if (hasToCallback) {
        actualToData = toData(callbackOptions);
        if (typeof actualToData !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: toData callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options2(callbackOptions);
        if (typeof actualOptions !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: options callback function failed to return an object.`
          );
        }
      }
      animationControls.push(actualPosition.animate.fromTo(actualFromData, actualToData, actualOptions));
    }
    return new AnimationGroupControl(animationControls);
  }
  /**
   * Provides the `to` animation tween for one or more Position instances as a group.
   *
   * @param {Position|{position: Position}|Iterable<Position>|Iterable<{position: Position}>} position -
   *
   * @param {object|Function}   toData -
   *
   * @param {object|Function}   options -
   *
   * @returns {TJSBasicAnimation} Basic animation control.
   */
  static to(position, toData, options2) {
    if (!isObject(toData) && typeof toData !== "function") {
      throw new TypeError(`AnimationGroupAPI.to error: 'toData' is not an object or function.`);
    }
    if (options2 !== void 0 && !isObject(options2) && typeof options2 !== "function") {
      throw new TypeError(`AnimationGroupAPI.to error: 'options' is not an object or function.`);
    }
    const animationControls = [];
    let index = -1;
    let callbackOptions;
    const hasDataCallback = typeof toData === "function";
    const hasOptionCallback = typeof options2 === "function";
    const hasCallback = hasDataCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index, position: void 0, data: void 0 };
    }
    let actualToData = toData;
    let actualOptions = options2;
    if (isIterable(position)) {
      for (const entry of position) {
        index++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.to warning: No Position instance found at index: ${index}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : entry;
        }
        if (hasDataCallback) {
          actualToData = toData(callbackOptions);
          if (actualToData === null || actualToData === void 0) {
            continue;
          }
          if (typeof actualToData !== "object") {
            throw new TypeError(`AnimationGroupAPI.to error: toData callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options2(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (typeof actualOptions !== "object") {
            throw new TypeError(`AnimationGroupAPI.to error: options callback function iteration(${index}) failed to return an object.`);
          }
        }
        animationControls.push(actualPosition.animate.to(actualToData, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.to warning: No Position instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : position;
      }
      if (hasDataCallback) {
        actualToData = toData(callbackOptions);
        if (typeof actualToData !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.to error: toData callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options2(callbackOptions);
        if (typeof actualOptions !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.to error: options callback function failed to return an object.`
          );
        }
      }
      animationControls.push(actualPosition.animate.to(actualToData, actualOptions));
    }
    return new AnimationGroupControl(animationControls);
  }
  /**
   * Provides the `to` animation tween for one or more Position instances as a group.
   *
   * @param {Position|{position: Position}|Iterable<Position>|Iterable<{position: Position}>} position -
   *
   * @param {Iterable<string>}  keys -
   *
   * @param {object|Function}   options -
   *
   * @returns {quickToCallback} Basic animation control.
   */
  static quickTo(position, keys, options2) {
    if (!isIterable(keys)) {
      throw new TypeError(`AnimationGroupAPI.quickTo error: 'keys' is not an iterable list.`);
    }
    if (options2 !== void 0 && !isObject(options2) && typeof options2 !== "function") {
      throw new TypeError(`AnimationGroupAPI.quickTo error: 'options' is not an object or function.`);
    }
    const quickToCallbacks = [];
    let index = -1;
    const hasOptionCallback = typeof options2 === "function";
    const callbackOptions = { index, position: void 0, data: void 0 };
    let actualOptions = options2;
    if (isIterable(position)) {
      for (const entry of position) {
        index++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.quickTo warning: No Position instance found at index: ${index}.`);
          continue;
        }
        callbackOptions.index = index;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : entry;
        if (hasOptionCallback) {
          actualOptions = options2(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (typeof actualOptions !== "object") {
            throw new TypeError(`AnimationGroupAPI.quickTo error: options callback function iteration(${index}) failed to return an object.`);
          }
        }
        quickToCallbacks.push(actualPosition.animate.quickTo(keys, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.quickTo warning: No Position instance found.`);
        return () => null;
      }
      callbackOptions.index = 0;
      callbackOptions.position = position;
      callbackOptions.data = isPosition ? void 0 : position;
      if (hasOptionCallback) {
        actualOptions = options2(callbackOptions);
        if (typeof actualOptions !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.quickTo error: options callback function failed to return an object.`
          );
        }
      }
      quickToCallbacks.push(actualPosition.animate.quickTo(keys, actualOptions));
    }
    const keysArray = [...keys];
    Object.freeze(keysArray);
    const quickToCB = (...args) => {
      const argsLength = args.length;
      if (argsLength === 0) {
        return;
      }
      if (typeof args[0] === "function") {
        const dataCallback = args[0];
        index = -1;
        let cntr = 0;
        if (isIterable(position)) {
          for (const entry of position) {
            index++;
            const isPosition = this.#isPosition(entry);
            const actualPosition = isPosition ? entry : entry.position;
            if (!this.#isPosition(actualPosition)) {
              continue;
            }
            callbackOptions.index = index;
            callbackOptions.position = position;
            callbackOptions.data = isPosition ? void 0 : entry;
            const toData = dataCallback(callbackOptions);
            if (toData === null || toData === void 0) {
              continue;
            }
            const toDataIterable = isIterable(toData);
            if (!Number.isFinite(toData) && !toDataIterable && typeof toData !== "object") {
              throw new TypeError(`AnimationGroupAPI.quickTo error: toData callback function iteration(${index}) failed to return a finite number, iterable list, or object.`);
            }
            if (toDataIterable) {
              quickToCallbacks[cntr++](...toData);
            } else {
              quickToCallbacks[cntr++](toData);
            }
          }
        } else {
          const isPosition = this.#isPosition(position);
          const actualPosition = isPosition ? position : position.position;
          if (!this.#isPosition(actualPosition)) {
            return;
          }
          callbackOptions.index = 0;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : position;
          const toData = dataCallback(callbackOptions);
          if (toData === null || toData === void 0) {
            return;
          }
          const toDataIterable = isIterable(toData);
          if (!Number.isFinite(toData) && !toDataIterable && typeof toData !== "object") {
            throw new TypeError(`AnimationGroupAPI.quickTo error: toData callback function iteration(${index}) failed to return a finite number, iterable list, or object.`);
          }
          if (toDataIterable) {
            quickToCallbacks[cntr++](...toData);
          } else {
            quickToCallbacks[cntr++](toData);
          }
        }
      } else {
        for (let cntr = quickToCallbacks.length; --cntr >= 0; ) {
          quickToCallbacks[cntr](...args);
        }
      }
    };
    quickToCB.keys = keysArray;
    quickToCB.options = (options3) => {
      if (options3 !== void 0 && !isObject(options3) && typeof options3 !== "function") {
        throw new TypeError(`AnimationGroupAPI.quickTo error: 'options' is not an object or function.`);
      }
      if (isObject(options3)) {
        for (let cntr = quickToCallbacks.length; --cntr >= 0; ) {
          quickToCallbacks[cntr].options(options3);
        }
      } else if (typeof options3 === "function") {
        if (isIterable(position)) {
          index = -1;
          let cntr = 0;
          for (const entry of position) {
            index++;
            const isPosition = this.#isPosition(entry);
            const actualPosition = isPosition ? entry : entry.position;
            if (!this.#isPosition(actualPosition)) {
              console.warn(
                `AnimationGroupAPI.quickTo.options warning: No Position instance found at index: ${index}.`
              );
              continue;
            }
            callbackOptions.index = index;
            callbackOptions.position = position;
            callbackOptions.data = isPosition ? void 0 : entry;
            actualOptions = options3(callbackOptions);
            if (actualOptions === null || actualOptions === void 0) {
              continue;
            }
            if (typeof actualOptions !== "object") {
              throw new TypeError(
                `AnimationGroupAPI.quickTo.options error: options callback function iteration(${index}) failed to return an object.`
              );
            }
            quickToCallbacks[cntr++].options(actualOptions);
          }
        } else {
          const isPosition = this.#isPosition(position);
          const actualPosition = isPosition ? position : position.position;
          if (!this.#isPosition(actualPosition)) {
            console.warn(`AnimationGroupAPI.quickTo.options warning: No Position instance found.`);
            return quickToCB;
          }
          callbackOptions.index = 0;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : position;
          actualOptions = options3(callbackOptions);
          if (typeof actualOptions !== "object") {
            throw new TypeError(
              `AnimationGroupAPI.quickTo error: options callback function failed to return an object.`
            );
          }
          quickToCallbacks[0].options(actualOptions);
        }
      }
      return quickToCB;
    };
    return quickToCB;
  }
}
class Centered {
  /**
   * @type {HTMLElement}
   */
  #element;
  /**
   * Provides a manual setting of the element height. As things go `offsetHeight` causes a browser layout and is not
   * performance oriented. If manually set this height is used instead of `offsetHeight`.
   *
   * @type {number}
   */
  #height;
  /**
   * Set from an optional value in the constructor to lock accessors preventing modification.
   */
  #lock;
  /**
   * Provides a manual setting of the element width. As things go `offsetWidth` causes a browser layout and is not
   * performance oriented. If manually set this width is used instead of `offsetWidth`.
   *
   * @type {number}
   */
  #width;
  constructor({ element: element2, lock = false, width, height } = {}) {
    this.element = element2;
    this.width = width;
    this.height = height;
    this.#lock = typeof lock === "boolean" ? lock : false;
  }
  get element() {
    return this.#element;
  }
  get height() {
    return this.#height;
  }
  get width() {
    return this.#width;
  }
  set element(element2) {
    if (this.#lock) {
      return;
    }
    if (element2 === void 0 || element2 === null || element2 instanceof HTMLElement) {
      this.#element = element2;
    } else {
      throw new TypeError(`'element' is not a HTMLElement, undefined, or null.`);
    }
  }
  set height(height) {
    if (this.#lock) {
      return;
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  set width(width) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
  }
  setDimension(width, height) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  getLeft(width) {
    const boundsWidth = this.#width ?? this.#element?.offsetWidth ?? globalThis.innerWidth;
    return (boundsWidth - width) / 2;
  }
  getTop(height) {
    const boundsHeight = this.#height ?? this.#element?.offsetHeight ?? globalThis.innerHeight;
    return (boundsHeight - height) / 2;
  }
}
const browserCentered = new Centered();
const positionInitial = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Centered,
  browserCentered
}, Symbol.toStringTag, { value: "Module" }));
class PositionChangeSet {
  constructor() {
    this.left = false;
    this.top = false;
    this.width = false;
    this.height = false;
    this.maxHeight = false;
    this.maxWidth = false;
    this.minHeight = false;
    this.minWidth = false;
    this.zIndex = false;
    this.transform = false;
    this.transformOrigin = false;
  }
  hasChange() {
    return this.left || this.top || this.width || this.height || this.maxHeight || this.maxWidth || this.minHeight || this.minWidth || this.zIndex || this.transform || this.transformOrigin;
  }
  set(value) {
    this.left = value;
    this.top = value;
    this.width = value;
    this.height = value;
    this.maxHeight = value;
    this.maxWidth = value;
    this.minHeight = value;
    this.minWidth = value;
    this.zIndex = value;
    this.transform = value;
    this.transformOrigin = value;
  }
}
class PositionData {
  constructor({
    height = null,
    left = null,
    maxHeight = null,
    maxWidth = null,
    minHeight = null,
    minWidth = null,
    rotateX = null,
    rotateY = null,
    rotateZ = null,
    scale = null,
    translateX = null,
    translateY = null,
    translateZ = null,
    top = null,
    transformOrigin = null,
    width = null,
    zIndex = null
  } = {}) {
    this.height = height;
    this.left = left;
    this.maxHeight = maxHeight;
    this.maxWidth = maxWidth;
    this.minHeight = minHeight;
    this.minWidth = minWidth;
    this.rotateX = rotateX;
    this.rotateY = rotateY;
    this.rotateZ = rotateZ;
    this.scale = scale;
    this.top = top;
    this.transformOrigin = transformOrigin;
    this.translateX = translateX;
    this.translateY = translateY;
    this.translateZ = translateZ;
    this.width = width;
    this.zIndex = zIndex;
    Object.seal(this);
  }
  /**
   * Copies given data to this instance.
   *
   * @param {PositionData}   data - Copy from this instance.
   *
   * @returns {PositionData} This instance.
   */
  copy(data2) {
    this.height = data2.height;
    this.left = data2.left;
    this.maxHeight = data2.maxHeight;
    this.maxWidth = data2.maxWidth;
    this.minHeight = data2.minHeight;
    this.minWidth = data2.minWidth;
    this.rotateX = data2.rotateX;
    this.rotateY = data2.rotateY;
    this.rotateZ = data2.rotateZ;
    this.scale = data2.scale;
    this.top = data2.top;
    this.transformOrigin = data2.transformOrigin;
    this.translateX = data2.translateX;
    this.translateY = data2.translateY;
    this.translateZ = data2.translateZ;
    this.width = data2.width;
    this.zIndex = data2.zIndex;
    return this;
  }
}
class PositionStateAPI {
  /** @type {PositionData} */
  #data;
  /**
   * @type {Map<string, PositionDataExtended>}
   */
  #dataSaved = /* @__PURE__ */ new Map();
  /** @type {Position} */
  #position;
  /** @type {Transforms} */
  #transforms;
  constructor(position, data2, transforms) {
    this.#position = position;
    this.#data = data2;
    this.#transforms = transforms;
  }
  /**
   * Returns any stored save state by name.
   *
   * @param {string}   name - Saved data set name.
   *
   * @returns {PositionDataExtended} The saved data set.
   */
  get({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`Position - getSave error: 'name' is not a string.`);
    }
    return this.#dataSaved.get(name);
  }
  /**
   * Returns any associated default data.
   *
   * @returns {PositionDataExtended} Associated default data.
   */
  getDefault() {
    return this.#dataSaved.get("#defaultData");
  }
  /**
   * Removes and returns any position state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to remove and retrieve.
   *
   * @returns {PositionDataExtended} Saved position data.
   */
  remove({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`Position - remove: 'name' is not a string.`);
    }
    const data2 = this.#dataSaved.get(name);
    this.#dataSaved.delete(name);
    return data2;
  }
  /**
   * Resets data to default values and invokes set.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.keepZIndex=false] - When true keeps current z-index.
   *
   * @param {boolean}  [opts.invokeSet=true] - When true invokes set method.
   *
   * @returns {boolean} Operation successful.
   */
  reset({ keepZIndex = false, invokeSet = true } = {}) {
    const defaultData2 = this.#dataSaved.get("#defaultData");
    if (typeof defaultData2 !== "object") {
      return false;
    }
    if (this.#position.animate.isScheduled) {
      this.#position.animate.cancel();
    }
    const zIndex = this.#position.zIndex;
    const data2 = Object.assign({}, defaultData2);
    if (keepZIndex) {
      data2.zIndex = zIndex;
    }
    this.#transforms.reset(data2);
    if (this.#position.parent?.reactive?.minimized) {
      this.#position.parent?.maximize?.({ animate: false, duration: 0 });
    }
    if (invokeSet) {
      setTimeout(() => this.#position.set(data2), 0);
    }
    return true;
  }
  /**
   * Restores a saved positional state returning the data. Several optional parameters are available
   * to control whether the restore action occurs silently (no store / inline styles updates), animates
   * to the stored data, or simply sets the stored data. Restoring via {@link AnimationAPI.to} allows
   * specification of the duration, easing, and interpolate functions along with configuring a Promise to be
   * returned if awaiting the end of the animation.
   *
   * @param {object}            params - Parameters
   *
   * @param {string}            params.name - Saved data set name.
   *
   * @param {boolean}           [params.remove=false] - Remove data set.
   *
   * @param {Iterable<string>}  [params.properties] - Specific properties to set / animate.
   *
   * @param {boolean}           [params.silent] - Set position data directly; no store or style updates.
   *
   * @param {boolean}           [params.async=false] - If animating return a Promise that resolves with any saved data.
   *
   * @param {boolean}           [params.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [params.duration=0.1] - Duration in seconds.
   *
   * @param {Function}          [params.ease=linear] - Easing function.
   *
   * @param {Function}          [params.interpolate=lerp] - Interpolation function.
   *
   * @returns {PositionDataExtended|Promise<PositionDataExtended>} Saved position data.
   */
  restore({
    name,
    remove = false,
    properties,
    silent = false,
    async = false,
    animateTo = false,
    duration = 0.1,
    ease = identity,
    interpolate = lerp$5
  }) {
    if (typeof name !== "string") {
      throw new TypeError(`Position - restore error: 'name' is not a string.`);
    }
    const dataSaved = this.#dataSaved.get(name);
    if (dataSaved) {
      if (remove) {
        this.#dataSaved.delete(name);
      }
      let data2 = dataSaved;
      if (isIterable(properties)) {
        data2 = {};
        for (const property of properties) {
          data2[property] = dataSaved[property];
        }
      }
      if (silent) {
        for (const property in data2) {
          this.#data[property] = data2[property];
        }
        return dataSaved;
      } else if (animateTo) {
        if (data2.transformOrigin !== this.#position.transformOrigin) {
          this.#position.transformOrigin = data2.transformOrigin;
        }
        if (async) {
          return this.#position.animate.to(data2, { duration, ease, interpolate }).finished.then(() => dataSaved);
        } else {
          this.#position.animate.to(data2, { duration, ease, interpolate });
        }
      } else {
        this.#position.set(data2);
      }
    }
    return dataSaved;
  }
  /**
   * Saves current position state with the opportunity to add extra data to the saved state.
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.name - name to index this saved data.
   *
   * @param {...*}     [opts.extra] - Extra data to add to saved data.
   *
   * @returns {PositionData} Current position data
   */
  save({ name, ...extra }) {
    if (typeof name !== "string") {
      throw new TypeError(`Position - save error: 'name' is not a string.`);
    }
    const data2 = this.#position.get(extra);
    this.#dataSaved.set(name, data2);
    return data2;
  }
  /**
   * Directly sets a position state.
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.name - name to index this saved data.
   *
   * @param {...*}     [opts.data] - Position data to set.
   */
  set({ name, ...data2 }) {
    if (typeof name !== "string") {
      throw new TypeError(`Position - set error: 'name' is not a string.`);
    }
    this.#dataSaved.set(name, data2);
  }
}
class StyleCache {
  constructor() {
    this.el = void 0;
    this.computed = void 0;
    this.marginLeft = void 0;
    this.marginTop = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.minHeight = void 0;
    this.minWidth = void 0;
    this.hasWillChange = false;
    this.resizeObserved = {
      contentHeight: void 0,
      contentWidth: void 0,
      offsetHeight: void 0,
      offsetWidth: void 0
    };
    const storeResizeObserved = writable$1(this.resizeObserved);
    this.stores = {
      element: writable$1(this.el),
      resizeContentHeight: propertyStore(storeResizeObserved, "contentHeight"),
      resizeContentWidth: propertyStore(storeResizeObserved, "contentWidth"),
      resizeObserved: storeResizeObserved,
      resizeOffsetHeight: propertyStore(storeResizeObserved, "offsetHeight"),
      resizeOffsetWidth: propertyStore(storeResizeObserved, "offsetWidth")
    };
  }
  /**
   * Returns the cached offsetHeight from any attached `resizeObserver` action otherwise gets the offsetHeight from
   * the element directly. The more optimized path is using `resizeObserver` as getting it from the element
   * directly is more expensive and alters the execution order of an animation frame.
   *
   * @returns {number} The element offsetHeight.
   */
  get offsetHeight() {
    if (this.el instanceof HTMLElement) {
      return this.resizeObserved.offsetHeight !== void 0 ? this.resizeObserved.offsetHeight : this.el.offsetHeight;
    }
    throw new Error(`StyleCache - get offsetHeight error: no element assigned.`);
  }
  /**
   * Returns the cached offsetWidth from any attached `resizeObserver` action otherwise gets the offsetWidth from
   * the element directly. The more optimized path is using `resizeObserver` as getting it from the element
   * directly is more expensive and alters the execution order of an animation frame.
   *
   * @returns {number} The element offsetHeight.
   */
  get offsetWidth() {
    if (this.el instanceof HTMLElement) {
      return this.resizeObserved.offsetWidth !== void 0 ? this.resizeObserved.offsetWidth : this.el.offsetWidth;
    }
    throw new Error(`StyleCache - get offsetWidth error: no element assigned.`);
  }
  /**
   * @param {HTMLElement} el -
   *
   * @returns {boolean} Does element match cached element.
   */
  hasData(el) {
    return this.el === el;
  }
  /**
   * Resets the style cache.
   */
  reset() {
    if (this.el instanceof HTMLElement && this.el.isConnected && !this.hasWillChange) {
      this.el.style.willChange = null;
    }
    this.el = void 0;
    this.computed = void 0;
    this.marginLeft = void 0;
    this.marginTop = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.minHeight = void 0;
    this.minWidth = void 0;
    this.hasWillChange = false;
    this.resizeObserved.contentHeight = void 0;
    this.resizeObserved.contentWidth = void 0;
    this.resizeObserved.offsetHeight = void 0;
    this.resizeObserved.offsetWidth = void 0;
    this.stores.element.set(void 0);
  }
  /**
   * Updates the style cache with new data from the given element.
   *
   * @param {HTMLElement} el - An HTML element.
   */
  update(el) {
    this.el = el;
    this.computed = globalThis.getComputedStyle(el);
    this.marginLeft = styleParsePixels(el.style.marginLeft) ?? styleParsePixels(this.computed.marginLeft);
    this.marginTop = styleParsePixels(el.style.marginTop) ?? styleParsePixels(this.computed.marginTop);
    this.maxHeight = styleParsePixels(el.style.maxHeight) ?? styleParsePixels(this.computed.maxHeight);
    this.maxWidth = styleParsePixels(el.style.maxWidth) ?? styleParsePixels(this.computed.maxWidth);
    this.minHeight = styleParsePixels(el.style.minHeight) ?? styleParsePixels(this.computed.minHeight);
    this.minWidth = styleParsePixels(el.style.minWidth) ?? styleParsePixels(this.computed.minWidth);
    const willChange = el.style.willChange !== "" ? el.style.willChange : this.computed.willChange;
    this.hasWillChange = willChange !== "" && willChange !== "auto";
    this.stores.element.set(el);
  }
}
class TransformData {
  constructor() {
    Object.seal(this);
  }
  /**
   * Stores the calculated bounding rectangle.
   *
   * @type {DOMRect}
   */
  #boundingRect = new DOMRect();
  /**
   * Stores the individual transformed corner points of the window in screenspace clockwise from:
   * top left -> top right -> bottom right -> bottom left.
   *
   * @type {Vector3[]}
   */
  #corners = [vec3.create(), vec3.create(), vec3.create(), vec3.create()];
  /**
   * Stores the current gl-matrix mat4 data.
   *
   * @type {Matrix4}
   */
  #mat4 = mat4.create();
  /**
   * Stores the pre & post origin translations to apply to matrix transforms.
   *
   * @type {Matrix4[]}
   */
  #originTranslations = [mat4.create(), mat4.create()];
  /**
   * @returns {DOMRect} The bounding rectangle.
   */
  get boundingRect() {
    return this.#boundingRect;
  }
  /**
   * @returns {Vector3[]} The transformed corner points as vec3 in screen space.
   */
  get corners() {
    return this.#corners;
  }
  /**
   * @returns {string} Returns the CSS style string for the transform matrix.
   */
  get css() {
    return `matrix3d(${this.mat4.join(",")})`;
  }
  /**
   * @returns {Matrix4} The transform matrix.
   */
  get mat4() {
    return this.#mat4;
  }
  /**
   * @returns {Matrix4[]} The pre / post translation matrices for origin translation.
   */
  get originTranslations() {
    return this.#originTranslations;
  }
}
class AdapterValidators {
  /** @type {boolean} */
  #enabled = true;
  /**
   * @type {ValidatorData[]}
   */
  #validatorData;
  #mapUnsubscribe = /* @__PURE__ */ new Map();
  /**
   * @returns {[AdapterValidators, ValidatorData[]]} Returns this and internal storage for validator adapter.
   */
  constructor() {
    this.#validatorData = [];
    Object.seal(this);
    return [this, this.#validatorData];
  }
  /**
   * @returns {boolean} Returns the enabled state.s
   */
  get enabled() {
    return this.#enabled;
  }
  /**
   * @returns {number} Returns the length of the validators array.
   */
  get length() {
    return this.#validatorData.length;
  }
  /**
   * @param {boolean}  enabled - Sets enabled state.
   */
  set enabled(enabled2) {
    if (typeof enabled2 !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled2;
  }
  /**
   * Provides an iterator for validators.
   *
   * @returns {Generator<ValidatorData|undefined>} Generator / iterator of validators.
   * @yields {ValidatorData}
   */
  *[Symbol.iterator]() {
    if (this.#validatorData.length === 0) {
      return;
    }
    for (const entry of this.#validatorData) {
      yield { ...entry };
    }
  }
  /**
   * @param {...(ValidatorFn|ValidatorData)}   validators -
   */
  add(...validators) {
    for (const validator of validators) {
      const validatorType = typeof validator;
      if (validatorType !== "function" && validatorType !== "object" || validator === null) {
        throw new TypeError(`AdapterValidator error: 'validator' is not a function or object.`);
      }
      let data2 = void 0;
      let subscribeFn = void 0;
      switch (validatorType) {
        case "function":
          data2 = {
            id: void 0,
            validator,
            weight: 1
          };
          subscribeFn = validator.subscribe;
          break;
        case "object":
          if (typeof validator.validator !== "function") {
            throw new TypeError(`AdapterValidator error: 'validator' attribute is not a function.`);
          }
          if (validator.weight !== void 0 && typeof validator.weight !== "number" || (validator.weight < 0 || validator.weight > 1)) {
            throw new TypeError(
              `AdapterValidator error: 'weight' attribute is not a number between '0 - 1' inclusive.`
            );
          }
          data2 = {
            id: validator.id !== void 0 ? validator.id : void 0,
            validator: validator.validator.bind(validator),
            weight: validator.weight || 1,
            instance: validator
          };
          subscribeFn = validator.validator.subscribe ?? validator.subscribe;
          break;
      }
      const index = this.#validatorData.findIndex((value) => {
        return data2.weight < value.weight;
      });
      if (index >= 0) {
        this.#validatorData.splice(index, 0, data2);
      } else {
        this.#validatorData.push(data2);
      }
      if (typeof subscribeFn === "function") {
        const unsubscribe = subscribeFn();
        if (typeof unsubscribe !== "function") {
          throw new TypeError(
            "AdapterValidator error: Filter has subscribe function, but no unsubscribe function is returned."
          );
        }
        if (this.#mapUnsubscribe.has(data2.validator)) {
          throw new Error(
            "AdapterValidator error: Filter added already has an unsubscribe function registered."
          );
        }
        this.#mapUnsubscribe.set(data2.validator, unsubscribe);
      }
    }
  }
  clear() {
    this.#validatorData.length = 0;
    for (const unsubscribe of this.#mapUnsubscribe.values()) {
      unsubscribe();
    }
    this.#mapUnsubscribe.clear();
  }
  /**
   * @param {...(ValidatorFn|ValidatorData)}   validators -
   */
  remove(...validators) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    for (const data2 of validators) {
      const actualValidator = typeof data2 === "function" ? data2 : isObject(data2) ? data2.validator : void 0;
      if (!actualValidator) {
        continue;
      }
      for (let cntr = this.#validatorData.length; --cntr >= 0; ) {
        if (this.#validatorData[cntr].validator === actualValidator) {
          this.#validatorData.splice(cntr, 1);
          let unsubscribe = void 0;
          if (typeof (unsubscribe = this.#mapUnsubscribe.get(actualValidator)) === "function") {
            unsubscribe();
            this.#mapUnsubscribe.delete(actualValidator);
          }
        }
      }
    }
  }
  /**
   * Remove validators by the provided callback. The callback takes 3 parameters: `id`, `validator`, and `weight`.
   * Any truthy value returned will remove that validator.
   *
   * @param {function(*, ValidatorFn, number): boolean} callback - Callback function to evaluate each validator
   *                                                                  entry.
   */
  removeBy(callback) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    if (typeof callback !== "function") {
      throw new TypeError(`AdapterValidator error: 'callback' is not a function.`);
    }
    this.#validatorData = this.#validatorData.filter((data2) => {
      const remove = callback.call(callback, { ...data2 });
      if (remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data2.validator)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data2.validator);
        }
      }
      return !remove;
    });
  }
  removeById(...ids) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    this.#validatorData = this.#validatorData.filter((data2) => {
      let remove = false;
      for (const id of ids) {
        remove |= data2.id === id;
      }
      if (remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data2.validator)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data2.validator);
        }
      }
      return !remove;
    });
  }
}
class BasicBounds {
  /**
   * When true constrains the min / max width or height to element.
   *
   * @type {boolean}
   */
  #constrain;
  /**
   * @type {HTMLElement}
   */
  #element;
  /**
   * When true the validator is active.
   *
   * @type {boolean}
   */
  #enabled;
  /**
   * Provides a manual setting of the element height. As things go `offsetHeight` causes a browser layout and is not
   * performance oriented. If manually set this height is used instead of `offsetHeight`.
   *
   * @type {number}
   */
  #height;
  /**
   * Set from an optional value in the constructor to lock accessors preventing modification.
   */
  #lock;
  /**
   * Provides a manual setting of the element width. As things go `offsetWidth` causes a browser layout and is not
   * performance oriented. If manually set this width is used instead of `offsetWidth`.
   *
   * @type {number}
   */
  #width;
  constructor({ constrain = true, element: element2, enabled: enabled2 = true, lock = false, width, height } = {}) {
    this.element = element2;
    this.constrain = constrain;
    this.enabled = enabled2;
    this.width = width;
    this.height = height;
    this.#lock = typeof lock === "boolean" ? lock : false;
  }
  get constrain() {
    return this.#constrain;
  }
  get element() {
    return this.#element;
  }
  get enabled() {
    return this.#enabled;
  }
  get height() {
    return this.#height;
  }
  get width() {
    return this.#width;
  }
  set constrain(constrain) {
    if (this.#lock) {
      return;
    }
    if (typeof constrain !== "boolean") {
      throw new TypeError(`'constrain' is not a boolean.`);
    }
    this.#constrain = constrain;
  }
  set element(element2) {
    if (this.#lock) {
      return;
    }
    if (element2 === void 0 || element2 === null || element2 instanceof HTMLElement) {
      this.#element = element2;
    } else {
      throw new TypeError(`'element' is not a HTMLElement, undefined, or null.`);
    }
  }
  set enabled(enabled2) {
    if (this.#lock) {
      return;
    }
    if (typeof enabled2 !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled2;
  }
  set height(height) {
    if (this.#lock) {
      return;
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  set width(width) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
  }
  setDimension(width, height) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  /**
   * Provides a validator that respects transforms in positional data constraining the position to within the target
   * elements bounds.
   *
   * @param {ValidationData}   valData - The associated validation data for position updates.
   *
   * @returns {PositionData} Potentially adjusted position data.
   */
  validator(valData) {
    if (!this.#enabled) {
      return valData.position;
    }
    const boundsWidth = this.#width ?? this.#element?.offsetWidth ?? globalThis.innerWidth;
    const boundsHeight = this.#height ?? this.#element?.offsetHeight ?? globalThis.innerHeight;
    if (typeof valData.position.width === "number") {
      const maxW = valData.maxWidth ?? (this.#constrain ? boundsWidth : Number.MAX_SAFE_INTEGER);
      valData.position.width = valData.width = Math.clamped(valData.position.width, valData.minWidth, maxW);
      if (valData.width + valData.position.left + valData.marginLeft > boundsWidth) {
        valData.position.left = boundsWidth - valData.width - valData.marginLeft;
      }
    }
    if (typeof valData.position.height === "number") {
      const maxH = valData.maxHeight ?? (this.#constrain ? boundsHeight : Number.MAX_SAFE_INTEGER);
      valData.position.height = valData.height = Math.clamped(valData.position.height, valData.minHeight, maxH);
      if (valData.height + valData.position.top + valData.marginTop > boundsHeight) {
        valData.position.top = boundsHeight - valData.height - valData.marginTop;
      }
    }
    const maxL = Math.max(boundsWidth - valData.width - valData.marginLeft, 0);
    valData.position.left = Math.round(Math.clamped(valData.position.left, 0, maxL));
    const maxT = Math.max(boundsHeight - valData.height - valData.marginTop, 0);
    valData.position.top = Math.round(Math.clamped(valData.position.top, 0, maxT));
    return valData.position;
  }
}
const s_TRANSFORM_DATA = new TransformData();
class TransformBounds {
  /**
   * When true constrains the min / max width or height to element.
   *
   * @type {boolean}
   */
  #constrain;
  /**
   * @type {HTMLElement}
   */
  #element;
  /**
   * When true the validator is active.
   *
   * @type {boolean}
   */
  #enabled;
  /**
   * Provides a manual setting of the element height. As things go `offsetHeight` causes a browser layout and is not
   * performance oriented. If manually set this height is used instead of `offsetHeight`.
   *
   * @type {number}
   */
  #height;
  /**
   * Set from an optional value in the constructor to lock accessors preventing modification.
   */
  #lock;
  /**
   * Provides a manual setting of the element width. As things go `offsetWidth` causes a browser layout and is not
   * performance oriented. If manually set this width is used instead of `offsetWidth`.
   *
   * @type {number}
   */
  #width;
  constructor({ constrain = true, element: element2, enabled: enabled2 = true, lock = false, width, height } = {}) {
    this.element = element2;
    this.constrain = constrain;
    this.enabled = enabled2;
    this.width = width;
    this.height = height;
    this.#lock = typeof lock === "boolean" ? lock : false;
  }
  get constrain() {
    return this.#constrain;
  }
  get element() {
    return this.#element;
  }
  get enabled() {
    return this.#enabled;
  }
  get height() {
    return this.#height;
  }
  get width() {
    return this.#width;
  }
  set constrain(constrain) {
    if (this.#lock) {
      return;
    }
    if (typeof constrain !== "boolean") {
      throw new TypeError(`'constrain' is not a boolean.`);
    }
    this.#constrain = constrain;
  }
  set element(element2) {
    if (this.#lock) {
      return;
    }
    if (element2 === void 0 || element2 === null || element2 instanceof HTMLElement) {
      this.#element = element2;
    } else {
      throw new TypeError(`'element' is not a HTMLElement, undefined, or null.`);
    }
  }
  set enabled(enabled2) {
    if (this.#lock) {
      return;
    }
    if (typeof enabled2 !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled2;
  }
  set height(height) {
    if (this.#lock) {
      return;
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  set width(width) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
  }
  setDimension(width, height) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  /**
   * Provides a validator that respects transforms in positional data constraining the position to within the target
   * elements bounds.
   *
   * @param {ValidationData}   valData - The associated validation data for position updates.
   *
   * @returns {PositionData} Potentially adjusted position data.
   */
  validator(valData) {
    if (!this.#enabled) {
      return valData.position;
    }
    const boundsWidth = this.#width ?? this.#element?.offsetWidth ?? globalThis.innerWidth;
    const boundsHeight = this.#height ?? this.#element?.offsetHeight ?? globalThis.innerHeight;
    if (typeof valData.position.width === "number") {
      const maxW = valData.maxWidth ?? (this.#constrain ? boundsWidth : Number.MAX_SAFE_INTEGER);
      valData.position.width = Math.clamped(valData.width, valData.minWidth, maxW);
    }
    if (typeof valData.position.height === "number") {
      const maxH = valData.maxHeight ?? (this.#constrain ? boundsHeight : Number.MAX_SAFE_INTEGER);
      valData.position.height = Math.clamped(valData.height, valData.minHeight, maxH);
    }
    const data2 = valData.transforms.getData(valData.position, s_TRANSFORM_DATA, valData);
    const initialX = data2.boundingRect.x;
    const initialY = data2.boundingRect.y;
    if (data2.boundingRect.bottom + valData.marginTop > boundsHeight) {
      data2.boundingRect.y += boundsHeight - data2.boundingRect.bottom - valData.marginTop;
    }
    if (data2.boundingRect.right + valData.marginLeft > boundsWidth) {
      data2.boundingRect.x += boundsWidth - data2.boundingRect.right - valData.marginLeft;
    }
    if (data2.boundingRect.top - valData.marginTop < 0) {
      data2.boundingRect.y += Math.abs(data2.boundingRect.top - valData.marginTop);
    }
    if (data2.boundingRect.left - valData.marginLeft < 0) {
      data2.boundingRect.x += Math.abs(data2.boundingRect.left - valData.marginLeft);
    }
    valData.position.left -= initialX - data2.boundingRect.x;
    valData.position.top -= initialY - data2.boundingRect.y;
    return valData.position;
  }
}
const basicWindow = new BasicBounds({ lock: true });
const transformWindow = new TransformBounds({ lock: true });
const positionValidators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BasicBounds,
  TransformBounds,
  basicWindow,
  transformWindow
}, Symbol.toStringTag, { value: "Module" }));
const s_SCALE_VECTOR = [1, 1, 1];
const s_TRANSLATE_VECTOR = [0, 0, 0];
const s_MAT4_RESULT = mat4.create();
const s_MAT4_TEMP = mat4.create();
const s_VEC3_TEMP = vec3.create();
class Transforms {
  /**
   * Stores the transform keys in the order added.
   *
   * @type {string[]}
   */
  #orderList = [];
  constructor() {
    this._data = {};
  }
  /**
   * @returns {boolean} Whether there are active transforms in local data.
   */
  get isActive() {
    return this.#orderList.length > 0;
  }
  /**
   * @returns {number|undefined} Any local rotateX data.
   */
  get rotateX() {
    return this._data.rotateX;
  }
  /**
   * @returns {number|undefined} Any local rotateY data.
   */
  get rotateY() {
    return this._data.rotateY;
  }
  /**
   * @returns {number|undefined} Any local rotateZ data.
   */
  get rotateZ() {
    return this._data.rotateZ;
  }
  /**
   * @returns {number|undefined} Any local rotateZ scale.
   */
  get scale() {
    return this._data.scale;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateX() {
    return this._data.translateX;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateY() {
    return this._data.translateY;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateZ() {
    return this._data.translateZ;
  }
  /**
   * Sets the local rotateX data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateX(value) {
    if (Number.isFinite(value)) {
      if (this._data.rotateX === void 0) {
        this.#orderList.push("rotateX");
      }
      this._data.rotateX = value;
    } else {
      if (this._data.rotateX !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "rotateX");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.rotateX;
    }
  }
  /**
   * Sets the local rotateY data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateY(value) {
    if (Number.isFinite(value)) {
      if (this._data.rotateY === void 0) {
        this.#orderList.push("rotateY");
      }
      this._data.rotateY = value;
    } else {
      if (this._data.rotateY !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "rotateY");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.rotateY;
    }
  }
  /**
   * Sets the local rotateZ data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateZ(value) {
    if (Number.isFinite(value)) {
      if (this._data.rotateZ === void 0) {
        this.#orderList.push("rotateZ");
      }
      this._data.rotateZ = value;
    } else {
      if (this._data.rotateZ !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "rotateZ");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.rotateZ;
    }
  }
  /**
   * Sets the local scale data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set scale(value) {
    if (Number.isFinite(value)) {
      if (this._data.scale === void 0) {
        this.#orderList.push("scale");
      }
      this._data.scale = value;
    } else {
      if (this._data.scale !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "scale");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.scale;
    }
  }
  /**
   * Sets the local translateX data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateX(value) {
    if (Number.isFinite(value)) {
      if (this._data.translateX === void 0) {
        this.#orderList.push("translateX");
      }
      this._data.translateX = value;
    } else {
      if (this._data.translateX !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "translateX");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.translateX;
    }
  }
  /**
   * Sets the local translateY data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateY(value) {
    if (Number.isFinite(value)) {
      if (this._data.translateY === void 0) {
        this.#orderList.push("translateY");
      }
      this._data.translateY = value;
    } else {
      if (this._data.translateY !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "translateY");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.translateY;
    }
  }
  /**
   * Sets the local translateZ data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateZ(value) {
    if (Number.isFinite(value)) {
      if (this._data.translateZ === void 0) {
        this.#orderList.push("translateZ");
      }
      this._data.translateZ = value;
    } else {
      if (this._data.translateZ !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "translateZ");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.translateZ;
    }
  }
  /**
   * Returns the matrix3d CSS transform for the given position / transform data.
   *
   * @param {object} [data] - Optional position data otherwise use local stored transform data.
   *
   * @returns {string} The CSS matrix3d string.
   */
  getCSS(data2 = this._data) {
    return `matrix3d(${this.getMat4(data2, s_MAT4_RESULT).join(",")})`;
  }
  /**
   * Returns the matrix3d CSS transform for the given position / transform data.
   *
   * @param {object} [data] - Optional position data otherwise use local stored transform data.
   *
   * @returns {string} The CSS matrix3d string.
   */
  getCSSOrtho(data2 = this._data) {
    return `matrix3d(${this.getMat4Ortho(data2, s_MAT4_RESULT).join(",")})`;
  }
  /**
   * Collects all data including a bounding rect, transform matrix, and points array of the given {@link PositionData}
   * instance with the applied local transform data.
   *
   * @param {PositionData} position - The position data to process.
   *
   * @param {TransformData} [output] - Optional TransformData output instance.
   *
   * @param {object} [validationData] - Optional validation data for adjustment parameters.
   *
   * @returns {TransformData} The output TransformData instance.
   */
  getData(position, output = new TransformData(), validationData = {}) {
    const valWidth = validationData.width ?? 0;
    const valHeight = validationData.height ?? 0;
    const valOffsetTop = validationData.offsetTop ?? validationData.marginTop ?? 0;
    const valOffsetLeft = validationData.offsetLeft ?? validationData.offsetLeft ?? 0;
    position.top += valOffsetTop;
    position.left += valOffsetLeft;
    const width = Number.isFinite(position.width) ? position.width : valWidth;
    const height = Number.isFinite(position.height) ? position.height : valHeight;
    const rect = output.corners;
    if (this.hasTransform(position)) {
      rect[0][0] = rect[0][1] = rect[0][2] = 0;
      rect[1][0] = width;
      rect[1][1] = rect[1][2] = 0;
      rect[2][0] = width;
      rect[2][1] = height;
      rect[2][2] = 0;
      rect[3][0] = 0;
      rect[3][1] = height;
      rect[3][2] = 0;
      const matrix = this.getMat4(position, output.mat4);
      const translate = s_GET_ORIGIN_TRANSLATION(position.transformOrigin, width, height, output.originTranslations);
      if (transformOriginDefault === position.transformOrigin) {
        vec3.transformMat4(rect[0], rect[0], matrix);
        vec3.transformMat4(rect[1], rect[1], matrix);
        vec3.transformMat4(rect[2], rect[2], matrix);
        vec3.transformMat4(rect[3], rect[3], matrix);
      } else {
        vec3.transformMat4(rect[0], rect[0], translate[0]);
        vec3.transformMat4(rect[0], rect[0], matrix);
        vec3.transformMat4(rect[0], rect[0], translate[1]);
        vec3.transformMat4(rect[1], rect[1], translate[0]);
        vec3.transformMat4(rect[1], rect[1], matrix);
        vec3.transformMat4(rect[1], rect[1], translate[1]);
        vec3.transformMat4(rect[2], rect[2], translate[0]);
        vec3.transformMat4(rect[2], rect[2], matrix);
        vec3.transformMat4(rect[2], rect[2], translate[1]);
        vec3.transformMat4(rect[3], rect[3], translate[0]);
        vec3.transformMat4(rect[3], rect[3], matrix);
        vec3.transformMat4(rect[3], rect[3], translate[1]);
      }
      rect[0][0] = position.left + rect[0][0];
      rect[0][1] = position.top + rect[0][1];
      rect[1][0] = position.left + rect[1][0];
      rect[1][1] = position.top + rect[1][1];
      rect[2][0] = position.left + rect[2][0];
      rect[2][1] = position.top + rect[2][1];
      rect[3][0] = position.left + rect[3][0];
      rect[3][1] = position.top + rect[3][1];
    } else {
      rect[0][0] = position.left;
      rect[0][1] = position.top;
      rect[1][0] = position.left + width;
      rect[1][1] = position.top;
      rect[2][0] = position.left + width;
      rect[2][1] = position.top + height;
      rect[3][0] = position.left;
      rect[3][1] = position.top + height;
      mat4.identity(output.mat4);
    }
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    for (let cntr = 4; --cntr >= 0; ) {
      if (rect[cntr][0] > maxX) {
        maxX = rect[cntr][0];
      }
      if (rect[cntr][0] < minX) {
        minX = rect[cntr][0];
      }
      if (rect[cntr][1] > maxY) {
        maxY = rect[cntr][1];
      }
      if (rect[cntr][1] < minY) {
        minY = rect[cntr][1];
      }
    }
    const boundingRect = output.boundingRect;
    boundingRect.x = minX;
    boundingRect.y = minY;
    boundingRect.width = maxX - minX;
    boundingRect.height = maxY - minY;
    position.top -= valOffsetTop;
    position.left -= valOffsetLeft;
    return output;
  }
  /**
   * Creates a transform matrix based on local data applied in order it was added.
   *
   * If no data object is provided then the source is the local transform data. If another data object is supplied
   * then the stored local transform order is applied then all remaining transform keys are applied. This allows the
   * construction of a transform matrix in advance of setting local data and is useful in collision detection.
   *
   * @param {object}   [data] - PositionData instance or local transform data.
   *
   * @param {Matrix4}  [output] - The output mat4 instance.
   *
   * @returns {Matrix4} Transform matrix.
   */
  getMat4(data2 = this._data, output = mat4.create()) {
    const matrix = mat4.identity(output);
    let seenKeys = 0;
    const orderList = this.#orderList;
    for (let cntr = 0; cntr < orderList.length; cntr++) {
      const key = orderList[cntr];
      switch (key) {
        case "rotateX":
          seenKeys |= transformKeysBitwise.rotateX;
          mat4.multiply(matrix, matrix, mat4.fromXRotation(s_MAT4_TEMP, degToRad(data2[key])));
          break;
        case "rotateY":
          seenKeys |= transformKeysBitwise.rotateY;
          mat4.multiply(matrix, matrix, mat4.fromYRotation(s_MAT4_TEMP, degToRad(data2[key])));
          break;
        case "rotateZ":
          seenKeys |= transformKeysBitwise.rotateZ;
          mat4.multiply(matrix, matrix, mat4.fromZRotation(s_MAT4_TEMP, degToRad(data2[key])));
          break;
        case "scale":
          seenKeys |= transformKeysBitwise.scale;
          s_SCALE_VECTOR[0] = s_SCALE_VECTOR[1] = data2[key];
          mat4.multiply(matrix, matrix, mat4.fromScaling(s_MAT4_TEMP, s_SCALE_VECTOR));
          break;
        case "translateX":
          seenKeys |= transformKeysBitwise.translateX;
          s_TRANSLATE_VECTOR[0] = data2.translateX;
          s_TRANSLATE_VECTOR[1] = 0;
          s_TRANSLATE_VECTOR[2] = 0;
          mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
          break;
        case "translateY":
          seenKeys |= transformKeysBitwise.translateY;
          s_TRANSLATE_VECTOR[0] = 0;
          s_TRANSLATE_VECTOR[1] = data2.translateY;
          s_TRANSLATE_VECTOR[2] = 0;
          mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
          break;
        case "translateZ":
          seenKeys |= transformKeysBitwise.translateZ;
          s_TRANSLATE_VECTOR[0] = 0;
          s_TRANSLATE_VECTOR[1] = 0;
          s_TRANSLATE_VECTOR[2] = data2.translateZ;
          mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
          break;
      }
    }
    if (data2 !== this._data) {
      for (let cntr = 0; cntr < transformKeys.length; cntr++) {
        const key = transformKeys[cntr];
        if (data2[key] === null || (seenKeys & transformKeysBitwise[key]) > 0) {
          continue;
        }
        switch (key) {
          case "rotateX":
            mat4.multiply(matrix, matrix, mat4.fromXRotation(s_MAT4_TEMP, degToRad(data2[key])));
            break;
          case "rotateY":
            mat4.multiply(matrix, matrix, mat4.fromYRotation(s_MAT4_TEMP, degToRad(data2[key])));
            break;
          case "rotateZ":
            mat4.multiply(matrix, matrix, mat4.fromZRotation(s_MAT4_TEMP, degToRad(data2[key])));
            break;
          case "scale":
            s_SCALE_VECTOR[0] = s_SCALE_VECTOR[1] = data2[key];
            mat4.multiply(matrix, matrix, mat4.fromScaling(s_MAT4_TEMP, s_SCALE_VECTOR));
            break;
          case "translateX":
            s_TRANSLATE_VECTOR[0] = data2[key];
            s_TRANSLATE_VECTOR[1] = 0;
            s_TRANSLATE_VECTOR[2] = 0;
            mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
            break;
          case "translateY":
            s_TRANSLATE_VECTOR[0] = 0;
            s_TRANSLATE_VECTOR[1] = data2[key];
            s_TRANSLATE_VECTOR[2] = 0;
            mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
            break;
          case "translateZ":
            s_TRANSLATE_VECTOR[0] = 0;
            s_TRANSLATE_VECTOR[1] = 0;
            s_TRANSLATE_VECTOR[2] = data2[key];
            mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
            break;
        }
      }
    }
    return matrix;
  }
  /**
   * Provides an orthographic enhancement to convert left / top positional data to a translate operation.
   *
   * This transform matrix takes into account that the remaining operations are , but adds any left / top attributes from passed in data to
   * translate X / Y.
   *
   * If no data object is provided then the source is the local transform data. If another data object is supplied
   * then the stored local transform order is applied then all remaining transform keys are applied. This allows the
   * construction of a transform matrix in advance of setting local data and is useful in collision detection.
   *
   * @param {object}   [data] - PositionData instance or local transform data.
   *
   * @param {Matrix4}  [output] - The output mat4 instance.
   *
   * @returns {Matrix4} Transform matrix.
   */
  getMat4Ortho(data2 = this._data, output = mat4.create()) {
    const matrix = mat4.identity(output);
    s_TRANSLATE_VECTOR[0] = (data2.left ?? 0) + (data2.translateX ?? 0);
    s_TRANSLATE_VECTOR[1] = (data2.top ?? 0) + (data2.translateY ?? 0);
    s_TRANSLATE_VECTOR[2] = data2.translateZ ?? 0;
    mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
    if (data2.scale !== null) {
      s_SCALE_VECTOR[0] = s_SCALE_VECTOR[1] = data2.scale;
      mat4.multiply(matrix, matrix, mat4.fromScaling(s_MAT4_TEMP, s_SCALE_VECTOR));
    }
    if (data2.rotateX === null && data2.rotateY === null && data2.rotateZ === null) {
      return matrix;
    }
    let seenKeys = 0;
    const orderList = this.#orderList;
    for (let cntr = 0; cntr < orderList.length; cntr++) {
      const key = orderList[cntr];
      switch (key) {
        case "rotateX":
          seenKeys |= transformKeysBitwise.rotateX;
          mat4.multiply(matrix, matrix, mat4.fromXRotation(s_MAT4_TEMP, degToRad(data2[key])));
          break;
        case "rotateY":
          seenKeys |= transformKeysBitwise.rotateY;
          mat4.multiply(matrix, matrix, mat4.fromYRotation(s_MAT4_TEMP, degToRad(data2[key])));
          break;
        case "rotateZ":
          seenKeys |= transformKeysBitwise.rotateZ;
          mat4.multiply(matrix, matrix, mat4.fromZRotation(s_MAT4_TEMP, degToRad(data2[key])));
          break;
      }
    }
    if (data2 !== this._data) {
      for (let cntr = 0; cntr < transformKeys.length; cntr++) {
        const key = transformKeys[cntr];
        if (data2[key] === null || (seenKeys & transformKeysBitwise[key]) > 0) {
          continue;
        }
        switch (key) {
          case "rotateX":
            mat4.multiply(matrix, matrix, mat4.fromXRotation(s_MAT4_TEMP, degToRad(data2[key])));
            break;
          case "rotateY":
            mat4.multiply(matrix, matrix, mat4.fromYRotation(s_MAT4_TEMP, degToRad(data2[key])));
            break;
          case "rotateZ":
            mat4.multiply(matrix, matrix, mat4.fromZRotation(s_MAT4_TEMP, degToRad(data2[key])));
            break;
        }
      }
    }
    return matrix;
  }
  /**
   * Tests an object if it contains transform keys and the values are finite numbers.
   *
   * @param {object} data - An object to test for transform data.
   *
   * @returns {boolean} Whether the given PositionData has transforms.
   */
  hasTransform(data2) {
    for (const key of transformKeys) {
      if (Number.isFinite(data2[key])) {
        return true;
      }
    }
    return false;
  }
  /**
   * Resets internal data from the given object containing valid transform keys.
   *
   * @param {object}   data - An object with transform data.
   */
  reset(data2) {
    for (const key in data2) {
      if (transformKeys.includes(key)) {
        if (Number.isFinite(data2[key])) {
          this._data[key] = data2[key];
        } else {
          const index = this.#orderList.findIndex((entry) => entry === key);
          if (index >= 0) {
            this.#orderList.splice(index, 1);
          }
          delete this._data[key];
        }
      }
    }
  }
}
function s_GET_ORIGIN_TRANSLATION(transformOrigin, width, height, output) {
  const vector = s_VEC3_TEMP;
  switch (transformOrigin) {
    case "top left":
      vector[0] = vector[1] = 0;
      mat4.fromTranslation(output[0], vector);
      mat4.fromTranslation(output[1], vector);
      break;
    case "top center":
      vector[0] = -width * 0.5;
      vector[1] = 0;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width * 0.5;
      mat4.fromTranslation(output[1], vector);
      break;
    case "top right":
      vector[0] = -width;
      vector[1] = 0;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width;
      mat4.fromTranslation(output[1], vector);
      break;
    case "center left":
      vector[0] = 0;
      vector[1] = -height * 0.5;
      mat4.fromTranslation(output[0], vector);
      vector[1] = height * 0.5;
      mat4.fromTranslation(output[1], vector);
      break;
    case null:
    case "center":
      vector[0] = -width * 0.5;
      vector[1] = -height * 0.5;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width * 0.5;
      vector[1] = height * 0.5;
      mat4.fromTranslation(output[1], vector);
      break;
    case "center right":
      vector[0] = -width;
      vector[1] = -height * 0.5;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width;
      vector[1] = height * 0.5;
      mat4.fromTranslation(output[1], vector);
      break;
    case "bottom left":
      vector[0] = 0;
      vector[1] = -height;
      mat4.fromTranslation(output[0], vector);
      vector[1] = height;
      mat4.fromTranslation(output[1], vector);
      break;
    case "bottom center":
      vector[0] = -width * 0.5;
      vector[1] = -height;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width * 0.5;
      vector[1] = height;
      mat4.fromTranslation(output[1], vector);
      break;
    case "bottom right":
      vector[0] = -width;
      vector[1] = -height;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width;
      vector[1] = height;
      mat4.fromTranslation(output[1], vector);
      break;
    default:
      mat4.identity(output[0]);
      mat4.identity(output[1]);
      break;
  }
  return output;
}
class UpdateElementData {
  constructor() {
    this.data = void 0;
    this.dataSubscribers = new PositionData();
    this.dimensionData = { width: 0, height: 0 };
    this.changeSet = void 0;
    this.options = void 0;
    this.queued = false;
    this.styleCache = void 0;
    this.transforms = void 0;
    this.transformData = new TransformData();
    this.subscriptions = void 0;
    this.storeDimension = writable$1(this.dimensionData);
    this.storeTransform = writable$1(this.transformData, () => {
      this.options.transformSubscribed = true;
      return () => this.options.transformSubscribed = false;
    });
    this.queued = false;
    Object.seal(this.dimensionData);
  }
}
function animateEvents(fn, store = void 0) {
  if (typeof fn !== "function") {
    throw new TypeError(`'fn' is not a function.`);
  }
  if (store !== void 0 && !isWritableStore(store)) {
    throw new TypeError(`'store' is not a writable store.`);
  }
  let startFired = false;
  let endFired = false;
  return (node, animations, params = {}) => {
    const animationConfig = fn(node, animations, params);
    const existingTick = animationConfig.tick;
    animationConfig.tick = (t, u) => {
      if (existingTick) {
        existingTick(t, u);
      }
      if (!startFired && t === 0) {
        if (store) {
          store.set(true);
        }
        node.dispatchEvent(new CustomEvent("animate:start", { bubbles: true }));
        startFired = true;
        endFired = false;
      }
      if (!endFired && t === 1) {
        if (store) {
          store.set(false);
        }
        node.dispatchEvent(new CustomEvent("animate:end", { bubbles: true }));
        endFired = true;
        startFired = false;
      }
    };
    return animationConfig;
  };
}
async function nextAnimationFrame(cntr = 1) {
  if (!Number.isInteger(cntr) || cntr < 1) {
    throw new TypeError(`nextAnimationFrame error: 'cntr' must be a positive integer greater than 0.`);
  }
  let currentTime = performance.now();
  for (; --cntr >= 0; ) {
    currentTime = await new Promise((resolve) => requestAnimationFrame(resolve));
  }
  return currentTime;
}
class UpdateElementManager {
  static list = [];
  static listCntr = 0;
  static updatePromise;
  static get promise() {
    return this.updatePromise;
  }
  /**
   * Potentially adds the given element and internal updateData instance to the list.
   *
   * @param {HTMLElement}       el - An HTMLElement instance.
   *
   * @param {UpdateElementData} updateData - An UpdateElementData instance.
   *
   * @returns {Promise<number>} The unified next frame update promise. Returns `currentTime`.
   */
  static add(el, updateData) {
    if (this.listCntr < this.list.length) {
      const entry = this.list[this.listCntr];
      entry[0] = el;
      entry[1] = updateData;
    } else {
      this.list.push([el, updateData]);
    }
    this.listCntr++;
    updateData.queued = true;
    if (!this.updatePromise) {
      this.updatePromise = this.wait();
    }
    return this.updatePromise;
  }
  /**
   * Await on `nextAnimationFrame` and iterate over list map invoking callback functions.
   *
   * @returns {Promise<number>} The next frame Promise / currentTime from nextAnimationFrame.
   */
  static async wait() {
    const currentTime = await nextAnimationFrame();
    this.updatePromise = void 0;
    for (let cntr = this.listCntr; --cntr >= 0; ) {
      const entry = this.list[cntr];
      const el = entry[0];
      const updateData = entry[1];
      entry[0] = void 0;
      entry[1] = void 0;
      updateData.queued = false;
      if (!el.isConnected) {
        continue;
      }
      if (updateData.options.ortho) {
        s_UPDATE_ELEMENT_ORTHO(el, updateData);
      } else {
        s_UPDATE_ELEMENT(el, updateData);
      }
      if (updateData.options.calculateTransform || updateData.options.transformSubscribed) {
        s_UPDATE_TRANSFORM(el, updateData);
      }
      this.updateSubscribers(updateData);
    }
    this.listCntr = 0;
    return currentTime;
  }
  /**
   * Potentially immediately updates the given element.
   *
   * @param {HTMLElement}       el - An HTMLElement instance.
   *
   * @param {UpdateElementData} updateData - An UpdateElementData instance.
   */
  static immediate(el, updateData) {
    if (!el.isConnected) {
      return;
    }
    if (updateData.options.ortho) {
      s_UPDATE_ELEMENT_ORTHO(el, updateData);
    } else {
      s_UPDATE_ELEMENT(el, updateData);
    }
    if (updateData.options.calculateTransform || updateData.options.transformSubscribed) {
      s_UPDATE_TRANSFORM(el, updateData);
    }
    this.updateSubscribers(updateData);
  }
  /**
   * @param {UpdateElementData} updateData - Data change set.
   */
  static updateSubscribers(updateData) {
    const data2 = updateData.data;
    const changeSet = updateData.changeSet;
    if (!changeSet.hasChange()) {
      return;
    }
    const output = updateData.dataSubscribers.copy(data2);
    const subscriptions = updateData.subscriptions;
    if (subscriptions.length > 0) {
      for (let cntr = 0; cntr < subscriptions.length; cntr++) {
        subscriptions[cntr](output);
      }
    }
    if (changeSet.width || changeSet.height) {
      updateData.dimensionData.width = data2.width;
      updateData.dimensionData.height = data2.height;
      updateData.storeDimension.set(updateData.dimensionData);
    }
    changeSet.set(false);
  }
}
function s_UPDATE_ELEMENT(el, updateData) {
  const changeSet = updateData.changeSet;
  const data2 = updateData.data;
  if (changeSet.left) {
    el.style.left = `${data2.left}px`;
  }
  if (changeSet.top) {
    el.style.top = `${data2.top}px`;
  }
  if (changeSet.zIndex) {
    el.style.zIndex = typeof data2.zIndex === "number" ? `${data2.zIndex}` : null;
  }
  if (changeSet.width) {
    el.style.width = typeof data2.width === "number" ? `${data2.width}px` : data2.width;
  }
  if (changeSet.height) {
    el.style.height = typeof data2.height === "number" ? `${data2.height}px` : data2.height;
  }
  if (changeSet.transformOrigin) {
    el.style.transformOrigin = data2.transformOrigin === "center" ? null : data2.transformOrigin;
  }
  if (changeSet.transform) {
    el.style.transform = updateData.transforms.isActive ? updateData.transforms.getCSS() : null;
  }
}
function s_UPDATE_ELEMENT_ORTHO(el, updateData) {
  const changeSet = updateData.changeSet;
  const data2 = updateData.data;
  if (changeSet.zIndex) {
    el.style.zIndex = typeof data2.zIndex === "number" ? `${data2.zIndex}` : null;
  }
  if (changeSet.width) {
    el.style.width = typeof data2.width === "number" ? `${data2.width}px` : data2.width;
  }
  if (changeSet.height) {
    el.style.height = typeof data2.height === "number" ? `${data2.height}px` : data2.height;
  }
  if (changeSet.transformOrigin) {
    el.style.transformOrigin = data2.transformOrigin === "center" ? null : data2.transformOrigin;
  }
  if (changeSet.left || changeSet.top || changeSet.transform) {
    el.style.transform = updateData.transforms.getCSSOrtho(data2);
  }
}
function s_UPDATE_TRANSFORM(el, updateData) {
  s_VALIDATION_DATA$1.height = updateData.data.height !== "auto" ? updateData.data.height : updateData.styleCache.offsetHeight;
  s_VALIDATION_DATA$1.width = updateData.data.width !== "auto" ? updateData.data.width : updateData.styleCache.offsetWidth;
  s_VALIDATION_DATA$1.marginLeft = updateData.styleCache.marginLeft;
  s_VALIDATION_DATA$1.marginTop = updateData.styleCache.marginTop;
  updateData.transforms.getData(updateData.data, updateData.transformData, s_VALIDATION_DATA$1);
  updateData.storeTransform.set(updateData.transformData);
}
const s_VALIDATION_DATA$1 = {
  height: void 0,
  width: void 0,
  marginLeft: void 0,
  marginTop: void 0
};
class Position {
  /**
   * @type {PositionData}
   */
  #data = new PositionData();
  /**
   * Provides the animation API.
   *
   * @type {AnimationAPI}
   */
  #animate = new AnimationAPI(this, this.#data);
  /**
   * Provides a way to turn on / off the position handling.
   *
   * @type {boolean}
   */
  #enabled = true;
  /**
   * Stores the style attributes that changed on update.
   *
   * @type {PositionChangeSet}
   */
  #positionChangeSet = new PositionChangeSet();
  /**
   * Stores ongoing options that are set in the constructor or by transform store subscription.
   *
   * @type {PositionOptions}
   */
  #options = {
    calculateTransform: false,
    initialHelper: void 0,
    ortho: true,
    transformSubscribed: false
  };
  /**
   * The associated parent for positional data tracking. Used in validators.
   *
   * @type {PositionParent}
   */
  #parent;
  /**
   * @type {StorePosition}
   */
  #stores;
  /**
   * Stores an instance of the computer styles for the target element.
   *
   * @type {StyleCache}
   */
  #styleCache;
  /**
   * Stores the subscribers.
   *
   * @type {(function(PositionData): void)[]}
   */
  #subscriptions = [];
  /**
   * @type {Transforms}
   */
  #transforms = new Transforms();
  /**
   * @type {UpdateElementData}
   */
  #updateElementData;
  /**
   * Stores the UpdateElementManager wait promise.
   *
   * @type {Promise}
   */
  #updateElementPromise;
  /**
   * @type {AdapterValidators}
   */
  #validators;
  /**
   * @type {ValidatorData[]}
   */
  #validatorData;
  /**
   * @type {PositionStateAPI}
   */
  #state = new PositionStateAPI(this, this.#data, this.#transforms);
  /**
   * @returns {AnimationGroupAPI} Public Animation API.
   */
  static get Animate() {
    return AnimationGroupAPI;
  }
  /**
   * @returns {{browserCentered?: Centered, Centered?: *}} Initial position helpers.
   */
  static get Initial() {
    return positionInitial;
  }
  /**
   * Returns TransformData class / constructor.
   *
   * @returns {TransformData} TransformData class / constructor.
   */
  static get TransformData() {
    return TransformData;
  }
  /**
   * Returns default validators.
   *
   * Note: `basicWindow` and `BasicBounds` will eventually be removed.
   *
   * @returns {{basicWindow?: BasicBounds, transformWindow?: TransformBounds, TransformBounds?: *, BasicBounds?: *}}
   *  Available validators.
   */
  static get Validators() {
    return positionValidators;
  }
  /**
   * Returns a duplicate of a given position instance copying any options and validators.
   *
   * // TODO: Consider more safety over options processing.
   *
   * @param {Position}          position - A position instance.
   *
   * @param {PositionOptions}   options - Position options.
   *
   * @returns {Position} A duplicate position instance.
   */
  static duplicate(position, options2) {
    if (!(position instanceof Position)) {
      throw new TypeError(`'position' is not an instance of Position.`);
    }
    const newPosition = new Position(options2);
    newPosition.#options = Object.assign({}, position.#options, options2);
    newPosition.#validators.add(...position.#validators);
    newPosition.set(position.#data);
    return newPosition;
  }
  /**
   * @param {PositionParent|PositionOptionsAll}   [parent] - A potential parent element or object w/ `elementTarget`
   *                                                      getter. May also be the PositionOptions object w/ 1 argument.
   *
   * @param {PositionOptionsAll}   [options] - Default values.
   */
  constructor(parent, options2) {
    if (isPlainObject(parent)) {
      options2 = parent;
    } else {
      this.#parent = parent;
    }
    const data2 = this.#data;
    const transforms = this.#transforms;
    this.#styleCache = new StyleCache();
    const updateData = new UpdateElementData();
    updateData.changeSet = this.#positionChangeSet;
    updateData.data = this.#data;
    updateData.options = this.#options;
    updateData.styleCache = this.#styleCache;
    updateData.subscriptions = this.#subscriptions;
    updateData.transforms = this.#transforms;
    this.#updateElementData = updateData;
    if (isObject(options2)) {
      if (typeof options2.calculateTransform === "boolean") {
        this.#options.calculateTransform = options2.calculateTransform;
      }
      if (typeof options2.ortho === "boolean") {
        this.#options.ortho = options2.ortho;
      }
      if (Number.isFinite(options2.height) || options2.height === "auto" || options2.height === "inherit" || options2.height === null) {
        data2.height = updateData.dimensionData.height = typeof options2.height === "number" ? Math.round(options2.height) : options2.height;
      }
      if (Number.isFinite(options2.left) || options2.left === null) {
        data2.left = typeof options2.left === "number" ? Math.round(options2.left) : options2.left;
      }
      if (Number.isFinite(options2.maxHeight) || options2.maxHeight === null) {
        data2.maxHeight = typeof options2.maxHeight === "number" ? Math.round(options2.maxHeight) : options2.maxHeight;
      }
      if (Number.isFinite(options2.maxWidth) || options2.maxWidth === null) {
        data2.maxWidth = typeof options2.maxWidth === "number" ? Math.round(options2.maxWidth) : options2.maxWidth;
      }
      if (Number.isFinite(options2.minHeight) || options2.minHeight === null) {
        data2.minHeight = typeof options2.minHeight === "number" ? Math.round(options2.minHeight) : options2.minHeight;
      }
      if (Number.isFinite(options2.minWidth) || options2.minWidth === null) {
        data2.minWidth = typeof options2.minWidth === "number" ? Math.round(options2.minWidth) : options2.minWidth;
      }
      if (Number.isFinite(options2.rotateX) || options2.rotateX === null) {
        transforms.rotateX = data2.rotateX = options2.rotateX;
      }
      if (Number.isFinite(options2.rotateY) || options2.rotateY === null) {
        transforms.rotateY = data2.rotateY = options2.rotateY;
      }
      if (Number.isFinite(options2.rotateZ) || options2.rotateZ === null) {
        transforms.rotateZ = data2.rotateZ = options2.rotateZ;
      }
      if (Number.isFinite(options2.scale) || options2.scale === null) {
        transforms.scale = data2.scale = options2.scale;
      }
      if (Number.isFinite(options2.top) || options2.top === null) {
        data2.top = typeof options2.top === "number" ? Math.round(options2.top) : options2.top;
      }
      if (typeof options2.transformOrigin === "string" || options2.transformOrigin === null) {
        data2.transformOrigin = transformOrigins.includes(options2.transformOrigin) ? options2.transformOrigin : null;
      }
      if (Number.isFinite(options2.translateX) || options2.translateX === null) {
        transforms.translateX = data2.translateX = options2.translateX;
      }
      if (Number.isFinite(options2.translateY) || options2.translateY === null) {
        transforms.translateY = data2.translateY = options2.translateY;
      }
      if (Number.isFinite(options2.translateZ) || options2.translateZ === null) {
        transforms.translateZ = data2.translateZ = options2.translateZ;
      }
      if (Number.isFinite(options2.width) || options2.width === "auto" || options2.width === "inherit" || options2.width === null) {
        data2.width = updateData.dimensionData.width = typeof options2.width === "number" ? Math.round(options2.width) : options2.width;
      }
      if (Number.isFinite(options2.zIndex) || options2.zIndex === null) {
        data2.zIndex = typeof options2.zIndex === "number" ? Math.round(options2.zIndex) : options2.zIndex;
      }
    }
    this.#stores = {
      // The main properties for manipulating Position.
      height: propertyStore(this, "height"),
      left: propertyStore(this, "left"),
      rotateX: propertyStore(this, "rotateX"),
      rotateY: propertyStore(this, "rotateY"),
      rotateZ: propertyStore(this, "rotateZ"),
      scale: propertyStore(this, "scale"),
      top: propertyStore(this, "top"),
      transformOrigin: propertyStore(this, "transformOrigin"),
      translateX: propertyStore(this, "translateX"),
      translateY: propertyStore(this, "translateY"),
      translateZ: propertyStore(this, "translateZ"),
      width: propertyStore(this, "width"),
      zIndex: propertyStore(this, "zIndex"),
      // Stores that control validation when width / height is not `auto`.
      maxHeight: propertyStore(this, "maxHeight"),
      maxWidth: propertyStore(this, "maxWidth"),
      minHeight: propertyStore(this, "minHeight"),
      minWidth: propertyStore(this, "minWidth"),
      // Readable stores based on updates or from resize observer changes.
      dimension: { subscribe: updateData.storeDimension.subscribe },
      element: { subscribe: this.#styleCache.stores.element.subscribe },
      resizeContentHeight: { subscribe: this.#styleCache.stores.resizeContentHeight.subscribe },
      resizeContentWidth: { subscribe: this.#styleCache.stores.resizeContentWidth.subscribe },
      resizeOffsetHeight: { subscribe: this.#styleCache.stores.resizeOffsetHeight.subscribe },
      resizeOffsetWidth: { subscribe: this.#styleCache.stores.resizeOffsetWidth.subscribe },
      transform: { subscribe: updateData.storeTransform.subscribe },
      // Protected store that should only be set by resizeObserver action.
      resizeObserved: this.#styleCache.stores.resizeObserved
    };
    subscribeIgnoreFirst(this.#stores.resizeObserved, (resizeData) => {
      const parent2 = this.#parent;
      const el = parent2 instanceof HTMLElement ? parent2 : parent2?.elementTarget;
      if (el instanceof HTMLElement && Number.isFinite(resizeData?.offsetWidth) && Number.isFinite(resizeData?.offsetHeight)) {
        this.set(data2);
      }
    });
    this.#stores.transformOrigin.values = transformOrigins;
    [this.#validators, this.#validatorData] = new AdapterValidators();
    if (options2?.initial || options2?.positionInitial) {
      const initialHelper = options2.initial ?? options2.positionInitial;
      if (typeof initialHelper?.getLeft !== "function" || typeof initialHelper?.getTop !== "function") {
        throw new Error(
          `'options.initial' position helper does not contain 'getLeft' and / or 'getTop' functions.`
        );
      }
      this.#options.initialHelper = options2.initial;
    }
    if (options2?.validator) {
      if (isIterable(options2?.validator)) {
        this.validators.add(...options2.validator);
      } else {
        this.validators.add(options2.validator);
      }
    }
  }
  /**
   * Returns the animation API.
   *
   * @returns {AnimationAPI} Animation API.
   */
  get animate() {
    return this.#animate;
  }
  /**
   * Returns the dimension data for the readable store.
   *
   * @returns {{width: number | 'auto', height: number | 'auto'}} Dimension data.
   */
  get dimension() {
    return this.#updateElementData.dimensionData;
  }
  /**
   * Returns the enabled state.
   *
   * @returns {boolean} Enabled state.
   */
  get enabled() {
    return this.#enabled;
  }
  /**
   * Returns the current HTMLElement being positioned.
   *
   * @returns {HTMLElement|undefined} Current HTMLElement being positioned.
   */
  get element() {
    return this.#styleCache.el;
  }
  /**
   * Returns a promise that is resolved on the next element update with the time of the update.
   *
   * @returns {Promise<number>} Promise resolved on element update.
   */
  get elementUpdated() {
    return this.#updateElementPromise;
  }
  /**
   * Returns the associated {@link PositionParent} instance.
   *
   * @returns {PositionParent} The PositionParent instance.
   */
  get parent() {
    return this.#parent;
  }
  /**
   * Returns the state API.
   *
   * @returns {PositionStateAPI} Position state API.
   */
  get state() {
    return this.#state;
  }
  /**
   * Returns the derived writable stores for individual data variables.
   *
   * @returns {StorePosition} Derived / writable stores.
   */
  get stores() {
    return this.#stores;
  }
  /**
   * Returns the transform data for the readable store.
   *
   * @returns {TransformData} Transform Data.
   */
  get transform() {
    return this.#updateElementData.transformData;
  }
  /**
   * Returns the validators.
   *
   * @returns {AdapterValidators} validators.
   */
  get validators() {
    return this.#validators;
  }
  /**
   * Sets the enabled state.
   *
   * @param {boolean}  enabled - New enabled state.
   */
  set enabled(enabled2) {
    if (typeof enabled2 !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled2;
  }
  /**
   * Sets the associated {@link PositionParent} instance. Resets the style cache and default data.
   *
   * @param {PositionParent|void} parent - A PositionParent instance.
   */
  set parent(parent) {
    if (parent !== void 0 && !(parent instanceof HTMLElement) && !isObject(parent)) {
      throw new TypeError(`'parent' is not an HTMLElement, object, or undefined.`);
    }
    this.#parent = parent;
    this.#state.remove({ name: "#defaultData" });
    this.#styleCache.reset();
    if (parent) {
      this.set(this.#data);
    }
  }
  // Data accessors ----------------------------------------------------------------------------------------------------
  /**
   * @returns {number|'auto'|'inherit'|null} height
   */
  get height() {
    return this.#data.height;
  }
  /**
   * @returns {number|null} left
   */
  get left() {
    return this.#data.left;
  }
  /**
   * @returns {number|null} maxHeight
   */
  get maxHeight() {
    return this.#data.maxHeight;
  }
  /**
   * @returns {number|null} maxWidth
   */
  get maxWidth() {
    return this.#data.maxWidth;
  }
  /**
   * @returns {number|null} minHeight
   */
  get minHeight() {
    return this.#data.minHeight;
  }
  /**
   * @returns {number|null} minWidth
   */
  get minWidth() {
    return this.#data.minWidth;
  }
  /**
   * @returns {number|null} rotateX
   */
  get rotateX() {
    return this.#data.rotateX;
  }
  /**
   * @returns {number|null} rotateY
   */
  get rotateY() {
    return this.#data.rotateY;
  }
  /**
   * @returns {number|null} rotateZ
   */
  get rotateZ() {
    return this.#data.rotateZ;
  }
  /**
   * @returns {number|null} alias for rotateZ
   */
  get rotation() {
    return this.#data.rotateZ;
  }
  /**
   * @returns {number|null} scale
   */
  get scale() {
    return this.#data.scale;
  }
  /**
   * @returns {number|null} top
   */
  get top() {
    return this.#data.top;
  }
  /**
   * @returns {string} transformOrigin
   */
  get transformOrigin() {
    return this.#data.transformOrigin;
  }
  /**
   * @returns {number|null} translateX
   */
  get translateX() {
    return this.#data.translateX;
  }
  /**
   * @returns {number|null} translateY
   */
  get translateY() {
    return this.#data.translateY;
  }
  /**
   * @returns {number|null} translateZ
   */
  get translateZ() {
    return this.#data.translateZ;
  }
  /**
   * @returns {number|'auto'|'inherit'|null} width
   */
  get width() {
    return this.#data.width;
  }
  /**
   * @returns {number|null} z-index
   */
  get zIndex() {
    return this.#data.zIndex;
  }
  /**
   * @param {number|string|null} height -
   */
  set height(height) {
    this.#stores.height.set(height);
  }
  /**
   * @param {number|string|null} left -
   */
  set left(left) {
    this.#stores.left.set(left);
  }
  /**
   * @param {number|string|null} maxHeight -
   */
  set maxHeight(maxHeight) {
    this.#stores.maxHeight.set(maxHeight);
  }
  /**
   * @param {number|string|null} maxWidth -
   */
  set maxWidth(maxWidth) {
    this.#stores.maxWidth.set(maxWidth);
  }
  /**
   * @param {number|string|null} minHeight -
   */
  set minHeight(minHeight) {
    this.#stores.minHeight.set(minHeight);
  }
  /**
   * @param {number|string|null} minWidth -
   */
  set minWidth(minWidth) {
    this.#stores.minWidth.set(minWidth);
  }
  /**
   * @param {number|string|null} rotateX -
   */
  set rotateX(rotateX) {
    this.#stores.rotateX.set(rotateX);
  }
  /**
   * @param {number|string|null} rotateY -
   */
  set rotateY(rotateY) {
    this.#stores.rotateY.set(rotateY);
  }
  /**
   * @param {number|string|null} rotateZ -
   */
  set rotateZ(rotateZ) {
    this.#stores.rotateZ.set(rotateZ);
  }
  /**
   * @param {number|string|null} rotateZ - alias for rotateZ
   */
  set rotation(rotateZ) {
    this.#stores.rotateZ.set(rotateZ);
  }
  /**
   * @param {number|string|null} scale -
   */
  set scale(scale) {
    this.#stores.scale.set(scale);
  }
  /**
   * @param {number|string|null} top -
   */
  set top(top) {
    this.#stores.top.set(top);
  }
  /**
   * @param {string} transformOrigin -
   */
  set transformOrigin(transformOrigin) {
    if (transformOrigins.includes(transformOrigin)) {
      this.#stores.transformOrigin.set(transformOrigin);
    }
  }
  /**
   * @param {number|string|null} translateX -
   */
  set translateX(translateX) {
    this.#stores.translateX.set(translateX);
  }
  /**
   * @param {number|string|null} translateY -
   */
  set translateY(translateY) {
    this.#stores.translateY.set(translateY);
  }
  /**
   * @param {number|string|null} translateZ -
   */
  set translateZ(translateZ) {
    this.#stores.translateZ.set(translateZ);
  }
  /**
   * @param {number|string|null} width -
   */
  set width(width) {
    this.#stores.width.set(width);
  }
  /**
   * @param {number|string|null} zIndex -
   */
  set zIndex(zIndex) {
    this.#stores.zIndex.set(zIndex);
  }
  /**
   * Assigns current position to object passed into method.
   *
   * @param {object|PositionData}  [position] - Target to assign current position data.
   *
   * @param {PositionGetOptions}   [options] - Defines options for specific keys and substituting null for numeric
   *                                           default values.
   *
   * @returns {PositionData} Passed in object with current position data.
   */
  get(position = {}, options2) {
    const keys = options2?.keys;
    const excludeKeys = options2?.exclude;
    const numeric = options2?.numeric ?? false;
    if (isIterable(keys)) {
      if (numeric) {
        for (const key of keys) {
          position[key] = this[key] ?? numericDefaults[key];
        }
      } else {
        for (const key of keys) {
          position[key] = this[key];
        }
      }
      if (isIterable(excludeKeys)) {
        for (const key of excludeKeys) {
          delete position[key];
        }
      }
      return position;
    } else {
      const data2 = Object.assign(position, this.#data);
      if (isIterable(excludeKeys)) {
        for (const key of excludeKeys) {
          delete data2[key];
        }
      }
      if (numeric) {
        setNumericDefaults(data2);
      }
      return data2;
    }
  }
  /**
   * @returns {PositionData} Current position data.
   */
  toJSON() {
    return Object.assign({}, this.#data);
  }
  /**
   * All calculation and updates of position are implemented in {@link Position}. This allows position to be fully
   * reactive and in control of updating inline styles for the application.
   *
   * Note: the logic for updating position is improved and changes a few aspects from the default
   * {@link Application.setPosition}. The gate on `popOut` is removed, so to ensure no positional application occurs
   * popOut applications can set `this.options.positionable` to false ensuring no positional inline styles are
   * applied.
   *
   * The initial set call on an application with a target element will always set width / height as this is
   * necessary for correct calculations.
   *
   * When a target element is present updated styles are applied after validation. To modify the behavior of set
   * implement one or more validator functions and add them from the application via
   * `this.position.validators.add(<Function>)`.
   *
   * Updates to any target element are decoupled from the underlying Position data. This method returns this instance
   * that you can then await on the target element inline style update by using {@link Position.elementUpdated}.
   *
   * @param {PositionDataExtended} [position] - Position data to set.
   *
   * @returns {Position} This Position instance.
   */
  set(position = {}) {
    if (typeof position !== "object") {
      throw new TypeError(`Position - set error: 'position' is not an object.`);
    }
    const parent = this.#parent;
    if (!this.#enabled) {
      return this;
    }
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return this;
    }
    const immediateElementUpdate = position.immediateElementUpdate === true;
    const data2 = this.#data;
    const transforms = this.#transforms;
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    const changeSet = this.#positionChangeSet;
    const styleCache = this.#styleCache;
    if (el) {
      if (!styleCache.hasData(el)) {
        styleCache.update(el);
        if (!styleCache.hasWillChange)
          ;
        changeSet.set(true);
        this.#updateElementData.queued = false;
      }
      convertRelative(position, this);
      position = this.#updatePosition(position, parent, el, styleCache);
      if (position === null) {
        return this;
      }
    }
    if (Number.isFinite(position.left)) {
      position.left = Math.round(position.left);
      if (data2.left !== position.left) {
        data2.left = position.left;
        changeSet.left = true;
      }
    }
    if (Number.isFinite(position.top)) {
      position.top = Math.round(position.top);
      if (data2.top !== position.top) {
        data2.top = position.top;
        changeSet.top = true;
      }
    }
    if (Number.isFinite(position.maxHeight) || position.maxHeight === null) {
      position.maxHeight = typeof position.maxHeight === "number" ? Math.round(position.maxHeight) : null;
      if (data2.maxHeight !== position.maxHeight) {
        data2.maxHeight = position.maxHeight;
        changeSet.maxHeight = true;
      }
    }
    if (Number.isFinite(position.maxWidth) || position.maxWidth === null) {
      position.maxWidth = typeof position.maxWidth === "number" ? Math.round(position.maxWidth) : null;
      if (data2.maxWidth !== position.maxWidth) {
        data2.maxWidth = position.maxWidth;
        changeSet.maxWidth = true;
      }
    }
    if (Number.isFinite(position.minHeight) || position.minHeight === null) {
      position.minHeight = typeof position.minHeight === "number" ? Math.round(position.minHeight) : null;
      if (data2.minHeight !== position.minHeight) {
        data2.minHeight = position.minHeight;
        changeSet.minHeight = true;
      }
    }
    if (Number.isFinite(position.minWidth) || position.minWidth === null) {
      position.minWidth = typeof position.minWidth === "number" ? Math.round(position.minWidth) : null;
      if (data2.minWidth !== position.minWidth) {
        data2.minWidth = position.minWidth;
        changeSet.minWidth = true;
      }
    }
    if (Number.isFinite(position.rotateX) || position.rotateX === null) {
      if (data2.rotateX !== position.rotateX) {
        data2.rotateX = transforms.rotateX = position.rotateX;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.rotateY) || position.rotateY === null) {
      if (data2.rotateY !== position.rotateY) {
        data2.rotateY = transforms.rotateY = position.rotateY;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.rotateZ) || position.rotateZ === null) {
      if (data2.rotateZ !== position.rotateZ) {
        data2.rotateZ = transforms.rotateZ = position.rotateZ;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.scale) || position.scale === null) {
      position.scale = typeof position.scale === "number" ? Math.max(0, Math.min(position.scale, 1e3)) : null;
      if (data2.scale !== position.scale) {
        data2.scale = transforms.scale = position.scale;
        changeSet.transform = true;
      }
    }
    if (typeof position.transformOrigin === "string" && transformOrigins.includes(
      position.transformOrigin
    ) || position.transformOrigin === null) {
      if (data2.transformOrigin !== position.transformOrigin) {
        data2.transformOrigin = position.transformOrigin;
        changeSet.transformOrigin = true;
      }
    }
    if (Number.isFinite(position.translateX) || position.translateX === null) {
      if (data2.translateX !== position.translateX) {
        data2.translateX = transforms.translateX = position.translateX;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.translateY) || position.translateY === null) {
      if (data2.translateY !== position.translateY) {
        data2.translateY = transforms.translateY = position.translateY;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.translateZ) || position.translateZ === null) {
      if (data2.translateZ !== position.translateZ) {
        data2.translateZ = transforms.translateZ = position.translateZ;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.zIndex)) {
      position.zIndex = Math.round(position.zIndex);
      if (data2.zIndex !== position.zIndex) {
        data2.zIndex = position.zIndex;
        changeSet.zIndex = true;
      }
    }
    if (Number.isFinite(position.width) || position.width === "auto" || position.width === "inherit" || position.width === null) {
      position.width = typeof position.width === "number" ? Math.round(position.width) : position.width;
      if (data2.width !== position.width) {
        data2.width = position.width;
        changeSet.width = true;
      }
    }
    if (Number.isFinite(position.height) || position.height === "auto" || position.height === "inherit" || position.height === null) {
      position.height = typeof position.height === "number" ? Math.round(position.height) : position.height;
      if (data2.height !== position.height) {
        data2.height = position.height;
        changeSet.height = true;
      }
    }
    if (el) {
      const defaultData2 = this.#state.getDefault();
      if (typeof defaultData2 !== "object") {
        this.#state.save({ name: "#defaultData", ...Object.assign({}, data2) });
      }
      if (immediateElementUpdate) {
        UpdateElementManager.immediate(el, this.#updateElementData);
        this.#updateElementPromise = Promise.resolve(performance.now());
      } else if (!this.#updateElementData.queued) {
        this.#updateElementPromise = UpdateElementManager.add(el, this.#updateElementData);
      }
    } else {
      UpdateElementManager.updateSubscribers(this.#updateElementData);
    }
    return this;
  }
  /**
   *
   * @param {function(PositionData): void} handler - Callback function that is invoked on update / changes. Receives
   *                                                 a copy of the PositionData.
   *
   * @returns {(function(): void)} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(Object.assign({}, this.#data));
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  /**
   * @param {PositionDataExtended} opts -
   *
   * @param {number|null} opts.left -
   *
   * @param {number|null} opts.top -
   *
   * @param {number|null} opts.maxHeight -
   *
   * @param {number|null} opts.maxWidth -
   *
   * @param {number|null} opts.minHeight -
   *
   * @param {number|null} opts.minWidth -
   *
   * @param {number|'auto'|null} opts.width -
   *
   * @param {number|'auto'|null} opts.height -
   *
   * @param {number|null} opts.rotateX -
   *
   * @param {number|null} opts.rotateY -
   *
   * @param {number|null} opts.rotateZ -
   *
   * @param {number|null} opts.scale -
   *
   * @param {string} opts.transformOrigin -
   *
   * @param {number|null} opts.translateX -
   *
   * @param {number|null} opts.translateY -
   *
   * @param {number|null} opts.translateZ -
   *
   * @param {number|null} opts.zIndex -
   *
   * @param {number|null} opts.rotation - alias for rotateZ
   *
   * @param {*} opts.rest -
   *
   * @param {object} parent -
   *
   * @param {HTMLElement} el -
   *
   * @param {StyleCache} styleCache -
   *
   * @returns {null|PositionData} Updated position data or null if validation fails.
   */
  #updatePosition({
    // Directly supported parameters
    left,
    top,
    maxWidth,
    maxHeight,
    minWidth,
    minHeight,
    width,
    height,
    rotateX,
    rotateY,
    rotateZ,
    scale,
    transformOrigin,
    translateX,
    translateY,
    translateZ,
    zIndex,
    // Aliased parameters
    rotation,
    ...rest
  } = {}, parent, el, styleCache) {
    let currentPosition = s_DATA_UPDATE.copy(this.#data);
    if (el.style.width === "" || width !== void 0) {
      if (width === "auto" || currentPosition.width === "auto" && width !== null) {
        currentPosition.width = "auto";
        width = styleCache.offsetWidth;
      } else if (width === "inherit" || currentPosition.width === "inherit" && width !== null) {
        currentPosition.width = "inherit";
        width = styleCache.offsetWidth;
      } else {
        const newWidth = Number.isFinite(width) ? width : currentPosition.width;
        currentPosition.width = width = Number.isFinite(newWidth) ? Math.round(newWidth) : styleCache.offsetWidth;
      }
    } else {
      width = Number.isFinite(currentPosition.width) ? currentPosition.width : styleCache.offsetWidth;
    }
    if (el.style.height === "" || height !== void 0) {
      if (height === "auto" || currentPosition.height === "auto" && height !== null) {
        currentPosition.height = "auto";
        height = styleCache.offsetHeight;
      } else if (height === "inherit" || currentPosition.height === "inherit" && height !== null) {
        currentPosition.height = "inherit";
        height = styleCache.offsetHeight;
      } else {
        const newHeight = Number.isFinite(height) ? height : currentPosition.height;
        currentPosition.height = height = Number.isFinite(newHeight) ? Math.round(newHeight) : styleCache.offsetHeight;
      }
    } else {
      height = Number.isFinite(currentPosition.height) ? currentPosition.height : styleCache.offsetHeight;
    }
    if (Number.isFinite(left)) {
      currentPosition.left = left;
    } else if (!Number.isFinite(currentPosition.left)) {
      currentPosition.left = typeof this.#options.initialHelper?.getLeft === "function" ? this.#options.initialHelper.getLeft(width) : 0;
    }
    if (Number.isFinite(top)) {
      currentPosition.top = top;
    } else if (!Number.isFinite(currentPosition.top)) {
      currentPosition.top = typeof this.#options.initialHelper?.getTop === "function" ? this.#options.initialHelper.getTop(height) : 0;
    }
    if (Number.isFinite(maxHeight) || maxHeight === null) {
      currentPosition.maxHeight = Number.isFinite(maxHeight) ? Math.round(maxHeight) : null;
    }
    if (Number.isFinite(maxWidth) || maxWidth === null) {
      currentPosition.maxWidth = Number.isFinite(maxWidth) ? Math.round(maxWidth) : null;
    }
    if (Number.isFinite(minHeight) || minHeight === null) {
      currentPosition.minHeight = Number.isFinite(minHeight) ? Math.round(minHeight) : null;
    }
    if (Number.isFinite(minWidth) || minWidth === null) {
      currentPosition.minWidth = Number.isFinite(minWidth) ? Math.round(minWidth) : null;
    }
    if (Number.isFinite(rotateX) || rotateX === null) {
      currentPosition.rotateX = rotateX;
    }
    if (Number.isFinite(rotateY) || rotateY === null) {
      currentPosition.rotateY = rotateY;
    }
    if (rotateZ !== currentPosition.rotateZ && (Number.isFinite(rotateZ) || rotateZ === null)) {
      currentPosition.rotateZ = rotateZ;
    } else if (rotation !== currentPosition.rotateZ && (Number.isFinite(rotation) || rotation === null)) {
      currentPosition.rotateZ = rotation;
    }
    if (Number.isFinite(translateX) || translateX === null) {
      currentPosition.translateX = translateX;
    }
    if (Number.isFinite(translateY) || translateY === null) {
      currentPosition.translateY = translateY;
    }
    if (Number.isFinite(translateZ) || translateZ === null) {
      currentPosition.translateZ = translateZ;
    }
    if (Number.isFinite(scale) || scale === null) {
      currentPosition.scale = typeof scale === "number" ? Math.max(0, Math.min(scale, 1e3)) : null;
    }
    if (typeof transformOrigin === "string" || transformOrigin === null) {
      currentPosition.transformOrigin = transformOrigins.includes(transformOrigin) ? transformOrigin : null;
    }
    if (Number.isFinite(zIndex) || zIndex === null) {
      currentPosition.zIndex = typeof zIndex === "number" ? Math.round(zIndex) : zIndex;
    }
    const validatorData = this.#validatorData;
    if (this.#validators.enabled && validatorData.length) {
      s_VALIDATION_DATA.parent = parent;
      s_VALIDATION_DATA.el = el;
      s_VALIDATION_DATA.computed = styleCache.computed;
      s_VALIDATION_DATA.transforms = this.#transforms;
      s_VALIDATION_DATA.height = height;
      s_VALIDATION_DATA.width = width;
      s_VALIDATION_DATA.marginLeft = styleCache.marginLeft;
      s_VALIDATION_DATA.marginTop = styleCache.marginTop;
      s_VALIDATION_DATA.maxHeight = styleCache.maxHeight ?? currentPosition.maxHeight;
      s_VALIDATION_DATA.maxWidth = styleCache.maxWidth ?? currentPosition.maxWidth;
      const isMinimized = parent?.reactive?.minimized ?? false;
      s_VALIDATION_DATA.minHeight = isMinimized ? currentPosition.minHeight ?? 0 : styleCache.minHeight || (currentPosition.minHeight ?? 0);
      s_VALIDATION_DATA.minWidth = isMinimized ? currentPosition.minWidth ?? 0 : styleCache.minWidth || (currentPosition.minWidth ?? 0);
      for (let cntr = 0; cntr < validatorData.length; cntr++) {
        s_VALIDATION_DATA.position = currentPosition;
        s_VALIDATION_DATA.rest = rest;
        currentPosition = validatorData[cntr].validator(s_VALIDATION_DATA);
        if (currentPosition === null) {
          return null;
        }
      }
    }
    return currentPosition;
  }
}
const s_DATA_UPDATE = new PositionData();
const s_VALIDATION_DATA = {
  position: void 0,
  parent: void 0,
  el: void 0,
  computed: void 0,
  transforms: void 0,
  height: void 0,
  width: void 0,
  marginLeft: void 0,
  marginTop: void 0,
  maxHeight: void 0,
  maxWidth: void 0,
  minHeight: void 0,
  minWidth: void 0,
  rest: void 0
};
Object.seal(s_VALIDATION_DATA);
class ApplicationState {
  /** @type {ApplicationShellExt} */
  #application;
  /** @type {Map<string, ApplicationStateData>} */
  #dataSaved = /* @__PURE__ */ new Map();
  /**
   * @param {ApplicationShellExt}   application - The application.
   */
  constructor(application) {
    this.#application = application;
    Object.seal(this);
  }
  /**
   * Returns current application state along with any extra data passed into method.
   *
   * @param {object} [extra] - Extra data to add to application state.
   *
   * @returns {ApplicationStateData} Passed in object with current application state.
   */
  get(extra = {}) {
    return Object.assign(extra, {
      position: this.#application?.position?.get(),
      beforeMinimized: this.#application?.position?.state.get({ name: "#beforeMinimized" }),
      options: Object.assign({}, this.#application?.options),
      ui: { minimized: this.#application?.reactive?.minimized }
    });
  }
  /**
   * Returns any stored save state by name.
   *
   * @param {string}   name - Saved data set name.
   *
   * @returns {ApplicationStateData} The saved data set.
   */
  getSave({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - getSave error: 'name' is not a string.`);
    }
    return this.#dataSaved.get(name);
  }
  /**
   * Removes and returns any application state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to remove and retrieve.
   *
   * @returns {ApplicationStateData} Saved application data.
   */
  remove({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - remove: 'name' is not a string.`);
    }
    const data2 = this.#dataSaved.get(name);
    this.#dataSaved.delete(name);
    return data2;
  }
  /**
   * Restores a saved application state returning the data. Several optional parameters are available
   * to control whether the restore action occurs silently (no store / inline styles updates), animates
   * to the stored data, or simply sets the stored data. Restoring via {@link AnimationAPI.to} allows
   * specification of the duration, easing, and interpolate functions along with configuring a Promise to be
   * returned if awaiting the end of the animation.
   *
   * @param {object}            params - Parameters
   *
   * @param {string}            params.name - Saved data set name.
   *
   * @param {boolean}           [params.remove=false] - Remove data set.
   *
   * @param {boolean}           [params.async=false] - If animating return a Promise that resolves with any saved data.
   *
   * @param {boolean}           [params.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [params.duration=0.1] - Duration in seconds.
   *
   * @param {Function}          [params.ease=linear] - Easing function.
   *
   * @param {Function}          [params.interpolate=lerp] - Interpolation function.
   *
   * @returns {ApplicationStateData|Promise<ApplicationStateData>} Saved application data.
   */
  restore({
    name,
    remove = false,
    async = false,
    animateTo = false,
    duration = 0.1,
    ease = identity,
    interpolate = lerp$5
  }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - restore error: 'name' is not a string.`);
    }
    const dataSaved = this.#dataSaved.get(name);
    if (dataSaved) {
      if (remove) {
        this.#dataSaved.delete(name);
      }
      if (async) {
        return this.set(dataSaved, { async, animateTo, duration, ease, interpolate }).then(() => dataSaved);
      } else {
        this.set(dataSaved, { async, animateTo, duration, ease, interpolate });
      }
    }
    return dataSaved;
  }
  /**
   * Saves current application state with the opportunity to add extra data to the saved state.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - name to index this saved data.
   *
   * @param {...*}     [options.extra] - Extra data to add to saved data.
   *
   * @returns {ApplicationStateData} Current application data
   */
  save({ name, ...extra }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - save error: 'name' is not a string.`);
    }
    const data2 = this.get(extra);
    this.#dataSaved.set(name, data2);
    return data2;
  }
  /**
   * Restores a saved application state returning the data. Several optional parameters are available
   * to control whether the restore action occurs silently (no store / inline styles updates), animates
   * to the stored data, or simply sets the stored data. Restoring via {@link AnimationAPI.to} allows
   * specification of the duration, easing, and interpolate functions along with configuring a Promise to be
   * returned if awaiting the end of the animation.
   *
   * Note: If serializing application state any minimized apps will use the before minimized state on initial render
   * of the app as it is currently not possible to render apps with Foundry VTT core API in the minimized state.
   *
   * TODO: THIS METHOD NEEDS TO BE REFACTORED WHEN TRL IS MADE INTO A STANDALONE FRAMEWORK.
   *
   * @param {ApplicationStateData}   data - Saved data set name.
   *
   * @param {object}            [opts] - Optional parameters
   *
   * @param {boolean}           [opts.async=false] - If animating return a Promise that resolves with any saved data.
   *
   * @param {boolean}           [opts.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [opts.duration=0.1] - Duration in seconds.
   *
   * @param {Function}          [opts.ease=linear] - Easing function.
   *
   * @param {Function}          [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {ApplicationShellExt|Promise<ApplicationShellExt>} When synchronous the application or Promise when
   *                                                             animating resolving with application.
   */
  set(data2, { async = false, animateTo = false, duration = 0.1, ease = identity, interpolate = lerp$5 } = {}) {
    if (!isObject(data2)) {
      throw new TypeError(`ApplicationState - restore error: 'data' is not an object.`);
    }
    const application = this.#application;
    if (!isObject(data2?.position)) {
      console.warn(`ApplicationState.set warning: 'data.position' is not an object.`);
      return application;
    }
    const rendered = application.rendered;
    if (animateTo && !rendered) {
      console.warn(`ApplicationState.set warning: Application is not rendered and 'animateTo' is true.`);
      return application;
    }
    if (animateTo) {
      if (data2.position.transformOrigin !== application.position.transformOrigin) {
        application.position.transformOrigin = data2.position.transformOrigin;
      }
      if (isObject(data2?.ui)) {
        const minimized = typeof data2.ui?.minimized === "boolean" ? data2.ui.minimized : false;
        if (application?.reactive?.minimized && !minimized) {
          application.maximize({ animate: false, duration: 0 });
        }
      }
      const promise2 = application.position.animate.to(
        data2.position,
        { duration, ease, interpolate }
      ).finished.then((cancelled) => {
        if (cancelled) {
          return application;
        }
        if (isObject(data2?.options)) {
          application?.reactive.mergeOptions(data2.options);
        }
        if (isObject(data2?.ui)) {
          const minimized = typeof data2.ui?.minimized === "boolean" ? data2.ui.minimized : false;
          if (!application?.reactive?.minimized && minimized) {
            application.minimize({ animate: false, duration: 0 });
          }
        }
        if (isObject(data2?.beforeMinimized)) {
          application.position.state.set({ name: "#beforeMinimized", ...data2.beforeMinimized });
        }
        return application;
      });
      if (async) {
        return promise2;
      }
    } else {
      if (rendered) {
        if (isObject(data2?.options)) {
          application?.reactive.mergeOptions(data2.options);
        }
        if (isObject(data2?.ui)) {
          const minimized = typeof data2.ui?.minimized === "boolean" ? data2.ui.minimized : false;
          if (application?.reactive?.minimized && !minimized) {
            application.maximize({ animate: false, duration: 0 });
          } else if (!application?.reactive?.minimized && minimized) {
            application.minimize({ animate: false, duration });
          }
        }
        if (isObject(data2?.beforeMinimized)) {
          application.position.state.set({ name: "#beforeMinimized", ...data2.beforeMinimized });
        }
        application.position.set(data2.position);
      } else {
        let positionData = data2.position;
        if (isObject(data2.beforeMinimized)) {
          positionData = data2.beforeMinimized;
          positionData.left = data2.position.left;
          positionData.top = data2.position.top;
        }
        application.position.set(positionData);
      }
    }
    return application;
  }
}
class GetSvelteData {
  /**
   * @type {MountedAppShell[]|null[]}
   */
  #applicationShellHolder;
  /**
   * @type {SvelteData[]}
   */
  #svelteData;
  /**
   * Keep a direct reference to the SvelteData array in an associated {@link SvelteApplication}.
   *
   * @param {MountedAppShell[]|null[]}  applicationShellHolder - A reference to the MountedAppShell array.
   *
   * @param {SvelteData[]}  svelteData - A reference to the SvelteData array of mounted components.
   */
  constructor(applicationShellHolder, svelteData) {
    this.#applicationShellHolder = applicationShellHolder;
    this.#svelteData = svelteData;
  }
  /**
   * Returns any mounted {@link MountedAppShell}.
   *
   * @returns {MountedAppShell|null} Any mounted application shell.
   */
  get applicationShell() {
    return this.#applicationShellHolder[0];
  }
  /**
   * Returns the indexed Svelte component.
   *
   * @param {number}   index -
   *
   * @returns {object} The loaded Svelte component.
   */
  component(index) {
    const data2 = this.#svelteData[index];
    return isObject(data2) ? data2?.component : void 0;
  }
  /**
   * Returns the Svelte component entries iterator.
   *
   * @returns {Generator<Array<number|SvelteComponent>>} Svelte component entries iterator.
   * @yields
   */
  *componentEntries() {
    for (let cntr = 0; cntr < this.#svelteData.length; cntr++) {
      yield [cntr, this.#svelteData[cntr].component];
    }
  }
  /**
   * Returns the Svelte component values iterator.
   *
   * @returns {Generator<SvelteComponent>} Svelte component values iterator.
   * @yields
   */
  *componentValues() {
    for (let cntr = 0; cntr < this.#svelteData.length; cntr++) {
      yield this.#svelteData[cntr].component;
    }
  }
  /**
   * Returns the indexed SvelteData entry.
   *
   * @param {number}   index -
   *
   * @returns {SvelteData} The loaded Svelte config + component.
   */
  data(index) {
    return this.#svelteData[index];
  }
  /**
   * Returns the {@link SvelteData} instance for a given component.
   *
   * @param {object} component - Svelte component.
   *
   * @returns {SvelteData} -  The loaded Svelte config + component.
   */
  dataByComponent(component) {
    for (const data2 of this.#svelteData) {
      if (data2.component === component) {
        return data2;
      }
    }
    return void 0;
  }
  /**
   * Returns the SvelteData entries iterator.
   *
   * @returns {IterableIterator<[number, SvelteData]>} SvelteData entries iterator.
   */
  dataEntries() {
    return this.#svelteData.entries();
  }
  /**
   * Returns the SvelteData values iterator.
   *
   * @returns {IterableIterator<SvelteData>} SvelteData values iterator.
   */
  dataValues() {
    return this.#svelteData.values();
  }
  /**
   * Returns the length of the mounted Svelte component list.
   *
   * @returns {number} Length of mounted Svelte component list.
   */
  get length() {
    return this.#svelteData.length;
  }
}
function loadSvelteConfig({ app, template, config, elementRootUpdate } = {}) {
  const svelteOptions = isObject(config.options) ? config.options : {};
  let target2;
  if (config.target instanceof HTMLElement) {
    target2 = config.target;
  } else if (template instanceof HTMLElement && typeof config.target === "string") {
    target2 = template.querySelector(config.target);
  } else {
    target2 = document.createDocumentFragment();
  }
  if (target2 === void 0) {
    console.log(
      `%c[TRL] loadSvelteConfig error - could not find target selector, '${config.target}', for config:
`,
      "background: rgb(57,34,34)",
      config
    );
    throw new Error();
  }
  const NewSvelteComponent = config.class;
  const svelteConfig = parseSvelteConfig({ ...config, target: target2 }, app);
  const externalContext = svelteConfig.context.get("#external");
  externalContext.application = app;
  externalContext.elementRootUpdate = elementRootUpdate;
  externalContext.sessionStorage = app.reactive.sessionStorage;
  let eventbus;
  if (isObject(app._eventbus) && typeof app._eventbus.createProxy === "function") {
    eventbus = app._eventbus.createProxy();
    externalContext.eventbus = eventbus;
  }
  Object.seal(externalContext);
  svelteConfig.context.set("external", new Proxy({}, {
    get(targetUnused, prop) {
      console.warn(`[TRL] Deprecation warning: Please change getContext('external') to getContext('#external').`);
      return externalContext[prop];
    }
  }));
  const component = new NewSvelteComponent(svelteConfig);
  svelteConfig.eventbus = eventbus;
  let element2;
  if (isApplicationShell(component)) {
    element2 = component.elementRoot;
  }
  if (target2 instanceof DocumentFragment && target2.firstElementChild) {
    if (element2 === void 0) {
      element2 = target2.firstElementChild;
    }
    template.append(target2);
  } else if (config.target instanceof HTMLElement && element2 === void 0) {
    if (config.target instanceof HTMLElement && typeof svelteOptions.selectorElement !== "string") {
      console.log(
        `%c[TRL] loadSvelteConfig error - HTMLElement target with no 'selectorElement' defined.

Note: If configuring an application shell and directly targeting a HTMLElement did you bind an'elementRoot' and include '<svelte:options accessors={true}/>'?

Offending config:
`,
        "background: rgb(57,34,34)",
        config
      );
      throw new Error();
    }
    element2 = target2.querySelector(svelteOptions.selectorElement);
    if (element2 === null || element2 === void 0) {
      console.log(
        `%c[TRL] loadSvelteConfig error - HTMLElement target with 'selectorElement', '${svelteOptions.selectorElement}', not found for config:
`,
        "background: rgb(57,34,34)",
        config
      );
      throw new Error();
    }
  }
  const injectHTML = !(config.target instanceof HTMLElement);
  return { config: svelteConfig, component, element: element2, injectHTML };
}
class SvelteReactive {
  /**
   * @type {SvelteApplication}
   */
  #application;
  /**
   * @type {boolean}
   */
  #initialized = false;
  /** @type {TJSSessionStorage} */
  #sessionStorage;
  /**
   * The Application option store which is injected into mounted Svelte component context under the `external` key.
   *
   * @type {StoreAppOptions}
   */
  #storeAppOptions;
  /**
   * Stores the update function for `#storeAppOptions`.
   *
   * @type {import('svelte/store').Writable.update}
   */
  #storeAppOptionsUpdate;
  /**
   * Stores the UI state data to make it accessible via getters.
   *
   * @type {object}
   */
  #dataUIState;
  /**
   * The UI option store which is injected into mounted Svelte component context under the `external` key.
   *
   * @type {StoreUIOptions}
   */
  #storeUIState;
  /**
   * Stores the update function for `#storeUIState`.
   *
   * @type {import('svelte/store').Writable.update}
   */
  #storeUIStateUpdate;
  /**
   * Stores the unsubscribe functions from local store subscriptions.
   *
   * @type {import('svelte/store').Unsubscriber[]}
   */
  #storeUnsubscribe = [];
  /**
   * @param {SvelteApplication} application - The host Foundry application.
   */
  constructor(application) {
    this.#application = application;
    const optionsSessionStorage = application?.options?.sessionStorage;
    if (optionsSessionStorage !== void 0 && !(optionsSessionStorage instanceof TJSSessionStorage)) {
      throw new TypeError(`'options.sessionStorage' is not an instance of TJSSessionStorage.`);
    }
    this.#sessionStorage = optionsSessionStorage !== void 0 ? optionsSessionStorage : new TJSSessionStorage();
  }
  /**
   * Initializes reactive support. Package private for internal use.
   *
   * @returns {SvelteStores|void} Internal methods to interact with Svelte stores.
   * @package
   */
  initialize() {
    if (this.#initialized) {
      return;
    }
    this.#initialized = true;
    this.#storesInitialize();
    return {
      appOptionsUpdate: this.#storeAppOptionsUpdate,
      uiOptionsUpdate: this.#storeUIStateUpdate,
      subscribe: this.#storesSubscribe.bind(this),
      unsubscribe: this.#storesUnsubscribe.bind(this)
    };
  }
  // Store getters -----------------------------------------------------------------------------------------------------
  /**
   * @returns {TJSSessionStorage} Returns TJSSessionStorage instance.
   */
  get sessionStorage() {
    return this.#sessionStorage;
  }
  /**
   * Returns the store for app options.
   *
   * @returns {StoreAppOptions} App options store.
   */
  get storeAppOptions() {
    return this.#storeAppOptions;
  }
  /**
   * Returns the store for UI options.
   *
   * @returns {StoreUIOptions} UI options store.
   */
  get storeUIState() {
    return this.#storeUIState;
  }
  // Only reactive getters ---------------------------------------------------------------------------------------------
  /**
   * Returns the current dragging UI state.
   *
   * @returns {boolean} Dragging UI state.
   */
  get dragging() {
    return this.#dataUIState.dragging;
  }
  /**
   * Returns the current minimized UI state.
   *
   * @returns {boolean} Minimized UI state.
   */
  get minimized() {
    return this.#dataUIState.minimized;
  }
  /**
   * Returns the current resizing UI state.
   *
   * @returns {boolean} Resizing UI state.
   */
  get resizing() {
    return this.#dataUIState.resizing;
  }
  // Reactive getter / setters -----------------------------------------------------------------------------------------
  /**
   * Returns the draggable app option.
   *
   * @returns {boolean} Draggable app option.
   */
  get draggable() {
    return this.#application?.options?.draggable;
  }
  /**
   * Returns the focusAuto app option.
   *
   * @returns {boolean} When true auto-management of app focus is enabled.
   */
  get focusAuto() {
    return this.#application?.options?.focusAuto;
  }
  /**
   * Returns the focusKeep app option.
   *
   * @returns {boolean} When `focusAuto` and `focusKeep` is true; keeps internal focus.
   */
  get focusKeep() {
    return this.#application?.options?.focusKeep;
  }
  /**
   * Returns the focusTrap app option.
   *
   * @returns {boolean} When true focus trapping / wrapping is enabled keeping focus inside app.
   */
  get focusTrap() {
    return this.#application?.options?.focusTrap;
  }
  /**
   * Returns the headerButtonNoClose app option.
   *
   * @returns {boolean} Remove the close the button in header app option.
   */
  get headerButtonNoClose() {
    return this.#application?.options?.headerButtonNoClose;
  }
  /**
   * Returns the headerButtonNoLabel app option.
   *
   * @returns {boolean} Remove the labels from buttons in header app option.
   */
  get headerButtonNoLabel() {
    return this.#application?.options?.headerButtonNoLabel;
  }
  /**
   * Returns the headerIcon app option.
   *
   * @returns {string|void} URL for header app icon.
   */
  get headerIcon() {
    return this.#application?.options?.headerIcon;
  }
  /**
   * Returns the headerNoTitleMinimized app option.
   *
   * @returns {boolean} When true removes the header title when minimized.
   */
  get headerNoTitleMinimized() {
    return this.#application?.options?.headerNoTitleMinimized;
  }
  /**
   * Returns the minimizable app option.
   *
   * @returns {boolean} Minimizable app option.
   */
  get minimizable() {
    return this.#application?.options?.minimizable;
  }
  /**
   * Returns the Foundry popOut state; {@link Application.popOut}
   *
   * @returns {boolean} Positionable app option.
   */
  get popOut() {
    return this.#application.popOut;
  }
  /**
   * Returns the positionable app option; {@link SvelteApplicationOptions.positionable}
   *
   * @returns {boolean} Positionable app option.
   */
  get positionable() {
    return this.#application?.options?.positionable;
  }
  /**
   * Returns the resizable option.
   *
   * @returns {boolean} Resizable app option.
   */
  get resizable() {
    return this.#application?.options?.resizable;
  }
  /**
   * Returns the title accessor from the parent Application class; {@link Application.title}
   * TODO: Application v2; note that super.title localizes `this.options.title`; IMHO it shouldn't.
   *
   * @returns {string} Title.
   */
  get title() {
    return this.#application.title;
  }
  /**
   * Sets `this.options.draggable` which is reactive for application shells.
   *
   * @param {boolean}  draggable - Sets the draggable option.
   */
  set draggable(draggable2) {
    if (typeof draggable2 === "boolean") {
      this.setOptions("draggable", draggable2);
    }
  }
  /**
   * Sets `this.options.focusAuto` which is reactive for application shells.
   *
   * @param {boolean}  focusAuto - Sets the focusAuto option.
   */
  set focusAuto(focusAuto) {
    if (typeof focusAuto === "boolean") {
      this.setOptions("focusAuto", focusAuto);
    }
  }
  /**
   * Sets `this.options.focusKeep` which is reactive for application shells.
   *
   * @param {boolean}  focusKeep - Sets the focusKeep option.
   */
  set focusKeep(focusKeep) {
    if (typeof focusKeep === "boolean") {
      this.setOptions("focusKeep", focusKeep);
    }
  }
  /**
   * Sets `this.options.focusTrap` which is reactive for application shells.
   *
   * @param {boolean}  focusTrap - Sets the focusTrap option.
   */
  set focusTrap(focusTrap) {
    if (typeof focusTrap === "boolean") {
      this.setOptions("focusTrap", focusTrap);
    }
  }
  /**
   * Sets `this.options.headerButtonNoClose` which is reactive for application shells.
   *
   * @param {boolean}  headerButtonNoClose - Sets the headerButtonNoClose option.
   */
  set headerButtonNoClose(headerButtonNoClose) {
    if (typeof headerButtonNoClose === "boolean") {
      this.setOptions("headerButtonNoClose", headerButtonNoClose);
    }
  }
  /**
   * Sets `this.options.headerButtonNoLabel` which is reactive for application shells.
   *
   * @param {boolean}  headerButtonNoLabel - Sets the headerButtonNoLabel option.
   */
  set headerButtonNoLabel(headerButtonNoLabel) {
    if (typeof headerButtonNoLabel === "boolean") {
      this.setOptions("headerButtonNoLabel", headerButtonNoLabel);
    }
  }
  /**
   * Sets `this.options.headerIcon` which is reactive for application shells.
   *
   * @param {string|void}  headerIcon - Sets the headerButtonNoLabel option.
   */
  set headerIcon(headerIcon) {
    if (headerIcon === void 0 || typeof headerIcon === "string") {
      this.setOptions("headerIcon", headerIcon);
    }
  }
  /**
   * Sets `this.options.headerNoTitleMinimized` which is reactive for application shells.
   *
   * @param {boolean}  headerNoTitleMinimized - Sets the headerNoTitleMinimized option.
   */
  set headerNoTitleMinimized(headerNoTitleMinimized) {
    if (typeof headerNoTitleMinimized === "boolean") {
      this.setOptions("headerNoTitleMinimized", headerNoTitleMinimized);
    }
  }
  /**
   * Sets `this.options.minimizable` which is reactive for application shells that are also pop out.
   *
   * @param {boolean}  minimizable - Sets the minimizable option.
   */
  set minimizable(minimizable) {
    if (typeof minimizable === "boolean") {
      this.setOptions("minimizable", minimizable);
    }
  }
  /**
   * Sets `this.options.popOut` which is reactive for application shells. This will add / remove this application
   * from `ui.windows`.
   *
   * @param {boolean}  popOut - Sets the popOut option.
   */
  set popOut(popOut) {
    if (typeof popOut === "boolean") {
      this.setOptions("popOut", popOut);
    }
  }
  /**
   * Sets `this.options.positionable` enabling / disabling {@link SvelteApplication.position.set}.
   *
   * @param {boolean}  positionable - Sets the positionable option.
   */
  set positionable(positionable) {
    if (typeof positionable === "boolean") {
      this.setOptions("positionable", positionable);
    }
  }
  /**
   * Sets `this.options.resizable` which is reactive for application shells.
   *
   * @param {boolean}  resizable - Sets the resizable option.
   */
  set resizable(resizable) {
    if (typeof resizable === "boolean") {
      this.setOptions("resizable", resizable);
    }
  }
  /**
   * Sets `this.options.title` which is reactive for application shells.
   *
   * Note: Will set empty string if title is undefined or null.
   *
   * @param {string|undefined|null}   title - Application title; will be localized, so a translation key is fine.
   */
  set title(title2) {
    if (typeof title2 === "string") {
      this.setOptions("title", title2);
    } else if (title2 === void 0 || title2 === null) {
      this.setOptions("title", "");
    }
  }
  // Reactive Options API -------------------------------------------------------------------------------------------
  /**
   * Provides a way to safely get this applications options given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {*}        [defaultValue] - A default value returned if the accessor is not found.
   *
   * @returns {*} Value at the accessor.
   */
  getOptions(accessor, defaultValue) {
    return safeAccess(this.#application.options, accessor, defaultValue);
  }
  /**
   * Provides a way to merge `options` into this applications options and update the appOptions store.
   *
   * @param {object}   options - The options object to merge with `this.options`.
   */
  mergeOptions(options2) {
    this.#storeAppOptionsUpdate((instanceOptions) => deepMerge(instanceOptions, options2));
  }
  /**
   * Provides a way to safely set this applications options given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * Additionally if an application shell Svelte component is mounted and exports the `appOptions` property then
   * the application options is set to `appOptions` potentially updating the application shell / Svelte component.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {*}        value - Value to set.
   */
  setOptions(accessor, value) {
    const success = safeSet(this.#application.options, accessor, value);
    if (success) {
      this.#storeAppOptionsUpdate(() => this.#application.options);
    }
  }
  /**
   * Initializes the Svelte stores and derived stores for the application options and UI state.
   *
   * While writable stores are created the update method is stored in private variables locally and derived Readable
   * stores are provided for essential options which are commonly used.
   *
   * These stores are injected into all Svelte components mounted under the `external` context: `storeAppOptions` and
   * ` storeUIState`.
   */
  #storesInitialize() {
    const writableAppOptions = writable$1(this.#application.options);
    this.#storeAppOptionsUpdate = writableAppOptions.update;
    const storeAppOptions = {
      subscribe: writableAppOptions.subscribe,
      draggable: propertyStore(writableAppOptions, "draggable"),
      focusAuto: propertyStore(writableAppOptions, "focusAuto"),
      focusKeep: propertyStore(writableAppOptions, "focusKeep"),
      focusTrap: propertyStore(writableAppOptions, "focusTrap"),
      headerButtonNoClose: propertyStore(writableAppOptions, "headerButtonNoClose"),
      headerButtonNoLabel: propertyStore(writableAppOptions, "headerButtonNoLabel"),
      headerIcon: propertyStore(writableAppOptions, "headerIcon"),
      headerNoTitleMinimized: propertyStore(writableAppOptions, "headerNoTitleMinimized"),
      minimizable: propertyStore(writableAppOptions, "minimizable"),
      popOut: propertyStore(writableAppOptions, "popOut"),
      positionable: propertyStore(writableAppOptions, "positionable"),
      resizable: propertyStore(writableAppOptions, "resizable"),
      title: propertyStore(writableAppOptions, "title")
    };
    Object.freeze(storeAppOptions);
    this.#storeAppOptions = storeAppOptions;
    this.#dataUIState = {
      dragging: false,
      headerButtons: [],
      minimized: this.#application._minimized,
      resizing: false
    };
    const writableUIOptions = writable$1(this.#dataUIState);
    this.#storeUIStateUpdate = writableUIOptions.update;
    const storeUIState = {
      subscribe: writableUIOptions.subscribe,
      dragging: propertyStore(writableUIOptions, "dragging"),
      headerButtons: derived(writableUIOptions, ($options, set2) => set2($options.headerButtons)),
      minimized: derived(writableUIOptions, ($options, set2) => set2($options.minimized)),
      resizing: propertyStore(writableUIOptions, "resizing")
    };
    Object.freeze(storeUIState);
    this.#storeUIState = storeUIState;
  }
  /**
   * Registers local store subscriptions for app options. `popOut` controls registering this app with `ui.windows`.
   *
   * @see SvelteApplication._injectHTML
   */
  #storesSubscribe() {
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.headerButtonNoClose, (value) => {
      this.updateHeaderButtons({ headerButtonNoClose: value });
    }));
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.headerButtonNoLabel, (value) => {
      this.updateHeaderButtons({ headerButtonNoLabel: value });
    }));
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.popOut, (value) => {
      if (value && this.#application.rendered) {
        globalThis.ui.windows[this.#application.appId] = this.#application;
      } else {
        delete globalThis.ui.windows[this.#application.appId];
      }
    }));
  }
  /**
   * Unsubscribes from any locally monitored stores.
   *
   * @see SvelteApplication.close
   */
  #storesUnsubscribe() {
    this.#storeUnsubscribe.forEach((unsubscribe) => unsubscribe());
    this.#storeUnsubscribe = [];
  }
  /**
   * Updates the UI Options store with the current header buttons. You may dynamically add / remove header buttons
   * if using an application shell Svelte component. In either overriding `_getHeaderButtons` or responding to the
   * Hooks fired return a new button array and the uiOptions store is updated and the application shell will render
   * the new buttons.
   *
   * Optionally you can set in the SvelteApplication app options {@link SvelteApplicationOptions.headerButtonNoClose}
   * to remove the close button and {@link SvelteApplicationOptions.headerButtonNoLabel} to true and labels will be
   * removed from the header buttons.
   *
   * @param {object} opts - Optional parameters (for internal use)
   *
   * @param {boolean} opts.headerButtonNoClose - The value for `headerButtonNoClose`.
   *
   * @param {boolean} opts.headerButtonNoLabel - The value for `headerButtonNoLabel`.
   */
  updateHeaderButtons({
    headerButtonNoClose = this.#application.options.headerButtonNoClose,
    headerButtonNoLabel = this.#application.options.headerButtonNoLabel
  } = {}) {
    let buttons = this.#application._getHeaderButtons();
    if (typeof headerButtonNoClose === "boolean" && headerButtonNoClose) {
      buttons = buttons.filter((button) => button.class !== "close");
    }
    if (typeof headerButtonNoLabel === "boolean" && headerButtonNoLabel) {
      for (const button of buttons) {
        button.label = void 0;
      }
    }
    this.#storeUIStateUpdate((options2) => {
      options2.headerButtons = buttons;
      return options2;
    });
  }
}
class SvelteApplication extends Application {
  /**
   * Stores the first mounted component which follows the application shell contract.
   *
   * @type {MountedAppShell[]|null[]} Application shell.
   */
  #applicationShellHolder = [null];
  /**
   * Stores and manages application state for saving / restoring / serializing.
   *
   * @type {ApplicationState}
   */
  #applicationState;
  /**
   * Stores the target element which may not necessarily be the main element.
   *
   * @type {HTMLElement}
   */
  #elementTarget = null;
  /**
   * Stores the content element which is set for application shells.
   *
   * @type {HTMLElement}
   */
  #elementContent = null;
  /**
   * Stores initial z-index from `_renderOuter` to set to target element / Svelte component.
   *
   * @type {number}
   */
  #initialZIndex = 95;
  /**
   * Stores on mount state which is checked in _render to trigger onSvelteMount callback.
   *
   * @type {boolean}
   */
  #onMount = false;
  /**
   * The position store.
   *
   * @type {Position}
   */
  #position;
  /**
   * Contains the Svelte stores and reactive accessors.
   *
   * @type {SvelteReactive}
   */
  #reactive;
  /**
   * Stores SvelteData entries with instantiated Svelte components.
   *
   * @type {SvelteData[]}
   */
  #svelteData = [];
  /**
   * Provides a helper class that combines multiple methods for interacting with the mounted components tracked in
   * {@link SvelteData}.
   *
   * @type {GetSvelteData}
   */
  #getSvelteData = new GetSvelteData(this.#applicationShellHolder, this.#svelteData);
  /**
   * Contains methods to interact with the Svelte stores.
   *
   * @type {SvelteStores}
   */
  #stores;
  /**
   * @param {SvelteApplicationOptions} options - The options for the application.
   *
   * @inheritDoc
   */
  constructor(options2 = {}) {
    super(options2);
    this.#applicationState = new ApplicationState(this);
    this.#position = new Position(this, {
      ...this.position,
      ...this.options,
      initial: this.options.positionInitial,
      ortho: this.options.positionOrtho,
      validator: this.options.positionValidator
    });
    delete this.position;
    Object.defineProperty(this, "position", {
      get: () => this.#position,
      set: (position) => {
        if (isObject(position)) {
          this.#position.set(position);
        }
      }
    });
    this.#reactive = new SvelteReactive(this);
    this.#stores = this.#reactive.initialize();
  }
  /**
   * Specifies the default options that SvelteApplication supports.
   *
   * @returns {SvelteApplicationOptions} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return deepMerge(super.defaultOptions, {
      defaultCloseAnimation: true,
      // If false the default slide close animation is not run.
      draggable: true,
      // If true then application shells are draggable.
      focusAuto: true,
      // When true auto-management of app focus is enabled.
      focusKeep: false,
      // When `focusAuto` and `focusKeep` is true; keeps internal focus.
      focusSource: void 0,
      // Stores any A11yFocusSource data that is applied when app is closed.
      focusTrap: true,
      // When true focus trapping / wrapping is enabled keeping focus inside app.
      headerButtonNoClose: false,
      // If true then the close header button is removed.
      headerButtonNoLabel: false,
      // If true then header button labels are removed for application shells.
      headerIcon: void 0,
      // Sets a header icon given an image URL.
      headerNoTitleMinimized: false,
      // If true then header title is hidden when application is minimized.
      minHeight: MIN_WINDOW_HEIGHT,
      // Assigned to position. Number specifying minimum window height.
      minWidth: MIN_WINDOW_WIDTH,
      // Assigned to position. Number specifying minimum window width.
      positionable: true,
      // If false then `position.set` does not take effect.
      positionInitial: Position.Initial.browserCentered,
      // A helper for initial position placement.
      positionOrtho: true,
      // When true Position is optimized for orthographic use.
      positionValidator: Position.Validators.transformWindow,
      // A function providing the default validator.
      sessionStorage: void 0,
      // An instance of SessionStorage to share across SvelteApplications.
      svelte: void 0,
      // A Svelte configuration object.
      transformOrigin: "top left"
      // By default, 'top / left' respects rotation when minimizing.
    });
  }
  /**
   * Returns the content element if an application shell is mounted.
   *
   * @returns {HTMLElement} Content element.
   */
  get elementContent() {
    return this.#elementContent;
  }
  /**
   * Returns the target element or main element if no target defined.
   *
   * @returns {HTMLElement} Target element.
   */
  get elementTarget() {
    return this.#elementTarget;
  }
  /**
   * Returns the reactive accessors & Svelte stores for SvelteApplication.
   *
   * @returns {SvelteReactive} The reactive accessors & Svelte stores.
   */
  get reactive() {
    return this.#reactive;
  }
  /**
   * Returns the application state manager.
   *
   * @returns {ApplicationState} The application state manager.
   */
  get state() {
    return this.#applicationState;
  }
  /**
   * Returns the Svelte helper class w/ various methods to access mounted Svelte components.
   *
   * @returns {GetSvelteData} GetSvelteData
   */
  get svelte() {
    return this.#getSvelteData;
  }
  /**
   * In this case of when a template is defined in app options `html` references the inner HTML / template. However,
   * to activate classic v1 tabs for a Svelte component the element target is passed as an array simulating JQuery as
   * the element is retrieved immediately and the core listeners use standard DOM queries.
   *
   * @inheritDoc
   * @protected
   * @ignore
   */
  _activateCoreListeners(html) {
    super._activateCoreListeners(typeof this.options.template === "string" ? html : [this.#elementTarget]);
  }
  /**
   * Provide an override to set this application as the active window regardless of z-index. Changes behaviour from
   * Foundry core. This is important / used for instance in dialog key handling for left / right button selection.
   *
   * @param {object} [opts] - Optional parameters.
   *
   * @param {boolean} [opts.force=false] - Force bring to top; will increment z-index by popOut order.
   *
   */
  bringToTop({ force = false } = {}) {
    if (force || this.popOut) {
      super.bringToTop();
    }
    if (document.activeElement !== document.body && !this.elementTarget.contains(document.activeElement)) {
      if (document.activeElement instanceof HTMLElement) {
        document.activeElement.blur();
      }
      document.body.focus();
    }
    globalThis.ui.activeWindow = this;
  }
  /**
   * Note: This method is fully overridden and duplicated as Svelte components need to be destroyed manually and the
   * best visual result is to destroy them after the default slide up animation occurs, but before the element
   * is removed from the DOM.
   *
   * If you destroy the Svelte components before the slide up animation the Svelte elements are removed immediately
   * from the DOM. The purpose of overriding ensures the slide up animation is always completed before
   * the Svelte components are destroyed and then the element is removed from the DOM.
   *
   * Close the application and un-register references to it within UI mappings.
   * This function returns a Promise which resolves once the window closing animation concludes
   *
   * @param {object}   [options] - Optional parameters.
   *
   * @param {boolean}  [options.force] - Force close regardless of render state.
   *
   * @returns {Promise<void>}    A Promise which resolves once the application is closed.
   * @ignore
   */
  async close(options2 = {}) {
    const states = Application.RENDER_STATES;
    if (!options2.force && ![states.RENDERED, states.ERROR].includes(this._state)) {
      return;
    }
    this.#stores.unsubscribe();
    this._state = states.CLOSING;
    const el = this.#elementTarget;
    if (!el) {
      return this._state = states.CLOSED;
    }
    const content = el.querySelector(".window-content");
    if (content) {
      content.style.overflow = "hidden";
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = "hidden";
      }
    }
    for (const cls of this.constructor._getInheritanceChain()) {
      Hooks.call(`close${cls.name}`, this, el);
    }
    const animate2 = typeof this.options.defaultCloseAnimation === "boolean" ? this.options.defaultCloseAnimation : true;
    if (animate2) {
      el.style.minHeight = "0";
      const { paddingBottom, paddingTop } = globalThis.getComputedStyle(el);
      await el.animate([
        { maxHeight: `${el.clientHeight}px`, paddingTop, paddingBottom },
        { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
      ], { duration: 250, easing: "ease-in", fill: "forwards" }).finished;
    }
    const svelteDestroyPromises = [];
    for (const entry of this.#svelteData) {
      svelteDestroyPromises.push(outroAndDestroy(entry.component));
      const eventbus = entry.config.eventbus;
      if (isObject(eventbus) && typeof eventbus.off === "function") {
        eventbus.off();
        entry.config.eventbus = void 0;
      }
    }
    await Promise.all(svelteDestroyPromises);
    this.#svelteData.length = 0;
    el.remove();
    this.position.state.restore({
      name: "#beforeMinimized",
      properties: ["width", "height"],
      silent: true,
      remove: true
    });
    this.#applicationShellHolder[0] = null;
    this._element = null;
    this.#elementContent = null;
    this.#elementTarget = null;
    delete globalThis.ui.windows[this.appId];
    this._minimized = false;
    this._scrollPositions = null;
    this._state = states.CLOSED;
    this.#onMount = false;
    this.#stores.uiOptionsUpdate((storeOptions) => deepMerge(storeOptions, { minimized: this._minimized }));
    A11yHelper.applyFocusSource(this.options.focusSource);
    delete this.options.focusSource;
  }
  /**
   * Inject the Svelte components defined in `this.options.svelte`. The Svelte component can attach to the existing
   * pop-out of Application or provide no template and render into a document fragment which is then attached to the
   * DOM.
   *
   * @param {JQuery} html -
   *
   * @inheritDoc
   * @ignore
   */
  _injectHTML(html) {
    if (this.popOut && html.length === 0 && Array.isArray(this.options.svelte)) {
      throw new Error(
        "SvelteApplication - _injectHTML - A popout app with no template can only support one Svelte component."
      );
    }
    this.reactive.updateHeaderButtons();
    const elementRootUpdate = () => {
      let cntr = 0;
      return (elementRoot) => {
        if (elementRoot !== null && elementRoot !== void 0 && cntr++ > 0) {
          this.#updateApplicationShell();
          return true;
        }
        return false;
      };
    };
    if (Array.isArray(this.options.svelte)) {
      for (const svelteConfig of this.options.svelte) {
        const svelteData = loadSvelteConfig({
          app: this,
          template: html[0],
          config: svelteConfig,
          elementRootUpdate
        });
        if (isApplicationShell(svelteData.component)) {
          if (this.svelte.applicationShell !== null) {
            throw new Error(
              `SvelteApplication - _injectHTML - An application shell is already mounted; offending config:
                    ${JSON.stringify(svelteConfig)}`
            );
          }
          this.#applicationShellHolder[0] = svelteData.component;
          if (isHMRProxy(svelteData.component) && Array.isArray(svelteData.component?.$$?.on_hmr)) {
            svelteData.component.$$.on_hmr.push(() => () => this.#updateApplicationShell());
          }
        }
        this.#svelteData.push(svelteData);
      }
    } else if (isObject(this.options.svelte)) {
      const svelteData = loadSvelteConfig({
        app: this,
        template: html[0],
        config: this.options.svelte,
        elementRootUpdate
      });
      if (isApplicationShell(svelteData.component)) {
        if (this.svelte.applicationShell !== null) {
          throw new Error(
            `SvelteApplication - _injectHTML - An application shell is already mounted; offending config:
                 ${JSON.stringify(this.options.svelte)}`
          );
        }
        this.#applicationShellHolder[0] = svelteData.component;
        if (isHMRProxy(svelteData.component) && Array.isArray(svelteData.component?.$$?.on_hmr)) {
          svelteData.component.$$.on_hmr.push(() => () => this.#updateApplicationShell());
        }
      }
      this.#svelteData.push(svelteData);
    }
    const isDocumentFragment = html.length && html[0] instanceof DocumentFragment;
    let injectHTML = true;
    for (const svelteData of this.#svelteData) {
      if (!svelteData.injectHTML) {
        injectHTML = false;
        break;
      }
    }
    if (injectHTML) {
      super._injectHTML(html);
    }
    if (this.svelte.applicationShell !== null) {
      this._element = $(this.svelte.applicationShell.elementRoot);
      this.#elementContent = hasGetter(this.svelte.applicationShell, "elementContent") ? this.svelte.applicationShell.elementContent : null;
      this.#elementTarget = hasGetter(this.svelte.applicationShell, "elementTarget") ? this.svelte.applicationShell.elementTarget : null;
    } else if (isDocumentFragment) {
      for (const svelteData of this.#svelteData) {
        if (svelteData.element instanceof HTMLElement) {
          this._element = $(svelteData.element);
          break;
        }
      }
    }
    if (this.#elementTarget === null) {
      this.#elementTarget = typeof this.options.selectorTarget === "string" ? this._element[0].querySelector(this.options.selectorTarget) : this._element[0];
    }
    if (this.#elementTarget === null || this.#elementTarget === void 0) {
      throw new Error(`SvelteApplication - _injectHTML: Target element '${this.options.selectorTarget}' not found.`);
    }
    if (typeof this.options.positionable === "boolean" && this.options.positionable) {
      this.#elementTarget.style.zIndex = typeof this.options.zIndex === "number" ? this.options.zIndex : this.#initialZIndex ?? 95;
    }
    this.#stores.subscribe();
  }
  /**
   * Provides a mechanism to update the UI options store for maximized.
   *
   * Note: the sanity check is duplicated from {@link Application.maximize} the store is updated _before_
   * performing the rest of animations. This allows application shells to remove / show any resize handlers
   * correctly. Extra constraint data is stored in a saved position state in {@link SvelteApplication.minimize}
   * to animate the content area.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.animate=true] - When true perform default maximizing animation.
   *
   * @param {number}   [opts.duration=0.1] - Controls content area animation duration in seconds.
   */
  async maximize({ animate: animate2 = true, duration = 0.1 } = {}) {
    if (!this.popOut || [false, null].includes(this._minimized)) {
      return;
    }
    this._minimized = null;
    const durationMS = duration * 1e3;
    const element2 = this.elementTarget;
    const header = element2.querySelector(".window-header");
    const content = element2.querySelector(".window-content");
    const positionBefore = this.position.state.get({ name: "#beforeMinimized" });
    if (animate2) {
      await this.position.state.restore({
        name: "#beforeMinimized",
        async: true,
        animateTo: true,
        properties: ["width"],
        duration: 0.1
      });
    }
    element2.classList.remove("minimized");
    for (let cntr = header.children.length; --cntr >= 0; ) {
      header.children[cntr].style.display = null;
    }
    content.style.display = null;
    let constraints;
    if (animate2) {
      ({ constraints } = this.position.state.restore({
        name: "#beforeMinimized",
        animateTo: true,
        properties: ["height"],
        remove: true,
        duration
      }));
    } else {
      ({ constraints } = this.position.state.remove({ name: "#beforeMinimized" }));
    }
    await content.animate([
      { maxHeight: 0, paddingTop: 0, paddingBottom: 0, offset: 0 },
      { ...constraints, offset: 1 },
      { maxHeight: "100%", offset: 1 }
    ], { duration: durationMS, fill: "forwards" }).finished;
    this.position.set({
      minHeight: positionBefore.minHeight ?? this.options?.minHeight ?? MIN_WINDOW_HEIGHT,
      minWidth: positionBefore.minWidth ?? this.options?.minWidth ?? MIN_WINDOW_WIDTH
    });
    element2.style.minWidth = null;
    element2.style.minHeight = null;
    this._minimized = false;
    setTimeout(() => {
      content.style.overflow = null;
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = null;
      }
    }, 50);
    this.#stores.uiOptionsUpdate((options2) => deepMerge(options2, { minimized: false }));
  }
  /**
   * Provides a mechanism to update the UI options store for minimized.
   *
   * Note: the sanity check is duplicated from {@link Application.minimize} the store is updated _before_
   * performing the rest of animations. This allows application shells to remove / show any resize handlers
   * correctly. Extra constraint data is stored in a saved position state in {@link SvelteApplication.minimize}
   * to animate the content area.
   *
   * @param {object}   [opts] - Optional parameters
   *
   * @param {boolean}  [opts.animate=true] - When true perform default minimizing animation.
   *
   * @param {number}   [opts.duration=0.1] - Controls content area animation duration in seconds.
   */
  async minimize({ animate: animate2 = true, duration = 0.1 } = {}) {
    if (!this.rendered || !this.popOut || [true, null].includes(this._minimized)) {
      return;
    }
    this.#stores.uiOptionsUpdate((options2) => deepMerge(options2, { minimized: true }));
    this._minimized = null;
    const durationMS = duration * 1e3;
    const element2 = this.elementTarget;
    const header = element2.querySelector(".window-header");
    const content = element2.querySelector(".window-content");
    const beforeMinWidth = this.position.minWidth;
    const beforeMinHeight = this.position.minHeight;
    this.position.set({ minWidth: 100, minHeight: 30 });
    element2.style.minWidth = "100px";
    element2.style.minHeight = "30px";
    if (content) {
      content.style.overflow = "hidden";
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = "hidden";
      }
    }
    const { paddingBottom, paddingTop } = globalThis.getComputedStyle(content);
    const constraints = {
      maxHeight: `${content.clientHeight}px`,
      paddingTop,
      paddingBottom
    };
    if (animate2) {
      const animation = content.animate([
        constraints,
        { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
      ], { duration: durationMS, fill: "forwards" });
      animation.finished.then(() => content.style.display = "none");
    } else {
      setTimeout(() => content.style.display = "none", durationMS);
    }
    const saved = this.position.state.save({ name: "#beforeMinimized", constraints });
    saved.minWidth = beforeMinWidth;
    saved.minHeight = beforeMinHeight;
    const headerOffsetHeight = header.offsetHeight;
    this.position.minHeight = headerOffsetHeight;
    if (animate2) {
      await this.position.animate.to({ height: headerOffsetHeight }, { duration }).finished;
    }
    for (let cntr = header.children.length; --cntr >= 0; ) {
      const className = header.children[cntr].className;
      if (className.includes("window-title") || className.includes("close")) {
        continue;
      }
      if (className.includes("keep-minimized")) {
        header.children[cntr].style.display = "block";
        continue;
      }
      header.children[cntr].style.display = "none";
    }
    if (animate2) {
      await this.position.animate.to({ width: MIN_WINDOW_WIDTH }, { duration: 0.1 }).finished;
    }
    element2.classList.add("minimized");
    this._minimized = true;
  }
  /**
   * Provides a callback after all Svelte components are initialized.
   *
   * @param {object}      [opts] - Optional parameters.
   *
   * @param {HTMLElement} [opts.element] - HTMLElement container for main application element.
   *
   * @param {HTMLElement} [opts.elementContent] - HTMLElement container for content area of application shells.
   *
   * @param {HTMLElement} [opts.elementTarget] - HTMLElement container for main application target element.
   */
  onSvelteMount({ element: element2, elementContent, elementTarget } = {}) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Provides a callback after the main application shell is remounted. This may occur during HMR / hot module
   * replacement or directly invoked from the `elementRootUpdate` callback passed to the application shell component
   * context.
   *
   * @param {object}      [opts] - Optional parameters.
   *
   * @param {HTMLElement} [opts.element] - HTMLElement container for main application element.
   *
   * @param {HTMLElement} [opts.elementContent] - HTMLElement container for content area of application shells.
   *
   * @param {HTMLElement} [opts.elementTarget] - HTMLElement container for main application target element.
   */
  onSvelteRemount({ element: element2, elementContent, elementTarget } = {}) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Override replacing HTML as Svelte components control the rendering process. Only potentially change the outer
   * application frame / title for pop-out applications.
   *
   * @inheritDoc
   * @ignore
   */
  _replaceHTML(element2, html) {
    if (!element2.length) {
      return;
    }
    this.reactive.updateHeaderButtons();
  }
  /**
   * Provides an override verifying that a new Application being rendered for the first time doesn't have a
   * corresponding DOM element already loaded. This is a check that only occurs when `this._state` is
   * `Application.RENDER_STATES.NONE`. It is useful in particular when SvelteApplication has a static ID
   * explicitly set in `this.options.id` and long intro / outro transitions are assigned. If a new application
   * sharing this static ID attempts to open / render for the first time while an existing DOM element sharing
   * this static ID exists then the initial render is cancelled below rather than crashing later in the render
   * cycle {@link Position.set}.
   *
   * @inheritDoc
   * @protected
   * @ignore
   */
  async _render(force = false, options2 = {}) {
    if (isObject(options2?.focusSource)) {
      this.options.focusSource = options2.focusSource;
    }
    if (this._state === Application.RENDER_STATES.NONE && document.querySelector(`#${this.id}`) instanceof HTMLElement) {
      console.warn(`SvelteApplication - _render: A DOM element already exists for CSS ID '${this.id}'. Cancelling initial render for new application with appId '${this.appId}'.`);
      return;
    }
    await super._render(force, options2);
    if (!this.#onMount) {
      this.onSvelteMount({ element: this._element[0], elementContent: this.#elementContent, elementTarget: this.#elementTarget });
      this.#onMount = true;
    }
  }
  /**
   * Render the inner application content. Only render a template if one is defined otherwise provide an empty
   * JQuery element per the core Foundry API.
   *
   * @param {object} data         The data used to render the inner template
   *
   * @returns {Promise.<JQuery>}   A promise resolving to the constructed jQuery object
   *
   * @protected
   * @ignore
   */
  async _renderInner(data2) {
    const html = typeof this.template === "string" ? await renderTemplate(this.template, data2) : document.createDocumentFragment();
    return $(html);
  }
  /**
   * Stores the initial z-index set in `_renderOuter` which is used in `_injectHTML` to set the target element
   * z-index after the Svelte component is mounted.
   *
   * @returns {Promise<JQuery>} Outer frame / unused.
   * @protected
   * @ignore
   */
  async _renderOuter() {
    const html = await super._renderOuter();
    this.#initialZIndex = html[0].style.zIndex;
    return html;
  }
  /**
   * All calculation and updates of position are implemented in {@link Position.set}. This allows position to be fully
   * reactive and in control of updating inline styles for the application.
   *
   * This method remains for backward compatibility with Foundry. If you have a custom override quite likely you need
   * to update to using the {@link Position.validators} functionality.
   *
   * @param {PositionDataExtended}   [position] - Position data.
   *
   * @returns {Position} The updated position object for the application containing the new values
   */
  setPosition(position) {
    return this.position.set(position);
  }
  /**
   * This method is invoked by the `elementRootUpdate` callback that is added to the external context passed to
   * Svelte components. When invoked it updates the local element roots tracked by SvelteApplication.
   *
   * This method may also be invoked by HMR / hot module replacement via `svelte-hmr`.
   */
  #updateApplicationShell() {
    const applicationShell = this.svelte.applicationShell;
    if (applicationShell !== null) {
      this._element = $(applicationShell.elementRoot);
      this.#elementContent = hasGetter(applicationShell, "elementContent") ? applicationShell.elementContent : null;
      this.#elementTarget = hasGetter(applicationShell, "elementTarget") ? applicationShell.elementTarget : null;
      if (this.#elementTarget === null) {
        this.#elementTarget = typeof this.options.selectorTarget === "string" ? this._element[0].querySelector(this.options.selectorTarget) : this._element[0];
      }
      if (typeof this.options.positionable === "boolean" && this.options.positionable) {
        this.#elementTarget.style.zIndex = typeof this.options.zIndex === "number" ? this.options.zIndex : this.#initialZIndex ?? 95;
        super.bringToTop();
        this.position.set(this.position.get());
      }
      super._activateCoreListeners([this.#elementTarget]);
      this.onSvelteRemount({ element: this._element[0], elementContent: this.#elementContent, elementTarget: this.#elementTarget });
    }
  }
}
const s_STYLE_KEY$1 = "#__trl-root-styles";
const cssVariables$1 = new StyleManager({ docKey: s_STYLE_KEY$1, version: 1 });
const TJSContainer_svelte_svelte_type_style_lang = "";
function resizeObserver(node, target2) {
  ResizeObserverManager.add(node, target2);
  return {
    update: (newTarget) => {
      ResizeObserverManager.remove(node, target2);
      target2 = newTarget;
      ResizeObserverManager.add(node, target2);
    },
    destroy: () => {
      ResizeObserverManager.remove(node, target2);
    }
  };
}
resizeObserver.updateCache = function(el) {
  if (!(el instanceof HTMLElement)) {
    throw new TypeError(`resizeObserverUpdate error: 'el' is not an HTMLElement.`);
  }
  const subscribers = s_MAP.get(el);
  if (Array.isArray(subscribers)) {
    const computed = globalThis.getComputedStyle(el);
    const borderBottom = styleParsePixels(el.style.borderBottom) ?? styleParsePixels(computed.borderBottom) ?? 0;
    const borderLeft = styleParsePixels(el.style.borderLeft) ?? styleParsePixels(computed.borderLeft) ?? 0;
    const borderRight = styleParsePixels(el.style.borderRight) ?? styleParsePixels(computed.borderRight) ?? 0;
    const borderTop = styleParsePixels(el.style.borderTop) ?? styleParsePixels(computed.borderTop) ?? 0;
    const paddingBottom = styleParsePixels(el.style.paddingBottom) ?? styleParsePixels(computed.paddingBottom) ?? 0;
    const paddingLeft = styleParsePixels(el.style.paddingLeft) ?? styleParsePixels(computed.paddingLeft) ?? 0;
    const paddingRight = styleParsePixels(el.style.paddingRight) ?? styleParsePixels(computed.paddingRight) ?? 0;
    const paddingTop = styleParsePixels(el.style.paddingTop) ?? styleParsePixels(computed.paddingTop) ?? 0;
    const additionalWidth = borderLeft + borderRight + paddingLeft + paddingRight;
    const additionalHeight = borderTop + borderBottom + paddingTop + paddingBottom;
    for (const subscriber of subscribers) {
      subscriber.styles.additionalWidth = additionalWidth;
      subscriber.styles.additionalHeight = additionalHeight;
      s_UPDATE_SUBSCRIBER(subscriber, subscriber.contentWidth, subscriber.contentHeight);
    }
  }
};
const s_MAP = /* @__PURE__ */ new Map();
class ResizeObserverManager {
  /**
   * Add an HTMLElement and ResizeObserverTarget instance for monitoring. Create cached style attributes for the
   * given element include border & padding dimensions for offset width / height calculations.
   *
   * @param {HTMLElement}    el - The element to observe.
   *
   * @param {ResizeObserverTarget} target - A target that contains one of several mechanisms for updating resize data.
   */
  static add(el, target2) {
    const updateType = s_GET_UPDATE_TYPE(target2);
    if (updateType === 0) {
      throw new Error(`'target' does not match supported ResizeObserverManager update mechanisms.`);
    }
    const computed = globalThis.getComputedStyle(el);
    const borderBottom = styleParsePixels(el.style.borderBottom) ?? styleParsePixels(computed.borderBottom) ?? 0;
    const borderLeft = styleParsePixels(el.style.borderLeft) ?? styleParsePixels(computed.borderLeft) ?? 0;
    const borderRight = styleParsePixels(el.style.borderRight) ?? styleParsePixels(computed.borderRight) ?? 0;
    const borderTop = styleParsePixels(el.style.borderTop) ?? styleParsePixels(computed.borderTop) ?? 0;
    const paddingBottom = styleParsePixels(el.style.paddingBottom) ?? styleParsePixels(computed.paddingBottom) ?? 0;
    const paddingLeft = styleParsePixels(el.style.paddingLeft) ?? styleParsePixels(computed.paddingLeft) ?? 0;
    const paddingRight = styleParsePixels(el.style.paddingRight) ?? styleParsePixels(computed.paddingRight) ?? 0;
    const paddingTop = styleParsePixels(el.style.paddingTop) ?? styleParsePixels(computed.paddingTop) ?? 0;
    const data2 = {
      updateType,
      target: target2,
      // Stores most recent contentRect.width and contentRect.height values from ResizeObserver.
      contentWidth: 0,
      contentHeight: 0,
      // Convenience data for total border & padding for offset width & height calculations.
      styles: {
        additionalWidth: borderLeft + borderRight + paddingLeft + paddingRight,
        additionalHeight: borderTop + borderBottom + paddingTop + paddingBottom
      }
    };
    if (s_MAP.has(el)) {
      const subscribers = s_MAP.get(el);
      subscribers.push(data2);
    } else {
      s_MAP.set(el, [data2]);
    }
    s_RESIZE_OBSERVER.observe(el);
  }
  /**
   * Removes all targets from monitoring when just an element is provided otherwise removes a specific target
   * from the monitoring map. If no more targets remain then the element is removed from monitoring.
   *
   * @param {HTMLElement}          el - Element to remove from monitoring.
   *
   * @param {ResizeObserverTarget} [target] - A specific target to remove from monitoring.
   */
  static remove(el, target2 = void 0) {
    const subscribers = s_MAP.get(el);
    if (Array.isArray(subscribers)) {
      const index = subscribers.findIndex((entry) => entry.target === target2);
      if (index >= 0) {
        s_UPDATE_SUBSCRIBER(subscribers[index], void 0, void 0);
        subscribers.splice(index, 1);
      }
      if (subscribers.length === 0) {
        s_MAP.delete(el);
        s_RESIZE_OBSERVER.unobserve(el);
      }
    }
  }
}
const s_UPDATE_TYPES = {
  none: 0,
  attribute: 1,
  function: 2,
  resizeObserved: 3,
  setContentBounds: 4,
  setDimension: 5,
  storeObject: 6,
  storesObject: 7
};
const s_RESIZE_OBSERVER = new ResizeObserver((entries) => {
  for (const entry of entries) {
    const subscribers = s_MAP.get(entry?.target);
    if (Array.isArray(subscribers)) {
      const contentWidth = entry.contentRect.width;
      const contentHeight = entry.contentRect.height;
      for (const subscriber of subscribers) {
        s_UPDATE_SUBSCRIBER(subscriber, contentWidth, contentHeight);
      }
    }
  }
});
function s_GET_UPDATE_TYPE(target2) {
  if (target2?.resizeObserved instanceof Function) {
    return s_UPDATE_TYPES.resizeObserved;
  }
  if (target2?.setDimension instanceof Function) {
    return s_UPDATE_TYPES.setDimension;
  }
  if (target2?.setContentBounds instanceof Function) {
    return s_UPDATE_TYPES.setContentBounds;
  }
  const targetType = typeof target2;
  if (targetType !== null && (targetType === "object" || targetType === "function")) {
    if (isUpdatableStore(target2.resizeObserved)) {
      return s_UPDATE_TYPES.storeObject;
    }
    const stores = target2?.stores;
    if (isObject(stores) || typeof stores === "function") {
      if (isUpdatableStore(stores.resizeObserved)) {
        return s_UPDATE_TYPES.storesObject;
      }
    }
  }
  if (targetType !== null && targetType === "object") {
    return s_UPDATE_TYPES.attribute;
  }
  if (targetType === "function") {
    return s_UPDATE_TYPES.function;
  }
  return s_UPDATE_TYPES.none;
}
function s_UPDATE_SUBSCRIBER(subscriber, contentWidth, contentHeight) {
  const styles = subscriber.styles;
  subscriber.contentWidth = contentWidth;
  subscriber.contentHeight = contentHeight;
  const offsetWidth = Number.isFinite(contentWidth) ? contentWidth + styles.additionalWidth : void 0;
  const offsetHeight = Number.isFinite(contentHeight) ? contentHeight + styles.additionalHeight : void 0;
  const target2 = subscriber.target;
  switch (subscriber.updateType) {
    case s_UPDATE_TYPES.attribute:
      target2.contentWidth = contentWidth;
      target2.contentHeight = contentHeight;
      target2.offsetWidth = offsetWidth;
      target2.offsetHeight = offsetHeight;
      break;
    case s_UPDATE_TYPES.function:
      target2?.(offsetWidth, offsetHeight, contentWidth, contentHeight);
      break;
    case s_UPDATE_TYPES.resizeObserved:
      target2.resizeObserved?.(offsetWidth, offsetHeight, contentWidth, contentHeight);
      break;
    case s_UPDATE_TYPES.setContentBounds:
      target2.setContentBounds?.(contentWidth, contentHeight);
      break;
    case s_UPDATE_TYPES.setDimension:
      target2.setDimension?.(offsetWidth, offsetHeight);
      break;
    case s_UPDATE_TYPES.storeObject:
      target2.resizeObserved.update((object) => {
        object.contentHeight = contentHeight;
        object.contentWidth = contentWidth;
        object.offsetHeight = offsetHeight;
        object.offsetWidth = offsetWidth;
        return object;
      });
      break;
    case s_UPDATE_TYPES.storesObject:
      target2.stores.resizeObserved.update((object) => {
        object.contentHeight = contentHeight;
        object.contentWidth = contentWidth;
        object.offsetHeight = offsetHeight;
        object.offsetWidth = offsetWidth;
        return object;
      });
      break;
  }
}
function applyScrolltop(element2, store) {
  if (!isWritableStore(store)) {
    throw new TypeError(`applyScrolltop error: 'store' must be a writable Svelte store.`);
  }
  function storeUpdate(value) {
    if (!Number.isFinite(value)) {
      return;
    }
    setTimeout(() => element2.scrollTop = value, 0);
  }
  let unsubscribe = store.subscribe(storeUpdate);
  const resizeControl = resizeObserver(element2, debounce(() => {
    if (element2.isConnected) {
      store.set(element2.scrollTop);
    }
  }, 500));
  function onScroll(event) {
    store.set(event.target.scrollTop);
  }
  const debounceFn = debounce((e) => onScroll(e), 500);
  element2.addEventListener("scroll", debounceFn);
  return {
    update: (newStore) => {
      unsubscribe();
      store = newStore;
      if (!isWritableStore(store)) {
        throw new TypeError(`applyScrolltop.update error: 'store' must be a writable Svelte store.`);
      }
      unsubscribe = store.subscribe(storeUpdate);
    },
    destroy: () => {
      element2.removeEventListener("scroll", debounceFn);
      unsubscribe();
      resizeControl.destroy();
    }
  };
}
function applyStyles(node, properties) {
  function setProperties() {
    if (typeof properties !== "object") {
      return;
    }
    for (const prop of Object.keys(properties)) {
      node.style.setProperty(`${prop}`, properties[prop]);
    }
  }
  setProperties();
  return {
    update(newProperties) {
      properties = newProperties;
      setProperties();
    }
  };
}
function draggable(node, {
  position,
  active: active2 = true,
  button = 0,
  storeDragging = void 0,
  ease = false,
  easeOptions = { duration: 0.1, ease: cubicOut },
  hasTargetClassList,
  ignoreTargetClassList
}) {
  if (hasTargetClassList !== void 0 && !isIterable(hasTargetClassList)) {
    throw new TypeError(`'hasTargetClassList' is not iterable.`);
  }
  if (ignoreTargetClassList !== void 0 && !isIterable(ignoreTargetClassList)) {
    throw new TypeError(`'ignoreTargetClassList' is not iterable.`);
  }
  let initialPosition = null;
  let initialDragPoint = {};
  let dragging = false;
  let quickTo = position.animate.quickTo(["top", "left"], easeOptions);
  const handlers = {
    dragDown: ["pointerdown", (e) => onDragPointerDown(e), false],
    dragMove: ["pointermove", (e) => onDragPointerChange(e), false],
    dragUp: ["pointerup", (e) => onDragPointerUp(e), false]
  };
  function activateListeners() {
    node.addEventListener(...handlers.dragDown);
    node.classList.add("draggable");
  }
  function removeListeners() {
    if (typeof storeDragging?.set === "function") {
      storeDragging.set(false);
    }
    node.removeEventListener(...handlers.dragDown);
    node.removeEventListener(...handlers.dragMove);
    node.removeEventListener(...handlers.dragUp);
    node.classList.remove("draggable");
  }
  if (active2) {
    activateListeners();
  }
  function onDragPointerDown(event) {
    if (event.button !== button || !event.isPrimary) {
      return;
    }
    if (!position.enabled) {
      return;
    }
    if (ignoreTargetClassList !== void 0 && event.target instanceof HTMLElement) {
      for (const targetClass of ignoreTargetClassList) {
        if (event.target.classList.contains(targetClass)) {
          return;
        }
      }
    }
    if (hasTargetClassList !== void 0 && event.target instanceof HTMLElement) {
      let foundTarget = false;
      for (const targetClass of hasTargetClassList) {
        if (event.target.classList.contains(targetClass)) {
          foundTarget = true;
          break;
        }
      }
      if (!foundTarget) {
        return;
      }
    }
    event.preventDefault();
    dragging = false;
    initialPosition = position.get();
    initialDragPoint = { x: event.clientX, y: event.clientY };
    node.addEventListener(...handlers.dragMove);
    node.addEventListener(...handlers.dragUp);
    node.setPointerCapture(event.pointerId);
  }
  function onDragPointerChange(event) {
    if ((event.buttons & 1) === 0) {
      onDragPointerUp(event);
      return;
    }
    if (event.button !== -1 || !event.isPrimary) {
      return;
    }
    event.preventDefault();
    if (!dragging && typeof storeDragging?.set === "function") {
      dragging = true;
      storeDragging.set(true);
    }
    const newLeft = initialPosition.left + (event.clientX - initialDragPoint.x);
    const newTop = initialPosition.top + (event.clientY - initialDragPoint.y);
    if (ease) {
      quickTo(newTop, newLeft);
    } else {
      s_POSITION_DATA.left = newLeft;
      s_POSITION_DATA.top = newTop;
      position.set(s_POSITION_DATA);
    }
  }
  function onDragPointerUp(event) {
    event.preventDefault();
    dragging = false;
    if (typeof storeDragging?.set === "function") {
      storeDragging.set(false);
    }
    node.removeEventListener(...handlers.dragMove);
    node.removeEventListener(...handlers.dragUp);
  }
  return {
    // The default of active being true won't automatically add listeners twice.
    update: (options2) => {
      if (typeof options2.active === "boolean") {
        active2 = options2.active;
        if (active2) {
          activateListeners();
        } else {
          removeListeners();
        }
      }
      if (typeof options2.button === "number") {
        button = options2.button;
      }
      if (options2.position !== void 0 && options2.position !== position) {
        position = options2.position;
        quickTo = position.animate.quickTo(["top", "left"], easeOptions);
      }
      if (typeof options2.ease === "boolean") {
        ease = options2.ease;
      }
      if (isObject(options2.easeOptions)) {
        easeOptions = options2.easeOptions;
        quickTo.options(easeOptions);
      }
      if (options2.hasTargetClassList !== void 0) {
        if (!isIterable(options2.hasTargetClassList)) {
          throw new TypeError(`'hasTargetClassList' is not iterable.`);
        } else {
          hasTargetClassList = options2.hasTargetClassList;
        }
      }
      if (options2.ignoreTargetClassList !== void 0) {
        if (!isIterable(options2.ignoreTargetClassList)) {
          throw new TypeError(`'ignoreTargetClassList' is not iterable.`);
        } else {
          ignoreTargetClassList = options2.ignoreTargetClassList;
        }
      }
    },
    destroy: () => removeListeners()
  };
}
class DraggableOptions {
  #ease = false;
  #easeOptions = { duration: 0.1, ease: cubicOut };
  /**
   * Stores the subscribers.
   *
   * @type {(function(DraggableOptions): void)[]}
   */
  #subscriptions = [];
  constructor({ ease, easeOptions } = {}) {
    Object.defineProperty(this, "ease", {
      get: () => {
        return this.#ease;
      },
      set: (newEase) => {
        if (typeof newEase !== "boolean") {
          throw new TypeError(`'ease' is not a boolean.`);
        }
        this.#ease = newEase;
        this.#updateSubscribers();
      },
      enumerable: true
    });
    Object.defineProperty(this, "easeOptions", {
      get: () => {
        return this.#easeOptions;
      },
      set: (newEaseOptions) => {
        if (newEaseOptions === null || typeof newEaseOptions !== "object") {
          throw new TypeError(`'easeOptions' is not an object.`);
        }
        if (newEaseOptions.duration !== void 0) {
          if (!Number.isFinite(newEaseOptions.duration)) {
            throw new TypeError(`'easeOptions.duration' is not a finite number.`);
          }
          if (newEaseOptions.duration < 0) {
            throw new Error(`'easeOptions.duration' is less than 0.`);
          }
          this.#easeOptions.duration = newEaseOptions.duration;
        }
        if (newEaseOptions.ease !== void 0) {
          if (typeof newEaseOptions.ease !== "function" && typeof newEaseOptions.ease !== "string") {
            throw new TypeError(`'easeOptions.ease' is not a function or string.`);
          }
          this.#easeOptions.ease = newEaseOptions.ease;
        }
        this.#updateSubscribers();
      },
      enumerable: true
    });
    if (ease !== void 0) {
      this.ease = ease;
    }
    if (easeOptions !== void 0) {
      this.easeOptions = easeOptions;
    }
  }
  /**
   * @returns {number} Get ease duration
   */
  get easeDuration() {
    return this.#easeOptions.duration;
  }
  /**
   * @returns {string|Function} Get easing function value.
   */
  get easeValue() {
    return this.#easeOptions.ease;
  }
  /**
   * @param {number}   duration - Set ease duration.
   */
  set easeDuration(duration) {
    if (!Number.isFinite(duration)) {
      throw new TypeError(`'duration' is not a finite number.`);
    }
    if (duration < 0) {
      throw new Error(`'duration' is less than 0.`);
    }
    this.#easeOptions.duration = duration;
    this.#updateSubscribers();
  }
  /**
   * @param {string|Function} value - Get easing function value.
   */
  set easeValue(value) {
    if (typeof value !== "function" && typeof value !== "string") {
      throw new TypeError(`'value' is not a function or string.`);
    }
    this.#easeOptions.ease = value;
    this.#updateSubscribers();
  }
  /**
   * Resets all options data to default values.
   */
  reset() {
    this.#ease = false;
    this.#easeOptions = { duration: 0.1, ease: cubicOut };
    this.#updateSubscribers();
  }
  /**
   * Resets easing options to default values.
   */
  resetEase() {
    this.#easeOptions = { duration: 0.1, ease: cubicOut };
    this.#updateSubscribers();
  }
  /**
   *
   * @param {function(DraggableOptions): void} handler - Callback function that is invoked on update / changes.
   *                                                 Receives the DraggableOptions object / instance.
   *
   * @returns {(function(): void)} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  #updateSubscribers() {
    const subscriptions = this.#subscriptions;
    if (subscriptions.length > 0) {
      for (let cntr = 0; cntr < subscriptions.length; cntr++) {
        subscriptions[cntr](this);
      }
    }
  }
}
draggable.options = (options2) => new DraggableOptions(options2);
const s_POSITION_DATA = { left: 0, top: 0 };
function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map((e) => `${e[0].toUpperCase()}${e.slice(1)}`);
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(style[`border${capitalized_secondary_properties[0]}Width`]);
  const border_width_end_value = parseFloat(style[`border${capitalized_secondary_properties[1]}Width`]);
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};${primary_property}: ${t * primary_property_value}px;padding-${secondary_properties[0]}: ${t * padding_start_value}px;padding-${secondary_properties[1]}: ${t * padding_end_value}px;margin-${secondary_properties[0]}: ${t * margin_start_value}px;margin-${secondary_properties[1]}: ${t * margin_end_value}px;border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
  };
}
function slideFade(node, options2) {
  const fadeEasing = options2.easingFade || options2.easing || identity;
  const slideEasing = options2.easingSlide || options2.easing || identity;
  const fadeTransition = fade(node);
  const slideTransition = slide(node);
  return {
    delay: options2.delay || 0,
    duration: options2.duration || 500,
    easing: identity,
    css: (t) => {
      const fadeT = fadeEasing(t);
      const slideT = slideEasing(t);
      return `${slideTransition.css(slideT, 1 - slideT)}; ${fadeTransition.css(fadeT, 1 - fadeT)}`;
    }
  };
}
const s_DEFAULT_TRANSITION = () => void 0;
const s_DEFAULT_TRANSITION_OPTIONS = {};
const TJSGlassPane_svelte_svelte_type_style_lang = "";
function create_else_block$i(ctx) {
  let div;
  let applyStyles_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "tjs-glass-pane-background svelte-auto-hqedxf");
      set_style(
        div,
        "background",
        /*background*/
        ctx[5]
      );
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[22](div);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(applyStyles_action = applyStyles.call(
          null,
          div,
          /*styles*/
          ctx[7]
        ));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      128)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx[7]
        );
      if (dirty & /*background*/
      32) {
        set_style(
          div,
          "background",
          /*background*/
          ctx[5]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(
          div,
          /*inTransition*/
          ctx[1],
          /*inTransitionOptions*/
          ctx[3]
        );
        div_intro.start();
      });
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(
        div,
        /*outTransition*/
        ctx[2],
        /*outTransitionOptions*/
        ctx[4]
      );
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$t(ctx) {
  let div0;
  let applyStyles_action;
  let div0_intro;
  let div0_outro;
  let t;
  let div1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  return {
    c() {
      div0 = element("div");
      t = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "tjs-glass-pane-background svelte-auto-hqedxf");
      set_style(
        div0,
        "background",
        /*background*/
        ctx[5]
      );
      attr(div1, "class", "tjs-glass-pane-container svelte-auto-hqedxf");
    },
    m(target2, anchor) {
      insert(target2, div0, anchor);
      ctx[20](div0);
      insert(target2, t, anchor);
      insert(target2, div1, anchor);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      ctx[21](div1);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(applyStyles_action = applyStyles.call(
          null,
          div0,
          /*styles*/
          ctx[7]
        ));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      128)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx[7]
        );
      if (dirty & /*background*/
      32) {
        set_style(
          div0,
          "background",
          /*background*/
          ctx[5]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (div0_outro)
          div0_outro.end(1);
        div0_intro = create_in_transition(
          div0,
          /*inTransition*/
          ctx[1],
          /*inTransitionOptions*/
          ctx[3]
        );
        div0_intro.start();
      });
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      if (div0_intro)
        div0_intro.invalidate();
      div0_outro = create_out_transition(
        div0,
        /*outTransition*/
        ctx[2],
        /*outTransitionOptions*/
        ctx[4]
      );
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      ctx[20](null);
      if (detaching && div0_outro)
        div0_outro.end();
      if (detaching)
        detach(t);
      if (detaching)
        detach(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[21](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1G(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$t, create_else_block$i];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*slotSeparate*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(
        div,
        "id",
        /*id*/
        ctx[6]
      );
      attr(div, "class", "tjs-glass-pane svelte-auto-hqedxf");
      set_style(
        div,
        "z-index",
        /*zIndex*/
        ctx[8]
      );
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[23](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window,
            "contextmenu",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "dblclick",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "keydown",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "keyup",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "mousedown",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "mousemove",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "mouseup",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "pointerdown",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "pointermove",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "pointerup",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "touchend",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "touchmove",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "touchstart",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "wheel",
            /*swallow*/
            ctx[12],
            true
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*id*/
      64) {
        attr(
          div,
          "id",
          /*id*/
          ctx2[6]
        );
      }
      if (dirty & /*zIndex*/
      256) {
        set_style(
          div,
          "z-index",
          /*zIndex*/
          ctx2[8]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1y($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { background = "#50505080" } = $$props;
  let { captureInput = true } = $$props;
  let { id = void 0 } = $$props;
  let { slotSeparate = void 0 } = $$props;
  let { styles = void 0 } = $$props;
  let { zIndex = Number.MAX_SAFE_INTEGER } = $$props;
  let backgroundEl, containerEl, glassPaneEl;
  let { transition = void 0 } = $$props;
  let { inTransition = s_DEFAULT_TRANSITION } = $$props;
  let { outTransition = s_DEFAULT_TRANSITION } = $$props;
  let { transitionOptions = void 0 } = $$props;
  let { inTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS } = $$props;
  let { outTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS } = $$props;
  let oldTransition = void 0;
  let oldTransitionOptions = void 0;
  function swallow(event) {
    const targetEl = event.target;
    if (targetEl !== glassPaneEl && targetEl !== backgroundEl && targetEl !== containerEl && glassPaneEl.contains(targetEl)) {
      return;
    }
    if (captureInput) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      backgroundEl = $$value;
      $$invalidate(9, backgroundEl);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerEl = $$value;
      $$invalidate(10, containerEl);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      backgroundEl = $$value;
      $$invalidate(9, backgroundEl);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      glassPaneEl = $$value;
      $$invalidate(11, glassPaneEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("background" in $$props2)
      $$invalidate(5, background = $$props2.background);
    if ("captureInput" in $$props2)
      $$invalidate(13, captureInput = $$props2.captureInput);
    if ("id" in $$props2)
      $$invalidate(6, id = $$props2.id);
    if ("slotSeparate" in $$props2)
      $$invalidate(0, slotSeparate = $$props2.slotSeparate);
    if ("styles" in $$props2)
      $$invalidate(7, styles = $$props2.styles);
    if ("zIndex" in $$props2)
      $$invalidate(8, zIndex = $$props2.zIndex);
    if ("transition" in $$props2)
      $$invalidate(14, transition = $$props2.transition);
    if ("inTransition" in $$props2)
      $$invalidate(1, inTransition = $$props2.inTransition);
    if ("outTransition" in $$props2)
      $$invalidate(2, outTransition = $$props2.outTransition);
    if ("transitionOptions" in $$props2)
      $$invalidate(15, transitionOptions = $$props2.transitionOptions);
    if ("inTransitionOptions" in $$props2)
      $$invalidate(3, inTransitionOptions = $$props2.inTransitionOptions);
    if ("outTransitionOptions" in $$props2)
      $$invalidate(4, outTransitionOptions = $$props2.outTransitionOptions);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*slotSeparate*/
    1) {
      $$invalidate(0, slotSeparate = typeof slotSeparate === "boolean" ? slotSeparate : false);
    }
    if ($$self.$$.dirty & /*oldTransition, transition*/
    81920) {
      if (oldTransition !== transition) {
        const newTransition = s_DEFAULT_TRANSITION !== transition && typeof transition === "function" ? transition : s_DEFAULT_TRANSITION;
        $$invalidate(1, inTransition = newTransition);
        $$invalidate(2, outTransition = newTransition);
        $$invalidate(16, oldTransition = newTransition);
      }
    }
    if ($$self.$$.dirty & /*oldTransitionOptions, transitionOptions*/
    163840) {
      if (oldTransitionOptions !== transitionOptions) {
        const newOptions = transitionOptions !== s_DEFAULT_TRANSITION_OPTIONS && isObject(transitionOptions) ? transitionOptions : s_DEFAULT_TRANSITION_OPTIONS;
        $$invalidate(3, inTransitionOptions = newOptions);
        $$invalidate(4, outTransitionOptions = newOptions);
        $$invalidate(17, oldTransitionOptions = newOptions);
      }
    }
    if ($$self.$$.dirty & /*inTransition*/
    2) {
      if (typeof inTransition !== "function") {
        $$invalidate(1, inTransition = s_DEFAULT_TRANSITION);
      }
    }
    if ($$self.$$.dirty & /*outTransition*/
    4) {
      if (typeof outTransition !== "function") {
        $$invalidate(2, outTransition = s_DEFAULT_TRANSITION);
      }
    }
    if ($$self.$$.dirty & /*inTransitionOptions*/
    8) {
      if (typeof inTransitionOptions !== "object") {
        $$invalidate(3, inTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS);
      }
    }
    if ($$self.$$.dirty & /*outTransitionOptions*/
    16) {
      if (typeof outTransitionOptions !== "object") {
        $$invalidate(4, outTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS);
      }
    }
  };
  return [
    slotSeparate,
    inTransition,
    outTransition,
    inTransitionOptions,
    outTransitionOptions,
    background,
    id,
    styles,
    zIndex,
    backgroundEl,
    containerEl,
    glassPaneEl,
    swallow,
    captureInput,
    transition,
    transitionOptions,
    oldTransition,
    oldTransitionOptions,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    div_binding,
    div_binding_1
  ];
}
class TJSGlassPane extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1y, create_fragment$1G, safe_not_equal, {
      background: 5,
      captureInput: 13,
      id: 6,
      slotSeparate: 0,
      styles: 7,
      zIndex: 8,
      transition: 14,
      inTransition: 1,
      outTransition: 2,
      transitionOptions: 15,
      inTransitionOptions: 3,
      outTransitionOptions: 4
    });
  }
}
class AppShellContextInternal {
  /** @type {InternalAppStores} */
  #stores;
  constructor() {
    this.#stores = {
      elementContent: writable$1(void 0),
      elementRoot: writable$1(void 0)
    };
    Object.freeze(this.#stores);
    Object.seal(this);
  }
  /**
   * @returns {InternalAppStores} The internal context stores for elementContent / elementRoot
   */
  get stores() {
    return this.#stores;
  }
}
const TJSHeaderButton_svelte_svelte_type_style_lang = "";
function create_if_block$s(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*label*/
        ctx[3]
      );
      attr(span, "class", "svelte-auto-166l8wd");
      toggle_class(
        span,
        "has-icon",
        /*icon*/
        ctx[4] !== void 0
      );
    },
    m(target2, anchor) {
      insert(target2, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*label*/
      8)
        set_data(
          t,
          /*label*/
          ctx2[3]
        );
      if (dirty & /*icon*/
      16) {
        toggle_class(
          span,
          "has-icon",
          /*icon*/
          ctx2[4] !== void 0
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$1F(ctx) {
  let a;
  let html_tag;
  let html_anchor;
  let a_class_value;
  let applyStyles_action;
  let mounted;
  let dispose;
  let if_block = (
    /*label*/
    ctx[3] && create_if_block$s(ctx)
  );
  return {
    c() {
      a = element("a");
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      if (if_block)
        if_block.c();
      html_tag.a = html_anchor;
      attr(a, "class", a_class_value = "header-button " + /*button*/
      ctx[0].class + " svelte-auto-166l8wd");
      attr(
        a,
        "aria-label",
        /*label*/
        ctx[3]
      );
      attr(a, "tabindex", "0");
      attr(a, "role", "button");
      toggle_class(
        a,
        "keep-minimized",
        /*keepMinimized*/
        ctx[2]
      );
    },
    m(target2, anchor) {
      insert(target2, a, anchor);
      html_tag.m(
        /*icon*/
        ctx[4],
        a
      );
      append(a, html_anchor);
      if (if_block)
        if_block.m(a, null);
      if (!mounted) {
        dispose = [
          listen(a, "click", stop_propagation(prevent_default(
            /*onClick*/
            ctx[5]
          ))),
          listen(a, "contextmenu", stop_propagation(prevent_default(
            /*onContextMenu*/
            ctx[6]
          ))),
          listen(
            a,
            "keydown",
            /*onKeydown*/
            ctx[7]
          ),
          listen(
            a,
            "keyup",
            /*onKeyup*/
            ctx[8]
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            a,
            /*styles*/
            ctx[1]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*icon*/
      16)
        html_tag.p(
          /*icon*/
          ctx2[4]
        );
      if (
        /*label*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$s(ctx2);
          if_block.c();
          if_block.m(a, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*button*/
      1 && a_class_value !== (a_class_value = "header-button " + /*button*/
      ctx2[0].class + " svelte-auto-166l8wd")) {
        attr(a, "class", a_class_value);
      }
      if (dirty & /*label*/
      8) {
        attr(
          a,
          "aria-label",
          /*label*/
          ctx2[3]
        );
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      2)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx2[1]
        );
      if (dirty & /*button, keepMinimized*/
      5) {
        toggle_class(
          a,
          "keep-minimized",
          /*keepMinimized*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const s_REGEX_HTML$1 = /^\s*<.*>$/;
function instance$1x($$self, $$props, $$invalidate) {
  let title2;
  let icon;
  let label;
  let keepMinimized;
  let keyCode;
  let styles;
  let { button = void 0 } = $$props;
  function onClick(event) {
    const invoke = button?.onPress ?? button?.onclick;
    if (typeof invoke === "function") {
      invoke.call(button, event);
      $$invalidate(0, button);
    }
  }
  function onContextMenu(event) {
    const invoke = button?.onContextMenu;
    if (typeof invoke === "function") {
      invoke.call(button, event);
      $$invalidate(0, button);
    }
  }
  function onKeydown(event) {
    if (event.code === keyCode) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function onKeyup(event) {
    if (event.code === keyCode) {
      const invoke = button.onPress ?? button.onclick;
      if (typeof invoke === "function") {
        invoke.call(button, event);
        $$invalidate(0, button);
      }
      event.preventDefault();
      event.stopPropagation();
    }
  }
  $$self.$$set = ($$props2) => {
    if ("button" in $$props2)
      $$invalidate(0, button = $$props2.button);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(9, title2 = isObject(button) && typeof button.title === "string" ? localize(button.title) : "");
    }
    if ($$self.$$.dirty & /*button, title*/
    513) {
      $$invalidate(4, icon = isObject(button) && typeof button.icon !== "string" ? void 0 : s_REGEX_HTML$1.test(button.icon) ? button.icon : `<i class="${button.icon}" title="${title2}"></i>`);
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(3, label = isObject(button) && typeof button.label === "string" ? localize(button.label) : void 0);
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(2, keepMinimized = isObject(button) && typeof button.keepMinimized === "boolean" ? button.keepMinimized : false);
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      keyCode = isObject(button) && typeof button.keyCode === "string" ? button.keyCode : "Enter";
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(1, styles = isObject(button) && isObject(button.styles) ? button.styles : void 0);
    }
  };
  return [
    button,
    styles,
    keepMinimized,
    label,
    icon,
    onClick,
    onContextMenu,
    onKeydown,
    onKeyup,
    title2
  ];
}
class TJSHeaderButton extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1x, create_fragment$1F, safe_not_equal, { button: 0 });
  }
  get button() {
    return this.$$.ctx[0];
  }
  set button(button) {
    this.$$set({ button });
    flush();
  }
}
const TJSApplicationHeader_svelte_svelte_type_style_lang = "";
function get_each_context$h(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  return child_ctx;
}
function get_each_context_1$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  return child_ctx;
}
function create_if_block$r(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "tjs-app-icon keep-minimized svelte-auto-1wviwl9");
      if (!src_url_equal(img.src, img_src_value = /*$storeHeaderIcon*/
      ctx[6]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "icon");
    },
    m(target2, anchor) {
      insert(target2, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$storeHeaderIcon*/
      64 && !src_url_equal(img.src, img_src_value = /*$storeHeaderIcon*/
      ctx2[6])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_each_block_1$3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*button*/
    ctx[31].props
  ];
  var switch_value = (
    /*button*/
    ctx[31].class
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & /*buttonsLeft*/
      2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*button*/
        ctx2[31].props
      )]) : {};
      if (dirty[0] & /*buttonsLeft*/
      2 && switch_value !== (switch_value = /*button*/
      ctx2[31].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_each_block$h(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*button*/
    ctx[31].props
  ];
  var switch_value = (
    /*button*/
    ctx[31].class
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & /*buttonsRight*/
      4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*button*/
        ctx2[31].props
      )]) : {};
      if (dirty[0] & /*buttonsRight*/
      4 && switch_value !== (switch_value = /*button*/
      ctx2[31].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_key_block(ctx) {
  let header;
  let t0;
  let h4;
  let t1_value = localize(
    /*$storeTitle*/
    ctx[7]
  ) + "";
  let t1;
  let t2;
  let t3;
  let span;
  let t4;
  let draggable_action;
  let minimizable_action;
  let current;
  let mounted;
  let dispose;
  let if_block = typeof /*$storeHeaderIcon*/
  ctx[6] === "string" && create_if_block$r(ctx);
  let each_value_1 = (
    /*buttonsLeft*/
    ctx[1]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let each_value = (
    /*buttonsRight*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      header = element("header");
      if (if_block)
        if_block.c();
      t0 = space();
      h4 = element("h4");
      t1 = text(t1_value);
      t2 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t3 = space();
      span = element("span");
      t4 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(h4, "class", "window-title svelte-auto-1wviwl9");
      set_style(
        h4,
        "display",
        /*displayHeaderTitle*/
        ctx[4]
      );
      attr(span, "class", "tjs-window-header-spacer keep-minimized svelte-auto-1wviwl9");
      attr(header, "class", "window-header flexrow svelte-auto-1wviwl9");
    },
    m(target2, anchor) {
      insert(target2, header, anchor);
      if (if_block)
        if_block.m(header, null);
      append(header, t0);
      append(header, h4);
      append(h4, t1);
      append(header, t2);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(header, null);
        }
      }
      append(header, t3);
      append(header, span);
      append(header, t4);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(header, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(draggable_action = /*draggable*/
          ctx[0].call(
            null,
            header,
            /*dragOptions*/
            ctx[3]
          )),
          action_destroyer(minimizable_action = /*minimizable*/
          ctx[18].call(
            null,
            header,
            /*$storeMinimizable*/
            ctx[5]
          )),
          listen(
            header,
            "pointerdown",
            /*onPointerdown*/
            ctx[19]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (typeof /*$storeHeaderIcon*/
      ctx2[6] === "string") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$r(ctx2);
          if_block.c();
          if_block.m(header, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if ((!current || dirty[0] & /*$storeTitle*/
      128) && t1_value !== (t1_value = localize(
        /*$storeTitle*/
        ctx2[7]
      ) + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*displayHeaderTitle*/
      16) {
        set_style(
          h4,
          "display",
          /*displayHeaderTitle*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*buttonsLeft*/
      2) {
        each_value_1 = /*buttonsLeft*/
        ctx2[1];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_1$3(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(header, t3);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty[0] & /*buttonsRight*/
      4) {
        each_value = /*buttonsRight*/
        ctx2[2];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$h(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$h(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(header, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
      if (draggable_action && is_function(draggable_action.update) && dirty[0] & /*dragOptions*/
      8)
        draggable_action.update.call(
          null,
          /*dragOptions*/
          ctx2[3]
        );
      if (minimizable_action && is_function(minimizable_action.update) && dirty[0] & /*$storeMinimizable*/
      32)
        minimizable_action.update.call(
          null,
          /*$storeMinimizable*/
          ctx2[5]
        );
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(header);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$1E(ctx) {
  let previous_key = (
    /*draggable*/
    ctx[0]
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target2, anchor) {
      key_block.m(target2, anchor);
      insert(target2, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*draggable*/
      1 && safe_not_equal(previous_key, previous_key = /*draggable*/
      ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function instance$1w($$self, $$props, $$invalidate) {
  let $focusKeep;
  let $focusAuto;
  let $elementRoot;
  let $storeHeaderButtons;
  let $storeMinimized;
  let $storeHeaderNoTitleMinimized;
  let $storeDraggable;
  let $storeMinimizable;
  let $storeHeaderIcon;
  let $storeTitle;
  let { draggable: draggable$1 = void 0 } = $$props;
  let { draggableOptions = void 0 } = $$props;
  const { application } = getContext("#external");
  const { focusAuto, focusKeep } = application.reactive.storeAppOptions;
  component_subscribe($$self, focusAuto, (value) => $$invalidate(26, $focusAuto = value));
  component_subscribe($$self, focusKeep, (value) => $$invalidate(25, $focusKeep = value));
  const { elementRoot } = getContext("#internal").stores;
  component_subscribe($$self, elementRoot, (value) => $$invalidate(27, $elementRoot = value));
  const storeTitle = application.reactive.storeAppOptions.title;
  component_subscribe($$self, storeTitle, (value) => $$invalidate(7, $storeTitle = value));
  const storeDraggable = application.reactive.storeAppOptions.draggable;
  component_subscribe($$self, storeDraggable, (value) => $$invalidate(24, $storeDraggable = value));
  const storeDragging = application.reactive.storeUIState.dragging;
  const storeHeaderButtons = application.reactive.storeUIState.headerButtons;
  component_subscribe($$self, storeHeaderButtons, (value) => $$invalidate(21, $storeHeaderButtons = value));
  const storeHeaderIcon = application.reactive.storeAppOptions.headerIcon;
  component_subscribe($$self, storeHeaderIcon, (value) => $$invalidate(6, $storeHeaderIcon = value));
  const storeHeaderNoTitleMinimized = application.reactive.storeAppOptions.headerNoTitleMinimized;
  component_subscribe($$self, storeHeaderNoTitleMinimized, (value) => $$invalidate(23, $storeHeaderNoTitleMinimized = value));
  const storeMinimizable = application.reactive.storeAppOptions.minimizable;
  component_subscribe($$self, storeMinimizable, (value) => $$invalidate(5, $storeMinimizable = value));
  const storeMinimized = application.reactive.storeUIState.minimized;
  component_subscribe($$self, storeMinimized, (value) => $$invalidate(22, $storeMinimized = value));
  const s_DRAG_TARGET_CLASSLIST = Object.freeze(["tjs-app-icon", "tjs-window-header-spacer", "window-header", "window-title"]);
  let dragOptions;
  let displayHeaderTitle;
  let buttonsLeft;
  let buttonsRight;
  function minimizable(node, booleanStore) {
    const callback = (event) => {
      if (event.target.classList.contains("window-title") || event.target.classList.contains("window-header") || event.target.classList.contains("keep-minimized")) {
        application._onToggleMinimize(event);
      }
    };
    function activateListeners() {
      node.addEventListener("dblclick", callback);
    }
    function removeListeners() {
      node.removeEventListener("dblclick", callback);
    }
    if (booleanStore) {
      activateListeners();
    }
    return {
      update: (booleanStore2) => {
        if (booleanStore2) {
          activateListeners();
        } else {
          removeListeners();
        }
      },
      destroy: () => removeListeners()
    };
  }
  function onPointerdown(event) {
    const rootEl = $elementRoot;
    if ($focusAuto && rootEl instanceof HTMLElement && rootEl?.isConnected) {
      if ($focusKeep) {
        const focusOutside = document.activeElement instanceof HTMLElement && !rootEl.contains(document.activeElement);
        if (focusOutside) {
          rootEl.focus();
        } else {
          event.preventDefault();
        }
      } else {
        rootEl.focus();
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("draggable" in $$props2)
      $$invalidate(0, draggable$1 = $$props2.draggable);
    if ("draggableOptions" in $$props2)
      $$invalidate(20, draggableOptions = $$props2.draggableOptions);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*draggable*/
    1) {
      $$invalidate(0, draggable$1 = typeof draggable$1 === "function" ? draggable$1 : draggable);
    }
    if ($$self.$$.dirty[0] & /*draggableOptions, $storeDraggable*/
    17825792) {
      $$invalidate(3, dragOptions = Object.assign(
        {},
        {
          ease: true,
          easeOptions: { duration: 0.08, ease: cubicOut }
        },
        isObject(draggableOptions) ? draggableOptions : {},
        {
          position: application.position,
          active: $storeDraggable,
          storeDragging,
          hasTargetClassList: s_DRAG_TARGET_CLASSLIST
        }
      ));
    }
    if ($$self.$$.dirty[0] & /*$storeHeaderNoTitleMinimized, $storeMinimized*/
    12582912) {
      $$invalidate(4, displayHeaderTitle = $storeHeaderNoTitleMinimized && $storeMinimized ? "none" : null);
    }
    if ($$self.$$.dirty[0] & /*$storeHeaderButtons, buttonsLeft, buttonsRight*/
    2097158) {
      {
        $$invalidate(1, buttonsLeft = []);
        $$invalidate(2, buttonsRight = []);
        for (const button of $storeHeaderButtons) {
          const buttonsList = typeof button?.alignLeft === "boolean" && button?.alignLeft ? buttonsLeft : buttonsRight;
          buttonsList.push(isSvelteComponent(button) ? { class: button, props: {} } : {
            class: TJSHeaderButton,
            props: { button }
          });
        }
      }
    }
  };
  return [
    draggable$1,
    buttonsLeft,
    buttonsRight,
    dragOptions,
    displayHeaderTitle,
    $storeMinimizable,
    $storeHeaderIcon,
    $storeTitle,
    focusAuto,
    focusKeep,
    elementRoot,
    storeTitle,
    storeDraggable,
    storeHeaderButtons,
    storeHeaderIcon,
    storeHeaderNoTitleMinimized,
    storeMinimizable,
    storeMinimized,
    minimizable,
    onPointerdown,
    draggableOptions,
    $storeHeaderButtons,
    $storeMinimized,
    $storeHeaderNoTitleMinimized,
    $storeDraggable
  ];
}
class TJSApplicationHeader extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1w, create_fragment$1E, safe_not_equal, { draggable: 0, draggableOptions: 20 }, null, [-1, -1]);
  }
}
const TJSFocusWrap_svelte_svelte_type_style_lang = "";
function create_fragment$1D(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "tjs-focus-wrap svelte-auto-kjcljd");
      attr(div, "tabindex", "0");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      ctx[4](div);
      if (!mounted) {
        dispose = listen(
          div,
          "focus",
          /*onFocus*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[4](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$1v($$self, $$props, $$invalidate) {
  let { elementRoot = void 0 } = $$props;
  let { enabled: enabled2 = true } = $$props;
  let ignoreElements, wrapEl;
  function onFocus() {
    if (!enabled2) {
      return;
    }
    if (elementRoot instanceof HTMLElement) {
      const firstFocusEl = A11yHelper.getFirstFocusableElement(elementRoot, ignoreElements);
      if (firstFocusEl instanceof HTMLElement && firstFocusEl !== wrapEl) {
        firstFocusEl.focus();
      } else {
        elementRoot.focus();
      }
    }
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapEl = $$value;
      $$invalidate(0, wrapEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(2, elementRoot = $$props2.elementRoot);
    if ("enabled" in $$props2)
      $$invalidate(3, enabled2 = $$props2.enabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*wrapEl*/
    1) {
      if (wrapEl) {
        ignoreElements = /* @__PURE__ */ new Set([wrapEl]);
      }
    }
  };
  return [wrapEl, onFocus, elementRoot, enabled2, div_binding];
}
class TJSFocusWrap extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1v, create_fragment$1D, safe_not_equal, { elementRoot: 2, enabled: 3 });
  }
}
function create_fragment$1C(ctx) {
  let div;
  let resizable_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<i class="fas fa-arrows-alt-h"></i>`;
      attr(div, "class", "window-resizable-handle");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      ctx[10](div);
      if (!mounted) {
        dispose = action_destroyer(resizable_action = /*resizable*/
        ctx[6].call(null, div, {
          active: (
            /*$storeResizable*/
            ctx[1]
          ),
          storeResizing: (
            /*storeResizing*/
            ctx[5]
          )
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (resizable_action && is_function(resizable_action.update) && dirty & /*$storeResizable*/
      2)
        resizable_action.update.call(null, {
          active: (
            /*$storeResizable*/
            ctx2[1]
          ),
          storeResizing: (
            /*storeResizing*/
            ctx2[5]
          )
        });
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$1u($$self, $$props, $$invalidate) {
  let $storeElementRoot;
  let $storeMinimized;
  let $storeResizable;
  let { isResizable = false } = $$props;
  const application = getContext("#external").application;
  const storeElementRoot = getContext("storeElementRoot");
  component_subscribe($$self, storeElementRoot, (value) => $$invalidate(8, $storeElementRoot = value));
  const storeResizable = application.reactive.storeAppOptions.resizable;
  component_subscribe($$self, storeResizable, (value) => $$invalidate(1, $storeResizable = value));
  const storeMinimized = application.reactive.storeUIState.minimized;
  component_subscribe($$self, storeMinimized, (value) => $$invalidate(9, $storeMinimized = value));
  const storeResizing = application.reactive.storeUIState.resizing;
  let elementResize;
  function resizable(node, { active: active2 = true, storeResizing: storeResizing2 = void 0 } = {}) {
    let position = null;
    let initialPosition = {};
    let resizing = false;
    const handlers = {
      resizeDown: ["pointerdown", (e) => onResizePointerDown(e), false],
      resizeMove: ["pointermove", (e) => onResizePointerMove(e), false],
      resizeUp: ["pointerup", (e) => onResizePointerUp(e), false]
    };
    function activateListeners() {
      node.addEventListener(...handlers.resizeDown);
      $$invalidate(7, isResizable = true);
      node.style.display = "block";
    }
    function removeListeners() {
      if (typeof storeResizing2?.set === "function") {
        storeResizing2.set(false);
      }
      node.removeEventListener(...handlers.resizeDown);
      node.removeEventListener(...handlers.resizeMove);
      node.removeEventListener(...handlers.resizeUp);
      node.style.display = "none";
      $$invalidate(7, isResizable = false);
    }
    if (active2) {
      activateListeners();
    } else {
      node.style.display = "none";
    }
    function onResizePointerDown(event) {
      event.preventDefault();
      resizing = false;
      position = application.position.get();
      if (position.height === "auto") {
        position.height = $storeElementRoot.clientHeight;
      }
      if (position.width === "auto") {
        position.width = $storeElementRoot.clientWidth;
      }
      initialPosition = { x: event.clientX, y: event.clientY };
      node.addEventListener(...handlers.resizeMove);
      node.addEventListener(...handlers.resizeUp);
      node.setPointerCapture(event.pointerId);
    }
    function onResizePointerMove(event) {
      event.preventDefault();
      if (!resizing && typeof storeResizing2?.set === "function") {
        resizing = true;
        storeResizing2.set(true);
      }
      application.position.set({
        width: position.width + (event.clientX - initialPosition.x),
        height: position.height + (event.clientY - initialPosition.y)
      });
    }
    function onResizePointerUp(event) {
      resizing = false;
      if (typeof storeResizing2?.set === "function") {
        storeResizing2.set(false);
      }
      event.preventDefault();
      node.removeEventListener(...handlers.resizeMove);
      node.removeEventListener(...handlers.resizeUp);
      application._onResize(event);
    }
    return {
      update: ({ active: active3 }) => {
        if (active3) {
          activateListeners();
        } else {
          removeListeners();
        }
      },
      destroy: () => removeListeners()
    };
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementResize = $$value;
      $$invalidate(0, elementResize), $$invalidate(7, isResizable), $$invalidate(9, $storeMinimized), $$invalidate(8, $storeElementRoot);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("isResizable" in $$props2)
      $$invalidate(7, isResizable = $$props2.isResizable);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*elementResize, isResizable, $storeMinimized, $storeElementRoot*/
    897) {
      if (elementResize) {
        $$invalidate(0, elementResize.style.display = isResizable && !$storeMinimized ? "block" : "none", elementResize);
        const elementRoot = $storeElementRoot;
        if (elementRoot) {
          elementRoot.classList[isResizable ? "add" : "remove"]("resizable");
        }
      }
    }
  };
  return [
    elementResize,
    $storeResizable,
    storeElementRoot,
    storeResizable,
    storeMinimized,
    storeResizing,
    resizable,
    isResizable,
    $storeElementRoot,
    $storeMinimized,
    div_binding
  ];
}
class ResizableHandle extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1u, create_fragment$1C, safe_not_equal, { isResizable: 7 });
  }
}
const ApplicationShell_svelte_svelte_type_style_lang = "";
function create_else_block$h(ctx) {
  let div;
  let tjsapplicationheader;
  let t0;
  let section2;
  let applyStyles_action;
  let t1;
  let resizablehandle;
  let t2;
  let tjsfocuswrap;
  let div_id_value;
  let div_class_value;
  let div_data_appid_value;
  let applyStyles_action_1;
  let current;
  let mounted;
  let dispose;
  tjsapplicationheader = new TJSApplicationHeader({
    props: {
      draggable: (
        /*draggable*/
        ctx[6]
      ),
      draggableOptions: (
        /*draggableOptions*/
        ctx[7]
      )
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[36].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    null
  );
  resizablehandle = new ResizableHandle({});
  tjsfocuswrap = new TJSFocusWrap({
    props: {
      elementRoot: (
        /*elementRoot*/
        ctx[1]
      ),
      enabled: (
        /*focusWrapEnabled*/
        ctx[11]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjsapplicationheader.$$.fragment);
      t0 = space();
      section2 = element("section");
      if (default_slot)
        default_slot.c();
      t1 = space();
      create_component(resizablehandle.$$.fragment);
      t2 = space();
      create_component(tjsfocuswrap.$$.fragment);
      attr(section2, "class", "window-content svelte-auto-oz81f7");
      attr(section2, "tabindex", "-1");
      attr(div, "id", div_id_value = /*application*/
      ctx[10].id);
      attr(div, "class", div_class_value = "app window-app " + /*application*/
      ctx[10].options.classes.join(" ") + " svelte-auto-oz81f7");
      attr(div, "data-appid", div_data_appid_value = /*application*/
      ctx[10].appId);
      attr(div, "tabindex", "-1");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsapplicationheader, div, null);
      append(div, t0);
      append(div, section2);
      if (default_slot) {
        default_slot.m(section2, null);
      }
      ctx[39](section2);
      append(div, t1);
      mount_component(resizablehandle, div, null);
      append(div, t2);
      mount_component(tjsfocuswrap, div, null);
      ctx[40](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            section2,
            "pointerdown",
            /*onPointerdownContent*/
            ctx[21]
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            section2,
            /*stylesContent*/
            ctx[9]
          )),
          action_destroyer(
            /*contentResizeObserver*/
            ctx[13].call(
              null,
              section2,
              /*resizeObservedContent*/
              ctx[22]
            )
          ),
          listen(div, "close:popup", stop_propagation(prevent_default(
            /*onClosePopup*/
            ctx[18]
          ))),
          listen(
            div,
            "keydown",
            /*onKeydown*/
            ctx[19],
            true
          ),
          listen(
            div,
            "pointerdown",
            /*onPointerdownApp*/
            ctx[20]
          ),
          action_destroyer(applyStyles_action_1 = applyStyles.call(
            null,
            div,
            /*stylesApp*/
            ctx[8]
          )),
          action_destroyer(
            /*appResizeObserver*/
            ctx[12].call(
              null,
              div,
              /*resizeObservedApp*/
              ctx[23]
            )
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const tjsapplicationheader_changes = {};
      if (dirty[0] & /*draggable*/
      64)
        tjsapplicationheader_changes.draggable = /*draggable*/
        ctx2[6];
      if (dirty[0] & /*draggableOptions*/
      128)
        tjsapplicationheader_changes.draggableOptions = /*draggableOptions*/
        ctx2[7];
      tjsapplicationheader.$set(tjsapplicationheader_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty[0] & /*stylesContent*/
      512)
        applyStyles_action.update.call(
          null,
          /*stylesContent*/
          ctx2[9]
        );
      const tjsfocuswrap_changes = {};
      if (dirty[0] & /*elementRoot*/
      2)
        tjsfocuswrap_changes.elementRoot = /*elementRoot*/
        ctx2[1];
      if (dirty[0] & /*focusWrapEnabled*/
      2048)
        tjsfocuswrap_changes.enabled = /*focusWrapEnabled*/
        ctx2[11];
      tjsfocuswrap.$set(tjsfocuswrap_changes);
      if (!current || dirty[0] & /*application*/
      1024 && div_id_value !== (div_id_value = /*application*/
      ctx2[10].id)) {
        attr(div, "id", div_id_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_class_value !== (div_class_value = "app window-app " + /*application*/
      ctx2[10].options.classes.join(" ") + " svelte-auto-oz81f7")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_data_appid_value !== (div_data_appid_value = /*application*/
      ctx2[10].appId)) {
        attr(div, "data-appid", div_data_appid_value);
      }
      if (applyStyles_action_1 && is_function(applyStyles_action_1.update) && dirty[0] & /*stylesApp*/
      256)
        applyStyles_action_1.update.call(
          null,
          /*stylesApp*/
          ctx2[8]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsapplicationheader.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(resizablehandle.$$.fragment, local);
      transition_in(tjsfocuswrap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsapplicationheader.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(resizablehandle.$$.fragment, local);
      transition_out(tjsfocuswrap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsapplicationheader);
      if (default_slot)
        default_slot.d(detaching);
      ctx[39](null);
      destroy_component(resizablehandle);
      destroy_component(tjsfocuswrap);
      ctx[40](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$q(ctx) {
  let div;
  let tjsapplicationheader;
  let t0;
  let section2;
  let applyStyles_action;
  let t1;
  let resizablehandle;
  let t2;
  let tjsfocuswrap;
  let div_id_value;
  let div_class_value;
  let div_data_appid_value;
  let applyStyles_action_1;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  tjsapplicationheader = new TJSApplicationHeader({
    props: {
      draggable: (
        /*draggable*/
        ctx[6]
      ),
      draggableOptions: (
        /*draggableOptions*/
        ctx[7]
      )
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[36].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    null
  );
  resizablehandle = new ResizableHandle({});
  tjsfocuswrap = new TJSFocusWrap({
    props: { elementRoot: (
      /*elementRoot*/
      ctx[1]
    ) }
  });
  return {
    c() {
      div = element("div");
      create_component(tjsapplicationheader.$$.fragment);
      t0 = space();
      section2 = element("section");
      if (default_slot)
        default_slot.c();
      t1 = space();
      create_component(resizablehandle.$$.fragment);
      t2 = space();
      create_component(tjsfocuswrap.$$.fragment);
      attr(section2, "class", "window-content svelte-auto-oz81f7");
      attr(section2, "tabindex", "-1");
      attr(div, "id", div_id_value = /*application*/
      ctx[10].id);
      attr(div, "class", div_class_value = "app window-app " + /*application*/
      ctx[10].options.classes.join(" ") + " svelte-auto-oz81f7");
      attr(div, "data-appid", div_data_appid_value = /*application*/
      ctx[10].appId);
      attr(div, "tabindex", "-1");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsapplicationheader, div, null);
      append(div, t0);
      append(div, section2);
      if (default_slot) {
        default_slot.m(section2, null);
      }
      ctx[37](section2);
      append(div, t1);
      mount_component(resizablehandle, div, null);
      append(div, t2);
      mount_component(tjsfocuswrap, div, null);
      ctx[38](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            section2,
            "pointerdown",
            /*onPointerdownContent*/
            ctx[21]
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            section2,
            /*stylesContent*/
            ctx[9]
          )),
          action_destroyer(
            /*contentResizeObserver*/
            ctx[13].call(
              null,
              section2,
              /*resizeObservedContent*/
              ctx[22]
            )
          ),
          listen(div, "close:popup", stop_propagation(prevent_default(
            /*onClosePopup*/
            ctx[18]
          ))),
          listen(
            div,
            "keydown",
            /*onKeydown*/
            ctx[19],
            true
          ),
          listen(
            div,
            "pointerdown",
            /*onPointerdownApp*/
            ctx[20]
          ),
          action_destroyer(applyStyles_action_1 = applyStyles.call(
            null,
            div,
            /*stylesApp*/
            ctx[8]
          )),
          action_destroyer(
            /*appResizeObserver*/
            ctx[12].call(
              null,
              div,
              /*resizeObservedApp*/
              ctx[23]
            )
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tjsapplicationheader_changes = {};
      if (dirty[0] & /*draggable*/
      64)
        tjsapplicationheader_changes.draggable = /*draggable*/
        ctx[6];
      if (dirty[0] & /*draggableOptions*/
      128)
        tjsapplicationheader_changes.draggableOptions = /*draggableOptions*/
        ctx[7];
      tjsapplicationheader.$set(tjsapplicationheader_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[35]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[35],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty[0] & /*stylesContent*/
      512)
        applyStyles_action.update.call(
          null,
          /*stylesContent*/
          ctx[9]
        );
      const tjsfocuswrap_changes = {};
      if (dirty[0] & /*elementRoot*/
      2)
        tjsfocuswrap_changes.elementRoot = /*elementRoot*/
        ctx[1];
      tjsfocuswrap.$set(tjsfocuswrap_changes);
      if (!current || dirty[0] & /*application*/
      1024 && div_id_value !== (div_id_value = /*application*/
      ctx[10].id)) {
        attr(div, "id", div_id_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_class_value !== (div_class_value = "app window-app " + /*application*/
      ctx[10].options.classes.join(" ") + " svelte-auto-oz81f7")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_data_appid_value !== (div_data_appid_value = /*application*/
      ctx[10].appId)) {
        attr(div, "data-appid", div_data_appid_value);
      }
      if (applyStyles_action_1 && is_function(applyStyles_action_1.update) && dirty[0] & /*stylesApp*/
      256)
        applyStyles_action_1.update.call(
          null,
          /*stylesApp*/
          ctx[8]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsapplicationheader.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(resizablehandle.$$.fragment, local);
      transition_in(tjsfocuswrap.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(
          div,
          /*inTransition*/
          ctx[2],
          /*inTransitionOptions*/
          ctx[4]
        );
        div_intro.start();
      });
      current = true;
    },
    o(local) {
      transition_out(tjsapplicationheader.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(resizablehandle.$$.fragment, local);
      transition_out(tjsfocuswrap.$$.fragment, local);
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(
        div,
        /*outTransition*/
        ctx[3],
        /*outTransitionOptions*/
        ctx[5]
      );
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsapplicationheader);
      if (default_slot)
        default_slot.d(detaching);
      ctx[37](null);
      destroy_component(resizablehandle);
      destroy_component(tjsfocuswrap);
      ctx[38](null);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$1B(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$q, create_else_block$h];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*inTransition*/
      ctx2[2] || /*outTransition*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if_blocks[current_block_type_index].m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1t($$self, $$props, $$invalidate) {
  let $focusKeep;
  let $focusAuto;
  let $minimized;
  let $focusTrap;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { elementContent = void 0 } = $$props;
  let { elementRoot = void 0 } = $$props;
  let { draggable: draggable2 = void 0 } = $$props;
  let { draggableOptions = void 0 } = $$props;
  let { stylesApp = void 0 } = $$props;
  let { stylesContent = void 0 } = $$props;
  let { appOffsetHeight = false } = $$props;
  let { appOffsetWidth = false } = $$props;
  const appResizeObserver = !!appOffsetHeight || !!appOffsetWidth ? resizeObserver : () => null;
  let { contentOffsetHeight = false } = $$props;
  let { contentOffsetWidth = false } = $$props;
  const contentResizeObserver = !!contentOffsetHeight || !!contentOffsetWidth ? resizeObserver : () => null;
  const internal = new AppShellContextInternal();
  const s_IGNORE_CLASSES = { ignoreClasses: ["tjs-focus-wrap"] };
  setContext("#internal", internal);
  const { application } = getContext("#external");
  const { focusAuto, focusKeep, focusTrap } = application.reactive.storeAppOptions;
  component_subscribe($$self, focusAuto, (value) => $$invalidate(32, $focusAuto = value));
  component_subscribe($$self, focusKeep, (value) => $$invalidate(41, $focusKeep = value));
  component_subscribe($$self, focusTrap, (value) => $$invalidate(34, $focusTrap = value));
  const { minimized } = application.reactive.storeUIState;
  component_subscribe($$self, minimized, (value) => $$invalidate(33, $minimized = value));
  let focusWrapEnabled;
  let { transition = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { transitionOptions = void 0 } = $$props;
  let { inTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS } = $$props;
  let { outTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS } = $$props;
  let oldTransition = void 0;
  let oldTransitionOptions = void 0;
  onMount(() => elementRoot.focus());
  function onClosePopup(event) {
    if (!$focusAuto) {
      return;
    }
    const targetEl = event?.detail?.target;
    if (!(targetEl instanceof HTMLElement)) {
      return;
    }
    if (A11yHelper.isFocusable(targetEl)) {
      return;
    }
    const elementRootContains = elementRoot.contains(targetEl);
    if (targetEl === elementRoot) {
      elementRoot.focus();
    } else if (targetEl === elementContent) {
      elementContent.focus();
    } else if (elementRootContains) {
      if (elementContent.contains(targetEl)) {
        elementContent.focus();
      } else {
        elementRoot.focus();
      }
    }
  }
  function onKeydown(event) {
    if (focusWrapEnabled && event.shiftKey && event.code === "Tab") {
      const allFocusable = A11yHelper.getFocusableElements(elementRoot, s_IGNORE_CLASSES);
      const firstFocusEl = allFocusable.length > 0 ? allFocusable[0] : void 0;
      const lastFocusEl = allFocusable.length > 0 ? allFocusable[allFocusable.length - 1] : void 0;
      if (elementRoot === document.activeElement || firstFocusEl === document.activeElement) {
        if (lastFocusEl instanceof HTMLElement && firstFocusEl !== lastFocusEl) {
          lastFocusEl.focus();
        }
        event.preventDefault();
        event.stopPropagation();
      }
    }
    if (typeof application?.options?.popOut === "boolean" && application.options.popOut && application !== globalThis.ui?.activeWindow) {
      application.bringToTop.call(application);
    }
  }
  function onPointerdownApp() {
    if (typeof application?.options?.popOut === "boolean" && application.options.popOut && application !== globalThis.ui?.activeWindow) {
      application.bringToTop.call(application);
    }
  }
  function onPointerdownContent(event) {
    const focusable = A11yHelper.isFocusable(event.target);
    if (!focusable && $focusAuto) {
      if ($focusKeep) {
        const focusOutside = document.activeElement instanceof HTMLElement && !elementRoot.contains(document.activeElement);
        if (focusOutside) {
          elementContent.focus();
        } else {
          event.preventDefault();
        }
      } else {
        elementContent.focus();
      }
    }
  }
  function resizeObservedContent(offsetWidth, offsetHeight) {
    $$invalidate(27, contentOffsetWidth = offsetWidth);
    $$invalidate(26, contentOffsetHeight = offsetHeight);
  }
  function resizeObservedApp(offsetWidth, offsetHeight, contentWidth, contentHeight) {
    application.position.stores.resizeObserved.update((object) => {
      object.contentWidth = contentWidth;
      object.contentHeight = contentHeight;
      object.offsetWidth = offsetWidth;
      object.offsetHeight = offsetHeight;
      return object;
    });
    $$invalidate(24, appOffsetHeight = offsetHeight);
    $$invalidate(25, appOffsetWidth = offsetWidth);
  }
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementContent = $$value;
      $$invalidate(0, elementContent);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementRoot = $$value;
      $$invalidate(1, elementRoot);
    });
  }
  function section_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementContent = $$value;
      $$invalidate(0, elementContent);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementRoot = $$value;
      $$invalidate(1, elementRoot);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("elementContent" in $$props2)
      $$invalidate(0, elementContent = $$props2.elementContent);
    if ("elementRoot" in $$props2)
      $$invalidate(1, elementRoot = $$props2.elementRoot);
    if ("draggable" in $$props2)
      $$invalidate(6, draggable2 = $$props2.draggable);
    if ("draggableOptions" in $$props2)
      $$invalidate(7, draggableOptions = $$props2.draggableOptions);
    if ("stylesApp" in $$props2)
      $$invalidate(8, stylesApp = $$props2.stylesApp);
    if ("stylesContent" in $$props2)
      $$invalidate(9, stylesContent = $$props2.stylesContent);
    if ("appOffsetHeight" in $$props2)
      $$invalidate(24, appOffsetHeight = $$props2.appOffsetHeight);
    if ("appOffsetWidth" in $$props2)
      $$invalidate(25, appOffsetWidth = $$props2.appOffsetWidth);
    if ("contentOffsetHeight" in $$props2)
      $$invalidate(26, contentOffsetHeight = $$props2.contentOffsetHeight);
    if ("contentOffsetWidth" in $$props2)
      $$invalidate(27, contentOffsetWidth = $$props2.contentOffsetWidth);
    if ("transition" in $$props2)
      $$invalidate(28, transition = $$props2.transition);
    if ("inTransition" in $$props2)
      $$invalidate(2, inTransition = $$props2.inTransition);
    if ("outTransition" in $$props2)
      $$invalidate(3, outTransition = $$props2.outTransition);
    if ("transitionOptions" in $$props2)
      $$invalidate(29, transitionOptions = $$props2.transitionOptions);
    if ("inTransitionOptions" in $$props2)
      $$invalidate(4, inTransitionOptions = $$props2.inTransitionOptions);
    if ("outTransitionOptions" in $$props2)
      $$invalidate(5, outTransitionOptions = $$props2.outTransitionOptions);
    if ("$$scope" in $$props2)
      $$invalidate(35, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*elementContent*/
    1) {
      if (elementContent !== void 0 && elementContent !== null) {
        getContext("#internal").stores.elementContent.set(elementContent);
      }
    }
    if ($$self.$$.dirty[0] & /*elementRoot*/
    2) {
      if (elementRoot !== void 0 && elementRoot !== null) {
        getContext("#internal").stores.elementRoot.set(elementRoot);
      }
    }
    if ($$self.$$.dirty[1] & /*$focusAuto, $focusTrap, $minimized*/
    14) {
      $$invalidate(11, focusWrapEnabled = $focusAuto && $focusTrap && !$minimized);
    }
    if ($$self.$$.dirty[0] & /*oldTransition, transition*/
    1342177280) {
      if (oldTransition !== transition) {
        const newTransition = typeof transition === "function" ? transition : void 0;
        $$invalidate(2, inTransition = newTransition);
        $$invalidate(3, outTransition = newTransition);
        $$invalidate(30, oldTransition = newTransition);
      }
    }
    if ($$self.$$.dirty[0] & /*transitionOptions*/
    536870912 | $$self.$$.dirty[1] & /*oldTransitionOptions*/
    1) {
      if (oldTransitionOptions !== transitionOptions) {
        const newOptions = transitionOptions !== s_DEFAULT_TRANSITION_OPTIONS && isObject(transitionOptions) ? transitionOptions : s_DEFAULT_TRANSITION_OPTIONS;
        $$invalidate(4, inTransitionOptions = newOptions);
        $$invalidate(5, outTransitionOptions = newOptions);
        $$invalidate(31, oldTransitionOptions = newOptions);
      }
    }
    if ($$self.$$.dirty[0] & /*inTransition*/
    4) {
      if (typeof inTransition !== "function") {
        $$invalidate(2, inTransition = void 0);
      }
    }
    if ($$self.$$.dirty[0] & /*outTransition, application*/
    1032) {
      {
        if (typeof outTransition !== "function") {
          $$invalidate(3, outTransition = void 0);
        }
        if (application && typeof application?.options?.defaultCloseAnimation === "boolean") {
          $$invalidate(10, application.options.defaultCloseAnimation = outTransition === void 0, application);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*inTransitionOptions*/
    16) {
      if (typeof inTransitionOptions !== "object") {
        $$invalidate(4, inTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS);
      }
    }
    if ($$self.$$.dirty[0] & /*outTransitionOptions*/
    32) {
      if (typeof outTransitionOptions !== "object") {
        $$invalidate(5, outTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS);
      }
    }
  };
  return [
    elementContent,
    elementRoot,
    inTransition,
    outTransition,
    inTransitionOptions,
    outTransitionOptions,
    draggable2,
    draggableOptions,
    stylesApp,
    stylesContent,
    application,
    focusWrapEnabled,
    appResizeObserver,
    contentResizeObserver,
    focusAuto,
    focusKeep,
    focusTrap,
    minimized,
    onClosePopup,
    onKeydown,
    onPointerdownApp,
    onPointerdownContent,
    resizeObservedContent,
    resizeObservedApp,
    appOffsetHeight,
    appOffsetWidth,
    contentOffsetHeight,
    contentOffsetWidth,
    transition,
    transitionOptions,
    oldTransition,
    oldTransitionOptions,
    $focusAuto,
    $minimized,
    $focusTrap,
    $$scope,
    slots,
    section_binding,
    div_binding,
    section_binding_1,
    div_binding_1
  ];
}
class ApplicationShell extends SvelteComponent {
  constructor(options2) {
    super();
    init(
      this,
      options2,
      instance$1t,
      create_fragment$1B,
      safe_not_equal,
      {
        elementContent: 0,
        elementRoot: 1,
        draggable: 6,
        draggableOptions: 7,
        stylesApp: 8,
        stylesContent: 9,
        appOffsetHeight: 24,
        appOffsetWidth: 25,
        contentOffsetHeight: 26,
        contentOffsetWidth: 27,
        transition: 28,
        inTransition: 2,
        outTransition: 3,
        transitionOptions: 29,
        inTransitionOptions: 4,
        outTransitionOptions: 5
      },
      null,
      [-1, -1]
    );
  }
  get elementContent() {
    return this.$$.ctx[0];
  }
  set elementContent(elementContent) {
    this.$$set({ elementContent });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get draggable() {
    return this.$$.ctx[6];
  }
  set draggable(draggable2) {
    this.$$set({ draggable: draggable2 });
    flush();
  }
  get draggableOptions() {
    return this.$$.ctx[7];
  }
  set draggableOptions(draggableOptions) {
    this.$$set({ draggableOptions });
    flush();
  }
  get stylesApp() {
    return this.$$.ctx[8];
  }
  set stylesApp(stylesApp) {
    this.$$set({ stylesApp });
    flush();
  }
  get stylesContent() {
    return this.$$.ctx[9];
  }
  set stylesContent(stylesContent) {
    this.$$set({ stylesContent });
    flush();
  }
  get appOffsetHeight() {
    return this.$$.ctx[24];
  }
  set appOffsetHeight(appOffsetHeight) {
    this.$$set({ appOffsetHeight });
    flush();
  }
  get appOffsetWidth() {
    return this.$$.ctx[25];
  }
  set appOffsetWidth(appOffsetWidth) {
    this.$$set({ appOffsetWidth });
    flush();
  }
  get contentOffsetHeight() {
    return this.$$.ctx[26];
  }
  set contentOffsetHeight(contentOffsetHeight) {
    this.$$set({ contentOffsetHeight });
    flush();
  }
  get contentOffsetWidth() {
    return this.$$.ctx[27];
  }
  set contentOffsetWidth(contentOffsetWidth) {
    this.$$set({ contentOffsetWidth });
    flush();
  }
  get transition() {
    return this.$$.ctx[28];
  }
  set transition(transition) {
    this.$$set({ transition });
    flush();
  }
  get inTransition() {
    return this.$$.ctx[2];
  }
  set inTransition(inTransition) {
    this.$$set({ inTransition });
    flush();
  }
  get outTransition() {
    return this.$$.ctx[3];
  }
  set outTransition(outTransition) {
    this.$$set({ outTransition });
    flush();
  }
  get transitionOptions() {
    return this.$$.ctx[29];
  }
  set transitionOptions(transitionOptions) {
    this.$$set({ transitionOptions });
    flush();
  }
  get inTransitionOptions() {
    return this.$$.ctx[4];
  }
  set inTransitionOptions(inTransitionOptions) {
    this.$$set({ inTransitionOptions });
    flush();
  }
  get outTransitionOptions() {
    return this.$$.ctx[5];
  }
  set outTransitionOptions(outTransitionOptions) {
    this.$$set({ outTransitionOptions });
    flush();
  }
}
const EmptyApplicationShell_svelte_svelte_type_style_lang = "";
const TJSApplicationShell_svelte_svelte_type_style_lang = "";
const DialogContent_svelte_svelte_type_style_lang = "";
function get_each_context$g(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  return child_ctx;
}
function create_if_block_3$9(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*dialogProps*/
    ctx[7]
  ];
  var switch_value = (
    /*dialogClass*/
    ctx[6]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
    ctx[16](switch_instance);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & /*dialogProps*/
      128 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*dialogProps*/
        ctx2[7]
      )]) : {};
      if (dirty & /*dialogClass*/
      64 && switch_value !== (switch_value = /*dialogClass*/
      ctx2[6])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          ctx2[16](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[16](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_2$c(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target2, anchor) {
      html_tag.m(
        /*content*/
        ctx[3],
        target2,
        anchor
      );
      insert(target2, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*content*/
      8)
        html_tag.p(
          /*content*/
          ctx2[3]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_if_block$p(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = (
    /*buttons*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*button*/
    ctx2[26].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$g(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$g(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "dialog-buttons svelte-auto-1r3281l");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      ctx[20](div);
    },
    p(ctx2, dirty) {
      if (dirty & /*buttons, onClick, currentButtonId*/
      530) {
        each_value = /*buttons*/
        ctx2[1];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block$g, null, get_each_context$g);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[20](null);
    }
  };
}
function create_if_block_1$e(ctx) {
  let html_tag;
  let raw_value = (
    /*button*/
    ctx[26].icon + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target2, anchor) {
      html_tag.m(raw_value, target2, anchor);
      insert(target2, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*buttons*/
      2 && raw_value !== (raw_value = /*button*/
      ctx2[26].icon + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_each_block$g(key_1, ctx) {
  let button;
  let span;
  let t0_value = (
    /*button*/
    ctx[26].label + ""
  );
  let t0;
  let span_title_value;
  let t1;
  let button_class_value;
  let button_disabled_value;
  let applyStyles_action;
  let mounted;
  let dispose;
  let if_block = (
    /*button*/
    ctx[26].icon && create_if_block_1$e(ctx)
  );
  function click_handler() {
    return (
      /*click_handler*/
      ctx[18](
        /*button*/
        ctx[26]
      )
    );
  }
  function focus_handler() {
    return (
      /*focus_handler*/
      ctx[19](
        /*button*/
        ctx[26]
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      span = element("span");
      if (if_block)
        if_block.c();
      t0 = text(t0_value);
      t1 = space();
      attr(span, "title", span_title_value = /*button*/
      ctx[26].title);
      attr(button, "class", button_class_value = "dialog-button " + /*button*/
      ctx[26].id + " svelte-auto-1r3281l");
      button.disabled = button_disabled_value = /*button*/
      ctx[26].disabled;
      this.first = button;
    },
    m(target2, anchor) {
      insert(target2, button, anchor);
      append(button, span);
      if (if_block)
        if_block.m(span, null);
      append(span, t0);
      append(button, t1);
      if (!mounted) {
        dispose = [
          listen(button, "click", stop_propagation(prevent_default(click_handler))),
          listen(button, "focus", focus_handler),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            button,
            /*button*/
            ctx[26].styles
          ))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*button*/
        ctx[26].icon
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1$e(ctx);
          if_block.c();
          if_block.m(span, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*buttons*/
      2 && t0_value !== (t0_value = /*button*/
      ctx[26].label + ""))
        set_data(t0, t0_value);
      if (dirty & /*buttons*/
      2 && span_title_value !== (span_title_value = /*button*/
      ctx[26].title)) {
        attr(span, "title", span_title_value);
      }
      if (dirty & /*buttons*/
      2 && button_class_value !== (button_class_value = "dialog-button " + /*button*/
      ctx[26].id + " svelte-auto-1r3281l")) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*buttons*/
      2 && button_disabled_value !== (button_disabled_value = /*button*/
      ctx[26].disabled)) {
        button.disabled = button_disabled_value;
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*buttons*/
      2)
        applyStyles_action.update.call(
          null,
          /*button*/
          ctx[26].styles
        );
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$1A(ctx) {
  let main2;
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  const if_block_creators = [create_if_block_2$c, create_if_block_3$9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*content*/
    ctx2[3] === "string")
      return 0;
    if (
      /*dialogClass*/
      ctx2[6]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*buttons*/
    ctx[1].length && create_if_block$p(ctx)
  );
  return {
    c() {
      main2 = element("main");
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "dialog-content");
    },
    m(target2, anchor) {
      insert(target2, main2, anchor);
      append(main2, div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      ctx[17](div);
      append(main2, t);
      if (if_block1)
        if_block1.m(main2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div, null);
        } else {
          if_block0 = null;
        }
      }
      if (
        /*buttons*/
        ctx2[1].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$p(ctx2);
          if_block1.c();
          if_block1.m(main2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[17](null);
      if (if_block1)
        if_block1.d();
    }
  };
}
const s_REGEX_HTML = /^\s*<.*>$/;
function instance$1s($$self, $$props, $$invalidate) {
  let autoClose;
  let focusFirst;
  let resolveId;
  let $elementRoot;
  let { data: data2 = void 0 } = $$props;
  let { preventDefault = false } = $$props;
  let { stopPropagation = false } = $$props;
  let { dialogComponent = void 0 } = $$props;
  let buttons;
  let contentEl;
  let buttonsEl;
  let content = void 0;
  let dialogClass;
  let dialogProps = {};
  let { elementRoot } = getContext("#internal").stores;
  component_subscribe($$self, elementRoot, (value) => $$invalidate(15, $elementRoot = value));
  let { application } = getContext("#external");
  let managedPromise = getContext("#managedPromise");
  let currentButtonId = data2.default;
  onDestroy(() => {
    const rootEl = $elementRoot;
    if (rootEl instanceof HTMLElement) {
      rootEl.removeEventListener("keydown", onKeydown);
      rootEl.removeEventListener("keyup", onKeyup);
    }
  });
  onMount(() => {
    if (focusFirst) {
      const focusEl = A11yHelper.getFirstFocusableElement(contentEl);
      if (focusEl instanceof HTMLElement) {
        setTimeout(() => focusEl.focus(), 0);
      }
    }
  });
  function onClick(button) {
    try {
      let result = void 0;
      const callback = button?.onPress;
      switch (typeof callback) {
        case "function":
          result = callback(application);
          break;
        case "string":
          if (dialogComponent !== void 0 && typeof dialogComponent[callback] === "function") {
            result = dialogComponent[callback](application);
          } else {
            if (dialogComponent === void 0) {
              console.warn(`[TRL] TJSDialog warning: 'onPress' defined as a string with no associated content Svelte component.`);
            } else if (typeof dialogComponent?.[callback] !== "function") {
              console.warn(`[TRL] TJSDialog warning: The content Svelte component does not contain an associated function '${callback}'. Did you remember to add '<svelte:options accessors={true} />' and export the function?`);
            }
          }
          break;
      }
      if (button.autoClose && autoClose) {
        if (resolveId && result === void 0) {
          result = button.id;
        }
        managedPromise.resolve(result);
      }
    } catch (err) {
      const notifyError = typeof data2.notifyError === "boolean" ? data2.notifyError : true;
      if (notifyError) {
        globalThis.ui.notifications.error(err, { console: false });
      }
      if (!managedPromise.reject(err)) {
        throw err;
      }
    } finally {
      if (button.autoClose && autoClose) {
        application.close();
      }
    }
  }
  function onKeydown(event) {
    switch (event.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "Enter":
        event.stopPropagation();
        break;
      case "Tab":
        event.stopPropagation();
        setTimeout(
          () => {
            const activeElement = document.activeElement;
            if (activeElement instanceof HTMLElement && buttonsEl instanceof HTMLElement && buttonsEl.contains(activeElement)) {
              for (let cntr = 0; cntr < activeElement.classList.length; cntr++) {
                const item2 = activeElement.classList.item(cntr);
                if (item2 !== "dialog-button" && item2 !== "default" && typeof data2.buttons[item2] !== void 0) {
                  $$invalidate(4, currentButtonId = item2);
                  break;
                }
              }
            }
          },
          0
        );
        break;
      default:
        if (preventDefault) {
          event.preventDefault();
        }
        if (stopPropagation) {
          event.stopPropagation();
        }
        break;
    }
  }
  function onKeyup(event) {
    switch (event.code) {
      case "ArrowLeft": {
        event.preventDefault();
        event.stopPropagation();
        const activeEl = document.activeElement;
        if (buttonsEl instanceof HTMLElement) {
          if (activeEl instanceof HTMLElement && buttonsEl.contains(activeEl)) {
            const currentIndex = buttons.findIndex((button) => button.id === currentButtonId);
            if (buttons.length && currentIndex > 0) {
              $$invalidate(4, currentButtonId = buttons[currentIndex - 1].id);
            }
          }
          const buttonEl = buttonsEl.querySelector(`.${currentButtonId}`);
          if (buttonEl instanceof HTMLElement) {
            buttonEl.focus();
          }
        }
        break;
      }
      case "ArrowRight": {
        event.preventDefault();
        event.stopPropagation();
        const activeEl = document.activeElement;
        if (buttonsEl instanceof HTMLElement) {
          if (activeEl instanceof HTMLElement && (buttonsEl.contains(activeEl) || currentButtonId === void 0)) {
            const currentIndex = buttons.findIndex((button) => button.id === currentButtonId);
            if (buttons.length && currentIndex < buttons.length - 1) {
              $$invalidate(4, currentButtonId = buttons[currentIndex + 1].id);
            }
          }
          const buttonEl = buttonsEl.querySelector(`.${currentButtonId}`);
          if (buttonEl instanceof HTMLElement) {
            buttonEl.focus();
          }
        }
        break;
      }
      case "Enter":
        event.preventDefault();
        event.stopPropagation();
        break;
      default:
        if (preventDefault) {
          event.preventDefault();
        }
        if (stopPropagation) {
          event.stopPropagation();
        }
        break;
    }
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dialogComponent = $$value;
      $$invalidate(0, dialogComponent);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentEl = $$value;
      $$invalidate(5, contentEl);
    });
  }
  const click_handler = (button) => onClick(button);
  const focus_handler = (button) => $$invalidate(4, currentButtonId = button.id);
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonsEl = $$value;
      $$invalidate(2, buttonsEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(10, data2 = $$props2.data);
    if ("preventDefault" in $$props2)
      $$invalidate(11, preventDefault = $$props2.preventDefault);
    if ("stopPropagation" in $$props2)
      $$invalidate(12, stopPropagation = $$props2.stopPropagation);
    if ("dialogComponent" in $$props2)
      $$invalidate(0, dialogComponent = $$props2.dialogComponent);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$elementRoot*/
    32768) {
      if ($elementRoot) {
        const rootEl = $elementRoot;
        if (rootEl instanceof HTMLElement) {
          rootEl.addEventListener("keydown", onKeydown);
          rootEl.addEventListener("keyup", onKeyup);
        }
      }
    }
    if ($$self.$$.dirty & /*data*/
    1024) {
      $$invalidate(13, autoClose = typeof data2.autoClose === "boolean" ? data2.autoClose : true);
    }
    if ($$self.$$.dirty & /*data*/
    1024) {
      $$invalidate(14, focusFirst = typeof data2.focusFirst === "boolean" ? data2.focusFirst : false);
    }
    if ($$self.$$.dirty & /*data*/
    1024) {
      {
        $$invalidate(1, buttons = !isObject(data2.buttons) ? [] : Object.keys(data2.buttons).reduce(
          (array, key) => {
            const b = data2.buttons[key];
            const icon = typeof b.icon !== "string" ? void 0 : s_REGEX_HTML.test(b.icon) ? b.icon : `<i class="${b.icon}"></i>`;
            const autoClose2 = typeof b.autoClose === "boolean" ? b.autoClose : true;
            const disabled = typeof b.disabled === "boolean" ? b.disabled : false;
            const label = typeof b.label === "string" ? `${icon !== void 0 ? " " : ""}${localize(b.label)}` : "";
            const title2 = typeof b.title === "string" ? localize(b.title) : void 0;
            const condition = typeof b.condition === "function" ? b.condition.call(b) : b.condition ?? true;
            if (condition) {
              array.push({
                ...b,
                id: key,
                autoClose: autoClose2,
                icon,
                label,
                title: title2,
                disabled
              });
            }
            return array;
          },
          []
        ));
      }
    }
    if ($$self.$$.dirty & /*buttons, currentButtonId*/
    18) {
      if (!buttons.find((button) => button.id === currentButtonId)) {
        $$invalidate(4, currentButtonId = void 0);
      }
    }
    if ($$self.$$.dirty & /*focusFirst, buttonsEl, currentButtonId*/
    16404) {
      if (!focusFirst && buttonsEl instanceof HTMLElement) {
        const buttonEl = buttonsEl.querySelector(`.${currentButtonId}`);
        if (buttonEl instanceof HTMLElement) {
          buttonEl.focus();
        }
      }
    }
    if ($$self.$$.dirty & /*data*/
    1024) {
      resolveId = typeof data2.resolveId === "boolean" ? data2.resolveId : false;
    }
    if ($$self.$$.dirty & /*content, data*/
    1032) {
      if (content !== data2.content) {
        $$invalidate(3, content = data2.content);
        try {
          if (isSvelteComponent(content)) {
            $$invalidate(6, dialogClass = content);
            $$invalidate(7, dialogProps = {});
          } else if (isObject(content)) {
            const svelteConfig = parseSvelteConfig(content, application);
            $$invalidate(6, dialogClass = svelteConfig.class);
            $$invalidate(7, dialogProps = svelteConfig.props ?? {});
            const children2 = svelteConfig?.context?.get("external")?.children;
            if (Array.isArray(children2)) {
              $$invalidate(7, dialogProps.children = children2, dialogProps);
            }
          } else {
            $$invalidate(6, dialogClass = void 0);
            $$invalidate(7, dialogProps = {});
          }
        } catch (err) {
          $$invalidate(6, dialogClass = void 0);
          $$invalidate(7, dialogProps = {});
          $$invalidate(3, content = err.message);
          console.error(err);
        }
      }
    }
  };
  return [
    dialogComponent,
    buttons,
    buttonsEl,
    content,
    currentButtonId,
    contentEl,
    dialogClass,
    dialogProps,
    elementRoot,
    onClick,
    data2,
    preventDefault,
    stopPropagation,
    autoClose,
    focusFirst,
    $elementRoot,
    switch_instance_binding,
    div_binding,
    click_handler,
    focus_handler,
    div_binding_1
  ];
}
class DialogContent extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1s, create_fragment$1A, safe_not_equal, {
      data: 10,
      preventDefault: 11,
      stopPropagation: 12,
      dialogComponent: 0
    });
  }
}
function create_else_block$g(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let updating_elementContent;
  let current;
  const applicationshell_spread_levels = [
    /*appProps*/
    ctx[6],
    { appOffsetHeight: true }
  ];
  function applicationshell_elementRoot_binding_1(value) {
    ctx[14](value);
  }
  function applicationshell_elementContent_binding_1(value) {
    ctx[15](value);
  }
  let applicationshell_props = {
    $$slots: { default: [create_default_slot_2$2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < applicationshell_spread_levels.length; i += 1) {
    applicationshell_props = assign(applicationshell_props, applicationshell_spread_levels[i]);
  }
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  if (
    /*elementContent*/
    ctx[1] !== void 0
  ) {
    applicationshell_props.elementContent = /*elementContent*/
    ctx[1];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding_1));
  binding_callbacks.push(() => bind(applicationshell, "elementContent", applicationshell_elementContent_binding_1));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(applicationshell, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = dirty & /*appProps*/
      64 ? get_spread_update(applicationshell_spread_levels, [
        get_spread_object(
          /*appProps*/
          ctx2[6]
        ),
        applicationshell_spread_levels[1]
      ]) : {};
      if (dirty & /*$$scope, data, dialogComponent*/
      1048588) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      if (!updating_elementContent && dirty & /*elementContent*/
      2) {
        updating_elementContent = true;
        applicationshell_changes.elementContent = /*elementContent*/
        ctx2[1];
        add_flush_callback(() => updating_elementContent = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
function create_if_block$o(ctx) {
  let tjsglasspane;
  let current;
  const tjsglasspane_spread_levels = [
    {
      id: `${/*application*/
      ctx[4].id}-glasspane`
    },
    /*modalProps*/
    ctx[7],
    { zIndex: (
      /*zIndex*/
      ctx[8]
    ) }
  ];
  let tjsglasspane_props = {
    $$slots: { default: [create_default_slot$y] },
    $$scope: { ctx }
  };
  for (let i = 0; i < tjsglasspane_spread_levels.length; i += 1) {
    tjsglasspane_props = assign(tjsglasspane_props, tjsglasspane_spread_levels[i]);
  }
  tjsglasspane = new TJSGlassPane({ props: tjsglasspane_props });
  return {
    c() {
      create_component(tjsglasspane.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjsglasspane, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjsglasspane_changes = dirty & /*application, modalProps, zIndex*/
      400 ? get_spread_update(tjsglasspane_spread_levels, [
        dirty & /*application*/
        16 && {
          id: `${/*application*/
          ctx2[4].id}-glasspane`
        },
        dirty & /*modalProps*/
        128 && get_spread_object(
          /*modalProps*/
          ctx2[7]
        ),
        dirty & /*zIndex*/
        256 && { zIndex: (
          /*zIndex*/
          ctx2[8]
        ) }
      ]) : {};
      if (dirty & /*$$scope, appProps, elementRoot, elementContent, data, dialogComponent*/
      1048655) {
        tjsglasspane_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjsglasspane.$set(tjsglasspane_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsglasspane.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsglasspane.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsglasspane, detaching);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let dialogcontent;
  let updating_dialogComponent;
  let current;
  function dialogcontent_dialogComponent_binding_1(value) {
    ctx[13](value);
  }
  let dialogcontent_props = { data: (
    /*data*/
    ctx[3]
  ) };
  if (
    /*dialogComponent*/
    ctx[2] !== void 0
  ) {
    dialogcontent_props.dialogComponent = /*dialogComponent*/
    ctx[2];
  }
  dialogcontent = new DialogContent({ props: dialogcontent_props });
  binding_callbacks.push(() => bind(dialogcontent, "dialogComponent", dialogcontent_dialogComponent_binding_1));
  return {
    c() {
      create_component(dialogcontent.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(dialogcontent, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dialogcontent_changes = {};
      if (dirty & /*data*/
      8)
        dialogcontent_changes.data = /*data*/
        ctx2[3];
      if (!updating_dialogComponent && dirty & /*dialogComponent*/
      4) {
        updating_dialogComponent = true;
        dialogcontent_changes.dialogComponent = /*dialogComponent*/
        ctx2[2];
        add_flush_callback(() => updating_dialogComponent = false);
      }
      dialogcontent.$set(dialogcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dialogcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dialogcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dialogcontent, detaching);
    }
  };
}
function create_default_slot_1$5(ctx) {
  let dialogcontent;
  let updating_dialogComponent;
  let current;
  function dialogcontent_dialogComponent_binding(value) {
    ctx[10](value);
  }
  let dialogcontent_props = {
    data: (
      /*data*/
      ctx[3]
    ),
    stopPropagation: true
  };
  if (
    /*dialogComponent*/
    ctx[2] !== void 0
  ) {
    dialogcontent_props.dialogComponent = /*dialogComponent*/
    ctx[2];
  }
  dialogcontent = new DialogContent({ props: dialogcontent_props });
  binding_callbacks.push(() => bind(dialogcontent, "dialogComponent", dialogcontent_dialogComponent_binding));
  return {
    c() {
      create_component(dialogcontent.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(dialogcontent, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dialogcontent_changes = {};
      if (dirty & /*data*/
      8)
        dialogcontent_changes.data = /*data*/
        ctx2[3];
      if (!updating_dialogComponent && dirty & /*dialogComponent*/
      4) {
        updating_dialogComponent = true;
        dialogcontent_changes.dialogComponent = /*dialogComponent*/
        ctx2[2];
        add_flush_callback(() => updating_dialogComponent = false);
      }
      dialogcontent.$set(dialogcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dialogcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dialogcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dialogcontent, detaching);
    }
  };
}
function create_default_slot$y(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let updating_elementContent;
  let current;
  const applicationshell_spread_levels = [
    /*appProps*/
    ctx[6],
    { appOffsetHeight: true }
  ];
  function applicationshell_elementRoot_binding(value) {
    ctx[11](value);
  }
  function applicationshell_elementContent_binding(value) {
    ctx[12](value);
  }
  let applicationshell_props = {
    $$slots: { default: [create_default_slot_1$5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < applicationshell_spread_levels.length; i += 1) {
    applicationshell_props = assign(applicationshell_props, applicationshell_spread_levels[i]);
  }
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  if (
    /*elementContent*/
    ctx[1] !== void 0
  ) {
    applicationshell_props.elementContent = /*elementContent*/
    ctx[1];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  binding_callbacks.push(() => bind(applicationshell, "elementContent", applicationshell_elementContent_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(applicationshell, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = dirty & /*appProps*/
      64 ? get_spread_update(applicationshell_spread_levels, [
        get_spread_object(
          /*appProps*/
          ctx2[6]
        ),
        applicationshell_spread_levels[1]
      ]) : {};
      if (dirty & /*$$scope, data, dialogComponent*/
      1048588) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      if (!updating_elementContent && dirty & /*elementContent*/
      2) {
        updating_elementContent = true;
        applicationshell_changes.elementContent = /*elementContent*/
        ctx2[1];
        add_flush_callback(() => updating_elementContent = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
function create_fragment$1z(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$o, create_else_block$g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*modal*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if_blocks[current_block_type_index].m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
const s_MODAL_BACKGROUND = "#50505080";
function instance$1r($$self, $$props, $$invalidate) {
  let { elementContent = void 0 } = $$props;
  let { elementRoot = void 0 } = $$props;
  let { data: data2 = {} } = $$props;
  let { dialogComponent = void 0 } = $$props;
  let { managedPromise = void 0 } = $$props;
  const application = getContext("#external").application;
  setContext("#managedPromise", managedPromise);
  const s_MODAL_TRANSITION = fade;
  const s_MODAL_TRANSITION_OPTIONS = { duration: 200 };
  let modal = void 0;
  const appProps = {
    // Stores any transition functions.
    transition: void 0,
    inTransition: void 0,
    outTransition: void 0,
    // Stores properties to set for options for any transitions.
    transitionOptions: void 0,
    inTransitionOptions: void 0,
    outTransitionOptions: void 0,
    // Stores any style overrides for application shell.
    stylesApp: void 0,
    stylesContent: void 0
  };
  const modalProps = {
    // Background CSS style string.
    background: void 0,
    slotSeparate: void 0,
    styles: void 0,
    // Stores any transition functions.
    transition: void 0,
    inTransition: void 0,
    outTransition: void 0,
    // Stores properties to set for options for any transitions.
    transitionOptions: void 0,
    inTransitionOptions: void 0,
    outTransitionOptions: void 0
  };
  let zIndex = void 0;
  if (modal === void 0) {
    modal = typeof data2?.modal === "boolean" ? data2.modal : false;
  }
  if (modal) {
    onDestroy(() => window.removeEventListener("keydown", onKeydownModal, { capture: true }));
    onMount(() => window.addEventListener("keydown", onKeydownModal, { capture: true }));
  } else {
    onDestroy(() => document.removeEventListener("keydown", onKeydown));
    onMount(() => document.addEventListener("keydown", onKeydown));
  }
  function onKeydown(event) {
    if (event.code === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      application.close();
    }
  }
  function onKeydownModal(event) {
    if (event.code === "Escape") {
      event.preventDefault();
      event.stopImmediatePropagation();
      application.close();
    }
  }
  function dialogcontent_dialogComponent_binding(value) {
    dialogComponent = value;
    $$invalidate(2, dialogComponent);
  }
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  function applicationshell_elementContent_binding(value) {
    elementContent = value;
    $$invalidate(1, elementContent);
  }
  function dialogcontent_dialogComponent_binding_1(value) {
    dialogComponent = value;
    $$invalidate(2, dialogComponent);
  }
  function applicationshell_elementRoot_binding_1(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  function applicationshell_elementContent_binding_1(value) {
    elementContent = value;
    $$invalidate(1, elementContent);
  }
  $$self.$$set = ($$props2) => {
    if ("elementContent" in $$props2)
      $$invalidate(1, elementContent = $$props2.elementContent);
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("data" in $$props2)
      $$invalidate(3, data2 = $$props2.data);
    if ("dialogComponent" in $$props2)
      $$invalidate(2, dialogComponent = $$props2.dialogComponent);
    if ("managedPromise" in $$props2)
      $$invalidate(9, managedPromise = $$props2.managedPromise);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*elementRoot, modal*/
    33) {
      if (elementRoot instanceof HTMLElement) {
        elementRoot.setAttribute("role", "dialog");
        if (modal) {
          elementRoot.setAttribute("aria-modal", "true");
        }
      }
    }
    if ($$self.$$.dirty & /*data, modal, zIndex, application*/
    312) {
      if (isObject(data2)) {
        const newZIndex = Number.isInteger(data2.zIndex) || data2.zIndex === null ? data2.zIndex : modal ? Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER - 1;
        if (zIndex !== newZIndex) {
          $$invalidate(8, zIndex = newZIndex);
        }
        const newDraggable = typeof data2.draggable === "boolean" ? data2.draggable : void 0;
        if (newDraggable !== void 0 && application.reactive.draggable !== newDraggable) {
          $$invalidate(4, application.reactive.draggable = newDraggable, application);
        }
        const newFocusAuto = typeof data2.focusAuto === "boolean" ? data2.focusAuto : void 0;
        if (newFocusAuto !== void 0 && application.reactive.focusAuto !== newFocusAuto) {
          $$invalidate(4, application.reactive.focusAuto = newFocusAuto, application);
        }
        const newFocusKeep = typeof data2.focusKeep === "boolean" ? data2.focusKeep : void 0;
        if (newFocusKeep !== void 0 && application.reactive.focusKeep !== newFocusKeep) {
          $$invalidate(4, application.reactive.focusKeep = newFocusKeep, application);
        }
        const newFocusTrap = typeof data2.focusTrap === "boolean" ? data2.focusTrap : void 0;
        if (newFocusTrap !== void 0 && application.reactive.focusTrap !== newFocusTrap) {
          $$invalidate(4, application.reactive.focusTrap = newFocusTrap, application);
        }
        const newMinimizable = typeof data2.minimizable === "boolean" ? data2.minimizable : void 0;
        if (newMinimizable !== void 0 && application.reactive.minimizable !== newMinimizable) {
          $$invalidate(4, application.reactive.minimizable = newMinimizable, application);
        }
        const newResizable = typeof data2.resizable === "boolean" ? data2.resizable : void 0;
        if (newResizable !== void 0 && application.reactive.resizable !== newResizable) {
          $$invalidate(4, application.reactive.resizable = newResizable, application);
        }
        const newTitle = data2.title ?? "Dialog";
        if (newTitle !== application?.options?.title) {
          $$invalidate(4, application.reactive.title = newTitle, application);
        }
        if (application.position.zIndex !== zIndex) {
          $$invalidate(4, application.position.zIndex = zIndex, application);
        }
      }
    }
    if ($$self.$$.dirty & /*data, appProps*/
    72) {
      if (isObject(data2?.transition)) {
        const d = data2.transition;
        if (d?.transition !== appProps.transition) {
          $$invalidate(6, appProps.transition = d.transition, appProps);
        }
        if (d?.inTransition !== appProps.inTransition) {
          $$invalidate(6, appProps.inTransition = d.inTransition, appProps);
        }
        if (d?.outTransition !== appProps.outTransition) {
          $$invalidate(6, appProps.outTransition = d.outTransition, appProps);
        }
        if (d?.transitionOptions !== appProps.transitionOptions) {
          $$invalidate(6, appProps.transitionOptions = d.transitionOptions, appProps);
        }
        if (d?.inTransitionOptions !== appProps.inTransitionOptions) {
          $$invalidate(6, appProps.inTransitionOptions = d.inTransitionOptions, appProps);
        }
        if (d?.outTransitionOptions !== appProps.outTransitionOptions) {
          $$invalidate(6, appProps.outTransitionOptions = d.outTransitionOptions, appProps);
        }
      }
    }
    if ($$self.$$.dirty & /*data, modalProps*/
    136) {
      {
        const newModalBackground = typeof data2?.modalOptions?.background === "string" ? data2.modalOptions.background : s_MODAL_BACKGROUND;
        if (newModalBackground !== modalProps.background) {
          $$invalidate(7, modalProps.background = newModalBackground, modalProps);
        }
      }
    }
    if ($$self.$$.dirty & /*data, modalProps*/
    136) {
      {
        const newModalSlotSeparate = typeof data2?.modalOptions?.slotSeparate === "boolean" ? data2.modalOptions.slotSeparate : void 0;
        if (newModalSlotSeparate !== modalProps.slotSeparate) {
          $$invalidate(7, modalProps.slotSeparate = newModalSlotSeparate, modalProps);
        }
      }
    }
    if ($$self.$$.dirty & /*data, modalProps*/
    136) {
      {
        const newModalStyles = isObject(data2?.modalOptions?.styles) ? data2.modalOptions.styles : void 0;
        if (newModalStyles !== modalProps.styles) {
          $$invalidate(7, modalProps.styles = newModalStyles, modalProps);
        }
      }
    }
    if ($$self.$$.dirty & /*data, modalProps*/
    136) {
      if (isObject(data2?.modalOptions?.transition)) {
        const d = data2.modalOptions.transition;
        if (d?.transition !== modalProps.transition) {
          $$invalidate(
            7,
            modalProps.transition = typeof d?.transition === "function" ? d.transition : s_MODAL_TRANSITION,
            modalProps
          );
        }
        if (d?.inTransition !== modalProps.inTransition) {
          $$invalidate(7, modalProps.inTransition = d.inTransition, modalProps);
        }
        if (d?.outTransition !== modalProps.outTransition) {
          $$invalidate(7, modalProps.outTransition = d.outTransition, modalProps);
        }
        if (d?.transitionOptions !== modalProps.transitionOptions) {
          $$invalidate(
            7,
            modalProps.transitionOptions = isObject(d?.transitionOptions) ? d.transitionOptions : s_MODAL_TRANSITION_OPTIONS,
            modalProps
          );
        }
        if (d?.inTransitionOptions !== modalProps.inTransitionOptions) {
          $$invalidate(7, modalProps.inTransitionOptions = d.inTransitionOptions, modalProps);
        }
        if (d?.outTransitionOptions !== modalProps.outTransitionOptions) {
          $$invalidate(7, modalProps.outTransitionOptions = d.outTransitionOptions, modalProps);
        }
      } else {
        const newModalTransition = typeof data2?.modalOptions?.transition?.transition === "function" ? data2.modalOptions.transition.transition : s_MODAL_TRANSITION;
        if (newModalTransition !== modalProps.transition) {
          $$invalidate(7, modalProps.transition = newModalTransition, modalProps);
        }
        const newModalTransitionOptions = isObject(data2?.modalOptions?.transitionOptions) ? data2.modalOptions.transitionOptions : s_MODAL_TRANSITION_OPTIONS;
        if (newModalTransitionOptions !== modalProps.transitionOptions) {
          $$invalidate(7, modalProps.transitionOptions = newModalTransitionOptions, modalProps);
        }
      }
    }
  };
  return [
    elementRoot,
    elementContent,
    dialogComponent,
    data2,
    application,
    modal,
    appProps,
    modalProps,
    zIndex,
    managedPromise,
    dialogcontent_dialogComponent_binding,
    applicationshell_elementRoot_binding,
    applicationshell_elementContent_binding,
    dialogcontent_dialogComponent_binding_1,
    applicationshell_elementRoot_binding_1,
    applicationshell_elementContent_binding_1
  ];
}
class DialogShell extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1r, create_fragment$1z, safe_not_equal, {
      elementContent: 1,
      elementRoot: 0,
      data: 3,
      dialogComponent: 2,
      managedPromise: 9
    });
  }
  get elementContent() {
    return this.$$.ctx[1];
  }
  set elementContent(elementContent) {
    this.$$set({ elementContent });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get data() {
    return this.$$.ctx[3];
  }
  set data(data2) {
    this.$$set({ data: data2 });
    flush();
  }
  get dialogComponent() {
    return this.$$.ctx[2];
  }
  set dialogComponent(dialogComponent) {
    this.$$set({ dialogComponent });
    flush();
  }
  get managedPromise() {
    return this.$$.ctx[9];
  }
  set managedPromise(managedPromise) {
    this.$$set({ managedPromise });
    flush();
  }
}
cssVariables$1.setProperties({
  // Anchor text shadow / header buttons
  "--tjs-default-text-shadow-focus-hover": "0 0 8px var(--color-shadow-primary)",
  // TJSApplicationShell app background.
  "--tjs-app-background": `url("${globalThis.foundry.utils.getRoute("/ui/denim075.png")}")`
}, false);
class TJSDialogData {
  /**
   * @type {SvelteApplication}
   */
  #application;
  /**
   * Provides configuration of the dialog button bar.
   *
   * @type {Record<string, TJSDialogButtonData>}
   */
  buttons;
  /**
   * A Svelte configuration object or HTML string content.
   *
   * @type {object|string}
   */
  content;
  /**
   * The default button ID to focus initially.
   *
   * @type {string}
   */
  default;
  /**
   * The dialog is draggable when true.
   *
   * @type {boolean}
   */
  draggable;
  /**
   * When true auto-management of app focus is enabled.
   *
   * @type {boolean}
   */
  focusAuto;
  /**
   * When true the first focusable element that isn't a button is focused.
   *
   * @type {boolean}
   */
  focusFirst;
  /**
   * When `focusAuto` and `focusKeep` is true; keeps internal focus.
   *
   * @type {boolean}
   */
  focusKeep;
  /**
   * When true the dialog is minimizable.
   *
   * @type {boolean}
   */
  minimizable;
  /**
   * When true a modal dialog is displayed.
   *
   * @type {boolean}
   */
  modal;
  /**
   * Additional options for modal dialog display.
   *
   * @type {object}
   * TODO: Better specify type / options.
   */
  modalOptions;
  /**
   * When true and an error is raised in dialog callback functions post a UI error notification.
   *
   * @type {boolean}
   */
  notifyError;
  /**
   * Callback invoked when dialog is closed; no button option selected. When defined as a string any matching function
   * by name exported from content Svelte component is invoked.
   *
   * @type {string|((application: TJSDialog) => any)}
   */
  onClose;
  /**
   * When true and a Promise has been created by {@link TJSDialog.wait} and the Promise is not in the process of being
   * resolved or rejected on close of the dialog any `onClose` function is invoked and any result that is undefined
   * will cause the Promise to then be rejected.
   *
   * @type {boolean}
   */
  rejectClose;
  /**
   * When true the dialog is resizable.
   *
   * @type {boolean}
   */
  resizable;
  /**
   * When true and resolving any Promises and there are undefined results from any button callbacks the button ID is
   * resolved.
   *
   * @type {boolean}
   */
  resolveId;
  /**
   * The dialog window title.
   *
   * @type {string}
   */
  title;
  /**
   * Transition options for the dialog.
   *
   * @type {object}
   * TODO: Better specify type / options.
   */
  transition;
  /**
   * A specific z-index for the dialog. Pass null for the dialog to act like other applications in regard bringing to
   * top when activated.
   *
   * @type {number|null}
   */
  zIndex;
  /**
   * @param {SvelteApplication} application - The host Foundry application.
   */
  constructor(application) {
    this.#application = application;
  }
  /**
   * Provides a way to safely get this dialogs data given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {*}        [defaultValue] - A default value returned if the accessor is not found.
   *
   * @returns {*} Value at the accessor.
   */
  get(accessor, defaultValue) {
    return safeAccess(this, accessor, defaultValue);
  }
  /**
   * @param {object} data - Merge provided data object into Dialog data.
   */
  merge(data2) {
    deepMerge(this, data2);
    const component = this.#application.svelte.component(0);
    if (component?.data) {
      component.data = this;
    }
  }
  /**
   * Provides a way to safely set this dialogs data given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * Automatically the dialog data will be updated in the associated DialogShell Svelte component.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {*}        value - Value to set.
   *
   * @returns {boolean} True if successful.
   */
  set(accessor, value) {
    const success = safeSet(this, accessor, value);
    if (success) {
      const component = this.#application.svelte.component(0);
      if (component?.data) {
        component.data = this;
      }
    }
    return success;
  }
}
class TJSDialog extends SvelteApplication {
  /** @type {TJSDialogData} */
  #data;
  /** @type {ManagedPromise} */
  #managedPromise;
  /**
   * @param {TJSDialogOptions}           data - Dialog options.
   *
   * @param {SvelteApplicationOptions}   [options] - SvelteApplication options.
   */
  constructor(data2, options2 = {}) {
    super(options2);
    this.#managedPromise = new ManagedPromise();
    this.#data = new TJSDialogData(this);
    this.data = data2;
    Object.defineProperty(this.svelte, "dialogComponent", {
      get: () => this.svelte?.applicationShell?.dialogComponent
    });
  }
  /**
   * Default options for TJSDialog. Provides a default width and setting `height` to `auto` to always display dialog
   * content even if it changes. The default `DialogShell` / `svelte` options should not be changed and instead mount
   * the dialog content component by supplying a Svelte configuration object to dialog data `content` field.
   *
   * @returns {SvelteApplicationOptions} Default options
   */
  static get defaultOptions() {
    return deepMerge(super.defaultOptions, {
      classes: ["dialog"],
      width: 400,
      height: "auto",
      svelte: {
        class: DialogShell,
        intro: true,
        target: document.body,
        props: function() {
          return {
            data: this.#data,
            managedPromise: this.#managedPromise
          };
        }
      }
    });
  }
  /**
   * Returns the dialog data.
   *
   * @returns {TJSDialogData} Dialog data.
   */
  get data() {
    return this.#data;
  }
  /**
   * @returns {ManagedPromise} Returns the managed promise.
   */
  get managedPromise() {
    return this.#managedPromise;
  }
  /**
   * Sets the dialog data; this is reactive.
   *
   * @param {object}   data - Dialog data.
   */
  set data(data2) {
    if (!isObject(data2)) {
      throw new TypeError(`TJSDialog set data error: 'data' is not an object'.`);
    }
    const descriptors = Object.getOwnPropertyDescriptors(this.#data);
    for (const descriptor in descriptors) {
      if (descriptors[descriptor].configurable) {
        delete this.#data[descriptor];
      }
    }
    this.#data.merge(data2);
  }
  /**
   * Close the dialog and un-register references to it within UI mappings.
   * This function returns a Promise which resolves once the window closing animation concludes.
   *
   * @param {object}   [options] - Optional parameters.
   *
   * @param {boolean}  [options.force] - Force close regardless of render state.
   *
   * @returns {Promise<void>} A Promise which resolves once the application is closed with the callback value or
   *                          `true`.
   */
  async close(options2) {
    try {
      if (this.#managedPromise.isActive && !this.#managedPromise.isProcessing) {
        const result = TJSDialog.#invokeFn(this.#data.onClose, this, null);
        const rejectClose = typeof this.#data.rejectClose === "boolean" ? this.#data.rejectClose : false;
        if (rejectClose && result === null) {
          this.#managedPromise.reject(new Error("TJSDialog was closed without a choice being made."));
        } else {
          this.#managedPromise.resolve(result);
        }
      }
    } catch (err) {
      const notifyError = typeof this.#data.notifyError === "boolean" ? this.#data.notifyError : true;
      if (notifyError) {
        globalThis.ui.notifications.error(err, { console: false });
      }
      if (!this.#managedPromise.reject(err)) {
        throw err;
      }
    } finally {
      await super.close(options2);
    }
  }
  /**
   * Brings to top or renders this dialog returning a Promise that is resolved any button pressed or when the dialog
   * is closed.
   *
   * Creates an anonymous data defined TJSDialog returning a Promise that can be awaited upon for the user to make a
   * choice.
   *
   * Note: `null` is returned if the dialog is closed without a user making a choice.
   *
   * @template T
   *
   * @param {object}   [options] - Options.
   *
   * @param {boolean}  [options.reuse=false] - When true if there is an existing managed Promise this allows multiple
   *        sources to await on the same result.
   *
   * @returns {Promise<T>} A promise for dialog resolution.
   */
  async wait(options2) {
    if (this.rendered) {
      this.bringToTop();
    } else {
      this.render(true, { focus: true });
    }
    return this.#managedPromise.create(options2);
  }
  // ---------------------------------------------------------------------------------------------------------------
  /**
   * A helper factory method to create simple confirmation dialog windows which consist of simple yes / no prompts.
   * If you require more flexibility, a custom TJSDialog instance is preferred. The default focused button is 'yes'.
   * You can change the default focused button by setting `default` to `yes` or `no`.
   *
   * @template T
   *
   * @param {TJSDialogOptions} data - Confirm dialog options.
   *
   * @param {string|((application: TJSDialog) => any)} [data.onYes] - Callback function upon `yes`; may be an async
   *        function. When defined as a string any matching function by name exported from content Svelte component is
   *        invoked.
   *
   * @param {string|((application: TJSDialog) => any)} [data.onNo] - Callback function upon `no`; may be an async
   *        function. When defined as a string any matching function by name exported from content Svelte component is
   *        invoked.
   *
   * @param {SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog constructor.
   *
   * @returns {Promise<T>} A promise which resolves with result of yes / no callbacks or true / false.
   *
   * @example
   * const result = await TJSDialog.confirm({
   *  title: 'A Yes or No Question',
   *  content: '<p>Choose wisely.</p>',
   *  onYes: () => 'YES Result'
   *  onNo: () => 'NO Result'
   * });
   *
   * // Logs 'YES result', 'NO Result', or null if the user closed the dialog without making a selection.
   * console.log(result);
   */
  static async confirm({ onYes, onNo, ...data2 } = {}, options2 = {}) {
    const mergedButtons = deepMerge({
      yes: {
        icon: "fas fa-check",
        label: "Yes"
      },
      no: {
        icon: "fas fa-times",
        label: "No"
      }
    }, data2.buttons ?? {});
    return this.wait({
      ...data2,
      buttons: deepMerge(mergedButtons, {
        yes: {
          onPress: (application) => this.#invokeFn(onYes, application, true)
        },
        no: {
          onPress: (application) => this.#invokeFn(onNo, application, false)
        }
      }),
      default: data2.default ?? "yes"
    }, options2);
  }
  /**
   * A helper method to invoke a callback function directly or lookup an exported function with the same name from any
   * content Svelte component to invoke. This is used internally to apply default values for `confirm` and `prompt`.
   *
   * @param {string|((application: TJSDialog) => any)} callback - Callback function to invoke; may be an async
   *        function. When defined as a string any matching function by name exported from content Svelte component is
   *        invoked.
   *
   * @param {TJSDialog} application - TJSDialog instance passed to callback.
   *
   * @param {*} [defaultResult] - An optional default result to return; undefined if not specified.
   *
   * @returns {*} Result.
   */
  static #invokeFn(callback, application, defaultResult = void 0) {
    let result = defaultResult;
    switch (typeof callback) {
      case "function":
        result = callback(application);
        break;
      case "string": {
        const dialogComponent = application?.svelte?.dialogComponent;
        if (dialogComponent !== void 0 && typeof dialogComponent?.[callback] === "function") {
          result = dialogComponent?.[callback](application);
        } else {
          if (dialogComponent === void 0) {
            console.warn(`[TRL] TJSDialog warning: 'onPress' defined as a string with no associated content Svelte component.`);
          } else if (typeof dialogComponent?.[callback] !== "function") {
            console.warn(`[TRL] TJSDialog warning: The content Svelte component does not contain an associated function '${callback}'. Did you remember to add '<svelte:options accessors={true} />' and export the function?`);
          }
        }
        break;
      }
    }
    return result;
  }
  /**
   * A helper factory method to display a basic "prompt" style TJSDialog with a single button.
   *
   * @template T
   *
   * @param {TJSDialogOptions} [data] - Prompt dialog options.
   *
   * @param {string|((application: TJSDialog) => any)} [data.onOk] - Callback function upon `ok`; may be an async
   *        function. When defined as a string any matching function by name exported from content Svelte component is
   *        invoked.
   *
   * @param {string}   [data.label] - The OK prompt button text.
   *
   * @param {string}   [data.icon="fas fa-check"] - Set another icon besides `fas fa-check` for button.
   *
   * @param {SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog constructor.
   *
   * @returns {Promise<T>} The returned value from the provided callback function or `true` if the button
   *          is pressed.
   *
   * @example
   * const result = await TJSDialog.prompt({
   *  title: 'Are you OK?',
   *  content: '<p>Are you OK?.</p>',
   *  label: 'Feeling Fine!'
   *  onOk: () => 'OK'
   * });
   *
   * // Logs 'OK' or null if the user closed the dialog without making a selection.
   * console.log(result);
   */
  static async prompt({ onOk, label, icon = "fas fa-check", ...data2 } = {}, options2 = {}) {
    return this.wait({
      ...data2,
      buttons: {
        ok: {
          icon,
          label,
          onPress: (application) => this.#invokeFn(onOk, application, true)
        }
      },
      default: "ok"
    }, options2);
  }
  /**
   * Creates an anonymous data defined TJSDialog returning a Promise that can be awaited upon for the user to make a
   * choice.
   *
   * Note: By default `null` is returned if the dialog is closed without a user making a choice.
   *
   * @template T
   *
   * @param {TJSDialogOptions}  data - Dialog data passed to the TJSDialog constructor.
   *
   * @param {SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog constructor.
   *
   * @returns {Promise<T>} A Promise that resolves to the chosen result.
   */
  static async wait(data2, options2 = {}) {
    if (!isObject(data2)) {
      throw new TypeError(`TJSDialog.wait error: 'data' is not an object'.`);
    }
    return new this({ ...data2 }, options2).wait();
  }
}
Hooks.on("PopOut:loading", (app) => {
  if (app instanceof SvelteApplication) {
    app.position.enabled = false;
  }
});
Hooks.on("PopOut:popin", (app) => {
  if (app instanceof SvelteApplication) {
    app.position.enabled = true;
  }
});
Hooks.on("PopOut:close", (app) => {
  if (app instanceof SvelteApplication) {
    app.position.enabled = true;
  }
});
function melee$1() {
  return {
    contrast: 0,
    delay: 0,
    elevation: 1e3,
    isWait: false,
    opacity: 1,
    playbackRate: 1,
    repeat: 1,
    repeatDelay: 250,
    saturate: 0,
    size: 1,
    tint: false,
    tintColor: "#FFFFFF",
    zIndex: 1
  };
}
function range$1() {
  return {
    contrast: 0,
    delay: 0,
    elevation: 1e3,
    isReturning: false,
    isWait: false,
    onlyX: false,
    opacity: 1,
    playbackRate: 1,
    repeat: 1,
    repeatDelay: 250,
    saturate: 0,
    tint: false,
    tintColor: "#FFFFFF",
    zIndex: 1
  };
}
function ontoken$1() {
  return {
    addTokenWidth: false,
    anchor: "0.5",
    contrast: 0,
    delay: 0,
    elevation: 1e3,
    fadeIn: 250,
    fadeOut: 500,
    isMasked: false,
    isRadius: false,
    isWait: false,
    opacity: 1,
    persistent: false,
    playbackRate: 1,
    playOn: "default",
    repeat: 1,
    repeatDelay: 250,
    saturate: 0,
    size: 1,
    tint: false,
    tintColor: "#FFFFFF",
    unbindAlpha: false,
    unbindVisibility: false,
    zIndex: 1
  };
}
function templatefx$1() {
  return {
    contrast: 0,
    delay: 0,
    elevation: 1e3,
    isMasked: false,
    isWait: false,
    occlusionAlpha: 0.5,
    occlusionMode: "3",
    opacity: 1,
    persistent: false,
    persistType: "sequencerground",
    playbackRate: 1,
    removeTemplate: false,
    repeat: 1,
    repeatDelay: 250,
    rotate: 0,
    saturate: 0,
    scale: "1",
    tint: false,
    tintColor: "#FFFFFF",
    zIndex: 1
  };
}
function aura$1() {
  return {
    addTokenWidth: true,
    alpha: false,
    alphaMax: 0.5,
    alphaMin: -0.5,
    alphaDuration: 1e3,
    breath: false,
    breathMax: 1.05,
    breathMin: 0.95,
    breathDuration: 1e3,
    delay: 0,
    elevation: 1e3,
    fadeIn: 250,
    fadeOut: 500,
    isRadius: true,
    isWait: false,
    opacity: 1,
    playbackRate: 1,
    playOn: "source",
    size: 3,
    tint: false,
    tintColor: "#FFFFFF",
    tintSaturate: 0,
    unbindAlpha: false,
    unbindVisibility: false,
    zIndex: 1
  };
}
function aefx$1(aeType) {
  if (aeType === "ontoken") {
    return {
      addTokenWidth: false,
      anchor: "0.5",
      delay: 0,
      elevation: 1e3,
      fadeIn: 250,
      fadeOut: 500,
      isMasked: false,
      isRadius: false,
      isWait: false,
      opacity: 1,
      persistent: false,
      playbackRate: 1,
      playOn: "source",
      repeat: 1,
      repeatDelay: 250,
      size: 1,
      unbindAlpha: false,
      unbindVisibility: false,
      zIndex: 1
    };
  } else if (aeType === "aura") {
    return {
      addTokenWidth: true,
      alpha: false,
      alphaMax: 0.5,
      alphaMin: -0.5,
      alphaDuration: 1e3,
      breath: false,
      breathMax: 1.05,
      breathMin: 0.95,
      breathDuration: 1e3,
      delay: 0,
      elevation: 1e3,
      fadeIn: 250,
      fadeOut: 500,
      isRadius: false,
      isWait: false,
      opacity: 1,
      playbackRate: 1,
      playOn: "source",
      size: 3,
      tint: false,
      tintColor: "#FFFFFF",
      tintSaturate: 0,
      unbindAlpha: false,
      unbindVisibility: false,
      zIndex: 1
    };
  }
}
function melee(current = {}) {
  return {
    id: current.id || uuidv4(),
    label: current.label || "",
    levels3d: current.levels3d || levels3d(),
    macro: current.macro || macro(),
    meleeSwitch: meleeSwitch(),
    menu: "melee",
    primary: primary({
      options: melee$1(),
      video: { dbSection: "melee", menuType: "weapon", animation: "club", variant: "01", color: "white" }
    }),
    secondary: current.secondary || secondary(),
    soundOnly: current.soundOnly || {
      sound: sound()
    },
    source: current.source || source(),
    target: current.target || target()
  };
}
function range(current = {}) {
  return {
    id: current.id || uuidv4(),
    label: current.label,
    levels3d: current.levels3d || levels3d(),
    macro: current.macro || macro(),
    menu: "range",
    primary: primary({
      options: range$1(),
      video: { dbSection: "range", menuType: "weapon", animation: "arrow", variant: "regular", color: "regular" }
    }),
    secondary: current.secondary || secondary(),
    soundOnly: current.soundOnly || {
      sound: sound()
    },
    source: current.source || source(),
    target: current.target || target()
  };
}
function ontoken(current = {}) {
  return {
    id: current.id || uuidv4(),
    label: current.label,
    levels3d: current.levels3d || levels3d(),
    macro: current.macro || macro(),
    menu: "ontoken",
    primary: primary({
      options: ontoken$1(),
      video: { dbSection: "static", menuType: "spell", animation: "curewounds", variant: "01", color: "blue" }
    }),
    secondary: current.secondary || secondary(),
    soundOnly: current.soundOnly || {
      sound: sound()
    },
    source: current.source || source(),
    target: current.target || target()
  };
}
function templatefx(current = {}) {
  return {
    id: current.id || uuidv4(),
    label: current.label,
    macro: current.macro || macro(),
    menu: "templatefx",
    primary: primary({
      options: templatefx$1(),
      video: { dbSection: "templatefx", menuType: "circle", animation: "calllightning", variant: "01", color: "blue" }
    }),
    secondary: current.secondary || secondary(),
    soundOnly: current.soundOnly || {
      sound: sound()
    },
    source: current.source || source(),
    target: current.target || target()
  };
}
function aura(current = {}) {
  return {
    id: current.id || uuidv4(),
    label: current.label,
    macro: current.macro || macro(),
    menu: "aura",
    primary: primary({
      options: aura$1(),
      video: { dbSection: "static", menuType: "spell", animation: "spiritguardians", variant: "01", color: "yellowblue" }
    }),
    secondary: current.secondary || secondary(),
    soundOnly: current.soundOnly || {
      sound: sound()
    },
    source: current.source || source(),
    target: current.target || target()
  };
}
function preset(current = {}, type) {
  switch (type) {
    case "dualattach":
      return {
        id: current.id || uuidv4(),
        data: {
          video: {
            dbSection: "range",
            menuType: "weapon",
            animation: "arrow",
            variant: "regular",
            color: "regular"
          },
          options: {
            elevation: 1e3,
            onlyX: false,
            opacity: 1,
            playbackRate: 1
          },
          sound: sound()
        },
        label: current.label || "",
        macro: current.macro || macro(),
        menu: "preset",
        presetType: current.presetType || "",
        soundOnly: {
          sound: sound()
        }
      };
    case "proToTemp":
      return {
        id: current.id || uuidv4(),
        data: {
          projectile: {
            dbSection: "range",
            menuType: "spell",
            animation: "fireballbeam",
            variant: "01",
            color: "orange",
            enableCustom: false,
            customPath: "",
            options: {
              elevation: 1e3,
              opacity: 1,
              playbackRate: 1,
              repeat: 1,
              repeatDelay: 250,
              removeTemplate: false,
              wait: -1800
            },
            sound: sound()
          },
          preExplosion: {
            enable: false,
            dbSection: "static",
            menuType: "spell",
            animation: "curewounds",
            variant: "01",
            color: "blue",
            options: {
              elevation: 1e3,
              opacity: 1,
              playbackRate: 1,
              repeat: 1,
              repeatDelay: 250,
              scale: 1,
              wait: 0
            },
            sound: sound()
          },
          explosion: {
            dbSection: "static",
            menuType: "spell",
            animation: "fireball",
            variant: "explode",
            color: "orange",
            options: {
              elevation: 1e3,
              opacity: 1,
              playbackRate: 1,
              repeat: 1,
              repeatDelay: 250,
              scale: 1.25,
              wait: -1e3
            },
            sound: sound()
          },
          afterImage: {
            enable: false,
            customPath: "",
            options: {
              elevation: 0,
              persistent: false,
              scale: 1
            }
          }
        },
        label: current.label || "",
        macro: current.macro || macro(),
        menu: "preset",
        presetType: current.presetType || "",
        soundOnly: {
          sound: sound()
        },
        secondary: secondary(),
        target: target()
      };
    case "teleportation":
      return {
        id: current.id || uuidv4(),
        data: {
          start: {
            dbSection: "static",
            enabe: true,
            menuType: "spell",
            animation: "mistystep",
            variant: "01",
            color: "blue",
            options: {
              delay: 0,
              elevation: 1e3,
              fadeIn: 250,
              fadeOut: 250,
              isMasked: false,
              opacity: 1,
              isRadius: false,
              playbackRate: 1,
              size: 1.5
            }
          },
          between: {
            dbSection: "range",
            enable: false,
            menuType: "weapon",
            animation: "arrow",
            variant: "regular",
            color: "regular",
            options: {
              delay: 0,
              elevation: 1e3,
              opacity: 1,
              playbackRate: 1
            }
          },
          end: {
            dbSection: "static",
            enabe: true,
            menuType: "spell",
            animation: "mistystep",
            variant: "02",
            color: "blue",
            options: {
              delay: 500,
              elevation: 1e3,
              fadeIn: 250,
              fadeOut: 250,
              isMasked: false,
              isRadius: false,
              opacity: 1,
              playbackRate: 1,
              size: 1.5
            }
          },
          options: {
            range: 30,
            hideFromPlayers: false,
            measureType: "alternating",
            teleport: true,
            speed: 120,
            delayMove: 1e3,
            alpha: 0,
            delayFade: 750,
            delayReturn: 250,
            checkCollision: true
          },
          sound: { enable: false }
        },
        label: current.label || "",
        macro: current.macro || macro(),
        menu: "preset",
        presetType: current.presetType || "",
        soundOnly: {
          sound: sound()
        }
      };
    case "thunderwave":
      return {
        id: current.id || uuidv4(),
        data: {
          video: {
            dbSection: "static",
            menuType: "spell",
            animation: "thunderwave",
            variant: "mid",
            color: "blue"
          },
          options: {
            elevation: 1e3,
            removeTemplate: false,
            repeat: 1,
            repeatDelay: 250,
            opacity: 1
          },
          sound: { enable: false }
        },
        label: current.label || "",
        macro: current.macro || macro(),
        menu: "preset",
        presetType: current.presetType || "",
        soundOnly: {
          sound: sound()
        }
      };
    default:
      return {
        id: current.id || uuidv4(),
        data: {
          projectile: {
            dbSection: "range",
            menuType: "weapon",
            animation: "arrow",
            variant: "regular",
            color: "regular",
            enableCustom: false,
            customPath: "",
            options: {
              elevation: 1e3,
              opacity: 1,
              playbackRate: 1,
              repeat: 1,
              repeatDelay: 250,
              removeTemplate: false,
              wait: -1800
            },
            sound: sound()
          },
          preExplosion: {
            dbSection: "static",
            menuType: "spell",
            animation: "curewounds",
            variant: "01",
            color: "blue",
            options: {
              elevation: 1e3,
              opacity: 1,
              playbackRate: 1,
              repeat: 1,
              repeatDelay: 250,
              scale: 1,
              wait: 0
            },
            enable: false,
            sound: sound()
          },
          explosion: {
            dbSection: "static",
            menuType: "spell",
            animation: "curewounds",
            variant: "01",
            color: "blue",
            options: {
              elevation: 1e3,
              opacity: 1,
              playbackRate: 1,
              repeat: 1,
              repeatDelay: 250,
              scale: 1.25,
              wait: -1e3
            },
            sound: sound()
          },
          afterImage: {
            enable: false,
            customPath: "",
            options: {
              elevation: 0,
              persistent: false,
              scale: 1
            }
          }
        },
        label: current.label || "",
        macro: current.macro || macro(),
        menu: "preset",
        presetType: current.presetType || "proToTemp",
        soundOnly: {
          sound: sound()
        },
        secondary: secondary(),
        target: target()
      };
  }
}
function aefx(current = {}, type) {
  if (type === "ontoken") {
    return {
      id: current.id || uuidv4(),
      label: current.label || "",
      activeEffectType: current.activeEffectType || "ontoken",
      menu: "aefx",
      macro: current.macro || macro(),
      primary: {
        video: {
          dbSection: "static",
          menuType: "spell",
          animation: "curewounds",
          variant: "01",
          color: "blue",
          enableCustom: false,
          customPath: ""
        },
        options: aefx$1("ontoken"),
        sound: sound()
      },
      secondary: current.secondary || secondary(),
      soundOnly: current.soundOnly || { sound: sound() },
      source: current.source || source()
    };
  } else if (type === "aura") {
    return {
      id: current.id || uuidv4(),
      label: current.label || "",
      activeEffectType: current.activeEffectType || "ontoken",
      menu: "aefx",
      macro: current.macro || macro(),
      primary: {
        video: {
          dbSection: "static",
          menuType: "spell",
          animation: "spiritguardians",
          variant: "01",
          color: "yellowblue",
          enableCustom: false,
          customPath: ""
        },
        options: aefx$1("aura"),
        sound: sound()
      },
      secondary: current.secondary || secondary(),
      soundOnly: current.soundOnly || { sound: sound() },
      source: current.source || source()
    };
  } else {
    return {
      id: current.id || uuidv4(),
      label: current.label || "",
      activeEffectType: current.activeEffectType || "ontoken",
      menu: "aefx",
      macro: current.macro || macro(),
      primary: {
        video: {
          dbSection: "static",
          menuType: "spell",
          animation: "curewounds",
          variant: "01",
          color: "blue",
          enableCustom: false,
          customPath: ""
        },
        options: aefx$1("ontoken"),
        sound: sound()
      },
      secondary: current.secondary || secondary(),
      soundOnly: current.soundOnly || { sound: sound() },
      source: current.source || source()
    };
  }
}
const changeSection = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aefx,
  aura,
  melee,
  ontoken,
  preset,
  range,
  templatefx
}, Symbol.toStringTag, { value: "Module" }));
function ripple({
  duration = 600,
  background = "rgba(255, 255, 255, 0.7)",
  events = ["click", "keyup"],
  keyCode = "Enter",
  debounce: debounce$1
} = {}) {
  return (element2) => {
    function createRipple(e) {
      const elementRect = element2.getBoundingClientRect();
      const diameter = Math.max(elementRect.width, elementRect.height);
      const radius = diameter / 2;
      const left = e.clientX ? `${e.clientX - (elementRect.left + radius)}px` : "0";
      const top = e.clientY ? `${e.clientY - (elementRect.top + radius)}px` : "0";
      const span = document.createElement("span");
      span.style.position = "absolute";
      span.style.width = `${diameter}px`;
      span.style.height = `${diameter}px`;
      span.style.left = left;
      span.style.top = top;
      span.style.background = `var(--tjs-action-ripple-background, ${background})`;
      span.style.borderRadius = "50%";
      span.style.pointerEvents = "none";
      span.style.transform = "translateZ(-1px)";
      element2.prepend(span);
      const animation = span.animate(
        [
          {
            // from
            transform: "scale(.7)",
            opacity: 0.5,
            filter: "blur(2px)"
          },
          {
            // to
            transform: "scale(4)",
            opacity: 0,
            filter: "blur(5px)"
          }
        ],
        duration
      );
      animation.onfinish = () => {
        if (span && span.isConnected) {
          span.remove();
        }
      };
    }
    function keyHandler(event) {
      if (event?.code === keyCode) {
        createRipple(event);
      }
    }
    const eventFn = Number.isInteger(debounce$1) && debounce$1 > 0 ? debounce(createRipple, debounce$1) : createRipple;
    const keyEventFn = Number.isInteger(debounce$1) && debounce$1 > 0 ? debounce(keyHandler, debounce$1) : keyHandler;
    for (const event of events) {
      if (["keydown", "keyup"].includes(event)) {
        element2.addEventListener(event, keyEventFn);
      } else {
        element2.addEventListener(event, eventFn);
      }
    }
    return {
      destroy: () => {
        for (const event of events) {
          if (["keydown", "keyup"].includes(event)) {
            element2.removeEventListener(event, keyEventFn);
          } else {
            element2.removeEventListener(event, eventFn);
          }
        }
      }
    };
  };
}
function rippleFocus({ duration = 300, background = "rgba(255, 255, 255, 0.7)", selectors } = {}) {
  return (element2) => {
    const targetEl = typeof selectors === "string" ? element2.querySelector(selectors) : element2.firstChild instanceof HTMLElement ? element2.firstChild : element2;
    let span = void 0;
    let clientX = -1;
    let clientY = -1;
    function blurRipple() {
      if (!(span instanceof HTMLElement) || document.activeElement === targetEl) {
        return;
      }
      const animation = span.animate(
        [
          {
            // from
            transform: "scale(3)",
            opacity: 0.3
          },
          {
            // to
            transform: "scale(.7)",
            opacity: 0
          }
        ],
        {
          duration,
          fill: "forwards"
        }
      );
      animation.onfinish = () => {
        clientX = clientY = -1;
        if (span && span.isConnected) {
          span.remove();
        }
        span = void 0;
      };
    }
    function focusRipple() {
      if (span instanceof HTMLElement) {
        return;
      }
      const elementRect = element2.getBoundingClientRect();
      const actualX = clientX >= 0 ? clientX : elementRect.left + elementRect.width / 2;
      const actualY = clientX >= 0 ? clientY : elementRect.top + elementRect.height / 2;
      const diameter = Math.max(elementRect.width, elementRect.height);
      const radius = diameter / 2;
      const left = `${actualX - (elementRect.left + radius)}px`;
      const top = `${actualY - (elementRect.top + radius)}px`;
      span = document.createElement("span");
      span.style.position = "absolute";
      span.style.width = `${diameter}px`;
      span.style.height = `${diameter}px`;
      span.style.left = left;
      span.style.top = top;
      span.style.background = `var(--tjs-action-ripple-background-focus, var(--tjs-action-ripple-background, ${background}))`;
      span.style.borderRadius = "50%";
      span.style.pointerEvents = "none";
      span.style.transform = "translateZ(-1px)";
      element2.prepend(span);
      span.animate(
        [
          {
            // from
            transform: "scale(.7)",
            opacity: 0.5
          },
          {
            // to
            transform: "scale(3)",
            opacity: 0.3
          }
        ],
        {
          duration,
          fill: "forwards"
        }
      );
    }
    function onPointerDown(e) {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    targetEl.addEventListener("pointerdown", onPointerDown);
    targetEl.addEventListener("blur", blurRipple);
    targetEl.addEventListener("focus", focusRipple);
    return {
      destroy: () => {
        targetEl.removeEventListener("pointerdown", onPointerDown);
        targetEl.removeEventListener("blur", blurRipple);
        targetEl.removeEventListener("focus", focusRipple);
      }
    };
  };
}
function toggleDetails(details, { store, clickActive = true } = {}) {
  const summary = details.querySelector("summary");
  let animation;
  let open = details.open;
  const unsubscribe = subscribeFirstRest(store, (value) => {
    open = value;
    details.open = open;
  }, async (value) => {
    open = value;
    await tick();
    handleAnimation2();
  });
  function animate2(a, b, value) {
    details.style.overflow = "hidden";
    const duration = Math.max(0, 30 * Math.log(Math.abs(b - a) + Number.EPSILON));
    animation = details.animate(
      {
        height: [`${a}px`, `${b}px`]
      },
      {
        duration,
        easing: "ease-out"
      }
    );
    animation.onfinish = () => {
      details.open = value;
      details.dataset.closing = "false";
      details.style.overflow = "";
    };
  }
  function handleAnimation2() {
    if (open) {
      const a = details.offsetHeight;
      if (animation) {
        animation.cancel();
      }
      details.open = true;
      const b = details.offsetHeight;
      animate2(a, b, true);
    } else {
      const a = details.offsetHeight;
      const b = summary.offsetHeight;
      details.dataset.closing = "true";
      animate2(a, b, false);
    }
  }
  function handleClick(e) {
    if (clickActive) {
      e.preventDefault();
      store.set(!open);
    }
  }
  summary.addEventListener("click", handleClick);
  return {
    destroy() {
      unsubscribe();
      summary.removeEventListener("click", handleClick);
    }
  };
}
class ObjectEntryStore {
  /**
   * @type {object}
   */
  #data;
  /**
   * Stores the subscribers.
   *
   * @type {(function(object): void)[]}
   */
  #subscriptions = [];
  /**
   * @param {object}   data -
   */
  constructor(data2 = {}) {
    if (!isObject(data2)) {
      throw new TypeError(`'data' is not an object.`);
    }
    this.#data = data2;
    if (typeof data2.id !== "string") {
      this.#data.id = uuidv4();
    }
    if (!uuidv4.isValid(data2.id)) {
      throw new Error(`'data.id' (${data2.id}) is not a valid UUIDv4 string.`);
    }
  }
  /**
   * Invoked by ArrayObjectStore to provide custom duplication. Override this static method in your entry store.
   *
   * @param {object}   data - A copy of local data w/ new ID already set.
   *
   * @param {ArrayObjectStore} arrayStore - The source ArrayObjectStore instance.
   */
  static duplicate(data2, arrayStore) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * @returns {object}
   * @protected
   */
  get _data() {
    return this.#data;
  }
  // ----------------------------------------------------------------------------------------------------------------
  /**
   * @returns {string}
   */
  get id() {
    return this.#data.id;
  }
  toJSON() {
    return this.#data;
  }
  /**
   * @param {function(object): void} handler - Callback function that is invoked on update / changes.
   *
   * @returns {(function(): void)} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this.#data);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  /**
   * @protected
   */
  _updateSubscribers() {
    const subscriptions = this.#subscriptions;
    const data2 = this.#data;
    for (let cntr = 0; cntr < subscriptions.length; cntr++) {
      subscriptions[cntr](data2);
    }
  }
}
class ArrayObjectStore {
  /** @type {T[]} */
  #data = [];
  /**
   * @type {Map<string, { store: T, unsubscribe: Function}>}
   */
  #dataMap = /* @__PURE__ */ new Map();
  /**
   * @type {DynArrayReducer<T>}
   */
  #dataReducer;
  /**
   * @type {boolean}
   */
  #manualUpdate;
  #StoreClass;
  /**
   * Stores the subscribers.
   *
   * @type {(function(T[]): void)[]}
   */
  #subscriptions = [];
  /**
   * @type {Function}
   */
  #updateSubscribersBound;
  /**
   * @returns {ObjectEntryStore}
   */
  static get EntryStore() {
    return ObjectEntryStore;
  }
  /**
   * @param {ArrayObjectStoreParams} params -
   */
  constructor({ StoreClass, defaultData: defaultData2 = [], childDebounce = 250, dataReducer = false, manualUpdate = false } = {}) {
    if (!Number.isInteger(childDebounce) || childDebounce < 0 || childDebounce > 1e3) {
      throw new TypeError(`'childDebounce' must be an integer between and including 0 - 1000.`);
    }
    if (typeof manualUpdate !== "boolean") {
      throw new TypeError(`'manualUpdate' is not a boolean.`);
    }
    if (!isWritableStore(StoreClass.prototype)) {
      throw new TypeError(`'StoreClass' is not a writable store constructor.`);
    }
    let hasIDGetter = false;
    for (let o = StoreClass.prototype; o; o = Object.getPrototypeOf(o)) {
      const descriptor = Object.getOwnPropertyDescriptor(o, "id");
      if (descriptor !== void 0 && descriptor.get !== void 0) {
        hasIDGetter = true;
        break;
      }
    }
    if (!hasIDGetter) {
      throw new TypeError(`'StoreClass' does not have a getter accessor for 'id' property.`);
    }
    if (!Array.isArray(defaultData2)) {
      throw new TypeError(`'defaultData' is not an array.`);
    }
    this.#manualUpdate = manualUpdate;
    this.#StoreClass = StoreClass;
    if (dataReducer) {
      this.#dataReducer = new DynArrayReducer({ data: this.#data });
    }
    this.#updateSubscribersBound = childDebounce === 0 ? this.updateSubscribers.bind(this) : debounce((data2) => this.updateSubscribers(data2), childDebounce);
  }
  /**
   * Provide an iterator for public access to entry stores.
   *
   * @returns {Generator<T | void>}
   * @yields {T|void}
   */
  *[Symbol.iterator]() {
    if (this.#data.length === 0) {
      return;
    }
    for (const entryStore of this.#data) {
      yield entryStore;
    }
  }
  /**
   * @returns {T[]}
   * @protected
   */
  get _data() {
    return this.#data;
  }
  /**
   * @returns {DynArrayReducer<T>}
   */
  get dataReducer() {
    if (!this.#dataReducer) {
      throw new Error(
        `'dataReducer' is not initialized; did you forget to specify 'dataReducer' as true in constructor options?`
      );
    }
    return this.#dataReducer;
  }
  /**
   * @returns {number}
   */
  get length() {
    return this.#data.length;
  }
  /**
   * Removes all child store entries.
   */
  clearEntries() {
    for (const storeEntryData of this.#dataMap.values()) {
      storeEntryData.unsubscribe();
    }
    this.#dataMap.clear();
    this.#data.length = 0;
    this.updateSubscribers();
  }
  /**
   * Creates a new store from given data.
   *
   * @param {object}   entryData -
   *
   * @returns {T}
   */
  createEntry(entryData = {}) {
    if (!isObject(entryData)) {
      throw new TypeError(`'entryData' is not an object.`);
    }
    if (typeof entryData.id !== "string") {
      entryData.id = uuidv4();
    }
    if (this.#data.findIndex((entry) => entry.id === entryData.id) >= 0) {
      throw new Error(`'entryData.id' (${entryData.id}) already in this ArrayObjectStore instance.`);
    }
    const store = this.#createStore(entryData);
    this.updateSubscribers();
    return store;
  }
  /**
   * Add a new store entry from the given data.
   *
   * @param {object}   entryData -
   *
   * @returns {T} New store entry instance.
   */
  #createStore(entryData) {
    const store = new this.#StoreClass(entryData, this);
    if (!uuidv4.isValid(store.id)) {
      throw new Error(`'store.id' (${store.id}) is not a UUIDv4 compliant string.`);
    }
    const unsubscribe = subscribeIgnoreFirst(store, this.#updateSubscribersBound);
    this.#data.push(store);
    this.#dataMap.set(entryData.id, { store, unsubscribe });
    return store;
  }
  /**
   * Deletes a given entry store by ID from this world setting array store instance.
   *
   * @param {string}  id - ID of entry to delete.
   *
   * @returns {boolean} Delete operation successful.
   */
  deleteEntry(id) {
    const result = this.#deleteStore(id);
    if (result) {
      this.updateSubscribers();
    }
    return result;
  }
  #deleteStore(id) {
    if (typeof id !== "string") {
      throw new TypeError(`'id' is not a string.`);
    }
    const storeEntryData = this.#dataMap.get(id);
    if (storeEntryData) {
      storeEntryData.unsubscribe();
      this.#dataMap.delete(id);
      const index = this.#data.findIndex((entry) => entry.id === id);
      if (index >= 0) {
        this.#data.splice(index, 1);
      }
      return true;
    }
    return false;
  }
  /**
   * Duplicates an entry store by the given ID.
   *
   * @param {string}   id - UUIDv4 string.
   *
   * @returns {*} Instance of StoreClass.
   */
  duplicateEntry(id) {
    if (typeof id !== "string") {
      throw new TypeError(`'id' is not a string.`);
    }
    const storeEntryData = this.#dataMap.get(id);
    if (storeEntryData) {
      const data2 = klona(storeEntryData.store.toJSON());
      data2.id = uuidv4();
      this.#StoreClass?.duplicate?.(data2, this);
      return this.createEntry(data2);
    }
    return void 0;
  }
  /**
   * Find an entry in the backing child store array.
   *
   * @param {function(T): T|void}  predicate - A predicate function
   *
   * @returns {T|void} Found entry in array or undefined.
   */
  findEntry(predicate) {
    return this.#data.find(predicate);
  }
  /**
   * Finds an entry store instance by 'id' / UUIDv4.
   *
   * @param {string}   id - A UUIDv4 string.
   *
   * @returns {T|void} Entry store instance.
   */
  getEntry(id) {
    const storeEntryData = this.#dataMap.get(id);
    return storeEntryData ? storeEntryData.store : void 0;
  }
  /**
   * Sets the children store data by 'id', adds new entry store instances, or removes entries that are no longer in the
   * update list.
   *
   * @param {T[]}   updateList -
   */
  set(updateList) {
    if (!Array.isArray(updateList)) {
      console.warn(`ArrayObjectStore.set warning: aborting set operation as 'updateList' is not an array.`);
      return;
    }
    const data2 = this.#data;
    const dataMap = this.#dataMap;
    const removeIDSet = new Set(dataMap.keys());
    let rebuildIndex = false;
    for (let updateIndex = 0; updateIndex < updateList.length; updateIndex++) {
      const updateData = updateList[updateIndex];
      const id = updateData.id;
      if (typeof id !== "string") {
        throw new Error(`'updateData.id' is not a string.`);
      }
      const localIndex = data2.findIndex((entry) => entry.id === id);
      if (localIndex >= 0) {
        const localEntry = data2[localIndex];
        localEntry.set(updateData);
        if (localIndex !== updateIndex) {
          data2.splice(localIndex, 1);
          if (updateIndex < data2.length) {
            data2.splice(updateIndex, 0, localEntry);
          } else {
            rebuildIndex = true;
          }
        }
        removeIDSet.delete(id);
      } else {
        this.#createStore(updateData);
      }
    }
    if (rebuildIndex) {
      for (const storeEntryData of dataMap.values()) {
        storeEntryData.unsubscribe();
      }
      data2.length = 0;
      dataMap.clear();
      for (const updateData of updateList) {
        this.#createStore(updateData);
      }
    } else {
      for (const id of removeIDSet) {
        this.#deleteStore(id);
      }
    }
    this.updateSubscribers();
  }
  toJSON() {
    return this.#data;
  }
  // -------------------------------------------------------------------------------------------------------------------
  /**
   * @param {function(T[]): void} handler - Callback function that is invoked on update / changes.
   *
   * @returns {(function(): void)} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this.#data);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  /**
   * Updates subscribers.
   *
   * @param {ArrayObjectUpdateData}  [update] -
   */
  updateSubscribers(update2) {
    const updateGate = typeof update2 === "boolean" ? update2 : !this.#manualUpdate;
    if (updateGate) {
      const subscriptions = this.#subscriptions;
      const data2 = this.#data;
      for (let cntr = 0; cntr < subscriptions.length; cntr++) {
        subscriptions[cntr](data2);
      }
    }
    if (this.#dataReducer) {
      this.#dataReducer.index.update(true);
    }
  }
}
class CrudArrayObjectStore extends ArrayObjectStore {
  /** @type {CrudDispatch} */
  #crudDispatch;
  /** @type {object} */
  #extraData;
  /**
   * @param {object}                  [opts] - Optional parameters.
   *
   * @param {CrudDispatch}            [opts.crudDispatch] -
   *
   * @param {object}                  [opts.extraData] -
   *
   * @param {ArrayObjectStoreParams}  [opts.rest] - Rest of ArrayObjectStore parameters.
   */
  constructor({ crudDispatch, extraData, ...rest }) {
    super({
      manualUpdate: typeof crudDispatch === "function",
      ...rest
    });
    if (crudDispatch !== void 0 && typeof crudDispatch !== "function") {
      throw new TypeError(`'crudDispatch' is not a function.`);
    }
    if (extraData !== void 0 && !isObject(extraData)) {
      throw new TypeError(`'extraData' is not an object.`);
    }
    this.#crudDispatch = crudDispatch;
    this.#extraData = extraData ?? {};
  }
  /**
   * Removes all child store entries.
   */
  clearEntries() {
    super.clearEntries();
    if (this.#crudDispatch) {
      this.#crudDispatch({ action: "clear", ...this.#extraData });
    }
  }
  /**
   * Creates a new store from given data.
   *
   * @param {object}   entryData -
   *
   * @returns {T}
   */
  createEntry(entryData = {}) {
    const store = super.createEntry(entryData);
    if (store && this.#crudDispatch) {
      this.#crudDispatch({
        action: "create",
        ...this.#extraData,
        id: store.id,
        data: store.toJSON()
      });
    }
    return store;
  }
  /**
   * Deletes a given entry store by ID from this world setting array store instance.
   *
   * @param {string}  id - ID of entry to delete.
   *
   * @returns {boolean} Delete operation successful.
   */
  deleteEntry(id) {
    const result = super.deleteEntry(id);
    if (result && this.#crudDispatch) {
      this.#crudDispatch({ action: "delete", ...this.#extraData, id });
    }
    return result;
  }
  /**
   * Updates subscribers, but provides special handling when WorldSettingArrayStore has an `crudDispatch` function
   * attached. When the update is an object with a valid UUIDv4 string as the id property the `crudDispatch`
   * function is invoked with  along with the data payload
   *
   * @param {ArrayObjectUpdateData} [update] -
   */
  updateSubscribers(update2) {
    if (this.#crudDispatch && isObject(update2) && uuidv4.isValid(update2.id)) {
      const result = this.#crudDispatch({
        action: "update",
        ...this.#extraData,
        id: update2.id,
        data: update2
        // TODO: Consider using klona to clone data.
      });
      super.updateSubscribers(typeof result === "boolean" ? result : update2);
    } else {
      super.updateSubscribers(update2);
    }
  }
}
function createFilterQuery(properties, { caseSensitive = false, store } = {}) {
  let keyword = "";
  let regex;
  if (store !== void 0 && !isWritableStore(store)) {
    throw new TypeError(`createFilterQuery error: 'store' is not a writable store.`);
  }
  const storeKeyword = store ? store : writable$1(keyword);
  if (store) {
    const current = get_store_value(store);
    if (typeof current === "string") {
      keyword = normalizeString(current);
      regex = new RegExp(RegExp.escape(keyword), caseSensitive ? "" : "i");
    } else {
      store.set(keyword);
    }
  }
  function filterQuery(data2) {
    if (keyword === "" || !regex) {
      return true;
    }
    if (isIterable(properties)) {
      for (const property of properties) {
        if (regex.test(normalizeString(data2?.[property]))) {
          return true;
        }
      }
      return false;
    } else {
      return regex.test(normalizeString(data2?.[properties]));
    }
  }
  filterQuery.subscribe = (handler) => {
    return storeKeyword.subscribe(handler);
  };
  filterQuery.set = (value) => {
    if (typeof value === "string") {
      keyword = normalizeString(value);
      regex = new RegExp(RegExp.escape(keyword), caseSensitive ? "" : "i");
      storeKeyword.set(keyword);
    }
  };
  return filterQuery;
}
class UIControl {
  /** @type {TJSSettingsCustomSection[]} */
  #sections = [];
  /** @type {TJSGameSettings} */
  #settings;
  /** @type {boolean} */
  #showSettings = false;
  /** @type {Function} */
  #showSettingsSet;
  /** @type {{showSettings: import('svelte/store').Readable<boolean>}} */
  #stores;
  /**
   * @param {TJSGameSettings}   settings -
   */
  constructor(settings) {
    this.#settings = settings;
    const showSettings = writable$1(this.#showSettings);
    this.#showSettingsSet = showSettings.set;
    this.#stores = {
      showSettings: { subscribe: showSettings.subscribe }
    };
    Object.freeze(this.#stores);
  }
  /**
   * @returns {boolean} Current `showSettings` state.
   */
  get showSettings() {
    return this.#showSettings;
  }
  /**
   * @returns {{showSettings: import('svelte/store').Readable<boolean>}} Returns the managed stores.
   */
  get stores() {
    return this.#stores;
  }
  /**
   * Sets current `showSettings` state.
   *
   * @param {boolean}  showSettings - New `showSettings` state.
   */
  set showSettings(showSettings) {
    this.#showSettings = showSettings;
    this.#showSettingsSet(this.#showSettings);
  }
  /**
   * Adds a custom section / folder defined by the provided TJSSettingsCustomSection options object.
   *
   * @param {TJSSettingsCustomSection} options - The configuration object for the custom section.
   */
  addSection(options2) {
    if (!isObject(options2)) {
      throw new TypeError(`'options' is not an object.`);
    }
    if (!isSvelteComponent(options2.class)) {
      throw new TypeError(`'options.class' is not a Svelte component.`);
    }
    if (options2.props !== void 0 && !isObject(options2.props)) {
      throw new TypeError(`'options.props' is not an object.`);
    }
    if (options2.folder !== void 0) {
      const folder = options2.folder;
      if (typeof folder !== "string" && !isObject(folder)) {
        throw new TypeError(`'options.folder' is not a string or object.`);
      }
      if (isObject(folder)) {
        if (typeof folder.label !== "string") {
          throw new TypeError(`'options.folder.label' is not a string.`);
        }
        if (folder.summaryEnd !== void 0) {
          if (!isObject(folder.summaryEnd)) {
            throw new TypeError(`'options.folder.summaryEnd' is not an object.`);
          }
          if (!isSvelteComponent(folder.summaryEnd.class)) {
            throw new TypeError(`'options.folder.summaryEnd.class' is not a Svelte component.`);
          }
          if (folder.summaryEnd.props !== void 0 && !isObject(folder.summaryEnd.props)) {
            throw new TypeError(`'options.folder.summaryEnd.props' is not an object.`);
          }
        }
        if (folder.styles !== void 0 && !isObject(folder.styles)) {
          throw new TypeError(`'options.folder.styles' is not an object.`);
        }
      }
    }
    if (options2.styles !== void 0 && !isObject(options2.styles)) {
      throw new TypeError(`'options.styles' is not an object.`);
    }
    this.#sections.push(options2);
  }
  /**
   * Creates the UISettingsData object by parsing stored settings in
   *
   * @param {TJSSettingsCreateOptions} [options] - Optional parameters.
   *
   * @returns {TJSSettingsUIData} Parsed UI settings data.
   */
  create(options2) {
    const settings = this.#parseSettings(options2);
    const destroy = () => this.#destroy(settings);
    return {
      ...settings,
      destroy
    };
  }
  /**
   * Destroy callback. Checks for any `requiresReload` parameter in each setting comparing against initial value
   * when `settings` is created and current value. If there is a difference then show a modal dialog asking the user
   * if they want to reload for those settings to take effect.
   *
   * @param {TJSSettingsUIData}   settings - The UI data object initiated w/ `create`.
   */
  #destroy(settings) {
    let requiresClientReload = false;
    let requiresWorldReload = false;
    if (Array.isArray(settings.topLevel)) {
      for (const setting of settings.topLevel) {
        const current = globalThis.game.settings.get(setting.namespace, setting.key);
        if (current === setting.initialValue) {
          continue;
        }
        requiresClientReload ||= setting.scope === "client" && setting.requiresReload;
        requiresWorldReload ||= setting.scope === "world" && setting.requiresReload;
      }
    }
    if (Array.isArray(settings.folders)) {
      for (const folder of settings.folders) {
        if (Array.isArray(folder.settings)) {
          for (const setting of folder.settings) {
            const current = globalThis.game.settings.get(setting.namespace, setting.key);
            if (current === setting.initialValue) {
              continue;
            }
            requiresClientReload ||= setting.scope === "client" && setting.requiresReload;
            requiresWorldReload ||= setting.scope === "world" && setting.requiresReload;
          }
        }
      }
    }
    if (requiresClientReload || requiresWorldReload) {
      this.#reloadConfirm({ world: requiresWorldReload });
    }
    this.#showSettings = false;
    this.#showSettingsSet(this.#showSettings);
  }
  /**
   * @param {TJSSettingsCreateOptions} [options] - Optional parameters.
   *
   * @returns {TJSSettingsUIData} Parsed UI settings data.
   */
  #parseSettings({ efx = "ripple", storage: storage2 } = {}) {
    const namespace = this.#settings.namespace;
    if (storage2 && typeof namespace !== "string") {
      console.warn(
        `TJSGameSettings warning: 'options.storage' defined, but 'namespace' not defined in TJSGameSettings.`
      );
    }
    const hasStorage = storage2 && typeof namespace === "string";
    const uiSettings = [];
    const canConfigure = globalThis.game.user.can("SETTINGS_MODIFY");
    for (const setting of this.#settings) {
      if (!setting.config || !canConfigure && setting.scope !== "client") {
        continue;
      }
      let options2;
      if (typeof setting.choices === "object") {
        options2 = Object.entries(setting.choices).map((entry) => ({ value: entry[0], label: localize(entry[1]) }));
      }
      let range2;
      if (typeof setting.range === "object") {
        range2 = {};
        if (typeof setting.range.min !== "number") {
          throw new TypeError(`Setting 'range.min' is not a number.`);
        }
        if (typeof setting.range.max !== "number") {
          throw new TypeError(`Setting 'range.max' is not a number.`);
        }
        if (setting.range.step !== void 0 && typeof setting.range.step !== "number") {
          throw new TypeError(`Setting 'range.step' is not a number.`);
        }
        range2.min = setting.range.min;
        range2.max = setting.range.max;
        range2.step = setting.range.step ? setting.range.step : 1;
      }
      const type = setting.type instanceof Function ? setting.type.name : "String";
      let filePicker;
      if (type === "String") {
        filePicker = setting.filePicker === true ? "any" : setting.filePicker;
      }
      let buttonData;
      if (filePicker) {
        buttonData = {
          icon: "fas fa-file-import fa-fw",
          efx: efx === "ripple" ? ripple() : void 0,
          title: "FILES.BrowseTooltip",
          styles: { "margin-left": "0.25em" }
        };
      }
      const store = this.#settings.getStore(setting.key);
      let selectData;
      let componentType = "text";
      if (setting.type === Boolean) {
        componentType = "checkbox";
      } else if (options2 !== void 0) {
        componentType = "select";
        selectData = {
          store,
          efx: efx === "ripple" ? rippleFocus() : void 0,
          type: componentType,
          options: options2
        };
      } else if (setting.type === Number) {
        componentType = typeof setting.range === "object" ? "range" : "number";
      }
      let inputData;
      if (componentType === "text" || componentType === "number") {
        inputData = {
          store,
          efx: efx === "ripple" ? rippleFocus() : void 0,
          type: componentType
        };
      }
      uiSettings.push({
        id: `${setting.namespace}.${setting.key}`,
        namespace: setting.namespace,
        folder: setting.folder,
        key: setting.key,
        name: localize(setting.name),
        hint: localize(setting.hint),
        type,
        componentType,
        filePicker,
        range: range2,
        store,
        initialValue: globalThis.game.settings.get(setting.namespace, setting.key),
        scope: setting.scope,
        requiresReload: typeof setting.requiresReload === "boolean" ? setting.requiresReload : false,
        buttonData,
        inputData,
        selectData
      });
    }
    const storeScrollbar = hasStorage ? storage2.getStore(`${namespace}-settings-scrollbar`) : writable$1(0);
    const topLevel = [];
    const folderData = {};
    for (const setting of uiSettings) {
      if (typeof setting.folder === "string") {
        const folderName = localize(setting.folder);
        if (!Array.isArray(folderData[folderName])) {
          folderData[folderName] = [];
        }
        folderData[folderName].push(setting);
      } else {
        topLevel.push(setting);
      }
    }
    const folders = Object.entries(folderData).map((entry) => {
      return {
        label: entry[0],
        store: hasStorage ? storage2.getStore(`${namespace}-settings-folder-${entry[0]}`) : void 0,
        settings: entry[1]
      };
    });
    const sections = [];
    for (const section2 of this.#sections) {
      const parsedSection = {
        class: section2.class,
        props: section2.props,
        styles: section2.styles
      };
      if (typeof section2.folder === "string") {
        const label = localize(section2.folder);
        parsedSection.folder = {
          label,
          store: hasStorage ? storage2.getStore(`${namespace}-settings-folder-${label}`) : void 0
        };
      } else if (isObject(section2.folder)) {
        const label = localize(section2.folder.label);
        parsedSection.folder = {
          label,
          store: hasStorage ? storage2.getStore(`${namespace}-settings-folder-${label}`) : void 0,
          summaryEnd: section2.folder.summaryEnd,
          styles: section2.folder.styles
        };
      }
      sections.push(parsedSection);
    }
    return {
      storeScrollbar,
      topLevel,
      folders,
      sections
    };
  }
  async #reloadConfirm({ world = false } = {}) {
    let title2 = localize("SETTINGS.ReloadPromptTitle");
    let label = localize("SETTINGS.ReloadPromptBody");
    title2 = title2 !== "SETTINGS.ReloadPromptTitle" ? title2 : "Reload Application?";
    label = label !== "SETTINGS.ReloadPromptBody" ? label : "Some of the changed settings require a reload of the application to take effect. Would you like to reload now?";
    const reload = await TJSDialog.confirm({
      modal: true,
      draggable: false,
      title: title2,
      content: `<p>${label}</p>`
    });
    if (!reload) {
      return;
    }
    if (world && globalThis.game.user.isGM) {
      globalThis.game.socket.emit("reload");
    }
    window.location.reload();
  }
  /**
   * Convenience method to swap `showSettings`.
   *
   * @returns {boolean} New `showSettings` state.
   */
  swapShowSettings() {
    this.#showSettings = !this.#showSettings;
    this.#showSettingsSet(this.#showSettings);
    return this.#showSettings;
  }
}
class TJSGameSettings {
  /** @type {string} */
  #namespace;
  /** @type {GameSettingData[]} */
  #settings = [];
  /**
   * @type {Map<string, import('svelte/store').Writable>}
   */
  #stores = /* @__PURE__ */ new Map();
  /** @type {UIControl} */
  #uiControl;
  /**
   * Creates the TJSGameSettings instance.
   *
   * @param {string}   namespace - The namespace for all settings.
   */
  constructor(namespace) {
    if (typeof namespace !== "string") {
      throw new TypeError(`'namespace' is not a string.`);
    }
    this.#namespace = namespace;
    this.#uiControl = new UIControl(this);
  }
  /**
   * Creates a new writable for the given key.
   *
   * @param {*}  initialValue - An initial value to set to new stores.
   *
   * @returns {import('svelte/store').Writable} The new writable.
   */
  static #createStore(initialValue) {
    return writable$1(initialValue);
  }
  /**
   * Provides an iterator / generator to return stored settings data.
   *
   * @returns {Generator<GameSettingData, void, *>}
   */
  *[Symbol.iterator]() {
    for (const setting of this.#settings) {
      yield setting;
    }
  }
  /**
   * @returns {string} Returns namespace set in constructor.
   */
  get namespace() {
    return this.#namespace;
  }
  /**
   * @returns {UIControl}
   */
  get uiControl() {
    return this.#uiControl;
  }
  /**
   * Gets a store from the `stores` Map or creates a new store for the key.
   *
   * @param {string}   key - Key to lookup in stores map.
   *
   * @param {string}   [initialValue] - An initial value to set to new stores.
   *
   * @returns {import('svelte/store').Writable} The store for the given key.
   */
  #getStore(key, initialValue) {
    let store = this.#stores.get(key);
    if (store === void 0) {
      store = TJSGameSettings.#createStore(initialValue);
      this.#stores.set(key, store);
    }
    return store;
  }
  /**
   * Returns a readable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Readable|undefined} The associated store for the given game setting key.
   */
  getReadableStore(key) {
    if (!this.#stores.has(key)) {
      console.warn(`TJSGameSettings - getReadableStore: '${key}' is not a registered setting.`);
      return;
    }
    const store = this.#getStore(key);
    return { subscribe: store.subscribe };
  }
  /**
   * Returns a writable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Writable|undefined} The associated store for the given game setting key.
   */
  getStore(key) {
    return this.getWritableStore(key);
  }
  /**
   * Returns a writable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Writable|undefined} The associated store for the given game setting key.
   */
  getWritableStore(key) {
    if (!this.#stores.has(key)) {
      console.warn(`TJSGameSettings - getWritableStore: '${key}' is not a registered setting.`);
      return;
    }
    return this.#getStore(key);
  }
  /**
   * Registers a setting with TJSGameSettings and Foundry core.
   *
   * Note: The specific store subscription handler assigned to the passed in store or store created for the setting
   * internally is returned from this function. In some cases when setting up custom stores particularly of object
   * types with several child property stores (`propertyStore`) it is necessary to only update the setting store and
   * not all subscribers to the custom store as the `propertyStore` instances are also subscribers to the custom store.
   *
   * This allows the custom store in the `set` implementation to mainly only trigger the TJSGameSettings subscriber
   * handler on updates and not all the connected `propertyStore` instances.
   *
   * @param {GameSetting} setting - A GameSetting instance to set to Foundry game settings.
   *
   * @param {boolean}     coreConfig - When false this overrides the `setting.options.config` parameter when
   *                                   registering the setting with Foundry. This allows the settings to be displayed
   *                                   in the app itself, but removed from the standard Foundry configuration location.
   *
   * @returns {Function} The specific store subscription handler assigned to the passed in store.
   */
  register(setting, coreConfig = true) {
    if (!isObject(setting)) {
      throw new TypeError(`TJSGameSettings - register: setting is not an object.`);
    }
    if (!isObject(setting.options)) {
      throw new TypeError(`TJSGameSettings - register: 'setting.options' attribute is not an object.`);
    }
    if (typeof coreConfig !== "boolean") {
      throw new TypeError(`TJSGameSettings - register: 'coreConfig' is not an boolean.`);
    }
    if (setting.store !== void 0 && !isWritableStore(setting.store)) {
      throw new TypeError(
        `TJSGameSettings - register: 'setting.store' attribute is not a writable store.`
      );
    }
    const namespace = setting.namespace;
    const key = setting.key;
    const folder = setting.folder;
    const foundryConfig = coreConfig ? setting.options.config : false;
    if (typeof namespace !== "string") {
      throw new TypeError(`TJSGameSettings - register: 'namespace' attribute is not a string.`);
    }
    if (typeof key !== "string") {
      throw new TypeError(`TJSGameSettings - register: 'key' attribute is not a string.`);
    }
    if (folder !== void 0 && typeof folder !== "string") {
      throw new TypeError(`TJSGameSettings - register: 'folder' attribute is not a string.`);
    }
    const store = setting.store;
    const options2 = setting.options;
    const onchangeFunctions = [];
    let gateSet = false;
    onchangeFunctions.push((value) => {
      const callbackStore = this.#getStore(key);
      if (callbackStore && !gateSet) {
        gateSet = true;
        callbackStore.set(value);
        gateSet = false;
      }
    });
    if (isIterable(options2?.onChange)) {
      for (const entry of options2.onChange) {
        if (typeof entry === "function") {
          onchangeFunctions.push(entry);
        }
      }
    } else if (typeof options2.onChange === "function") {
      onchangeFunctions.push(options2.onChange);
    }
    const onChange = (value) => {
      for (const entry of onchangeFunctions) {
        entry(value);
      }
    };
    globalThis.game.settings.register(namespace, key, { ...options2, config: foundryConfig, onChange });
    const targetStore = store ? store : this.#getStore(key, globalThis.game.settings.get(namespace, key));
    if (store) {
      this.#stores.set(key, targetStore);
      store.set(globalThis.game.settings.get(namespace, key));
    }
    const storeHandler = async (value) => {
      if (!gateSet && globalThis.game.settings.get(namespace, key) !== value) {
        gateSet = true;
        await globalThis.game.settings.set(namespace, key, value);
      }
      gateSet = false;
    };
    subscribeIgnoreFirst(targetStore, storeHandler);
    this.#settings.push({
      namespace,
      key,
      folder,
      ...options2
    });
    return storeHandler;
  }
  /**
   * Registers multiple settings.
   *
   * Please refer to the note in {@link TJSGameSettings.register} about the returned object of store subscriber handler
   * functions.
   *
   * @param {Iterable<GameSetting>} settings - An iterable list of game setting configurations to register.
   *
   * @param {boolean}     coreConfig - When false this overrides the `setting.options.config` parameter when
   *                                   registering the setting with Foundry. This allows the settings to be displayed
   *                                   in the app itself, but removed from the standard Foundry configuration location.
   *
   * @returns {Object<string, Function>} An object containing all TJSGameSetting store subscriber handlers for each
   * setting `key` added.
   */
  registerAll(settings, coreConfig) {
    const storeHandlers = {};
    if (!isIterable(settings)) {
      throw new TypeError(`TJSGameSettings - registerAll: settings is not iterable.`);
    }
    for (const entry of settings) {
      if (!isObject(entry)) {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings is not an object.`);
      }
      if (typeof entry.namespace !== "string") {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'namespace' attribute.`);
      }
      if (typeof entry.key !== "string") {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'key' attribute.`);
      }
      if (!isObject(entry.options)) {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'options' attribute.`);
      }
      storeHandlers[entry.key] = this.register(entry, coreConfig);
    }
    return storeHandlers;
  }
}
class WorldSettingArrayStore extends CrudArrayObjectStore {
  /** @type {string} */
  #key;
  /** @type {string} */
  #namespace;
  /**
   *
   * @param {object}            [opts] - Optional parameters.
   *
   * @param {TJSGameSettings}   [opts.gameSettings] - An instance of TJSGameSettings.
   *
   * @param {string}            [opts.namespace] - Game setting 'namespace' field.
   *
   * @param {string}            [opts.key] - Game setting 'key' field.
   *
   * @param {CrudArrayObjectStoreParams} [opts.rest] - Rest of CrudArrayObjectStore parameters.
   */
  constructor({ gameSettings: gameSettings2, namespace, key, ...rest }) {
    super({
      ...rest,
      extraData: { namespace, key }
    });
    if (typeof key !== "string") {
      throw new TypeError(`'key' is not a string.`);
    }
    if (typeof namespace !== "string") {
      throw new TypeError(`'namespace' is not a string.`);
    }
    this.#namespace = namespace;
    this.#key = key;
    if (gameSettings2) {
      gameSettings2.register({
        namespace,
        key,
        store: this,
        options: {
          scope: "world",
          config: false,
          default: Array.isArray(rest.defaultData) ? rest.defaultData : [],
          type: Array
        }
      });
    }
  }
  /**
   * @returns {string}
   */
  get key() {
    return this.#key;
  }
  /**
   * @returns {string}
   */
  get namespace() {
    return this.#namespace;
  }
}
function getPreviewFile(data2) {
  if (data2.includes("undefined")) {
    return;
  }
  let seqFiles = Sequencer.Database.getEntry(data2, { softFail: true });
  if (Array.isArray(seqFiles)) {
    seqFiles = seqFiles[0].file;
    if (Array.isArray(seqFiles)) {
      return seqFiles[0].file;
    }
    if (isObject2(seqFiles)) {
      if (Array.isArray(seqFiles["15ft"])) {
        seqFiles = seqFiles["15ft"];
        return seqFiles[0];
      }
      seqFiles = seqFiles["15ft"];
      return seqFiles[0];
    }
    return seqFiles;
  }
  if (isObject2(seqFiles.file)) {
    if (Array.isArray(seqFiles.file["15ft"])) {
      seqFiles = seqFiles.file["15ft"];
      return seqFiles[0];
    }
    return seqFiles.file["15ft"];
  }
  return seqFiles.file;
  function isObject2(test) {
    return typeof test === "object";
  }
}
const currentStore = writable$1(void 0);
const autorecPreviews_svelte_svelte_type_style_lang = "";
function create_if_block_10(ctx) {
  let div2;
  let t0;
  let div1;
  let label;
  let t2;
  let div0;
  let video2;
  let track;
  let video_src_value;
  let t3;
  let t4;
  let if_block0 = (
    /*enableSource*/
    ctx[17] && create_if_block_13(ctx)
  );
  let if_block1 = (
    /*enableSecondary*/
    ctx[13] && create_if_block_12(ctx)
  );
  let if_block2 = (
    /*enableTarget*/
    ctx[11] && create_if_block_11(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.primary")}`;
      t2 = space();
      div0 = element("div");
      video2 = element("video");
      track = element("track");
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1uxnhny");
      attr(track, "kind", "captions");
      attr(video2, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video2.src, video_src_value = /*filePath*/
      ctx[14]))
        attr(video2, "src", video_src_value);
      video2.autoplay = "autoplay";
      video2.controls = true;
      attr(video2, "controlslist", "nodownload");
      attr(video2, "disablepictureinpicture", "");
      video2.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
      attr(div2, "class", "flexcol aa-full-preview svelte-auto-1uxnhny");
    },
    m(target2, anchor) {
      insert(target2, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t0);
      append(div2, div1);
      append(div1, label);
      append(div1, t2);
      append(div1, div0);
      append(div0, video2);
      append(video2, track);
      append(div2, t3);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t4);
      if (if_block2)
        if_block2.m(div2, null);
    },
    p(ctx2, dirty) {
      if (
        /*enableSource*/
        ctx2[17]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*filePath*/
      16384 && !src_url_equal(video2.src, video_src_value = /*filePath*/
      ctx2[14])) {
        attr(video2, "src", video_src_value);
      }
      if (
        /*enableSecondary*/
        ctx2[13]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          if_block1.m(div2, t4);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*enableTarget*/
        ctx2[11]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_11(ctx2);
          if_block2.c();
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_13(ctx) {
  let div1;
  let label;
  let t1;
  let div0;
  let video2;
  let track;
  let video_src_value;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.source")}`;
      t1 = space();
      div0 = element("div");
      video2 = element("video");
      track = element("track");
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1uxnhny");
      attr(track, "kind", "captions");
      attr(video2, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video2.src, video_src_value = /*sFilePath*/
      ctx[16]))
        attr(video2, "src", video_src_value);
      video2.autoplay = "autoplay";
      video2.controls = true;
      attr(video2, "controlslist", "nodownload");
      attr(video2, "disablepictureinpicture", "");
      video2.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label);
      append(div1, t1);
      append(div1, div0);
      append(div0, video2);
      append(video2, track);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*sFilePath*/
      65536 && !src_url_equal(video2.src, video_src_value = /*sFilePath*/
      ctx2[16])) {
        attr(video2, "src", video_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_12(ctx) {
  let div1;
  let label;
  let t1;
  let div0;
  let video2;
  let track;
  let video_src_value;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.variants.secondary")}`;
      t1 = space();
      div0 = element("div");
      video2 = element("video");
      track = element("track");
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1uxnhny");
      attr(track, "kind", "captions");
      attr(video2, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video2.src, video_src_value = /*eFilePath*/
      ctx[12]))
        attr(video2, "src", video_src_value);
      video2.autoplay = "autoplay";
      video2.controls = true;
      attr(video2, "controlslist", "nodownload");
      attr(video2, "disablepictureinpicture", "");
      video2.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label);
      append(div1, t1);
      append(div1, div0);
      append(div0, video2);
      append(video2, track);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*eFilePath*/
      4096 && !src_url_equal(video2.src, video_src_value = /*eFilePath*/
      ctx2[12])) {
        attr(video2, "src", video_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_11(ctx) {
  let div1;
  let label;
  let t1;
  let div0;
  let video2;
  let track;
  let video_src_value;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.target")}`;
      t1 = space();
      div0 = element("div");
      video2 = element("video");
      track = element("track");
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1uxnhny");
      attr(track, "kind", "captions");
      attr(video2, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video2.src, video_src_value = /*tFilePath*/
      ctx[10]))
        attr(video2, "src", video_src_value);
      video2.autoplay = "autoplay";
      video2.controls = true;
      attr(video2, "controlslist", "nodownload");
      attr(video2, "disablepictureinpicture", "");
      video2.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label);
      append(div1, t1);
      append(div1, div0);
      append(div0, video2);
      append(video2, track);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*tFilePath*/
      1024 && !src_url_equal(video2.src, video_src_value = /*tFilePath*/
      ctx2[10])) {
        attr(video2, "src", video_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_8(ctx) {
  let div;
  let if_block = (
    /*animation*/
    ctx[1].data.video && create_if_block_9(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "flexcol aa-full-preview svelte-auto-1uxnhny");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (
        /*animation*/
        ctx2[1].data.video
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_9(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_9(ctx) {
  let div1;
  let label;
  let t1;
  let div0;
  let video2;
  let track;
  let video_src_value;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.primary")}`;
      t1 = space();
      div0 = element("div");
      video2 = element("video");
      track = element("track");
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1uxnhny");
      attr(track, "kind", "captions");
      attr(video2, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video2.src, video_src_value = /*dafilePath*/
      ctx[9]))
        attr(video2, "src", video_src_value);
      video2.autoplay = "autoplay";
      video2.controls = true;
      attr(video2, "controlslist", "nodownload");
      attr(video2, "disablepictureinpicture", "");
      video2.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label);
      append(div1, t1);
      append(div1, div0);
      append(div0, video2);
      append(video2, track);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*dafilePath*/
      512 && !src_url_equal(video2.src, video_src_value = /*dafilePath*/
      ctx2[9])) {
        attr(video2, "src", video_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_4$5(ctx) {
  let div;
  let t0;
  let t1;
  let if_block0 = (
    /*animation*/
    ctx[1].data?.start?.enable && create_if_block_7(ctx)
  );
  let if_block1 = (
    /*animation*/
    ctx[1].data?.between?.enable && create_if_block_6$3(ctx)
  );
  let if_block2 = (
    /*animation*/
    ctx[1].data?.end?.enable && create_if_block_5$4(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(div, "class", "flexcol aa-full-preview svelte-auto-1uxnhny");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
    },
    p(ctx2, dirty) {
      if (
        /*animation*/
        ctx2[1].data?.start?.enable
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_7(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*animation*/
        ctx2[1].data?.between?.enable
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_6$3(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*animation*/
        ctx2[1].data?.end?.enable
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_5$4(ctx2);
          if_block2.c();
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_7(ctx) {
  let div1;
  let label;
  let t1;
  let div0;
  let video2;
  let track;
  let video_src_value;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.start")}`;
      t1 = space();
      div0 = element("div");
      video2 = element("video");
      track = element("track");
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1uxnhny");
      attr(track, "kind", "captions");
      attr(video2, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video2.src, video_src_value = /*tpsfilePath*/
      ctx[8]))
        attr(video2, "src", video_src_value);
      video2.autoplay = "autoplay";
      video2.controls = true;
      attr(video2, "controlslist", "nodownload");
      attr(video2, "disablepictureinpicture", "");
      video2.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label);
      append(div1, t1);
      append(div1, div0);
      append(div0, video2);
      append(video2, track);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*tpsfilePath*/
      256 && !src_url_equal(video2.src, video_src_value = /*tpsfilePath*/
      ctx2[8])) {
        attr(video2, "src", video_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_6$3(ctx) {
  let div1;
  let label;
  let t1;
  let div0;
  let video2;
  let track;
  let video_src_value;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.between")}`;
      t1 = space();
      div0 = element("div");
      video2 = element("video");
      track = element("track");
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1uxnhny");
      attr(track, "kind", "captions");
      attr(video2, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video2.src, video_src_value = /*tpbfilePath*/
      ctx[7]))
        attr(video2, "src", video_src_value);
      video2.autoplay = "autoplay";
      video2.controls = true;
      attr(video2, "controlslist", "nodownload");
      attr(video2, "disablepictureinpicture", "");
      video2.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label);
      append(div1, t1);
      append(div1, div0);
      append(div0, video2);
      append(video2, track);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*tpbfilePath*/
      128 && !src_url_equal(video2.src, video_src_value = /*tpbfilePath*/
      ctx2[7])) {
        attr(video2, "src", video_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_5$4(ctx) {
  let div1;
  let label;
  let t1;
  let div0;
  let video2;
  let track;
  let video_src_value;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.end")}`;
      t1 = space();
      div0 = element("div");
      video2 = element("video");
      track = element("track");
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1uxnhny");
      attr(track, "kind", "captions");
      attr(video2, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video2.src, video_src_value = /*tpefilePath*/
      ctx[6]))
        attr(video2, "src", video_src_value);
      video2.autoplay = "autoplay";
      video2.controls = true;
      attr(video2, "controlslist", "nodownload");
      attr(video2, "disablepictureinpicture", "");
      video2.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label);
      append(div1, t1);
      append(div1, div0);
      append(div0, video2);
      append(video2, track);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*tpefilePath*/
      64 && !src_url_equal(video2.src, video_src_value = /*tpefilePath*/
      ctx2[6])) {
        attr(video2, "src", video_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block$n(ctx) {
  let div4;
  let div1;
  let label0;
  let t1;
  let div0;
  let video0;
  let track0;
  let video0_src_value;
  let t2;
  let t3;
  let div3;
  let label1;
  let t5;
  let div2;
  let video1;
  let track1;
  let video1_src_value;
  let t6;
  let t7;
  let if_block0 = (
    /*animation*/
    ctx[1].data?.preExplosion?.enable && create_if_block_3$8(ctx)
  );
  let if_block1 = (
    /*enableSecondary*/
    ctx[13] && create_if_block_2$b(ctx)
  );
  let if_block2 = (
    /*enableTarget*/
    ctx[11] && create_if_block_1$d(ctx)
  );
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.projectile")}`;
      t1 = space();
      div0 = element("div");
      video0 = element("video");
      track0 = element("track");
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      div3 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.explosion")}`;
      t5 = space();
      div2 = element("div");
      video1 = element("video");
      track1 = element("track");
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      if (if_block2)
        if_block2.c();
      attr(label0, "for", "");
      attr(label0, "class", "svelte-auto-1uxnhny");
      attr(track0, "kind", "captions");
      attr(video0, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video0.src, video0_src_value = /*pfilePath*/
      ctx[5]))
        attr(video0, "src", video0_src_value);
      video0.autoplay = "autoplay";
      video0.controls = true;
      attr(video0, "controlslist", "nodownload");
      attr(video0, "disablepictureinpicture", "");
      video0.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
      attr(label1, "for", "");
      attr(label1, "class", "svelte-auto-1uxnhny");
      attr(track1, "kind", "captions");
      attr(video1, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video1.src, video1_src_value = /*e2filePath*/
      ctx[3]))
        attr(video1, "src", video1_src_value);
      video1.autoplay = "autoplay";
      video1.controls = true;
      attr(video1, "controlslist", "nodownload");
      attr(video1, "disablepictureinpicture", "");
      video1.loop = true;
      attr(div2, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div3, "class", "flexcol");
      attr(div4, "class", "flexcol aa-full-preview svelte-auto-1uxnhny");
    },
    m(target2, anchor) {
      insert(target2, div4, anchor);
      append(div4, div1);
      append(div1, label0);
      append(div1, t1);
      append(div1, div0);
      append(div0, video0);
      append(video0, track0);
      append(div4, t2);
      if (if_block0)
        if_block0.m(div4, null);
      append(div4, t3);
      append(div4, div3);
      append(div3, label1);
      append(div3, t5);
      append(div3, div2);
      append(div2, video1);
      append(video1, track1);
      append(div4, t6);
      if (if_block1)
        if_block1.m(div4, null);
      append(div4, t7);
      if (if_block2)
        if_block2.m(div4, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*pfilePath*/
      32 && !src_url_equal(video0.src, video0_src_value = /*pfilePath*/
      ctx2[5])) {
        attr(video0, "src", video0_src_value);
      }
      if (
        /*animation*/
        ctx2[1].data?.preExplosion?.enable
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$8(ctx2);
          if_block0.c();
          if_block0.m(div4, t3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*e2filePath*/
      8 && !src_url_equal(video1.src, video1_src_value = /*e2filePath*/
      ctx2[3])) {
        attr(video1, "src", video1_src_value);
      }
      if (
        /*enableSecondary*/
        ctx2[13]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$b(ctx2);
          if_block1.c();
          if_block1.m(div4, t7);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*enableTarget*/
        ctx2[11]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$d(ctx2);
          if_block2.c();
          if_block2.m(div4, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_3$8(ctx) {
  let div1;
  let label;
  let t3;
  let div0;
  let video2;
  let track;
  let video_src_value;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.pre")}  ${localize("autoanimations.menus.explosion")}`;
      t3 = space();
      div0 = element("div");
      video2 = element("video");
      track = element("track");
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1uxnhny");
      attr(track, "kind", "captions");
      attr(video2, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video2.src, video_src_value = /*e1filePath*/
      ctx[4]))
        attr(video2, "src", video_src_value);
      video2.autoplay = "autoplay";
      video2.controls = true;
      attr(video2, "controlslist", "nodownload");
      attr(video2, "disablepictureinpicture", "");
      video2.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label);
      append(div1, t3);
      append(div1, div0);
      append(div0, video2);
      append(video2, track);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*e1filePath*/
      16 && !src_url_equal(video2.src, video_src_value = /*e1filePath*/
      ctx2[4])) {
        attr(video2, "src", video_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_2$b(ctx) {
  let div1;
  let label;
  let t1;
  let div0;
  let video2;
  let track;
  let video_src_value;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.variants.secondary")}`;
      t1 = space();
      div0 = element("div");
      video2 = element("video");
      track = element("track");
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1uxnhny");
      attr(track, "kind", "captions");
      attr(video2, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video2.src, video_src_value = /*eFilePath*/
      ctx[12]))
        attr(video2, "src", video_src_value);
      video2.autoplay = "autoplay";
      video2.controls = true;
      attr(video2, "controlslist", "nodownload");
      attr(video2, "disablepictureinpicture", "");
      video2.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label);
      append(div1, t1);
      append(div1, div0);
      append(div0, video2);
      append(video2, track);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*eFilePath*/
      4096 && !src_url_equal(video2.src, video_src_value = /*eFilePath*/
      ctx2[12])) {
        attr(video2, "src", video_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_1$d(ctx) {
  let div1;
  let label;
  let t1;
  let div0;
  let video2;
  let track;
  let video_src_value;
  return {
    c() {
      div1 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.target")}`;
      t1 = space();
      div0 = element("div");
      video2 = element("video");
      track = element("track");
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1uxnhny");
      attr(track, "kind", "captions");
      attr(video2, "class", "aaVideoPreview svelte-auto-1uxnhny");
      if (!src_url_equal(video2.src, video_src_value = /*tFilePath*/
      ctx[10]))
        attr(video2, "src", video_src_value);
      video2.autoplay = "autoplay";
      video2.controls = true;
      attr(video2, "controlslist", "nodownload");
      attr(video2, "disablepictureinpicture", "");
      video2.loop = true;
      attr(div0, "class", "aa-video-overlay svelte-auto-1uxnhny");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label);
      append(div1, t1);
      append(div1, div0);
      append(div0, video2);
      append(video2, track);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*tFilePath*/
      1024 && !src_url_equal(video2.src, video_src_value = /*tFilePath*/
      ctx2[10])) {
        attr(video2, "src", video_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_fragment$1y(ctx) {
  let div;
  let label0;
  let t0;
  let t1;
  let label1;
  let i;
  let t2;
  let t3;
  let t4_value = localize("autoanimations.menus.preview") + "";
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block3_anchor;
  let if_block0 = (
    /*animation*/
    ctx[1].primary && create_if_block_10(ctx)
  );
  let if_block1 = (
    /*animation*/
    (ctx[1].data && /*animation*/
    ctx[1].presetType === "dualattach" || /*animation*/
    ctx[1].presetType === "thunderwave") && create_if_block_8(ctx)
  );
  let if_block2 = (
    /*animation*/
    ctx[1].data && /*animation*/
    ctx[1].presetType === "teleportation" && create_if_block_4$5(ctx)
  );
  let if_block3 = (
    /*animation*/
    ctx[1].data && /*animation*/
    ctx[1].presetType === "proToTemp" && create_if_block$n(ctx)
  );
  return {
    c() {
      div = element("div");
      label0 = element("label");
      t0 = text(
        /*name*/
        ctx[15]
      );
      t1 = space();
      label1 = element("label");
      i = element("i");
      t2 = text(
        /*previewType*/
        ctx[18]
      );
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      if (if_block2)
        if_block2.c();
      t8 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      attr(label0, "class", "aa-section-label svelte-auto-1uxnhny");
      attr(label0, "for", "");
      attr(label1, "for", "");
      set_style(label1, "align-self", "center");
      set_style(label1, "font-size", "14px");
      attr(div, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, label0);
      append(label0, t0);
      append(div, t1);
      append(div, label1);
      append(label1, i);
      append(i, t2);
      append(i, t3);
      append(i, t4);
      insert(target2, t5, anchor);
      if (if_block0)
        if_block0.m(target2, anchor);
      insert(target2, t6, anchor);
      if (if_block1)
        if_block1.m(target2, anchor);
      insert(target2, t7, anchor);
      if (if_block2)
        if_block2.m(target2, anchor);
      insert(target2, t8, anchor);
      if (if_block3)
        if_block3.m(target2, anchor);
      insert(target2, if_block3_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*name*/
      32768)
        set_data(
          t0,
          /*name*/
          ctx2[15]
        );
      if (dirty[0] & /*previewType*/
      262144)
        set_data(
          t2,
          /*previewType*/
          ctx2[18]
        );
      if (
        /*animation*/
        ctx2[1].primary
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          if_block0.m(t6.parentNode, t6);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*animation*/
        ctx2[1].data && /*animation*/
        ctx2[1].presetType === "dualattach" || /*animation*/
        ctx2[1].presetType === "thunderwave"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_8(ctx2);
          if_block1.c();
          if_block1.m(t7.parentNode, t7);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*animation*/
        ctx2[1].data && /*animation*/
        ctx2[1].presetType === "teleportation"
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_4$5(ctx2);
          if_block2.c();
          if_block2.m(t8.parentNode, t8);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*animation*/
        ctx2[1].data && /*animation*/
        ctx2[1].presetType === "proToTemp"
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block$n(ctx2);
          if_block3.c();
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t5);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t6);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t7);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t8);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(if_block3_anchor);
    }
  };
}
function instance$1q($$self, $$props, $$invalidate) {
  let newStore;
  let videoIDX;
  let idx;
  let animationSection;
  let animation;
  let previewType;
  let enableSource;
  let sCustom;
  let sCustomPath;
  let sDbSection;
  let sMenuType;
  let sAnim;
  let sVariant;
  let sColor;
  let sCompiledPath;
  let sFilePath;
  let name;
  let custom;
  let customPath;
  let dbSection;
  let menuType;
  let anim;
  let variant;
  let color;
  let compiledPath;
  let filePath;
  let enableSecondary;
  let eCustom;
  let eCustomPath;
  let eDbSection;
  let eMenuType;
  let eAnim;
  let eVariant;
  let eColor;
  let eCompiledPath;
  let eFilePath;
  let enableTarget;
  let tCustom;
  let tCustomPath;
  let tDbSection;
  let tMenuType;
  let tAnim;
  let tVariant;
  let tColor;
  let tCompiledPath;
  let tFilePath;
  let daCustom;
  let daCustomPath;
  let daDbSection;
  let daMenuType;
  let daAnim;
  let daVariant;
  let daColor;
  let daCompiledPath;
  let dafilePath;
  let tpsCustom;
  let tpsCustomPath;
  let tpsDbSection;
  let tpsMenuType;
  let tpsAnim;
  let tpsVariant;
  let tpsColor;
  let tpsCompiledPath;
  let tpsfilePath;
  let tpbCustom;
  let tpbCustomPath;
  let tpbDbSection;
  let tpbMenuType;
  let tpbAnim;
  let tpbVariant;
  let tpbColor;
  let tpbCompiledPath;
  let tpbfilePath;
  let tpeCustom;
  let tpeCustomPath;
  let tpeDbSection;
  let tpeMenuType;
  let tpeAnim;
  let tpeVariant;
  let tpeColor;
  let tpeCompiledPath;
  let tpefilePath;
  let pCustom;
  let pCustomPath;
  let pDbSection;
  let pMenuType;
  let pAnim;
  let pVariant;
  let pColor;
  let pCompiledPath;
  let pfilePath;
  let e1Custom;
  let e1CustomPath;
  let e1DbSection;
  let e1MenuType;
  let e1Anim;
  let e1Variant;
  let e1Color;
  let e1CompiledPath;
  let e1filePath;
  let e2Custom;
  let e2CustomPath;
  let e2DbSection;
  let e2MenuType;
  let e2Anim;
  let e2Variant;
  let e2Color;
  let e2CompiledPath;
  let e2filePath;
  let $position;
  let $storageStore, $$unsubscribe_storageStore = noop, $$subscribe_storageStore = () => ($$unsubscribe_storageStore(), $$unsubscribe_storageStore = subscribe(storageStore, ($$value) => $$invalidate(116, $storageStore = $$value)), storageStore);
  let $animationSection, $$unsubscribe_animationSection = noop, $$subscribe_animationSection = () => ($$unsubscribe_animationSection(), $$unsubscribe_animationSection = subscribe(animationSection, ($$value) => $$invalidate(112, $animationSection = $$value)), animationSection);
  let $newStore, $$unsubscribe_newStore = noop, $$subscribe_newStore = () => ($$unsubscribe_newStore(), $$unsubscribe_newStore = subscribe(newStore, ($$value) => $$invalidate(113, $newStore = $$value)), newStore);
  let $videoIDX, $$unsubscribe_videoIDX = noop, $$subscribe_videoIDX = () => ($$unsubscribe_videoIDX(), $$unsubscribe_videoIDX = subscribe(videoIDX, ($$value) => $$invalidate(114, $videoIDX = $$value)), videoIDX);
  let $currentStore;
  component_subscribe($$self, currentStore, ($$value) => $$invalidate(115, $currentStore = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_storageStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_animationSection());
  $$self.$$.on_destroy.push(() => $$unsubscribe_newStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_videoIDX());
  let { storageStore = void 0 } = $$props;
  $$subscribe_storageStore();
  const { application } = getContext("#external");
  const position = application.position;
  component_subscribe($$self, position, (value) => $$invalidate(111, $position = value));
  const storeAppState = foundry.utils.debounce(() => set_store_value(storageStore, $storageStore = application.state.get(), $storageStore), 500);
  $$self.$$set = ($$props2) => {
    if ("storageStore" in $$props2)
      $$subscribe_storageStore($$invalidate(0, storageStore = $$props2.storageStore));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[3] & /*$currentStore*/
    4194304) {
      $$subscribe_newStore($$invalidate(2, newStore = $currentStore));
    }
    if ($$self.$$.dirty[3] & /*$currentStore*/
    4194304) {
      $$subscribe_videoIDX($$invalidate(20, videoIDX = $currentStore.stores.videoIDX));
    }
    if ($$self.$$.dirty[3] & /*$videoIDX*/
    2097152) {
      $$invalidate(110, idx = $videoIDX);
    }
    if ($$self.$$.dirty[0] & /*newStore*/
    4 | $$self.$$.dirty[3] & /*idx, $newStore*/
    1179648) {
      $$subscribe_animationSection($$invalidate(19, animationSection = idx === "item" ? newStore : $newStore[idx]));
    }
    if ($$self.$$.dirty[3] & /*$animationSection*/
    524288) {
      $$invalidate(1, animation = $animationSection);
    }
    if ($$self.$$.dirty[3] & /*idx*/
    131072) {
      $$invalidate(18, previewType = idx === "item" ? "Item" : "Autorec");
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(17, enableSource = animation.source?.enable);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(105, sCustom = animation.source?.video?.enableCustom);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(104, sCustomPath = animation.source?.video?.customPath);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(109, sDbSection = animation.source?.video?.dbSection);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(108, sMenuType = animation.source?.video?.menuType);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(107, sAnim = animation.source?.video?.animation);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(106, sVariant = animation.source?.video?.variant);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(86, sColor = animation.source?.video?.color);
    }
    if ($$self.$$.dirty[2] & /*sColor*/
    16777216 | $$self.$$.dirty[3] & /*sCustom, sCustomPath, sDbSection, sMenuType, sAnim, sVariant*/
    129024) {
      $$invalidate(103, sCompiledPath = sCustom && sCustomPath ? sCustomPath : sColor === "random" ? `autoanimations.${sDbSection}.${sMenuType}.${sAnim}.${sVariant}` : `autoanimations.${sDbSection}.${sMenuType}.${sAnim}.${sVariant}.${sColor}`);
    }
    if ($$self.$$.dirty[3] & /*sCustom, sCustomPath, sCompiledPath*/
    7168) {
      $$invalidate(16, sFilePath = sCustom && sCustomPath && sCustomPath.split(".").length < 3 ? sCustomPath : getPreviewFile(sCompiledPath));
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(15, name = animation.label);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(98, custom = animation.primary?.video?.enableCustom);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(97, customPath = animation.primary?.video?.customPath);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(102, dbSection = animation.primary?.video?.dbSection);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(101, menuType = animation.primary?.video?.menuType);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(100, anim = animation.primary?.video?.animation);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(99, variant = animation.primary?.video?.variant);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(95, color = animation.primary?.video?.color);
    }
    if ($$self.$$.dirty[3] & /*custom, customPath, color, dbSection, menuType, anim, variant*/
    1012) {
      $$invalidate(96, compiledPath = custom && customPath ? customPath : color === "random" ? `autoanimations.${dbSection}.${menuType}.${anim}.${variant}` : `autoanimations.${dbSection}.${menuType}.${anim}.${variant}.${color}`);
    }
    if ($$self.$$.dirty[3] & /*custom, customPath, compiledPath*/
    56) {
      $$invalidate(14, filePath = custom && customPath && customPath.split(".").length < 3 ? customPath : getPreviewFile(compiledPath));
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(13, enableSecondary = animation.secondary?.enable ?? false);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(89, eCustom = animation.secondary?.video?.enableCustom);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(88, eCustomPath = animation.secondary?.video?.customPath);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(94, eDbSection = animation.secondary?.video?.dbSection);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(93, eMenuType = animation.secondary?.video?.menuType);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(92, eAnim = animation.secondary?.video?.animation);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(91, eVariant = animation.secondary?.video?.variant);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(90, eColor = animation.secondary?.video?.color);
    }
    if ($$self.$$.dirty[2] & /*eCustom, eCustomPath, eAnim, eVariant, eColor*/
    2080374784 | $$self.$$.dirty[3] & /*color, eDbSection, eMenuType*/
    7) {
      $$invalidate(87, eCompiledPath = eCustom && eCustomPath ? eCustomPath : color === "random" ? `autoanimations.${eDbSection}.${eMenuType}.${eAnim}.${eVariant}` : `autoanimations.${eDbSection}.${eMenuType}.${eAnim}.${eVariant}.${eColor}`);
    }
    if ($$self.$$.dirty[2] & /*eCustom, eCustomPath, eCompiledPath*/
    234881024) {
      $$invalidate(12, eFilePath = eCustom && eCustomPath && eCustomPath.split(".").length < 3 ? eCustomPath : getPreviewFile(eCompiledPath));
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(11, enableTarget = animation.target?.enable ?? false);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(80, tCustom = animation.target?.video?.enableCustom);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(79, tCustomPath = animation.target?.video?.customPath);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(85, tDbSection = animation.target?.video?.dbSection);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(84, tMenuType = animation.target?.video?.menuType);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(83, tAnim = animation.target?.video?.animation);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(82, tVariant = animation.target?.video?.variant);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(81, tColor = animation.target?.video?.color);
    }
    if ($$self.$$.dirty[2] & /*tCustom, tCustomPath, sColor, tDbSection, tMenuType, tAnim, tVariant, tColor*/
    33423360) {
      $$invalidate(78, tCompiledPath = tCustom && tCustomPath ? tCustomPath : sColor === "random" ? `autoanimations.${tDbSection}.${tMenuType}.${tAnim}.${tVariant}` : `autoanimations.${tDbSection}.${tMenuType}.${tAnim}.${tVariant}.${tColor}`);
    }
    if ($$self.$$.dirty[2] & /*tCustom, tCustomPath, tCompiledPath*/
    458752) {
      $$invalidate(10, tFilePath = tCustom && tCustomPath && tCustomPath.split(".").length < 3 ? tCustomPath : getPreviewFile(tCompiledPath));
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(72, daCustom = animation.data?.video?.enableCustom);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(71, daCustomPath = animation.data?.video?.customPath);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(77, daDbSection = animation.data?.video?.dbSection);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(76, daMenuType = animation.data?.video?.menuType);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(75, daAnim = animation.data?.video?.animation);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(74, daVariant = animation.data?.video?.variant);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(73, daColor = animation.data?.video?.color);
    }
    if ($$self.$$.dirty[2] & /*daCustom, daCustomPath, daColor, daDbSection, daMenuType, daAnim, daVariant*/
    65024) {
      $$invalidate(70, daCompiledPath = daCustom && daCustomPath ? daCustomPath : daColor === "random" ? `autoanimations.${daDbSection}.${daMenuType}.${daAnim}.${daVariant}` : `autoanimations.${daDbSection}.${daMenuType}.${daAnim}.${daVariant}.${daColor}`);
    }
    if ($$self.$$.dirty[2] & /*daCustom, daCustomPath, daCompiledPath*/
    1792) {
      $$invalidate(9, dafilePath = daCustom && daCustomPath && daCustomPath.split(".").length < 3 ? daCustomPath : getPreviewFile(daCompiledPath));
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(64, tpsCustom = animation.data?.start?.enableCustom);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(63, tpsCustomPath = animation.data?.start?.customPath);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(69, tpsDbSection = animation.data?.start?.dbSection);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(68, tpsMenuType = animation.data?.start?.menuType);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(67, tpsAnim = animation.data?.start?.animation);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(66, tpsVariant = animation.data?.start?.variant);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(65, tpsColor = animation.data?.start?.color);
    }
    if ($$self.$$.dirty[2] & /*tpsCustom, tpsCustomPath, tpsColor, tpsDbSection, tpsMenuType, tpsAnim, tpsVariant*/
    254) {
      $$invalidate(62, tpsCompiledPath = tpsCustom && tpsCustomPath ? tpsCustomPath : tpsColor === "random" ? `autoanimations.${tpsDbSection}.${tpsMenuType}.${tpsAnim}.${tpsVariant}` : `autoanimations.${tpsDbSection}.${tpsMenuType}.${tpsAnim}.${tpsVariant}.${tpsColor}`);
    }
    if ($$self.$$.dirty[2] & /*tpsCustom, tpsCustomPath, tpsCompiledPath*/
    7) {
      $$invalidate(8, tpsfilePath = tpsCustom && tpsCustomPath && tpsCustomPath.split(".").length < 3 ? tpsCustomPath : getPreviewFile(tpsCompiledPath));
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(56, tpbCustom = animation.data?.between?.enableCustom);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(55, tpbCustomPath = animation.data?.between?.customPath);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(61, tpbDbSection = animation.data?.between?.dbSection);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(60, tpbMenuType = animation.data?.between?.menuType);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(59, tpbAnim = animation.data?.between?.animation);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(58, tpbVariant = animation.data?.between?.variant);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(57, tpbColor = animation.data?.between?.color);
    }
    if ($$self.$$.dirty[1] & /*tpbCustom, tpbCustomPath, tpbColor, tpbDbSection, tpbMenuType, tpbAnim, tpbVariant*/
    2130706432) {
      $$invalidate(54, tpbCompiledPath = tpbCustom && tpbCustomPath ? tpbCustomPath : tpbColor === "random" ? `autoanimations.${tpbDbSection}.${tpbMenuType}.${tpbAnim}.${tpbVariant}` : `autoanimations.${tpbDbSection}.${tpbMenuType}.${tpbAnim}.${tpbVariant}.${tpbColor}`);
    }
    if ($$self.$$.dirty[1] & /*tpbCustom, tpbCustomPath, tpbCompiledPath*/
    58720256) {
      $$invalidate(7, tpbfilePath = tpbCustom && tpbCustomPath && tpbCustomPath.split(".").length < 3 ? tpbCustomPath : getPreviewFile(tpbCompiledPath));
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(48, tpeCustom = animation.data?.end?.enableCustom);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(47, tpeCustomPath = animation.data?.end?.customPath);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(53, tpeDbSection = animation.data?.end?.dbSection);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(52, tpeMenuType = animation.data?.end?.menuType);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(51, tpeAnim = animation.data?.end?.animation);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(50, tpeVariant = animation.data?.end?.variant);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(49, tpeColor = animation.data?.end?.color);
    }
    if ($$self.$$.dirty[1] & /*tpeCustom, tpeCustomPath, tpeColor, tpeDbSection, tpeMenuType, tpeAnim, tpeVariant*/
    8323072) {
      $$invalidate(46, tpeCompiledPath = tpeCustom && tpeCustomPath ? tpeCustomPath : tpeColor === "random" ? `autoanimations.${tpeDbSection}.${tpeMenuType}.${tpeAnim}.${tpeVariant}` : `autoanimations.${tpeDbSection}.${tpeMenuType}.${tpeAnim}.${tpeVariant}.${tpeColor}`);
    }
    if ($$self.$$.dirty[1] & /*tpeCustom, tpeCustomPath, tpeCompiledPath*/
    229376) {
      $$invalidate(6, tpefilePath = tpeCustom && tpeCustomPath && tpeCustomPath.split(".").length < 3 ? tpeCustomPath : getPreviewFile(tpeCompiledPath));
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(40, pCustom = animation.data?.projectile?.enableCustom);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(39, pCustomPath = animation.data?.projectile?.customPath);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(45, pDbSection = animation.data?.projectile?.dbSection);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(44, pMenuType = animation.data?.projectile?.menuType);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(43, pAnim = animation.data?.projectile?.animation);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(42, pVariant = animation.data?.projectile?.variant);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(41, pColor = animation.data?.projectile?.color);
    }
    if ($$self.$$.dirty[1] & /*pCustom, pCustomPath, pColor, pDbSection, pMenuType, pAnim, pVariant*/
    32512) {
      $$invalidate(38, pCompiledPath = pCustom && pCustomPath ? pCustomPath : pColor === "random" ? `autoanimations.${pDbSection}.${pMenuType}.${pAnim}.${pVariant}` : `autoanimations.${pDbSection}.${pMenuType}.${pAnim}.${pVariant}.${pColor}`);
    }
    if ($$self.$$.dirty[1] & /*pCustom, pCustomPath, pCompiledPath*/
    896) {
      $$invalidate(5, pfilePath = pCustom && pCustomPath && pCustomPath.split(".").length < 3 ? pCustomPath : getPreviewFile(pCompiledPath));
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(32, e1Custom = animation.data?.preExplosion?.enableCustom);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(31, e1CustomPath = animation.data?.preExplosion?.customPath);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(37, e1DbSection = animation.data?.preExplosion?.dbSection);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(36, e1MenuType = animation.data?.preExplosion?.menuType);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(35, e1Anim = animation.data?.preExplosion?.animation);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(34, e1Variant = animation.data?.preExplosion?.variant);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(33, e1Color = animation.data?.preExplosion?.color);
    }
    if ($$self.$$.dirty[1] & /*e1Custom, e1CustomPath, e1Color, e1DbSection, e1MenuType, e1Anim, e1Variant*/
    127) {
      $$invalidate(30, e1CompiledPath = e1Custom && e1CustomPath ? e1CustomPath : e1Color === "random" ? `autoanimations.${e1DbSection}.${e1MenuType}.${e1Anim}.${e1Variant}` : `autoanimations.${e1DbSection}.${e1MenuType}.${e1Anim}.${e1Variant}.${e1Color}`);
    }
    if ($$self.$$.dirty[0] & /*e1CompiledPath*/
    1073741824 | $$self.$$.dirty[1] & /*e1Custom, e1CustomPath*/
    3) {
      $$invalidate(4, e1filePath = e1Custom && e1CustomPath && e1CustomPath.split(".").length < 3 ? e1CustomPath : getPreviewFile(e1CompiledPath));
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(24, e2Custom = animation.data?.explosion?.enableCustom);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(23, e2CustomPath = animation.data?.explosion?.customPath);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(29, e2DbSection = animation.data?.explosion?.dbSection);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(28, e2MenuType = animation.data?.explosion?.menuType);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(27, e2Anim = animation.data?.explosion?.animation);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(26, e2Variant = animation.data?.explosion?.variant);
    }
    if ($$self.$$.dirty[0] & /*animation*/
    2) {
      $$invalidate(25, e2Color = animation.data?.explosion?.color);
    }
    if ($$self.$$.dirty[0] & /*e2Custom, e2CustomPath, e2Color, e2DbSection, e2MenuType, e2Anim, e2Variant*/
    1065353216) {
      $$invalidate(22, e2CompiledPath = e2Custom && e2CustomPath ? e2CustomPath : e2Color === "random" ? `autoanimations.${e2DbSection}.${e2MenuType}.${e2Anim}.${e2Variant}` : `autoanimations.${e2DbSection}.${e2MenuType}.${e2Anim}.${e2Variant}.${e2Color}`);
    }
    if ($$self.$$.dirty[0] & /*e2Custom, e2CustomPath, e2CompiledPath*/
    29360128) {
      $$invalidate(3, e2filePath = e2Custom && e2CustomPath && e2CustomPath.split(".").length < 3 ? e2CustomPath : getPreviewFile(e2CompiledPath));
    }
    if ($$self.$$.dirty[3] & /*$position*/
    262144) {
      storeAppState($position);
    }
  };
  return [
    storageStore,
    animation,
    newStore,
    e2filePath,
    e1filePath,
    pfilePath,
    tpefilePath,
    tpbfilePath,
    tpsfilePath,
    dafilePath,
    tFilePath,
    enableTarget,
    eFilePath,
    enableSecondary,
    filePath,
    name,
    sFilePath,
    enableSource,
    previewType,
    animationSection,
    videoIDX,
    position,
    e2CompiledPath,
    e2CustomPath,
    e2Custom,
    e2Color,
    e2Variant,
    e2Anim,
    e2MenuType,
    e2DbSection,
    e1CompiledPath,
    e1CustomPath,
    e1Custom,
    e1Color,
    e1Variant,
    e1Anim,
    e1MenuType,
    e1DbSection,
    pCompiledPath,
    pCustomPath,
    pCustom,
    pColor,
    pVariant,
    pAnim,
    pMenuType,
    pDbSection,
    tpeCompiledPath,
    tpeCustomPath,
    tpeCustom,
    tpeColor,
    tpeVariant,
    tpeAnim,
    tpeMenuType,
    tpeDbSection,
    tpbCompiledPath,
    tpbCustomPath,
    tpbCustom,
    tpbColor,
    tpbVariant,
    tpbAnim,
    tpbMenuType,
    tpbDbSection,
    tpsCompiledPath,
    tpsCustomPath,
    tpsCustom,
    tpsColor,
    tpsVariant,
    tpsAnim,
    tpsMenuType,
    tpsDbSection,
    daCompiledPath,
    daCustomPath,
    daCustom,
    daColor,
    daVariant,
    daAnim,
    daMenuType,
    daDbSection,
    tCompiledPath,
    tCustomPath,
    tCustom,
    tColor,
    tVariant,
    tAnim,
    tMenuType,
    tDbSection,
    sColor,
    eCompiledPath,
    eCustomPath,
    eCustom,
    eColor,
    eVariant,
    eAnim,
    eMenuType,
    eDbSection,
    color,
    compiledPath,
    customPath,
    custom,
    variant,
    anim,
    menuType,
    dbSection,
    sCompiledPath,
    sCustomPath,
    sCustom,
    sVariant,
    sAnim,
    sMenuType,
    sDbSection,
    idx,
    $position,
    $animationSection,
    $newStore,
    $videoIDX,
    $currentStore
  ];
}
class AutorecPreviews extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1q, create_fragment$1y, safe_not_equal, { storageStore: 0 }, null, [-1, -1, -1, -1]);
  }
}
const aaSessionStorage = new TJSSessionStorage();
const constants = {
  moduleId: "autoanimations",
  moduleLabel: "Automated Animations"
};
const sessionConstants = {
  optionsInfoAppState: `${constants.moduleId}.options-info.app-state`,
  videoPreviewAppState: `${constants.moduleId}.video-preview.app-state`,
  itemAppState: `${constants.moduleId}.item.app-state`,
  activeEffectAppState: `${constants.moduleId}.active-effect.app-state`
};
class TotalPreview extends TJSDialog {
  static #app;
  constructor(data2) {
    super({
      title: "Video Preview",
      resizable: true,
      zIndex: null,
      content: {
        class: AutorecPreviews,
        props: {
          ...data2,
          storageStore: aaSessionStorage.getStore(sessionConstants.videoPreviewAppState)
        }
      }
    }, { minimizable: false });
    try {
      this.state.set(aaSessionStorage.getItem(sessionConstants.videoPreviewAppState));
    } catch (err) {
    }
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      minimizable: true,
      width: "auto",
      height: "auto",
      closeOnSubmit: true,
      id: `AA-Video-Preview`
    });
  }
  /**
   * Close the instance of TotalVideo and remove reference to single static app reference.
   *
   * @inheritDoc
   */
  async close(options2) {
    await super.close(options2);
    TotalPreview.#app = void 0;
  }
  /**
   * Show a single static instance of TotalVideo; if it is already open then bring it to top.
   */
  static show() {
    if (this.#app) {
      this.#app.bringToTop();
    } else {
      this.#app = new TotalPreview().render(true, { focus: true });
    }
  }
}
let AnimationStore$2 = class AnimationStore2 extends ObjectEntryStore {
  /** @type {AnimationPropertyStores} */
  #stores;
  /**
   * @param {object}   data -
   */
  constructor(data2 = {}) {
    super(data2);
    this.#stores = {
      videoIDX: writable$1(void 0)
    };
  }
  /**
   * @returns {AnimationPropertyStores}
   */
  get stores() {
    return this.#stores;
  }
  // ----------------------------------------------------------------------------------------------------------------
  /**
  * @param {object}   data -
  */
  set() {
    this._updateSubscribers();
  }
  async selectCustom(section2, section02 = "video") {
    const current = this._data[section2][section02].customPath;
    const picker = new FilePicker({
      type: "imagevideo",
      current,
      callback: (path) => {
        this._data[section2][section02].customPath = path;
        this._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  loadPreviews() {
    TotalPreview.show();
  }
  getMenuDB(section2, idx, isOnToken) {
    let menuDB = isOnToken ? "static" : this._data.menu === "ontoken" || this._data.menu === "aura" ? "static" : this._data.menu;
    menuDB = section2 === "secondary" ? "static" : menuDB;
    return menuDB;
  }
  menuTypeList(menuDB = "static") {
    return newTypeMenu[menuDB] || [];
  }
  animationList(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    return newNameMenu[menuDB][menuType] || [];
  }
  variantList(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    let animation = this._data[section2][section02].animation;
    return newVariantMenu[menuDB][menuType]?.[animation] || [];
  }
  colorList(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    let animation = this._data[section2][section02].animation;
    let variant = this._data[section2][section02].variant;
    return newColorMenu[menuDB][menuType]?.[animation]?.[variant] || [];
  }
  async databaseToClipboard(section2, idx, section02, dbSection) {
    const dbPath = await this.getDBPath(section2, idx, section02, dbSection);
    const app = new CopyClipBoard({
      target: document.getElementById("clipboard"),
      props: { dbPath }
    });
    app.$destroy();
  }
  async getDBPath(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    let animation = this._data[section2][section02].animation;
    let variant = this._data[section2][section02].variant;
    let color = this._data[section2][section02].color;
    return color === "random" ? `autoanimations.${menuDB}.${menuType}.${animation}.${variant}` : `autoanimations.${menuDB}.${menuType}.${animation}.${variant}.${color}`;
  }
  menuTypeChange(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    this._data[section2][section02].animation = newNameMenu[menuDB][menuType][0][0];
    let animation = this._data[section2][section02].animation;
    this._data[section2][section02].variant = newVariantMenu[menuDB][menuType][animation][0][0];
    let variant = this._data[section2][section02].variant;
    this._data[section2][section02].color = newColorMenu[menuDB][menuType][animation][variant][0][0];
  }
  animationChange(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    let animation = this._data[section2][section02].animation;
    this._data[section2][section02].variant = newVariantMenu[menuDB][menuType][animation][0][0];
    let variant = this._data[section2][section02].variant;
    this._data[section2][section02].color = newColorMenu[menuDB][menuType][animation][variant][0][0];
  }
  variantChange(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    let animation = this._data[section2][section02].animation;
    let variant = this._data[section2][section02].variant;
    this._data[section2][section02].color = newColorMenu[menuDB][menuType][animation][variant][0][0];
  }
  get typeMenu() {
    return newTypeMenu;
  }
  get animationMenu() {
    return newNameMenu;
  }
  get variantMenu() {
    return newVariantMenu;
  }
  get colorMenu() {
    return newColorMenu;
  }
  get returnWeapons() {
    return aaReturnWeapons;
  }
  async openMacro(data2) {
    if (!data2) {
      ui.notifications.info(`Automated Animations: Cannot locate Macro ${data2}`);
      return;
    }
    if (data2.startsWith("Compendium")) {
      let packArray = data2.split(".");
      let pack = game.packs.get(`${packArray[1]}.${packArray[2]}`);
      if (!pack) {
        ui.notifications.info(
          `Autoanimations | Compendium ${packArray[1]}.${packArray[2]} was not found`
        );
        return;
      }
      let macroFilter = pack.index.filter((m) => m.name === packArray[3]);
      if (!macroFilter.length) {
        ui.notifications.info(
          `Autoanimations | A macro named ${packArray[3]} was not found in Compendium ${packArray[1]}.${packArray[2]}`
        );
        return;
      }
      let macroDocument = await pack.getDocument(macroFilter[0]._id);
      macroDocument.sheet.render(true);
    } else {
      if (!data2) {
        return;
      }
      let getTest = game.macros.getName(data2);
      if (!getTest) {
        ui.notifications.info(
          `Autoanimations | Could not find the macro named ${data2}`
        );
        return;
      }
      game.macros.getName(data2).sheet.render(true);
    }
  }
  playSound(data2) {
    const currentSection = data2 || {};
    const file = currentSection?.file;
    const volume = currentSection?.volume ?? 0.75;
    const startTime = currentSection?.startTime ?? 0;
    new Sequence().sound().file(file).volume(volume).startTime(startTime).play();
  }
  async selectCustom(section2, section02 = "video", idx) {
    const current = this._data[section2][section02].customPath;
    const picker = new FilePicker({
      type: "imagevideo",
      current,
      callback: (path) => {
        this._data[section2][section02].customPath = path;
        this._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  async selectSound(section2, idx) {
    const current = this._data[section2].sound.file;
    const picker = new FilePicker({
      type: "audio",
      current,
      callback: (path) => {
        this._data[section2].sound.file = path;
        this._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  async selectSoundNested(section2, section02, idx) {
    const current = this._data[section2][section02].sound.file;
    const picker = new FilePicker({
      type: "audio",
      current,
      callback: (path) => {
        this._data[section2][section02].sound.file = path;
        this._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  openSequencerViewer() {
    Sequencer.DatabaseViewer.show();
  }
  async copyFromAutorec(autorec) {
    if (!autorec) {
      ui.notifications.info("Automated Animations | There is no Global match found to copy!");
      return;
    }
    if (!isObject(autorec)) {
      ui.notifications.info("Automated Animations | Global Autorec data is not valid");
    }
    let data2 = foundry.utils.deepClone(autorec);
    this._data.activeEffectType = data2.activeEffectType;
    this._data.macro = data2.macro;
    this._data.primary = data2.primary;
    this._data.secondary = data2.secondary;
    this._data.source = data2.source;
    this._data.soundOnly = data2.soundOnly;
    this._updateSubscribers();
  }
  async copyToAutorec(label) {
    let menu = this._data.activeEffectType;
    if (menu === "default") {
      custom_warning("You are attempting to copy an Item to the Global menu, but you haven't configured the item!");
    }
    let data2 = foundry.utils.deepClone(this._data);
    data2.id = uuidv4();
    data2.label = label;
    delete data2.isCustomized;
    delete data2.isEnabled;
    let currentMenu = await game.settings.get("autoanimations", `aaAutorec-aefx`);
    currentMenu.push(data2);
    await game.settings.set("autoanimations", `aaAutorec-aefx`, currentMenu);
  }
};
class FoundryStyles {
  static #sheet = void 0;
  static #sheetMap = /* @__PURE__ */ new Map();
  static #initialized = false;
  /**
   * Called once on initialization / first usage. Parses the core foundry style sheet.
   */
  static #initialize() {
    this.#initialized = true;
    const styleSheets = Array.from(document.styleSheets).filter((entry) => entry.href !== null);
    let sheet;
    const foundryStyleSheet = globalThis.foundry.utils.getRoute("/css/style.css");
    for (const styleSheet of styleSheets) {
      let url;
      try {
        url = new URL(styleSheet.href);
      } catch (err) {
        continue;
      }
      if (typeof url.pathname === "string" && url.pathname === foundryStyleSheet) {
        this.#sheet = sheet = styleSheet;
        break;
      }
    }
    if (!sheet) {
      return;
    }
    for (const rule of sheet.cssRules) {
      if (!(rule instanceof CSSStyleRule)) {
        continue;
      }
      const obj2 = {};
      for (const entry of rule.style.cssText.split(";")) {
        const parts = entry.split(":");
        if (parts.length < 2) {
          continue;
        }
        obj2[parts[0].trim()] = parts[1].trim();
      }
      this.#sheetMap.set(rule.selectorText, obj2);
    }
  }
  /**
   * Gets the properties object associated with the selector. Try and use a direct match otherwise all keys
   * are iterated to find a selector string that includes the `selector`.
   *
   * @param {string}   selector - Selector to find.
   *
   * @returns {Object<string, string>} Properties object.
   */
  static getProperties(selector) {
    if (!this.#initialized) {
      this.#initialize();
    }
    if (this.#sheetMap.has(selector)) {
      return this.#sheetMap.get(selector);
    }
    for (const key of this.#sheetMap.keys()) {
      if (key.includes(selector)) {
        return this.#sheetMap.get(key);
      }
    }
    return void 0;
  }
  /**
   * Gets a specific property value from the given `selector` and `property` key. Try and use a direct selector
   * match otherwise all keys are iterated to find a selector string that includes `selector`.
   *
   * @param {string}   selector - Selector to find.
   *
   * @param {string}   property - Specific property to locate.
   *
   * @returns {string|undefined} Property value.
   */
  static getProperty(selector, property) {
    if (!this.#initialized) {
      this.#initialize();
    }
    if (this.#sheetMap.has(selector)) {
      const data2 = this.#sheetMap.get(selector);
      return typeof data2 === "object" && property in data2 ? data2[property] : void 0;
    }
    for (const key of this.#sheetMap.keys()) {
      if (key.includes(selector)) {
        const data2 = this.#sheetMap.get(key);
        if (typeof data2 === "object" && property in data2) {
          return data2[property];
        }
      }
    }
    return void 0;
  }
}
const s_STYLE_KEY = "#__tjs-root-styles";
const cssVariables = new StyleManager({ docKey: s_STYLE_KEY, version: 1 });
const TJSIconButton_svelte_svelte_type_style_lang = "";
function create_fragment$1x(ctx) {
  let div;
  let a;
  let i;
  let i_class_value;
  let a_title_value;
  let applyStyles_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      a = element("a");
      i = element("i");
      attr(i, "class", i_class_value = null_to_empty(
        /*icon*/
        ctx[0]
      ) + " svelte-auto-f8994r");
      attr(a, "role", "button");
      attr(a, "tabindex", "0");
      attr(a, "title", a_title_value = localize(
        /*title*/
        ctx[1]
      ));
      attr(a, "class", "svelte-auto-f8994r");
      attr(div, "class", "tjs-icon-button svelte-auto-f8994r");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, a);
      append(a, i);
      if (!mounted) {
        dispose = [
          listen(
            a,
            "click",
            /*onClick*/
            ctx[4]
          ),
          listen(
            a,
            "contextmenu",
            /*onContextMenuPress*/
            ctx[5]
          ),
          listen(
            a,
            "keydown",
            /*onKeydown*/
            ctx[6]
          ),
          listen(
            a,
            "keyup",
            /*onKeyup*/
            ctx[7]
          ),
          listen(
            a,
            "click",
            /*click_handler*/
            ctx[13]
          ),
          listen(
            a,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[14]
          ),
          action_destroyer(
            /*efx*/
            ctx[3].call(null, a)
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            div,
            /*styles*/
            ctx[2]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*icon*/
      1 && i_class_value !== (i_class_value = null_to_empty(
        /*icon*/
        ctx2[0]
      ) + " svelte-auto-f8994r")) {
        attr(i, "class", i_class_value);
      }
      if (dirty & /*title*/
      2 && a_title_value !== (a_title_value = localize(
        /*title*/
        ctx2[1]
      ))) {
        attr(a, "title", a_title_value);
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      4)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx2[2]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1p($$self, $$props, $$invalidate) {
  let { button = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { title: title2 = void 0 } = $$props;
  let { styles = void 0 } = $$props;
  let { efx = void 0 } = $$props;
  let { keyCode = void 0 } = $$props;
  let { onPress = void 0 } = $$props;
  let { onContextMenu = void 0 } = $$props;
  let { onClickPropagate = void 0 } = $$props;
  const dispatch2 = createEventDispatcher();
  function onClick(event) {
    if (typeof onPress === "function") {
      onPress();
    }
    dispatch2("press");
    if (!onClickPropagate) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function onContextMenuPress(event) {
    if (typeof onContextMenu === "function") {
      onContextMenu();
    }
    if (!onClickPropagate) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function onKeydown(event) {
    if (event.code === keyCode) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function onKeyup(event) {
    if (event.code === keyCode) {
      if (typeof onPress === "function") {
        onPress();
      }
      dispatch2("press");
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("button" in $$props2)
      $$invalidate(12, button = $$props2.button);
    if ("icon" in $$props2)
      $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2)
      $$invalidate(1, title2 = $$props2.title);
    if ("styles" in $$props2)
      $$invalidate(2, styles = $$props2.styles);
    if ("efx" in $$props2)
      $$invalidate(3, efx = $$props2.efx);
    if ("keyCode" in $$props2)
      $$invalidate(8, keyCode = $$props2.keyCode);
    if ("onPress" in $$props2)
      $$invalidate(9, onPress = $$props2.onPress);
    if ("onContextMenu" in $$props2)
      $$invalidate(10, onContextMenu = $$props2.onContextMenu);
    if ("onClickPropagate" in $$props2)
      $$invalidate(11, onClickPropagate = $$props2.onClickPropagate);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*button, icon*/
    4097) {
      $$invalidate(0, icon = isObject(button) && typeof button.icon === "string" ? button.icon : typeof icon === "string" ? icon : "");
    }
    if ($$self.$$.dirty & /*button, title*/
    4098) {
      $$invalidate(1, title2 = isObject(button) && typeof button.title === "string" ? button.title : typeof title2 === "string" ? title2 : "");
    }
    if ($$self.$$.dirty & /*button, styles*/
    4100) {
      $$invalidate(2, styles = isObject(button) && typeof button.styles === "object" ? button.styles : typeof styles === "object" ? styles : void 0);
    }
    if ($$self.$$.dirty & /*button, efx*/
    4104) {
      $$invalidate(3, efx = isObject(button) && typeof button.efx === "function" ? button.efx : typeof efx === "function" ? efx : () => {
      });
    }
    if ($$self.$$.dirty & /*button, keyCode*/
    4352) {
      $$invalidate(8, keyCode = isObject(button) && typeof button.keyCode === "string" ? button.keyCode : typeof keyCode === "string" ? keyCode : "Enter");
    }
    if ($$self.$$.dirty & /*button, onPress*/
    4608) {
      $$invalidate(9, onPress = isObject(button) && typeof button.onPress === "function" ? button.onPress : typeof onPress === "function" ? onPress : void 0);
    }
    if ($$self.$$.dirty & /*button, onContextMenu*/
    5120) {
      $$invalidate(10, onContextMenu = isObject(button) && typeof button.onContextMenu === "function" ? button.onContextMenu : typeof onContextMenu === "function" ? onContextMenu : void 0);
    }
    if ($$self.$$.dirty & /*button, onClickPropagate*/
    6144) {
      $$invalidate(11, onClickPropagate = isObject(button) && typeof button.onClickPropagate === "boolean" ? button.onClickPropagate : typeof onClickPropagate === "boolean" ? onClickPropagate : false);
    }
  };
  return [
    icon,
    title2,
    styles,
    efx,
    onClick,
    onContextMenuPress,
    onKeydown,
    onKeyup,
    keyCode,
    onPress,
    onContextMenu,
    onClickPropagate,
    button,
    click_handler,
    contextmenu_handler
  ];
}
class TJSIconButton extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1p, create_fragment$1x, safe_not_equal, {
      button: 12,
      icon: 0,
      title: 1,
      styles: 2,
      efx: 3,
      keyCode: 8,
      onPress: 9,
      onContextMenu: 10,
      onClickPropagate: 11
    });
  }
}
const TJSToggleIconButton_svelte_svelte_type_style_lang = "";
function create_if_block$m(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target2, anchor) {
      if (default_slot) {
        default_slot.m(target2, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$1w(ctx) {
  let div;
  let a;
  let i;
  let i_class_value;
  let a_title_value;
  let t;
  let applyStyles_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*selected*/
    ctx[4] && create_if_block$m(ctx)
  );
  return {
    c() {
      div = element("div");
      a = element("a");
      i = element("i");
      t = space();
      if (if_block)
        if_block.c();
      attr(i, "class", i_class_value = null_to_empty(
        /*icon*/
        ctx[0]
      ) + " svelte-auto-1pmmjvy");
      toggle_class(
        i,
        "selected",
        /*selected*/
        ctx[4]
      );
      attr(a, "role", "button");
      attr(a, "tabindex", "0");
      attr(a, "title", a_title_value = localize(
        /*titleCurrent*/
        ctx[6]
      ));
      attr(a, "class", "svelte-auto-1pmmjvy");
      toggle_class(
        a,
        "selected",
        /*selected*/
        ctx[4]
      );
      attr(div, "class", "tjs-toggle-icon-button svelte-auto-1pmmjvy");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, a);
      append(a, i);
      ctx[26](a);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            a,
            "click",
            /*onClick*/
            ctx[7]
          ),
          listen(
            a,
            "contextmenu",
            /*onContextMenuPress*/
            ctx[8]
          ),
          listen(
            a,
            "keydown",
            /*onKeydown*/
            ctx[11]
          ),
          listen(
            a,
            "keyup",
            /*onKeyup*/
            ctx[12]
          ),
          listen(
            a,
            "click",
            /*click_handler*/
            ctx[24]
          ),
          listen(
            a,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[25]
          ),
          action_destroyer(
            /*efx*/
            ctx[3].call(null, a)
          ),
          listen(
            div,
            "click",
            /*onClickDiv*/
            ctx[9]
          ),
          listen(
            div,
            "close:popup",
            /*onClosePopup*/
            ctx[10]
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            div,
            /*styles*/
            ctx[2]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*icon*/
      1 && i_class_value !== (i_class_value = null_to_empty(
        /*icon*/
        ctx2[0]
      ) + " svelte-auto-1pmmjvy")) {
        attr(i, "class", i_class_value);
      }
      if (!current || dirty & /*icon, selected*/
      17) {
        toggle_class(
          i,
          "selected",
          /*selected*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*titleCurrent*/
      64 && a_title_value !== (a_title_value = localize(
        /*titleCurrent*/
        ctx2[6]
      ))) {
        attr(a, "title", a_title_value);
      }
      if (!current || dirty & /*selected*/
      16) {
        toggle_class(
          a,
          "selected",
          /*selected*/
          ctx2[4]
        );
      }
      if (
        /*selected*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*selected*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$m(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      4)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx2[2]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[26](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1o($$self, $$props, $$invalidate) {
  let titleCurrent;
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(21, $store = $$value)), store);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { button = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { title: title2 = void 0 } = $$props;
  let { titleSelected = void 0 } = $$props;
  let { store = void 0 } = $$props;
  $$subscribe_store();
  let { styles = void 0 } = $$props;
  let { efx = void 0 } = $$props;
  let { keyCode = void 0 } = $$props;
  let { onPress = void 0 } = $$props;
  let { onClose = void 0 } = $$props;
  let { onContextMenu = void 0 } = $$props;
  let { onClickPropagate = void 0 } = $$props;
  const dispatch2 = createEventDispatcher();
  let anchorEl;
  let selected = false;
  function onClick(event) {
    $$invalidate(4, selected = !selected);
    if (store) {
      store.set(selected);
    }
    if (typeof onPress === "function") {
      onPress(selected);
    }
    dispatch2("press", { selected });
    if (!onClickPropagate) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function onContextMenuPress(event) {
    if (typeof onContextMenu === "function") {
      onContextMenu();
    }
    if (!onClickPropagate) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function onClickDiv(event) {
    if (!onClickPropagate) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function onClosePopup(event) {
    $$invalidate(4, selected = false);
    if (store) {
      store.set(false);
    }
    if (typeof onClose === "function") {
      onClose(selected);
    }
    if (typeof event?.detail?.keyboardFocus === "boolean" && event.detail.keyboardFocus && anchorEl?.isConnected) {
      anchorEl.focus();
      event.stopPropagation();
      event.preventDefault();
    }
  }
  function onKeydown(event) {
    if (event.code === keyCode) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function onKeyup(event) {
    if (event.code === keyCode) {
      $$invalidate(4, selected = !selected);
      if (store) {
        store.set(selected);
      }
      if (typeof onPress === "function") {
        onPress(selected);
      }
      dispatch2("press", { selected });
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      anchorEl = $$value;
      $$invalidate(5, anchorEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("button" in $$props2)
      $$invalidate(20, button = $$props2.button);
    if ("icon" in $$props2)
      $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2)
      $$invalidate(13, title2 = $$props2.title);
    if ("titleSelected" in $$props2)
      $$invalidate(14, titleSelected = $$props2.titleSelected);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(1, store = $$props2.store));
    if ("styles" in $$props2)
      $$invalidate(2, styles = $$props2.styles);
    if ("efx" in $$props2)
      $$invalidate(3, efx = $$props2.efx);
    if ("keyCode" in $$props2)
      $$invalidate(15, keyCode = $$props2.keyCode);
    if ("onPress" in $$props2)
      $$invalidate(16, onPress = $$props2.onPress);
    if ("onClose" in $$props2)
      $$invalidate(17, onClose = $$props2.onClose);
    if ("onContextMenu" in $$props2)
      $$invalidate(18, onContextMenu = $$props2.onContextMenu);
    if ("onClickPropagate" in $$props2)
      $$invalidate(19, onClickPropagate = $$props2.onClickPropagate);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*button, icon*/
    1048577) {
      $$invalidate(0, icon = isObject(button) && typeof button.icon === "string" ? button.icon : typeof icon === "string" ? icon : "");
    }
    if ($$self.$$.dirty & /*button, title*/
    1056768) {
      $$invalidate(13, title2 = isObject(button) && typeof button.title === "string" ? button.title : typeof title2 === "string" ? title2 : "");
    }
    if ($$self.$$.dirty & /*button, titleSelected*/
    1064960) {
      $$invalidate(14, titleSelected = isObject(button) && typeof button.titleSelected === "string" ? button.titleSelected : typeof titleSelected === "string" ? titleSelected : "");
    }
    if ($$self.$$.dirty & /*button, store*/
    1048578) {
      $$subscribe_store($$invalidate(1, store = isObject(button) && isWritableStore(button.store) ? button.store : isWritableStore(store) ? store : void 0));
    }
    if ($$self.$$.dirty & /*button, styles*/
    1048580) {
      $$invalidate(2, styles = isObject(button) && typeof button.styles === "object" ? button.styles : typeof styles === "object" ? styles : void 0);
    }
    if ($$self.$$.dirty & /*button, efx*/
    1048584) {
      $$invalidate(3, efx = isObject(button) && typeof button.efx === "function" ? button.efx : typeof efx === "function" ? efx : () => {
      });
    }
    if ($$self.$$.dirty & /*button, keyCode*/
    1081344) {
      $$invalidate(15, keyCode = isObject(button) && typeof button.keyCode === "string" ? button.keyCode : typeof keyCode === "string" ? keyCode : "Enter");
    }
    if ($$self.$$.dirty & /*button, onPress*/
    1114112) {
      $$invalidate(16, onPress = isObject(button) && typeof button.onPress === "function" ? button.onPress : typeof onPress === "function" ? onPress : void 0);
    }
    if ($$self.$$.dirty & /*button, onClose*/
    1179648) {
      $$invalidate(17, onClose = isObject(button) && typeof button.onClose === "function" ? button.onClose : typeof onClose === "function" ? onClose : void 0);
    }
    if ($$self.$$.dirty & /*button, onContextMenu*/
    1310720) {
      $$invalidate(18, onContextMenu = isObject(button) && typeof button.onContextMenu === "function" ? button.onContextMenu : typeof onContextMenu === "function" ? onContextMenu : void 0);
    }
    if ($$self.$$.dirty & /*button, onClickPropagate*/
    1572864) {
      $$invalidate(19, onClickPropagate = isObject(button) && typeof button.onClickPropagate === "boolean" ? button.onClickPropagate : typeof onClickPropagate === "boolean" ? onClickPropagate : false);
    }
    if ($$self.$$.dirty & /*store, $store*/
    2097154) {
      if (store) {
        $$invalidate(4, selected = $store);
      }
    }
    if ($$self.$$.dirty & /*selected, titleSelected, title*/
    24592) {
      $$invalidate(6, titleCurrent = selected && titleSelected !== "" ? titleSelected : title2);
    }
  };
  return [
    icon,
    store,
    styles,
    efx,
    selected,
    anchorEl,
    titleCurrent,
    onClick,
    onContextMenuPress,
    onClickDiv,
    onClosePopup,
    onKeydown,
    onKeyup,
    title2,
    titleSelected,
    keyCode,
    onPress,
    onClose,
    onContextMenu,
    onClickPropagate,
    button,
    $store,
    $$scope,
    slots,
    click_handler,
    contextmenu_handler,
    a_binding
  ];
}
class TJSToggleIconButton extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1o, create_fragment$1w, safe_not_equal, {
      button: 20,
      icon: 0,
      title: 13,
      titleSelected: 14,
      store: 1,
      styles: 2,
      efx: 3,
      keyCode: 15,
      onPress: 16,
      onClose: 17,
      onContextMenu: 18,
      onClickPropagate: 19
    });
  }
}
const TJSScrollContainer_svelte_svelte_type_style_lang = "";
const TJSContentEdit_svelte_svelte_type_style_lang = "";
globalThis.ProseMirror ? globalThis.ProseMirror.ProseMirrorKeyMaps : class {
};
globalThis.ProseMirror ? globalThis.ProseMirror.Plugin : class {
};
const TJSProseMirror_svelte_svelte_type_style_lang = "";
const TJSTinyMCE_svelte_svelte_type_style_lang = "";
const TJSSvgFolder_svelte_svelte_type_style_lang = "";
const get_summary_end_slot_changes = (dirty) => ({});
const get_summary_end_slot_context = (ctx) => ({});
const get_label_slot_changes = (dirty) => ({});
const get_label_slot_context = (ctx) => ({});
function create_if_block_4$4(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "tjs-folder-focus-indicator svelte-auto-xu2oc2");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_else_block$f(ctx) {
  let div;
  let t_value = localize(
    /*label*/
    ctx[1]
  ) + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "label svelte-auto-xu2oc2");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, t);
      ctx[34](div);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*label*/
      2 && t_value !== (t_value = localize(
        /*label*/
        ctx2[1]
      ) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[34](null);
    }
  };
}
function create_if_block_3$7(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    isObject(
      /*folder*/
      ctx[5]?.slotLabel?.props
    ) ? (
      /*folder*/
      ctx[5].slotLabel.props
    ) : {}
  ];
  var switch_value = (
    /*folder*/
    ctx[5].slotLabel.class
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & /*folder*/
      32 ? get_spread_update(switch_instance_spread_levels, [
        get_spread_object(isObject(
          /*folder*/
          ctx2[5]?.slotLabel?.props
        ) ? (
          /*folder*/
          ctx2[5].slotLabel.props
        ) : {})
      ]) : {};
      if (dirty[0] & /*folder*/
      32 && switch_value !== (switch_value = /*folder*/
      ctx2[5].slotLabel.class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function fallback_block_2(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$7, create_else_block$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & /*folder*/
    32)
      show_if = null;
    if (show_if == null)
      show_if = !!isSvelteComponent(
        /*folder*/
        ctx2[5]?.slotLabel?.class
      );
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if_blocks[current_block_type_index].m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_2$a(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    isObject(
      /*folder*/
      ctx[5]?.slotSummaryEnd?.props
    ) ? (
      /*folder*/
      ctx[5].slotSummaryEnd.props
    ) : {}
  ];
  var switch_value = (
    /*folder*/
    ctx[5].slotSummaryEnd.class
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & /*folder*/
      32 ? get_spread_update(switch_instance_spread_levels, [
        get_spread_object(isObject(
          /*folder*/
          ctx2[5]?.slotSummaryEnd?.props
        ) ? (
          /*folder*/
          ctx2[5].slotSummaryEnd.props
        ) : {})
      ]) : {};
      if (dirty[0] & /*folder*/
      32 && switch_value !== (switch_value = /*folder*/
      ctx2[5].slotSummaryEnd.class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function fallback_block_1(ctx) {
  let show_if = isSvelteComponent(
    /*folder*/
    ctx[5]?.slotSummaryEnd?.class
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_2$a(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if (if_block)
        if_block.m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*folder*/
      32)
        show_if = isSvelteComponent(
          /*folder*/
          ctx2[5]?.slotSummaryEnd?.class
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*folder*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$a(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$l(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block$1(ctx);
  return {
    c() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    m(target2, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target2, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[24],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*folder*/
        32)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block_1$c(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    isObject(
      /*folder*/
      ctx[5]?.slotDefault?.props
    ) ? (
      /*folder*/
      ctx[5].slotDefault.props
    ) : {}
  ];
  var switch_value = (
    /*folder*/
    ctx[5].slotDefault.class
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & /*folder*/
      32 ? get_spread_update(switch_instance_spread_levels, [
        get_spread_object(isObject(
          /*folder*/
          ctx2[5]?.slotDefault?.props
        ) ? (
          /*folder*/
          ctx2[5].slotDefault.props
        ) : {})
      ]) : {};
      if (dirty[0] & /*folder*/
      32 && switch_value !== (switch_value = /*folder*/
      ctx2[5].slotDefault.class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function fallback_block$1(ctx) {
  let show_if = isSvelteComponent(
    /*folder*/
    ctx[5]?.slotDefault?.class
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_1$c(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if (if_block)
        if_block.m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*folder*/
      32)
        show_if = isSvelteComponent(
          /*folder*/
          ctx2[5]?.slotDefault?.class
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*folder*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$1v(ctx) {
  let details;
  let summary;
  let svg;
  let path;
  let t0;
  let t1;
  let t2;
  let t3;
  let div;
  let toggleDetails_action;
  let applyStyles_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*localOptions*/
    ctx[7].focusIndicator && create_if_block_4$4()
  );
  const label_slot_template = (
    /*#slots*/
    ctx[25].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    get_label_slot_context
  );
  const label_slot_or_fallback = label_slot || fallback_block_2(ctx);
  const summary_end_slot_template = (
    /*#slots*/
    ctx[25]["summary-end"]
  );
  const summary_end_slot = create_slot(
    summary_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    get_summary_end_slot_context
  );
  const summary_end_slot_or_fallback = summary_end_slot || fallback_block_1(ctx);
  let if_block1 = (
    /*visible*/
    ctx[11] && create_if_block$l(ctx)
  );
  return {
    c() {
      details = element("details");
      summary = element("summary");
      svg = svg_element("svg");
      path = svg_element("path");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      t2 = space();
      if (summary_end_slot_or_fallback)
        summary_end_slot_or_fallback.c();
      t3 = space();
      div = element("div");
      if (if_block1)
        if_block1.c();
      attr(path, "fill", "currentColor");
      attr(path, "stroke", "currentColor");
      set_style(path, "stroke-linejoin", "round");
      set_style(path, "stroke-width", "3");
      attr(path, "d", "M5,8L19,8L12,15Z");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", "svelte-auto-xu2oc2");
      attr(summary, "class", "svelte-auto-xu2oc2");
      toggle_class(
        summary,
        "default-cursor",
        /*localOptions*/
        ctx[7].chevronOnly
      );
      attr(div, "class", "contents svelte-auto-xu2oc2");
      attr(details, "class", "tjs-svg-folder svelte-auto-xu2oc2");
      attr(
        details,
        "data-id",
        /*id*/
        ctx[0]
      );
      attr(
        details,
        "data-label",
        /*label*/
        ctx[1]
      );
      attr(details, "data-closing", "false");
    },
    m(target2, anchor) {
      insert(target2, details, anchor);
      append(details, summary);
      append(summary, svg);
      append(svg, path);
      ctx[33](svg);
      append(summary, t0);
      if (if_block0)
        if_block0.m(summary, null);
      append(summary, t1);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(summary, null);
      }
      append(summary, t2);
      if (summary_end_slot_or_fallback) {
        summary_end_slot_or_fallback.m(summary, null);
      }
      ctx[35](summary);
      append(details, t3);
      append(details, div);
      if (if_block1)
        if_block1.m(div, null);
      ctx[36](details);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            summary,
            "click",
            /*onClickSummary*/
            ctx[12],
            true
          ),
          listen(summary, "contextmenu", function() {
            if (is_function(
              /*onContextMenu*/
              ctx[4]
            ))
              ctx[4].apply(this, arguments);
          }),
          listen(
            summary,
            "keydown",
            /*onKeyDown*/
            ctx[13],
            true
          ),
          listen(
            summary,
            "keyup",
            /*onKeyUp*/
            ctx[14],
            true
          ),
          listen(
            details,
            "close",
            /*onLocalClose*/
            ctx[15]
          ),
          listen(
            details,
            "closeAny",
            /*onLocalClose*/
            ctx[15]
          ),
          listen(
            details,
            "open",
            /*onLocalOpen*/
            ctx[16]
          ),
          listen(
            details,
            "openAny",
            /*onLocalOpen*/
            ctx[16]
          ),
          listen(
            details,
            "click",
            /*click_handler*/
            ctx[26]
          ),
          listen(
            details,
            "keydown",
            /*keydown_handler*/
            ctx[27]
          ),
          listen(
            details,
            "keyup",
            /*keyup_handler*/
            ctx[28]
          ),
          listen(
            details,
            "open",
            /*open_handler*/
            ctx[29]
          ),
          listen(
            details,
            "close",
            /*close_handler*/
            ctx[30]
          ),
          listen(
            details,
            "openAny",
            /*openAny_handler*/
            ctx[31]
          ),
          listen(
            details,
            "closeAny",
            /*closeAny_handler*/
            ctx[32]
          ),
          action_destroyer(toggleDetails_action = toggleDetails.call(null, details, {
            store: (
              /*store*/
              ctx[2]
            ),
            clickActive: false
          })),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            details,
            /*styles*/
            ctx[3]
          ))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*localOptions*/
        ctx[7].focusIndicator
      ) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_4$4();
          if_block0.c();
          if_block0.m(summary, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (label_slot) {
        if (label_slot.p && (!current || dirty[0] & /*$$scope*/
        16777216)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx,
            /*$$scope*/
            ctx[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[24]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx[24],
              dirty,
              get_label_slot_changes
            ),
            get_label_slot_context
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & /*folder, labelEl, label*/
        290)) {
          label_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
        }
      }
      if (summary_end_slot) {
        if (summary_end_slot.p && (!current || dirty[0] & /*$$scope*/
        16777216)) {
          update_slot_base(
            summary_end_slot,
            summary_end_slot_template,
            ctx,
            /*$$scope*/
            ctx[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[24]
            ) : get_slot_changes(
              summary_end_slot_template,
              /*$$scope*/
              ctx[24],
              dirty,
              get_summary_end_slot_changes
            ),
            get_summary_end_slot_context
          );
        }
      } else {
        if (summary_end_slot_or_fallback && summary_end_slot_or_fallback.p && (!current || dirty[0] & /*folder*/
        32)) {
          summary_end_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*localOptions*/
      128) {
        toggle_class(
          summary,
          "default-cursor",
          /*localOptions*/
          ctx[7].chevronOnly
        );
      }
      if (
        /*visible*/
        ctx[11]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty[0] & /*visible*/
          2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$l(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*id*/
      1) {
        attr(
          details,
          "data-id",
          /*id*/
          ctx[0]
        );
      }
      if (!current || dirty[0] & /*label*/
      2) {
        attr(
          details,
          "data-label",
          /*label*/
          ctx[1]
        );
      }
      if (toggleDetails_action && is_function(toggleDetails_action.update) && dirty[0] & /*store*/
      4)
        toggleDetails_action.update.call(null, {
          store: (
            /*store*/
            ctx[2]
          ),
          clickActive: false
        });
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty[0] & /*styles*/
      8)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx[3]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      transition_in(summary_end_slot_or_fallback, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(label_slot_or_fallback, local);
      transition_out(summary_end_slot_or_fallback, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(details);
      ctx[33](null);
      if (if_block0)
        if_block0.d();
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
      if (summary_end_slot_or_fallback)
        summary_end_slot_or_fallback.d(detaching);
      ctx[35](null);
      if (if_block1)
        if_block1.d();
      ctx[36](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1n($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(23, $store = $$value)), store);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { folder = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { keyCode = void 0 } = $$props;
  let { options: options2 = void 0 } = $$props;
  let { store = void 0 } = $$props;
  $$subscribe_store();
  let { styles = void 0 } = $$props;
  let { onClose = void 0 } = $$props;
  let { onOpen = void 0 } = $$props;
  let { onContextMenu = void 0 } = $$props;
  const localOptions = {
    chevronOnly: false,
    focusIndicator: false
  };
  let detailsEl, labelEl, summaryEl, svgEl;
  let storeUnsubscribe;
  let visible = $store;
  let timeoutId;
  onDestroy(() => storeUnsubscribe());
  function createEvent(type, bubbles = false) {
    return new CustomEvent(
      type,
      {
        detail: {
          element: detailsEl,
          folder,
          id,
          label,
          store
        },
        bubbles
      }
    );
  }
  function handleOpenClose(event, fromKeyboard = false) {
    const target2 = event.target;
    const chevronTarget = target2 === svgEl || svgEl.contains(target2);
    if (target2 === summaryEl || target2 === labelEl || chevronTarget || target2.querySelector(".summary-click") !== null) {
      if (!fromKeyboard && localOptions.chevronOnly && !chevronTarget) {
        event.preventDefault();
        event.stopPropagation();
        return;
      }
      set_store_value(store, $store = !$store, $store);
      if ($store && typeof onOpen === "function") {
        onOpen();
      } else if (typeof onClose === "function") {
        onClose();
      }
      event.preventDefault();
      event.stopPropagation();
    } else {
      if (target2.classList.contains("no-summary-click") || target2.querySelector(".no-summary-click") !== null || target2.parentElement && target2.parentElement.classList.contains("no-summary-click")) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }
  function onClickSummary(event) {
    if (document.activeElement === summaryEl && (event?.pointerId === -1 || event?.mozInputSource === 6)) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    handleOpenClose(event);
  }
  function onKeyDown(event) {
    if (document.activeElement === summaryEl && event.code === keyCode) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function onKeyUp(event) {
    if (document.activeElement === summaryEl && event.code === keyCode) {
      handleOpenClose(event, true);
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function onLocalClose(event) {
    event.preventDefault();
    event.stopPropagation();
    store.set(false);
  }
  function onLocalOpen(event) {
    event.preventDefault();
    event.stopPropagation();
    store.set(true);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function open_handler(event) {
    bubble.call(this, $$self, event);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  function openAny_handler(event) {
    bubble.call(this, $$self, event);
  }
  function closeAny_handler(event) {
    bubble.call(this, $$self, event);
  }
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      svgEl = $$value;
      $$invalidate(10, svgEl);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      labelEl = $$value;
      $$invalidate(8, labelEl);
    });
  }
  function summary_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      summaryEl = $$value;
      $$invalidate(9, summaryEl);
    });
  }
  function details_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      detailsEl = $$value;
      $$invalidate(6, detailsEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("folder" in $$props2)
      $$invalidate(5, folder = $$props2.folder);
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("keyCode" in $$props2)
      $$invalidate(17, keyCode = $$props2.keyCode);
    if ("options" in $$props2)
      $$invalidate(18, options2 = $$props2.options);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(2, store = $$props2.store));
    if ("styles" in $$props2)
      $$invalidate(3, styles = $$props2.styles);
    if ("onClose" in $$props2)
      $$invalidate(19, onClose = $$props2.onClose);
    if ("onOpen" in $$props2)
      $$invalidate(20, onOpen = $$props2.onOpen);
    if ("onContextMenu" in $$props2)
      $$invalidate(4, onContextMenu = $$props2.onContextMenu);
    if ("$$scope" in $$props2)
      $$invalidate(24, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*folder, id*/
    33) {
      $$invalidate(0, id = isObject(folder) && typeof folder.id === "string" ? folder.id : typeof id === "string" ? id : void 0);
    }
    if ($$self.$$.dirty[0] & /*folder, label*/
    34) {
      $$invalidate(1, label = isObject(folder) && typeof folder.label === "string" ? folder.label : typeof label === "string" ? label : "");
    }
    if ($$self.$$.dirty[0] & /*folder, keyCode*/
    131104) {
      $$invalidate(17, keyCode = isObject(folder) && typeof folder.keyCode === "string" ? folder.keyCode : typeof keyCode === "string" ? keyCode : "Enter");
    }
    if ($$self.$$.dirty[0] & /*folder, options*/
    262176) {
      {
        $$invalidate(18, options2 = isObject(folder) && isObject(folder.options) ? folder.options : isObject(options2) ? options2 : {});
        if (typeof options2?.chevronOnly === "boolean") {
          $$invalidate(7, localOptions.chevronOnly = options2.chevronOnly, localOptions);
        }
        if (typeof options2?.focusIndicator === "boolean") {
          $$invalidate(7, localOptions.focusIndicator = options2.focusIndicator, localOptions);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*folder, store, storeUnsubscribe, detailsEl*/
    2097252) {
      {
        $$subscribe_store($$invalidate(2, store = isObject(folder) && isWritableStore(folder.store) ? folder.store : isWritableStore(store) ? store : writable$1(false)));
        if (typeof storeUnsubscribe === "function") {
          storeUnsubscribe();
        }
        $$invalidate(21, storeUnsubscribe = subscribeIgnoreFirst(store, (value) => {
          if (detailsEl) {
            detailsEl.dispatchEvent(createEvent(value ? "open" : "close"));
            detailsEl.dispatchEvent(createEvent(value ? "openAny" : "closeAny", true));
          }
        }));
      }
    }
    if ($$self.$$.dirty[0] & /*folder, styles*/
    40) {
      $$invalidate(3, styles = isObject(folder) && isObject(folder.styles) ? folder.styles : isObject(styles) ? styles : void 0);
    }
    if ($$self.$$.dirty[0] & /*folder, onClose*/
    524320) {
      $$invalidate(19, onClose = isObject(folder) && typeof folder.onClose === "function" ? folder.onClose : typeof onClose === "function" ? onClose : void 0);
    }
    if ($$self.$$.dirty[0] & /*folder, onOpen*/
    1048608) {
      $$invalidate(20, onOpen = isObject(folder) && typeof folder.onOpen === "function" ? folder.onOpen : typeof onOpen === "function" ? onOpen : void 0);
    }
    if ($$self.$$.dirty[0] & /*folder, onContextMenu*/
    48) {
      $$invalidate(4, onContextMenu = isObject(folder) && typeof folder.onContextMenu === "function" ? folder.onContextMenu : typeof onContextMenu === "function" ? onContextMenu : () => null);
    }
    if ($$self.$$.dirty[0] & /*$store, timeoutId*/
    12582912) {
      if (!$store) {
        $$invalidate(22, timeoutId = setTimeout(() => $$invalidate(11, visible = false), 500));
      } else {
        clearTimeout(timeoutId);
        $$invalidate(11, visible = true);
      }
    }
  };
  return [
    id,
    label,
    store,
    styles,
    onContextMenu,
    folder,
    detailsEl,
    localOptions,
    labelEl,
    summaryEl,
    svgEl,
    visible,
    onClickSummary,
    onKeyDown,
    onKeyUp,
    onLocalClose,
    onLocalOpen,
    keyCode,
    options2,
    onClose,
    onOpen,
    storeUnsubscribe,
    timeoutId,
    $store,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    open_handler,
    close_handler,
    openAny_handler,
    closeAny_handler,
    svg_binding,
    div_binding,
    summary_binding,
    details_binding
  ];
}
class TJSSvgFolder extends SvelteComponent {
  constructor(options2) {
    super();
    init(
      this,
      options2,
      instance$1n,
      create_fragment$1v,
      safe_not_equal,
      {
        folder: 5,
        id: 0,
        label: 1,
        keyCode: 17,
        options: 18,
        store: 2,
        styles: 3,
        onClose: 19,
        onOpen: 20,
        onContextMenu: 4
      },
      null,
      [-1, -1]
    );
  }
}
const TJSIconFolder_svelte_svelte_type_style_lang = "";
const TJSInputNumber_svelte_svelte_type_style_lang = "";
function create_fragment$1u(ctx) {
  let div;
  let input_1;
  let applyStyles_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input_1 = element("input");
      attr(input_1, "class", "tjs-input svelte-auto-1lqnchb");
      attr(input_1, "type", "number");
      attr(
        input_1,
        "max",
        /*max*/
        ctx[1]
      );
      attr(
        input_1,
        "min",
        /*min*/
        ctx[2]
      );
      attr(
        input_1,
        "step",
        /*step*/
        ctx[4]
      );
      attr(
        input_1,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      input_1.disabled = /*disabled*/
      ctx[0];
      toggle_class(input_1, "is-value-invalid", !/*$storeIsValid*/
      ctx[10]);
      attr(div, "class", "tjs-input-container svelte-auto-1lqnchb");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input_1);
      ctx[16](input_1);
      set_input_value(
        input_1,
        /*$store*/
        ctx[11]
      );
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[17]
          ),
          listen(
            input_1,
            "focusin",
            /*onFocusIn*/
            ctx[12]
          ),
          listen(
            input_1,
            "keydown",
            /*onKeyDown*/
            ctx[13]
          ),
          action_destroyer(
            /*efx*/
            ctx[8].call(null, div)
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            div,
            /*styles*/
            ctx[7]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*max*/
      2) {
        attr(
          input_1,
          "max",
          /*max*/
          ctx2[1]
        );
      }
      if (dirty & /*min*/
      4) {
        attr(
          input_1,
          "min",
          /*min*/
          ctx2[2]
        );
      }
      if (dirty & /*step*/
      16) {
        attr(
          input_1,
          "step",
          /*step*/
          ctx2[4]
        );
      }
      if (dirty & /*placeholder*/
      8) {
        attr(
          input_1,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (dirty & /*disabled*/
      1) {
        input_1.disabled = /*disabled*/
        ctx2[0];
      }
      if (dirty & /*$store*/
      2048 && to_number(input_1.value) !== /*$store*/
      ctx2[11]) {
        set_input_value(
          input_1,
          /*$store*/
          ctx2[11]
        );
      }
      if (dirty & /*$storeIsValid*/
      1024) {
        toggle_class(input_1, "is-value-invalid", !/*$storeIsValid*/
        ctx2[10]);
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      128)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx2[7]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1m($$self, $$props, $$invalidate) {
  let $storeIsValid, $$unsubscribe_storeIsValid = noop, $$subscribe_storeIsValid = () => ($$unsubscribe_storeIsValid(), $$unsubscribe_storeIsValid = subscribe(storeIsValid, ($$value) => $$invalidate(10, $storeIsValid = $$value)), storeIsValid);
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(11, $store = $$value)), store);
  $$self.$$.on_destroy.push(() => $$unsubscribe_storeIsValid());
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { input = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { options: options2 = void 0 } = $$props;
  let { max = void 0 } = $$props;
  let { min = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { step = void 0 } = $$props;
  let { store = void 0 } = $$props;
  $$subscribe_store();
  let { storeIsValid = void 0 } = $$props;
  $$subscribe_storeIsValid();
  let { styles = void 0 } = $$props;
  let { efx = void 0 } = $$props;
  const localOptions = {
    blurOnEnterKey: true,
    cancelOnEscKey: false
  };
  let inputEl;
  let initialValue;
  function onFocusIn() {
    if (localOptions.cancelOnEscKey) {
      initialValue = inputEl.value === "" ? null : globalThis.parseFloat(inputEl.value);
    }
  }
  function onKeyDown(event) {
    if (localOptions.blurOnEnterKey && event.code === "Enter") {
      event.preventDefault();
      event.stopPropagation();
      inputEl.blur();
      return;
    }
    if (event.code === "Escape") {
      if (localOptions.cancelOnEscKey && (initialValue === null || typeof initialValue === "number")) {
        event.preventDefault();
        event.stopPropagation();
        store.set(initialValue);
        initialValue = void 0;
        inputEl.blur();
      }
    }
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(9, inputEl);
    });
  }
  function input_1_input_handler() {
    $store = to_number(this.value);
    store.set($store);
  }
  $$self.$$set = ($$props2) => {
    if ("input" in $$props2)
      $$invalidate(15, input = $$props2.input);
    if ("disabled" in $$props2)
      $$invalidate(0, disabled = $$props2.disabled);
    if ("options" in $$props2)
      $$invalidate(14, options2 = $$props2.options);
    if ("max" in $$props2)
      $$invalidate(1, max = $$props2.max);
    if ("min" in $$props2)
      $$invalidate(2, min = $$props2.min);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("step" in $$props2)
      $$invalidate(4, step = $$props2.step);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(5, store = $$props2.store));
    if ("storeIsValid" in $$props2)
      $$subscribe_storeIsValid($$invalidate(6, storeIsValid = $$props2.storeIsValid));
    if ("styles" in $$props2)
      $$invalidate(7, styles = $$props2.styles);
    if ("efx" in $$props2)
      $$invalidate(8, efx = $$props2.efx);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*input, disabled*/
    32769) {
      $$invalidate(0, disabled = isObject(input) && typeof input.disabled === "boolean" ? input.disabled : typeof disabled === "boolean" ? disabled : false);
    }
    if ($$self.$$.dirty & /*input, options*/
    49152) {
      {
        $$invalidate(14, options2 = isObject(input) && isObject(input.options) ? input.options : isObject(options2) ? options2 : {});
        if (typeof options2?.blurOnEnterKey === "boolean") {
          localOptions.blurOnEnterKey = options2.blurOnEnterKey;
        }
        if (typeof options2?.cancelOnEscKey === "boolean") {
          localOptions.cancelOnEscKey = options2.cancelOnEscKey;
        }
      }
    }
    if ($$self.$$.dirty & /*input, max*/
    32770) {
      $$invalidate(1, max = isObject(input) && typeof input.max === "number" ? input.max : typeof max === "number" ? max : void 0);
    }
    if ($$self.$$.dirty & /*input, min*/
    32772) {
      $$invalidate(2, min = isObject(input) && typeof input.min === "number" ? input.min : typeof min === "number" ? min : void 0);
    }
    if ($$self.$$.dirty & /*input, placeholder*/
    32776) {
      $$invalidate(3, placeholder = isObject(input) && typeof input.placeholder === "string" ? localize(input.placeholder) : typeof placeholder === "string" ? localize(placeholder) : void 0);
    }
    if ($$self.$$.dirty & /*input, step*/
    32784) {
      $$invalidate(4, step = isObject(input) && typeof input.step === "number" ? input.step : typeof step === "number" ? step : void 0);
    }
    if ($$self.$$.dirty & /*input, store*/
    32800) {
      $$subscribe_store($$invalidate(5, store = isObject(input) && isWritableStore(input.store) ? input.store : isWritableStore(store) ? store : writable$1(void 0)));
    }
    if ($$self.$$.dirty & /*input, storeIsValid*/
    32832) {
      $$subscribe_storeIsValid($$invalidate(6, storeIsValid = isObject(input) && isReadableStore(input.storeIsValid) ? input.storeIsValid : isReadableStore(storeIsValid) ? storeIsValid : writable$1(true)));
    }
    if ($$self.$$.dirty & /*input, storeIsValid*/
    32832) {
      $$subscribe_storeIsValid($$invalidate(6, storeIsValid = isObject(input) && isReadableStore(input.storeIsValid) ? input.storeIsValid : isReadableStore(storeIsValid) ? storeIsValid : writable$1(true)));
    }
    if ($$self.$$.dirty & /*input, styles*/
    32896) {
      $$invalidate(7, styles = isObject(input) && isObject(input.styles) ? input.styles : typeof styles === "object" ? styles : void 0);
    }
    if ($$self.$$.dirty & /*input, efx*/
    33024) {
      $$invalidate(8, efx = isObject(input) && typeof input.efx === "function" ? input.efx : typeof efx === "function" ? efx : () => {
      });
    }
  };
  return [
    disabled,
    max,
    min,
    placeholder,
    step,
    store,
    storeIsValid,
    styles,
    efx,
    inputEl,
    $storeIsValid,
    $store,
    onFocusIn,
    onKeyDown,
    options2,
    input,
    input_1_binding,
    input_1_input_handler
  ];
}
class TJSInputNumber extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1m, create_fragment$1u, safe_not_equal, {
      input: 15,
      disabled: 0,
      options: 14,
      max: 1,
      min: 2,
      placeholder: 3,
      step: 4,
      store: 5,
      storeIsValid: 6,
      styles: 7,
      efx: 8
    });
  }
}
const TJSInputText_svelte_svelte_type_style_lang = "";
function create_fragment$1t(ctx) {
  let div;
  let input_1;
  let applyStyles_action;
  let mounted;
  let dispose;
  let input_1_levels = [
    { class: "tjs-input" },
    { type: (
      /*type*/
      ctx[0]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[2]
    ) },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_1_levels.length; i += 1) {
    input_data = assign(input_data, input_1_levels[i]);
  }
  return {
    c() {
      div = element("div");
      input_1 = element("input");
      set_attributes(input_1, input_data);
      toggle_class(input_1, "is-value-invalid", !/*$storeIsValid*/
      ctx[8]);
      toggle_class(input_1, "svelte-auto-dc9eoa", true);
      attr(div, "class", "tjs-input-container svelte-auto-dc9eoa");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input_1);
      if (input_1.autofocus)
        input_1.focus();
      ctx[14](input_1);
      set_input_value(
        input_1,
        /*$store*/
        ctx[9]
      );
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[15]
          ),
          listen(
            input_1,
            "focusin",
            /*onFocusIn*/
            ctx[10]
          ),
          listen(
            input_1,
            "keydown",
            /*onKeyDown*/
            ctx[11]
          ),
          action_destroyer(
            /*efx*/
            ctx[6].call(null, div)
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            div,
            /*styles*/
            ctx[5]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(input_1, input_data = get_spread_update(input_1_levels, [
        { class: "tjs-input" },
        dirty & /*type*/
        1 && { type: (
          /*type*/
          ctx2[0]
        ) },
        dirty & /*placeholder*/
        4 && { placeholder: (
          /*placeholder*/
          ctx2[2]
        ) },
        dirty & /*disabled*/
        2 && { disabled: (
          /*disabled*/
          ctx2[1]
        ) }
      ]));
      if (dirty & /*$store*/
      512 && input_1.value !== /*$store*/
      ctx2[9]) {
        set_input_value(
          input_1,
          /*$store*/
          ctx2[9]
        );
      }
      toggle_class(input_1, "is-value-invalid", !/*$storeIsValid*/
      ctx2[8]);
      toggle_class(input_1, "svelte-auto-dc9eoa", true);
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      32)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx2[5]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1l($$self, $$props, $$invalidate) {
  let $storeIsValid, $$unsubscribe_storeIsValid = noop, $$subscribe_storeIsValid = () => ($$unsubscribe_storeIsValid(), $$unsubscribe_storeIsValid = subscribe(storeIsValid, ($$value) => $$invalidate(8, $storeIsValid = $$value)), storeIsValid);
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(9, $store = $$value)), store);
  $$self.$$.on_destroy.push(() => $$unsubscribe_storeIsValid());
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { input = void 0 } = $$props;
  let { type = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { options: options2 = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { store = void 0 } = $$props;
  $$subscribe_store();
  let { storeIsValid = void 0 } = $$props;
  $$subscribe_storeIsValid();
  let { styles = void 0 } = $$props;
  let { efx = void 0 } = $$props;
  const localOptions = {
    blurOnEnterKey: true,
    cancelOnEscKey: false,
    clearOnEscKey: false
  };
  let inputEl;
  let initialValue;
  function onFocusIn(event) {
    initialValue = localOptions.cancelOnEscKey ? inputEl.value : void 0;
  }
  function onKeyDown(event) {
    if (localOptions.blurOnEnterKey && event.code === "Enter") {
      event.preventDefault();
      event.stopPropagation();
      inputEl.blur();
      return;
    }
    if (event.code === "Escape") {
      if (localOptions.cancelOnEscKey && typeof initialValue === "string") {
        event.preventDefault();
        event.stopPropagation();
        store.set(initialValue);
        initialValue = void 0;
        inputEl.blur();
      } else if (localOptions.clearOnEscKey) {
        event.preventDefault();
        event.stopPropagation();
        store.set("");
        inputEl.blur();
      }
    }
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(7, inputEl);
    });
  }
  function input_1_input_handler() {
    $store = this.value;
    store.set($store);
  }
  $$self.$$set = ($$props2) => {
    if ("input" in $$props2)
      $$invalidate(13, input = $$props2.input);
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("options" in $$props2)
      $$invalidate(12, options2 = $$props2.options);
    if ("placeholder" in $$props2)
      $$invalidate(2, placeholder = $$props2.placeholder);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(3, store = $$props2.store));
    if ("storeIsValid" in $$props2)
      $$subscribe_storeIsValid($$invalidate(4, storeIsValid = $$props2.storeIsValid));
    if ("styles" in $$props2)
      $$invalidate(5, styles = $$props2.styles);
    if ("efx" in $$props2)
      $$invalidate(6, efx = $$props2.efx);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*input, type*/
    8193) {
      {
        $$invalidate(0, type = isObject(input) && typeof input.type === "string" ? input.type : typeof type === "string" ? type : "text");
        switch (type) {
          case "email":
          case "password":
          case "search":
          case "text":
          case "url":
            break;
          default:
            throw new Error(`'TJSInputText only supports text input types: 'email', 'password', 'search', 'text', 'url'.`);
        }
      }
    }
    if ($$self.$$.dirty & /*input, disabled*/
    8194) {
      $$invalidate(1, disabled = isObject(input) && typeof input.disabled === "boolean" ? input.disabled : typeof disabled === "boolean" ? disabled : false);
    }
    if ($$self.$$.dirty & /*input, options*/
    12288) {
      {
        $$invalidate(12, options2 = isObject(input) && isObject(input.options) ? input.options : isObject(options2) ? options2 : {});
        if (typeof options2?.blurOnEnterKey === "boolean") {
          localOptions.blurOnEnterKey = options2.blurOnEnterKey;
        }
        if (typeof options2?.cancelOnEscKey === "boolean") {
          localOptions.cancelOnEscKey = options2.cancelOnEscKey;
        }
        if (typeof options2?.clearOnEscKey === "boolean") {
          localOptions.clearOnEscKey = options2.clearOnEscKey;
        }
      }
    }
    if ($$self.$$.dirty & /*input, placeholder*/
    8196) {
      $$invalidate(2, placeholder = isObject(input) && typeof input.placeholder === "string" ? localize(input.placeholder) : typeof placeholder === "string" ? localize(placeholder) : void 0);
    }
    if ($$self.$$.dirty & /*input, store*/
    8200) {
      $$subscribe_store($$invalidate(3, store = isObject(input) && isWritableStore(input.store) ? input.store : isWritableStore(store) ? store : writable$1(void 0)));
    }
    if ($$self.$$.dirty & /*input, storeIsValid*/
    8208) {
      $$subscribe_storeIsValid($$invalidate(4, storeIsValid = isObject(input) && isReadableStore(input.storeIsValid) ? input.storeIsValid : isReadableStore(storeIsValid) ? storeIsValid : writable$1(true)));
    }
    if ($$self.$$.dirty & /*input, styles*/
    8224) {
      $$invalidate(5, styles = isObject(input) && isObject(input.styles) ? input.styles : typeof styles === "object" ? styles : void 0);
    }
    if ($$self.$$.dirty & /*input, efx*/
    8256) {
      $$invalidate(6, efx = isObject(input) && typeof input.efx === "function" ? input.efx : typeof efx === "function" ? efx : () => {
      });
    }
  };
  return [
    type,
    disabled,
    placeholder,
    store,
    storeIsValid,
    styles,
    efx,
    inputEl,
    $storeIsValid,
    $store,
    onFocusIn,
    onKeyDown,
    options2,
    input,
    input_1_binding,
    input_1_input_handler
  ];
}
class TJSInputText extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1l, create_fragment$1t, safe_not_equal, {
      input: 13,
      type: 0,
      disabled: 1,
      options: 12,
      placeholder: 2,
      store: 3,
      storeIsValid: 4,
      styles: 5,
      efx: 6
    });
  }
}
function create_fragment$1s(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*component*/
    ctx[1]
  );
  function switch_props(ctx2) {
    return { props: { input: (
      /*input*/
      ctx2[0]
    ) } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & /*input*/
      1)
        switch_instance_changes.input = /*input*/
        ctx2[0];
      if (dirty & /*component*/
      2 && switch_value !== (switch_value = /*component*/
      ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function instance$1k($$self, $$props, $$invalidate) {
  let { input = void 0 } = $$props;
  let component;
  $$self.$$set = ($$props2) => {
    if ("input" in $$props2)
      $$invalidate(0, input = $$props2.input);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*input*/
    1) {
      {
        const type = isObject(input) && typeof input.type === "string" ? input.type : "text";
        switch (type) {
          case "email":
          case "password":
          case "search":
          case "text":
          case "url":
            $$invalidate(1, component = TJSInputText);
            break;
          case "number":
            $$invalidate(1, component = TJSInputNumber);
            break;
          default:
            throw new Error(`'TJSInput' currently only supports text input types: 'email', 'number', 'password', 'search', 'text', 'url'.`);
        }
      }
    }
  };
  return [input, component];
}
class TJSInput extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1k, create_fragment$1s, safe_not_equal, { input: 0 });
  }
}
const TJSSelect_svelte_svelte_type_style_lang = "";
function get_each_context$f(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_each_block$f(ctx) {
  let option;
  let t0_value = (
    /*option*/
    ctx[10].label + ""
  );
  let t0;
  let t1;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      attr(option, "class", "tjs-select-option svelte-auto-1q83byg");
      option.__value = option_value_value = /*option*/
      ctx[10].value;
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      1 && t0_value !== (t0_value = /*option*/
      ctx2[10].label + ""))
        set_data(t0, t0_value);
      if (dirty & /*options*/
      1 && option_value_value !== (option_value_value = /*option*/
      ctx2[10].value)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$1r(ctx) {
  let div;
  let select_1;
  let applyStyles_action;
  let mounted;
  let dispose;
  let each_value = (
    /*options*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      select_1 = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(select_1, "class", "tjs-select svelte-auto-1q83byg");
      if (
        /*$store*/
        ctx[4] === void 0
      )
        add_render_callback(() => (
          /*select_1_change_handler*/
          ctx[9].call(select_1)
        ));
      attr(div, "class", "tjs-select-container svelte-auto-1q83byg");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, select_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select_1, null);
        }
      }
      select_option(
        select_1,
        /*$store*/
        ctx[4],
        true
      );
      if (!mounted) {
        dispose = [
          listen(
            select_1,
            "change",
            /*change_handler_1*/
            ctx[8]
          ),
          listen(
            select_1,
            "change",
            /*select_1_change_handler*/
            ctx[9]
          ),
          listen(
            div,
            "change",
            /*change_handler*/
            ctx[7]
          ),
          action_destroyer(
            /*efx*/
            ctx[3].call(null, div)
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            div,
            /*styles*/
            ctx[2]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*options*/
      1) {
        each_value = /*options*/
        ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$f(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$f(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select_1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$store, options*/
      17) {
        select_option(
          select_1,
          /*$store*/
          ctx2[4]
        );
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      4)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx2[2]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1j($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(4, $store = $$value)), store);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { select = void 0 } = $$props;
  let { selected = void 0 } = $$props;
  let { options: options2 = void 0 } = $$props;
  let { store = void 0 } = $$props;
  $$subscribe_store();
  let { styles = void 0 } = $$props;
  let { efx = void 0 } = $$props;
  onMount(() => {
    if (selected && store && !options2.includes($store) && options2.includes(selected)) {
      store.set(selected);
    }
  });
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function select_1_change_handler() {
    $store = select_value(this);
    store.set($store);
    $$invalidate(0, options2), $$invalidate(6, select);
  }
  $$self.$$set = ($$props2) => {
    if ("select" in $$props2)
      $$invalidate(6, select = $$props2.select);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
    if ("options" in $$props2)
      $$invalidate(0, options2 = $$props2.options);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(1, store = $$props2.store));
    if ("styles" in $$props2)
      $$invalidate(2, styles = $$props2.styles);
    if ("efx" in $$props2)
      $$invalidate(3, efx = $$props2.efx);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*select, selected*/
    96) {
      $$invalidate(5, selected = typeof select === "object" && typeof select.selected === "string" ? select.selected : typeof selected === "string" ? selected : void 0);
    }
    if ($$self.$$.dirty & /*select, options*/
    65) {
      $$invalidate(0, options2 = typeof select === "object" && Array.isArray(select.options) ? select.options : Array.isArray(options2) ? options2 : []);
    }
    if ($$self.$$.dirty & /*select, store*/
    66) {
      $$subscribe_store($$invalidate(1, store = typeof select === "object" && isWritableStore(select.store) ? select.store : isWritableStore(store) ? store : writable$1(void 0)));
    }
    if ($$self.$$.dirty & /*select, styles*/
    68) {
      $$invalidate(2, styles = typeof select === "object" && typeof select.styles === "object" ? select.styles : typeof styles === "object" ? styles : void 0);
    }
    if ($$self.$$.dirty & /*select, efx*/
    72) {
      $$invalidate(3, efx = typeof select === "object" && typeof select.efx === "function" ? select.efx : typeof efx === "function" ? efx : () => {
      });
    }
  };
  return [
    options2,
    store,
    styles,
    efx,
    $store,
    selected,
    select,
    change_handler,
    change_handler_1,
    select_1_change_handler
  ];
}
class TJSSelect extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1j, create_fragment$1r, safe_not_equal, {
      select: 6,
      selected: 5,
      options: 0,
      store: 1,
      styles: 2,
      efx: 3
    });
  }
}
const TJSToggleLabel_svelte_svelte_type_style_lang = "";
const ResizeHitBox_svelte_svelte_type_style_lang = "";
const SelectedBorder_svelte_svelte_type_style_lang = "";
const PositionControl_svelte_svelte_type_style_lang = "";
const TJSPositionControlLayer_svelte_svelte_type_style_lang = "";
const TJSMenu_svelte_svelte_type_style_lang = "";
const { document: document_1 } = globals;
const get_after_slot_changes = (dirty) => ({});
const get_after_slot_context = (ctx) => ({});
function get_each_context$e(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i];
  return child_ctx;
}
const get_before_slot_changes = (dirty) => ({});
const get_before_slot_context = (ctx) => ({});
function create_if_block_6$2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    isObject(
      /*menu*/
      ctx[2]?.slotDefault?.props
    ) ? (
      /*menu*/
      ctx[2].slotDefault.props
    ) : {}
  ];
  var switch_value = (
    /*menu*/
    ctx[2].slotDefault.class
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & /*menu*/
      4 ? get_spread_update(switch_instance_spread_levels, [
        get_spread_object(isObject(
          /*menu*/
          ctx2[2]?.slotDefault?.props
        ) ? (
          /*menu*/
          ctx2[2].slotDefault.props
        ) : {})
      ]) : {};
      if (dirty[0] & /*menu*/
      4 && switch_value !== (switch_value = /*menu*/
      ctx2[2].slotDefault.class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function fallback_block(ctx) {
  let show_if = isSvelteComponent(
    /*menu*/
    ctx[2]?.slotDefault?.class
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_6$2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if (if_block)
        if_block.m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*menu*/
      4)
        show_if = isSvelteComponent(
          /*menu*/
          ctx2[2]?.slotDefault?.class
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*menu*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_6$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_5$3(ctx) {
  let li;
  let span;
  let t;
  let current;
  let mounted;
  let dispose;
  const before_slot_template = (
    /*#slots*/
    ctx[19].before
  );
  const before_slot = create_slot(
    before_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_before_slot_context
  );
  return {
    c() {
      li = element("li");
      span = element("span");
      t = space();
      if (before_slot)
        before_slot.c();
      attr(span, "class", "tjs-menu-focus-indicator svelte-auto-7526ak");
      attr(li, "class", "tjs-menu-item svelte-auto-7526ak");
      attr(li, "role", "menuitem");
      attr(li, "tabindex", "0");
    },
    m(target2, anchor) {
      insert(target2, li, anchor);
      append(li, span);
      append(li, t);
      if (before_slot) {
        before_slot.m(li, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            li,
            "click",
            /*click_handler*/
            ctx[20]
          ),
          listen(
            li,
            "keyup",
            /*keyup_handler*/
            ctx[21]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (before_slot) {
        if (before_slot.p && (!current || dirty[0] & /*$$scope*/
        262144)) {
          update_slot_base(
            before_slot,
            before_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              before_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_before_slot_changes
            ),
            get_before_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(before_slot, local);
      current = true;
    },
    o(local) {
      transition_out(before_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (before_slot)
        before_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$3(ctx) {
  let hr;
  return {
    c() {
      hr = element("hr");
      attr(hr, "class", "svelte-auto-7526ak");
    },
    m(target2, anchor) {
      insert(target2, hr, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(hr);
    }
  };
}
function create_if_block_3$6(ctx) {
  let li;
  let span0;
  let t0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t1;
  let span1;
  let t2_value = localize(
    /*item*/
    ctx[36].label
  ) + "";
  let t2;
  let mounted;
  let dispose;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[26](
        /*item*/
        ctx[36]
      )
    );
  }
  function keyup_handler_3(...args) {
    return (
      /*keyup_handler_3*/
      ctx[27](
        /*item*/
        ctx[36],
        ...args
      )
    );
  }
  return {
    c() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      img = element("img");
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      attr(span0, "class", "tjs-menu-focus-indicator svelte-auto-7526ak");
      if (!src_url_equal(img.src, img_src_value = /*item*/
      ctx[36].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*item*/
      ctx[36].imageAlt);
      attr(img, "class", "svelte-auto-7526ak");
      attr(span1, "class", "tjs-menu-item-label svelte-auto-7526ak");
      attr(li, "class", "tjs-menu-item tjs-menu-item-button svelte-auto-7526ak");
      attr(li, "role", "menuitem");
      attr(li, "tabindex", "0");
    },
    m(target2, anchor) {
      insert(target2, li, anchor);
      append(li, span0);
      append(li, t0);
      append(li, img);
      append(li, t1);
      append(li, span1);
      append(span1, t2);
      if (!mounted) {
        dispose = [
          listen(li, "click", click_handler_3),
          listen(li, "keyup", keyup_handler_3)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*allItems*/
      8 && !src_url_equal(img.src, img_src_value = /*item*/
      ctx[36].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty[0] & /*allItems*/
      8 && img_alt_value !== (img_alt_value = /*item*/
      ctx[36].imageAlt)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty[0] & /*allItems*/
      8 && t2_value !== (t2_value = localize(
        /*item*/
        ctx[36].label
      ) + ""))
        set_data(t2, t2_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$9(ctx) {
  let li;
  let span0;
  let t0;
  let i;
  let i_class_value;
  let t1;
  let span1;
  let t2_value = localize(
    /*item*/
    ctx[36].label
  ) + "";
  let t2;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[24](
        /*item*/
        ctx[36]
      )
    );
  }
  function keyup_handler_2(...args) {
    return (
      /*keyup_handler_2*/
      ctx[25](
        /*item*/
        ctx[36],
        ...args
      )
    );
  }
  return {
    c() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      i = element("i");
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      attr(span0, "class", "tjs-menu-focus-indicator svelte-auto-7526ak");
      attr(i, "class", i_class_value = null_to_empty(
        /*item*/
        ctx[36].icon
      ) + " svelte-auto-7526ak");
      attr(span1, "class", "tjs-menu-item-label svelte-auto-7526ak");
      attr(li, "class", "tjs-menu-item tjs-menu-item-button svelte-auto-7526ak");
      attr(li, "role", "menuitem");
      attr(li, "tabindex", "0");
    },
    m(target2, anchor) {
      insert(target2, li, anchor);
      append(li, span0);
      append(li, t0);
      append(li, i);
      append(li, t1);
      append(li, span1);
      append(span1, t2);
      if (!mounted) {
        dispose = [
          listen(li, "click", click_handler_2),
          listen(li, "keyup", keyup_handler_2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*allItems*/
      8 && i_class_value !== (i_class_value = null_to_empty(
        /*item*/
        ctx[36].icon
      ) + " svelte-auto-7526ak")) {
        attr(i, "class", i_class_value);
      }
      if (dirty[0] & /*allItems*/
      8 && t2_value !== (t2_value = localize(
        /*item*/
        ctx[36].label
      ) + ""))
        set_data(t2, t2_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$b(ctx) {
  let li;
  let span;
  let t;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  const switch_instance_spread_levels = [
    isObject(
      /*item*/
      ctx[36].props
    ) ? (
      /*item*/
      ctx[36].props
    ) : {}
  ];
  var switch_value = (
    /*item*/
    ctx[36].class
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[22](
        /*item*/
        ctx[36]
      )
    );
  }
  function keyup_handler_1(...args) {
    return (
      /*keyup_handler_1*/
      ctx[23](
        /*item*/
        ctx[36],
        ...args
      )
    );
  }
  return {
    c() {
      li = element("li");
      span = element("span");
      t = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(span, "class", "tjs-menu-focus-indicator svelte-auto-7526ak");
      attr(li, "class", "tjs-menu-item svelte-auto-7526ak");
      attr(li, "role", "menuitem");
      attr(li, "tabindex", "0");
    },
    m(target2, anchor) {
      insert(target2, li, anchor);
      append(li, span);
      append(li, t);
      if (switch_instance)
        mount_component(switch_instance, li, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(li, "click", click_handler_1),
          listen(li, "keyup", keyup_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = dirty[0] & /*allItems*/
      8 ? get_spread_update(switch_instance_spread_levels, [
        get_spread_object(isObject(
          /*item*/
          ctx[36].props
        ) ? (
          /*item*/
          ctx[36].props
        ) : {})
      ]) : {};
      if (dirty[0] & /*allItems*/
      8 && switch_value !== (switch_value = /*item*/
      ctx[36].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, li, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block$e(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$b, create_if_block_2$9, create_if_block_3$6, create_if_block_4$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*item*/
      ctx2[36]["#type"] === "class"
    )
      return 0;
    if (
      /*item*/
      ctx2[36]["#type"] === "icon"
    )
      return 1;
    if (
      /*item*/
      ctx2[36]["#type"] === "image"
    )
      return 2;
    if (
      /*item*/
      ctx2[36]["#type"] === "separator-hr"
    )
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target2, anchor);
      }
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$k(ctx) {
  let li;
  let span;
  let t;
  let current;
  let mounted;
  let dispose;
  const after_slot_template = (
    /*#slots*/
    ctx[19].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_after_slot_context
  );
  return {
    c() {
      li = element("li");
      span = element("span");
      t = space();
      if (after_slot)
        after_slot.c();
      attr(span, "class", "tjs-menu-focus-indicator svelte-auto-7526ak");
      attr(li, "class", "tjs-menu-item svelte-auto-7526ak");
      attr(li, "role", "menuitem");
      attr(li, "tabindex", "0");
    },
    m(target2, anchor) {
      insert(target2, li, anchor);
      append(li, span);
      append(li, t);
      if (after_slot) {
        after_slot.m(li, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            li,
            "click",
            /*click_handler_4*/
            ctx[28]
          ),
          listen(
            li,
            "keyup",
            /*keyup_handler_4*/
            ctx[29]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (after_slot) {
        if (after_slot.p && (!current || dirty[0] & /*$$scope*/
        262144)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_after_slot_changes
            ),
            get_after_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(after_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (after_slot)
        after_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$1q(ctx) {
  let t0;
  let nav;
  let ol;
  let t1;
  let t2;
  let t3;
  let t4;
  let tjsfocuswrap;
  let applyStyles_action;
  let nav_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  let if_block0 = (
    /*$$slots*/
    ctx[12].before && create_if_block_5$3(ctx)
  );
  let each_value = (
    /*allItems*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block1 = (
    /*$$slots*/
    ctx[12].after && create_if_block$k(ctx)
  );
  tjsfocuswrap = new TJSFocusWrap({
    props: { elementRoot: (
      /*menuEl*/
      ctx[4]
    ) }
  });
  return {
    c() {
      t0 = space();
      nav = element("nav");
      ol = element("ol");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      create_component(tjsfocuswrap.$$.fragment);
      attr(ol, "class", "tjs-menu-items svelte-auto-7526ak");
      attr(ol, "role", "menu");
      attr(nav, "class", "tjs-menu svelte-auto-7526ak");
      attr(nav, "tabindex", "-1");
    },
    m(target2, anchor) {
      insert(target2, t0, anchor);
      insert(target2, nav, anchor);
      append(nav, ol);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(ol, null);
      }
      append(ol, t1);
      if (if_block0)
        if_block0.m(ol, null);
      append(ol, t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ol, null);
        }
      }
      append(ol, t3);
      if (if_block1)
        if_block1.m(ol, null);
      append(nav, t4);
      mount_component(tjsfocuswrap, nav, null);
      ctx[30](nav);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window,
            "blur",
            /*onWindowBlur*/
            ctx[11]
          ),
          listen(
            document_1.body,
            "pointerdown",
            /*onClose*/
            ctx[7]
          ),
          listen(
            document_1.body,
            "wheel",
            /*onClose*/
            ctx[7]
          ),
          listen(nav, "click", stop_propagation(prevent_default(click_handler_5))),
          listen(nav, "keydown", stop_propagation(
            /*onKeydownMenu*/
            ctx[8]
          )),
          listen(nav, "keyup", stop_propagation(prevent_default(
            /*onKeyupMenu*/
            ctx[9]
          ))),
          listen(nav, "pointerdown", stop_propagation(pointerdown_handler)),
          listen(nav, "pointerup", stop_propagation(pointerup_handler)),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            nav,
            /*styles*/
            ctx[0]
          )),
          action_destroyer(
            /*efx*/
            ctx[1].call(null, nav)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*menu*/
        4)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (
        /*$$slots*/
        ctx2[12].before
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          4096) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(ol, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*onClick, allItems, onKeyupItem*/
      1096) {
        each_value = /*allItems*/
        ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$e(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$e(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ol, t3);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[12].after
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          4096) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$k(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(ol, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const tjsfocuswrap_changes = {};
      if (dirty[0] & /*menuEl*/
      16)
        tjsfocuswrap_changes.elementRoot = /*menuEl*/
        ctx2[4];
      tjsfocuswrap.$set(tjsfocuswrap_changes);
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty[0] & /*styles*/
      1)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block0);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block1);
      transition_in(tjsfocuswrap.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!nav_transition)
          nav_transition = create_bidirectional_transition(
            nav,
            /*animate*/
            ctx[5],
            {},
            true
          );
        nav_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block0);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block1);
      transition_out(tjsfocuswrap.$$.fragment, local);
      if (!nav_transition)
        nav_transition = create_bidirectional_transition(
          nav,
          /*animate*/
          ctx[5],
          {},
          false
        );
      nav_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(nav);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
      destroy_component(tjsfocuswrap);
      ctx[30](null);
      if (detaching && nav_transition)
        nav_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const click_handler_5 = () => null;
const pointerdown_handler = () => null;
const pointerup_handler = () => null;
function instance$1i($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { menu = void 0 } = $$props;
  let { items = void 0 } = $$props;
  let { focusEl = void 0 } = $$props;
  let { offset = void 0 } = $$props;
  let { styles = void 0 } = $$props;
  let { efx = void 0 } = $$props;
  let { keyCode = void 0 } = $$props;
  let { transitionOptions = void 0 } = $$props;
  const s_DEFAULT_OFFSET = { x: 0, y: 0 };
  const s_IGNORE_CLASSES = { ignoreClasses: ["tjs-focus-wrap"] };
  let allItems;
  let menuEl;
  let closed = false;
  let focusOptions = void 0;
  let hasKeyboardFocus = false;
  onMount(() => {
    const activeEl = document.activeElement;
    const parentEl = menuEl.parentElement;
    if (parentEl instanceof HTMLElement && activeEl instanceof HTMLElement && parentEl.contains(activeEl) && activeEl.matches(":focus-visible")) {
      const firstFocusEl = A11yHelper.getFirstFocusableElement(menuEl);
      if (firstFocusEl instanceof HTMLElement && !firstFocusEl.classList.contains("tjs-focus-wrap")) {
        firstFocusEl.focus();
        hasKeyboardFocus = true;
      } else {
        menuEl.focus();
      }
      focusOptions = { focusSource: { focusEl: [activeEl] } };
      if (focusEl) {
        focusOptions.focusSource.focusEl.push(focusEl);
      }
    } else {
      menuEl.focus();
      if (focusEl) {
        focusOptions = { focusSource: { focusEl: [focusEl] } };
      }
    }
  });
  function animate2(node) {
    const result = getStackingContext(node.parentElement);
    if (!(result?.node instanceof HTMLElement)) {
      console.warn(`'TJSMenu.animate warning: Could not locate parent stacking context element.`);
      return;
    }
    const stackingContextRect = result?.node.getBoundingClientRect();
    const stackingContextRight = stackingContextRect.x + stackingContextRect.width;
    const nodeRect = node.getBoundingClientRect();
    const parentRect = node.parentElement.getBoundingClientRect();
    const adjustedOffset = { ...s_DEFAULT_OFFSET, ...offset };
    node.style.top = `${adjustedOffset.y + parentRect.height}px`;
    if (parentRect.x + nodeRect.width < stackingContextRight) {
      node.style.left = `${adjustedOffset.x}px`;
      node.style.removeProperty("right");
    } else {
      node.style.right = `${adjustedOffset.x}px`;
      node.style.removeProperty("left");
    }
    return slideFade(node, transitionOptions);
  }
  function onClick(item2) {
    const callback = item2?.onPress;
    if (typeof callback === "function") {
      callback(item2, focusOptions);
    }
    if (!closed) {
      closed = true;
      menuEl.dispatchEvent(new CustomEvent("close:popup", { bubbles: true, cancelable: true }));
    }
  }
  async function onClose(event) {
    if (event.target === menuEl || menuEl.contains(event.target)) {
      return;
    }
    if (event.target === menuEl.parentElement || menuEl.parentElement.contains(event.target)) {
      return;
    }
    if (!closed) {
      closed = true;
      menuEl.dispatchEvent(new CustomEvent(
        "close:popup",
        {
          bubbles: true,
          cancelable: true,
          detail: { target: event.target }
        }
      ));
    }
  }
  function onKeydownMenu(event) {
    if (event.code === keyCode) {
      event.stopPropagation();
      return;
    }
    switch (event.code) {
      case "Tab":
        event.stopPropagation();
        if (event.shiftKey) {
          const allFocusable = A11yHelper.getFocusableElements(menuEl, s_IGNORE_CLASSES);
          const firstFocusEl = allFocusable.length > 0 ? allFocusable[0] : void 0;
          const lastFocusEl = allFocusable.length > 0 ? allFocusable[allFocusable.length - 1] : void 0;
          if (menuEl === document.activeElement || firstFocusEl === document.activeElement) {
            if (lastFocusEl instanceof HTMLElement && firstFocusEl !== lastFocusEl) {
              lastFocusEl.focus();
            }
            event.preventDefault();
          }
        }
        break;
      default:
        event.stopPropagation();
        break;
    }
  }
  function onKeyupMenu(event) {
    switch (event.code) {
      case "Escape":
        if (!closed) {
          closed = true;
          menuEl.dispatchEvent(new CustomEvent(
            "close:popup",
            {
              bubbles: true,
              cancelable: true,
              detail: { keyboardFocus: hasKeyboardFocus }
            }
          ));
        }
        event.preventDefault();
        event.stopPropagation();
        break;
    }
  }
  function onKeyupItem(event, item2) {
    if (event.code === keyCode) {
      const callback = item2?.onPress;
      if (typeof callback === "function") {
        callback(item2, focusOptions);
      }
      if (!closed) {
        closed = true;
        event.preventDefault();
        event.stopPropagation();
        menuEl.dispatchEvent(new CustomEvent(
          "close:popup",
          {
            bubbles: true,
            cancelable: true,
            detail: { keyboardFocus: hasKeyboardFocus }
          }
        ));
      }
    }
  }
  function onWindowBlur() {
    if (!closed) {
      closed = true;
      menuEl.dispatchEvent(new CustomEvent("close:popup", { bubbles: true, cancelable: true }));
    }
  }
  const click_handler = () => onClick();
  const keyup_handler = (event) => onKeyupItem(event);
  const click_handler_1 = (item2) => onClick(item2);
  const keyup_handler_1 = (item2, event) => onKeyupItem(event, item2);
  const click_handler_2 = (item2) => onClick(item2);
  const keyup_handler_2 = (item2, event) => onKeyupItem(event, item2);
  const click_handler_3 = (item2) => onClick(item2);
  const keyup_handler_3 = (item2, event) => onKeyupItem(event, item2);
  const click_handler_4 = () => onClick();
  const keyup_handler_4 = (event) => onKeyupItem(event);
  function nav_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menuEl = $$value;
      $$invalidate(4, menuEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("menu" in $$props2)
      $$invalidate(2, menu = $$props2.menu);
    if ("items" in $$props2)
      $$invalidate(17, items = $$props2.items);
    if ("focusEl" in $$props2)
      $$invalidate(13, focusEl = $$props2.focusEl);
    if ("offset" in $$props2)
      $$invalidate(14, offset = $$props2.offset);
    if ("styles" in $$props2)
      $$invalidate(0, styles = $$props2.styles);
    if ("efx" in $$props2)
      $$invalidate(1, efx = $$props2.efx);
    if ("keyCode" in $$props2)
      $$invalidate(15, keyCode = $$props2.keyCode);
    if ("transitionOptions" in $$props2)
      $$invalidate(16, transitionOptions = $$props2.transitionOptions);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*menu, items*/
    131076) {
      {
        const tempList = isObject(menu) && isIterable(menu.items) ? menu.items : isIterable(items) ? items : [];
        const tempItems = [];
        let cntr = -1;
        for (const item2 of tempList) {
          cntr++;
          if (!isObject(item2)) {
            throw new TypeError(`TJSMenu error: 'item[${cntr}]' is not an object.`);
          }
          if (typeof item2.condition === "function" && !item2.condition()) {
            continue;
          }
          if (typeof item2.condition === "boolean" && !item2.condition) {
            continue;
          }
          let type;
          if (isSvelteComponent(item2.class)) {
            type = "class";
          } else if (typeof item2.icon === "string") {
            type = "icon";
          } else if (typeof item2.image === "string") {
            type = "image";
          } else if (typeof item2.separator === "string") {
            if (item2.separator !== "hr") {
              throw new Error(`TJSMenu error: 'item[${cntr}]' has unknown separator type; only 'hr' is currently supported.`);
            }
            type = "separator-hr";
          }
          if (type === void 0) {
            throw new TypeError(`TJSMenu error: Unknown type for 'item[${cntr}]'.`);
          }
          tempItems.push({ ...item2, "#type": type });
        }
        $$invalidate(3, allItems = tempItems);
      }
    }
    if ($$self.$$.dirty[0] & /*menu, focusEl*/
    8196) {
      $$invalidate(13, focusEl = isObject(menu) && A11yHelper.isFocusSource(menu.focusEl) ? menu.focusEl : A11yHelper.isFocusSource(focusEl) ? focusEl : void 0);
    }
    if ($$self.$$.dirty[0] & /*menu, offset*/
    16388) {
      $$invalidate(14, offset = isObject(menu) && isObject(menu.offset) ? menu.offset : isObject(offset) ? offset : s_DEFAULT_OFFSET);
    }
    if ($$self.$$.dirty[0] & /*menu, styles*/
    5) {
      $$invalidate(0, styles = isObject(menu) && isObject(menu.styles) ? menu.styles : isObject(styles) ? styles : void 0);
    }
    if ($$self.$$.dirty[0] & /*menu, efx*/
    6) {
      $$invalidate(1, efx = isObject(menu) && typeof menu.efx === "function" ? menu.efx : typeof efx === "function" ? efx : () => {
      });
    }
    if ($$self.$$.dirty[0] & /*menu, keyCode*/
    32772) {
      $$invalidate(15, keyCode = isObject(menu) && typeof menu.keyCode === "string" ? menu.keyCode : typeof keyCode === "string" ? keyCode : "Enter");
    }
    if ($$self.$$.dirty[0] & /*menu, transitionOptions*/
    65540) {
      $$invalidate(16, transitionOptions = isObject(menu) && isObject(menu.transitionOptions) ? menu.transitionOptions : isObject(transitionOptions) ? transitionOptions : { duration: 200, easing: quintOut });
    }
  };
  return [
    styles,
    efx,
    menu,
    allItems,
    menuEl,
    animate2,
    onClick,
    onClose,
    onKeydownMenu,
    onKeyupMenu,
    onKeyupItem,
    onWindowBlur,
    $$slots,
    focusEl,
    offset,
    keyCode,
    transitionOptions,
    items,
    $$scope,
    slots,
    click_handler,
    keyup_handler,
    click_handler_1,
    keyup_handler_1,
    click_handler_2,
    keyup_handler_2,
    click_handler_3,
    keyup_handler_3,
    click_handler_4,
    keyup_handler_4,
    nav_binding
  ];
}
class TJSMenu extends SvelteComponent {
  constructor(options2) {
    super();
    init(
      this,
      options2,
      instance$1i,
      create_fragment$1q,
      safe_not_equal,
      {
        menu: 2,
        items: 17,
        focusEl: 13,
        offset: 14,
        styles: 0,
        efx: 1,
        keyCode: 15,
        transitionOptions: 16
      },
      null,
      [-1, -1]
    );
  }
}
const TJSContextMenuImpl_svelte_svelte_type_style_lang = "";
const SettingEntry_svelte_svelte_type_style_lang = "";
function create_if_block_6$1(ctx) {
  let tjsinput;
  let current;
  tjsinput = new TJSInput({
    props: { input: (
      /*setting*/
      ctx[0].inputData
    ) }
  });
  return {
    c() {
      create_component(tjsinput.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjsinput, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjsinput_changes = {};
      if (dirty & /*setting*/
      1)
        tjsinput_changes.input = /*setting*/
        ctx2[0].inputData;
      tjsinput.$set(tjsinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsinput, detaching);
    }
  };
}
function create_if_block_5$2(ctx) {
  let tjsselect;
  let current;
  tjsselect = new TJSSelect({
    props: { select: (
      /*setting*/
      ctx[0].selectData
    ) }
  });
  return {
    c() {
      create_component(tjsselect.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjsselect, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjsselect_changes = {};
      if (dirty & /*setting*/
      1)
        tjsselect_changes.select = /*setting*/
        ctx2[0].selectData;
      tjsselect.$set(tjsselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsselect, detaching);
    }
  };
}
function create_if_block_4$2(ctx) {
  let input;
  let input_id_value;
  let input_min_value;
  let input_max_value;
  let input_step_value;
  let t0;
  let span;
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      t0 = space();
      span = element("span");
      t1 = text(
        /*$store*/
        ctx[1]
      );
      attr(input, "type", "range");
      attr(input, "id", input_id_value = /*setting*/
      ctx[0].id);
      attr(input, "min", input_min_value = /*setting*/
      ctx[0].range.min);
      attr(input, "max", input_max_value = /*setting*/
      ctx[0].range.max);
      attr(input, "step", input_step_value = /*setting*/
      ctx[0].range.step);
      attr(input, "class", "svelte-auto-ip8xeq");
      attr(span, "class", "range-value svelte-auto-ip8xeq");
    },
    m(target2, anchor) {
      insert(target2, input, anchor);
      set_input_value(
        input,
        /*$store*/
        ctx[1]
      );
      insert(target2, t0, anchor);
      insert(target2, span, anchor);
      append(span, t1);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[5]
          ),
          listen(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*setting*/
      1 && input_id_value !== (input_id_value = /*setting*/
      ctx2[0].id)) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*setting*/
      1 && input_min_value !== (input_min_value = /*setting*/
      ctx2[0].range.min)) {
        attr(input, "min", input_min_value);
      }
      if (dirty & /*setting*/
      1 && input_max_value !== (input_max_value = /*setting*/
      ctx2[0].range.max)) {
        attr(input, "max", input_max_value);
      }
      if (dirty & /*setting*/
      1 && input_step_value !== (input_step_value = /*setting*/
      ctx2[0].range.step)) {
        attr(input, "step", input_step_value);
      }
      if (dirty & /*$store*/
      2) {
        set_input_value(
          input,
          /*$store*/
          ctx2[1]
        );
      }
      if (dirty & /*$store*/
      2)
        set_data(
          t1,
          /*$store*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(span);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_3$5(ctx) {
  let tjsinput;
  let current;
  tjsinput = new TJSInput({
    props: { input: (
      /*setting*/
      ctx[0].inputData
    ) }
  });
  return {
    c() {
      create_component(tjsinput.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjsinput, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjsinput_changes = {};
      if (dirty & /*setting*/
      1)
        tjsinput_changes.input = /*setting*/
        ctx2[0].inputData;
      tjsinput.$set(tjsinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsinput, detaching);
    }
  };
}
function create_if_block_2$8(ctx) {
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "id", input_id_value = /*setting*/
      ctx[0].id);
    },
    m(target2, anchor) {
      insert(target2, input, anchor);
      input.checked = /*$store*/
      ctx[1];
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*setting*/
      1 && input_id_value !== (input_id_value = /*setting*/
      ctx2[0].id)) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*$store*/
      2) {
        input.checked = /*$store*/
        ctx2[1];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$a(ctx) {
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*setting*/
      ctx[0].buttonData
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*onFilePicker*/
    ctx[3]
  );
  return {
    c() {
      create_component(tjsiconbutton.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjsiconbutton, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjsiconbutton_changes = {};
      if (dirty & /*setting*/
      1)
        tjsiconbutton_changes.button = /*setting*/
        ctx2[0].buttonData;
      tjsiconbutton.$set(tjsiconbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsiconbutton, detaching);
    }
  };
}
function create_if_block$j(ctx) {
  let p;
  let t_value = (
    /*setting*/
    ctx[0].hint + ""
  );
  let t;
  return {
    c() {
      p = element("p");
      t = text(t_value);
      attr(p, "class", "hint svelte-auto-ip8xeq");
    },
    m(target2, anchor) {
      insert(target2, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*setting*/
      1 && t_value !== (t_value = /*setting*/
      ctx2[0].hint + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_fragment$1p(ctx) {
  let section2;
  let label;
  let t0_value = (
    /*setting*/
    ctx[0].name + ""
  );
  let t0;
  let label_for_value;
  let t1;
  let div;
  let current_block_type_index;
  let if_block0;
  let t2;
  let t3;
  let current;
  const if_block_creators = [
    create_if_block_2$8,
    create_if_block_3$5,
    create_if_block_4$2,
    create_if_block_5$2,
    create_if_block_6$1
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*setting*/
      ctx2[0].componentType === "checkbox"
    )
      return 0;
    if (
      /*setting*/
      ctx2[0].componentType === "number"
    )
      return 1;
    if (
      /*setting*/
      ctx2[0].componentType === "range"
    )
      return 2;
    if (
      /*setting*/
      ctx2[0].componentType === "select"
    )
      return 3;
    if (
      /*setting*/
      ctx2[0].componentType === "text"
    )
      return 4;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*setting*/
    ctx[0].filePicker && create_if_block_1$a(ctx)
  );
  let if_block2 = (
    /*setting*/
    ctx[0].hint && create_if_block$j(ctx)
  );
  return {
    c() {
      section2 = element("section");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      div = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(label, "for", label_for_value = /*setting*/
      ctx[0].id);
      attr(label, "class", "svelte-auto-ip8xeq");
      attr(div, "class", "svelte-auto-ip8xeq");
      toggle_class(
        div,
        "checkbox",
        /*setting*/
        ctx[0].componentType === "checkbox"
      );
      attr(section2, "class", "tjs-settings-entry svelte-auto-ip8xeq");
    },
    m(target2, anchor) {
      insert(target2, section2, anchor);
      append(section2, label);
      append(label, t0);
      append(section2, t1);
      append(section2, div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      append(section2, t3);
      if (if_block2)
        if_block2.m(section2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*setting*/
      1) && t0_value !== (t0_value = /*setting*/
      ctx2[0].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & /*setting*/
      1 && label_for_value !== (label_for_value = /*setting*/
      ctx2[0].id)) {
        attr(label, "for", label_for_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        } else {
          if_block0 = null;
        }
      }
      if (
        /*setting*/
        ctx2[0].filePicker
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*setting*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$a(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*setting*/
      1) {
        toggle_class(
          div,
          "checkbox",
          /*setting*/
          ctx2[0].componentType === "checkbox"
        );
      }
      if (
        /*setting*/
        ctx2[0].hint
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$j(ctx2);
          if_block2.c();
          if_block2.m(section2, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$1h($$self, $$props, $$invalidate) {
  let $store;
  let { setting = void 0 } = $$props;
  const store = setting.store;
  component_subscribe($$self, store, (value) => $$invalidate(1, $store = value));
  let filePickerApp;
  function onFilePicker() {
    if (filePickerApp) {
      filePickerApp.bringToTop();
      return;
    }
    filePickerApp = new FilePicker({
      type: setting.filePicker,
      current: setting.value,
      callback: (result) => set_store_value(store, $store = result, $store)
    });
    const originalClose = filePickerApp.close;
    filePickerApp.close = async function(options2) {
      await originalClose.call(filePickerApp, options2);
      filePickerApp = void 0;
    };
    filePickerApp.render(true, { focus: true });
  }
  function input_change_handler() {
    $store = this.checked;
    store.set($store);
  }
  function input_change_input_handler() {
    $store = to_number(this.value);
    store.set($store);
  }
  $$self.$$set = ($$props2) => {
    if ("setting" in $$props2)
      $$invalidate(0, setting = $$props2.setting);
  };
  return [
    setting,
    $store,
    store,
    onFilePicker,
    input_change_handler,
    input_change_input_handler
  ];
}
class SettingEntry extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1h, create_fragment$1p, safe_not_equal, { setting: 0 });
  }
}
const TJSSettingsEdit_svelte_svelte_type_style_lang = "";
const get_settings_footer_slot_changes$1 = (dirty) => ({
  settings: dirty & /*settings*/
  1,
  options: dirty & /*options*/
  2
});
const get_settings_footer_slot_context$1 = (ctx) => ({
  settings: (
    /*settings*/
    ctx[0]
  ),
  options: (
    /*options*/
    ctx[1]
  ),
  uiSettings: (
    /*uiSettings*/
    ctx[3]
  )
});
function get_each_context$d(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function get_each_context_2$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  return child_ctx;
}
function get_each_context_3$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  return child_ctx;
}
const get_settings_header_slot_changes$1 = (dirty) => ({
  settings: dirty & /*settings*/
  1,
  options: dirty & /*options*/
  2
});
const get_settings_header_slot_context$1 = (ctx) => ({
  settings: (
    /*settings*/
    ctx[0]
  ),
  options: (
    /*options*/
    ctx[1]
  ),
  uiSettings: (
    /*uiSettings*/
    ctx[3]
  )
});
function create_if_block_2$7(ctx) {
  let section2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_3 = (
    /*uiSettings*/
    ctx[3].topLevel
  );
  const get_key = (ctx2) => (
    /*setting*/
    ctx2[12].key
  );
  for (let i = 0; i < each_value_3.length; i += 1) {
    let child_ctx = get_each_context_3$1(ctx, each_value_3, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_3$1(key, child_ctx));
  }
  return {
    c() {
      section2 = element("section");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(section2, "class", "tjs-settings-section svelte-auto-m1gb0h");
    },
    m(target2, anchor) {
      insert(target2, section2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(section2, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*uiSettings*/
      8) {
        each_value_3 = /*uiSettings*/
        ctx2[3].topLevel;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_3, each_1_lookup, section2, outro_and_destroy_block, create_each_block_3$1, null, get_each_context_3$1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_each_block_3$1(key_1, ctx) {
  let first;
  let settingentry;
  let current;
  settingentry = new SettingEntry({ props: { setting: (
    /*setting*/
    ctx[12]
  ) } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(settingentry.$$.fragment);
      this.first = first;
    },
    m(target2, anchor) {
      insert(target2, first, anchor);
      mount_component(settingentry, target2, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(settingentry, detaching);
    }
  };
}
function create_each_block_2$1(key_1, ctx) {
  let first;
  let settingentry;
  let current;
  settingentry = new SettingEntry({ props: { setting: (
    /*setting*/
    ctx[12]
  ) } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(settingentry.$$.fragment);
      this.first = first;
    },
    m(target2, anchor) {
      insert(target2, first, anchor);
      mount_component(settingentry, target2, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(settingentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(settingentry, detaching);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_2 = (
    /*folder*/
    ctx[9].settings
  );
  const get_key = (ctx2) => (
    /*setting*/
    ctx2[12].key
  );
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2$1(ctx, each_value_2, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_2$1(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target2, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target2, anchor);
        }
      }
      insert(target2, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*uiSettings*/
      8) {
        each_value_2 = /*folder*/
        ctx2[9].settings;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2$1, each_1_anchor, get_each_context_2$1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_1$2(ctx) {
  let section2;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      label: (
        /*folder*/
        ctx[9].label
      ),
      store: (
        /*folder*/
        ctx[9].store
      ),
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      section2 = element("section");
      create_component(tjssvgfolder.$$.fragment);
      attr(section2, "class", "tjs-settings-section svelte-auto-m1gb0h");
    },
    m(target2, anchor) {
      insert(target2, section2, anchor);
      mount_component(tjssvgfolder, section2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope*/
      32) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section2);
      destroy_component(tjssvgfolder);
    }
  };
}
function create_else_block$e(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    typeof /*section*/
    ctx[6].props === "object" ? (
      /*section*/
      ctx[6].props
    ) : {}
  ];
  var switch_value = (
    /*section*/
    ctx[6].class
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & /*uiSettings*/
      8 ? get_spread_update(switch_instance_spread_levels, [
        get_spread_object(typeof /*section*/
        ctx2[6].props === "object" ? (
          /*section*/
          ctx2[6].props
        ) : {})
      ]) : {};
      if (switch_value !== (switch_value = /*section*/
      ctx2[6].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block$i(ctx) {
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*section*/
        ctx[6].folder
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$p],
        default: [create_default_slot$x]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tjssvgfolder.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjssvgfolder, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope*/
      32) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjssvgfolder, detaching);
    }
  };
}
function create_default_slot$x(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    typeof /*section*/
    ctx[6].props === "object" ? (
      /*section*/
      ctx[6].props
    ) : {}
  ];
  var switch_value = (
    /*section*/
    ctx[6].class
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & /*uiSettings*/
      8 ? get_spread_update(switch_instance_spread_levels, [
        get_spread_object(typeof /*section*/
        ctx2[6].props === "object" ? (
          /*section*/
          ctx2[6].props
        ) : {})
      ]) : {};
      if (switch_value !== (switch_value = /*section*/
      ctx2[6].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_1$9(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    typeof /*section*/
    ctx[6]?.folder?.summaryEnd?.props === "object" ? (
      /*section*/
      ctx[6].folder.summaryEnd.props
    ) : {}
  ];
  var switch_value = (
    /*section*/
    ctx[6].folder.summaryEnd.class
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & /*uiSettings*/
      8 ? get_spread_update(switch_instance_spread_levels, [
        get_spread_object(typeof /*section*/
        ctx2[6]?.folder?.summaryEnd?.props === "object" ? (
          /*section*/
          ctx2[6].folder.summaryEnd.props
        ) : {})
      ]) : {};
      if (switch_value !== (switch_value = /*section*/
      ctx2[6].folder.summaryEnd.class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_summary_end_slot$p(ctx) {
  let show_if = isSvelteComponent(
    /*section*/
    ctx[6]?.folder?.summaryEnd?.class
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_1$9(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if (if_block)
        if_block.m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_each_block$d(ctx) {
  let section2;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$i, create_else_block$e];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*section*/
      ctx2[6].folder
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      section2 = element("section");
      if_block.c();
      t = space();
      attr(section2, "class", "tjs-settings-section svelte-auto-m1gb0h");
    },
    m(target2, anchor) {
      insert(target2, section2, anchor);
      if_blocks[current_block_type_index].m(section2, null);
      append(section2, t);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(applyStyles.call(
          null,
          section2,
          /*section*/
          ctx[6].styles
        ));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if_block.p(ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section2);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1o(ctx) {
  let main2;
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let applyStyles_action;
  let current;
  let mounted;
  let dispose;
  const settings_header_slot_template = (
    /*#slots*/
    ctx[4]["settings-header"]
  );
  const settings_header_slot = create_slot(
    settings_header_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_settings_header_slot_context$1
  );
  let if_block = (
    /*uiSettings*/
    ctx[3].topLevel.length && create_if_block_2$7(ctx)
  );
  let each_value_1 = (
    /*uiSettings*/
    ctx[3].folders
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let each_value = (
    /*uiSettings*/
    ctx[3].sections
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const settings_footer_slot_template = (
    /*#slots*/
    ctx[4]["settings-footer"]
  );
  const settings_footer_slot = create_slot(
    settings_footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_settings_footer_slot_context$1
  );
  return {
    c() {
      main2 = element("main");
      if (settings_header_slot)
        settings_header_slot.c();
      t0 = space();
      div = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      if (settings_footer_slot)
        settings_footer_slot.c();
      attr(div, "class", "scrollable svelte-auto-m1gb0h");
      attr(main2, "class", "tjs-settings svelte-auto-m1gb0h");
    },
    m(target2, anchor) {
      insert(target2, main2, anchor);
      if (settings_header_slot) {
        settings_header_slot.m(main2, null);
      }
      append(main2, t0);
      append(main2, div);
      if (if_block)
        if_block.m(div, null);
      append(div, t1);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div, null);
        }
      }
      append(div, t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(main2, t3);
      if (settings_footer_slot) {
        settings_footer_slot.m(main2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(applyScrolltop.call(
            null,
            div,
            /*uiSettings*/
            ctx[3].storeScrollbar
          )),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            main2,
            /*styles*/
            ctx[2]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (settings_header_slot) {
        if (settings_header_slot.p && (!current || dirty & /*$$scope, settings, options*/
        35)) {
          update_slot_base(
            settings_header_slot,
            settings_header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              settings_header_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_settings_header_slot_changes$1
            ),
            get_settings_header_slot_context$1
          );
        }
      }
      if (
        /*uiSettings*/
        ctx2[3].topLevel.length
      )
        if_block.p(ctx2, dirty);
      if (dirty & /*uiSettings*/
      8) {
        each_value_1 = /*uiSettings*/
        ctx2[3].folders;
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_1$2(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(div, t2);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty & /*uiSettings, isSvelteComponent*/
      8) {
        each_value = /*uiSettings*/
        ctx2[3].sections;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$d(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$d(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
      if (settings_footer_slot) {
        if (settings_footer_slot.p && (!current || dirty & /*$$scope, settings, options*/
        35)) {
          update_slot_base(
            settings_footer_slot,
            settings_footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              settings_footer_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_settings_footer_slot_changes$1
            ),
            get_settings_footer_slot_context$1
          );
        }
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      4)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx2[2]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(settings_header_slot, local);
      transition_in(if_block);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(settings_footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(settings_header_slot, local);
      transition_out(if_block);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(settings_footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main2);
      if (settings_header_slot)
        settings_header_slot.d(detaching);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (settings_footer_slot)
        settings_footer_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1g($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { settings = void 0 } = $$props;
  let { options: options2 = void 0 } = $$props;
  let { styles = void 0 } = $$props;
  const uiSettings = settings.uiControl.create(options2);
  onDestroy(() => uiSettings.destroy());
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
    if ("options" in $$props2)
      $$invalidate(1, options2 = $$props2.options);
    if ("styles" in $$props2)
      $$invalidate(2, styles = $$props2.styles);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [settings, options2, styles, uiSettings, slots, $$scope];
}
class TJSSettingsEdit extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1g, create_fragment$1o, safe_not_equal, { settings: 0, options: 1, styles: 2 });
  }
}
const get_settings_header_slot_changes = (dirty) => ({
  settings: dirty & /*settings*/
  1,
  options: dirty & /*options*/
  2,
  uiSettings: dirty & /*uiSettings*/
  64
});
const get_settings_header_slot_context = (ctx) => ({
  slot: "settings-header",
  settings: (
    /*settings*/
    ctx[0]
  ),
  options: (
    /*options*/
    ctx[1]
  ),
  uiSettings: (
    /*uiSettings*/
    ctx[6]
  )
});
const get_settings_footer_slot_changes = (dirty) => ({
  settings: dirty & /*settings*/
  1,
  options: dirty & /*options*/
  2,
  uiSettings: dirty & /*uiSettings*/
  64
});
const get_settings_footer_slot_context = (ctx) => ({
  slot: "settings-footer",
  settings: (
    /*settings*/
    ctx[0]
  ),
  options: (
    /*options*/
    ctx[1]
  ),
  uiSettings: (
    /*uiSettings*/
    ctx[6]
  )
});
function create_else_block$d(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target2, anchor) {
      if (default_slot) {
        default_slot.m(target2, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block$h(ctx) {
  let tjssettingsedit;
  let current;
  tjssettingsedit = new TJSSettingsEdit({
    props: {
      settings: (
        /*settings*/
        ctx[0]
      ),
      options: (
        /*options*/
        ctx[1]
      ),
      $$slots: {
        "settings-footer": [
          create_settings_footer_slot$1,
          ({ uiSettings }) => ({ 6: uiSettings }),
          ({ uiSettings }) => uiSettings ? 64 : 0
        ],
        "settings-header": [
          create_settings_header_slot,
          ({ uiSettings }) => ({ 6: uiSettings }),
          ({ uiSettings }) => uiSettings ? 64 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tjssettingsedit.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjssettingsedit, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjssettingsedit_changes = {};
      if (dirty & /*settings*/
      1)
        tjssettingsedit_changes.settings = /*settings*/
        ctx2[0];
      if (dirty & /*options*/
      2)
        tjssettingsedit_changes.options = /*options*/
        ctx2[1];
      if (dirty & /*$$scope, settings, options, uiSettings*/
      99) {
        tjssettingsedit_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssettingsedit.$set(tjssettingsedit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssettingsedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssettingsedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjssettingsedit, detaching);
    }
  };
}
function create_settings_header_slot(ctx) {
  let current;
  const settings_header_slot_template = (
    /*#slots*/
    ctx[4]["settings-header"]
  );
  const settings_header_slot = create_slot(
    settings_header_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_settings_header_slot_context
  );
  return {
    c() {
      if (settings_header_slot)
        settings_header_slot.c();
    },
    m(target2, anchor) {
      if (settings_header_slot) {
        settings_header_slot.m(target2, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (settings_header_slot) {
        if (settings_header_slot.p && (!current || dirty & /*$$scope, settings, options, uiSettings*/
        99)) {
          update_slot_base(
            settings_header_slot,
            settings_header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              settings_header_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_settings_header_slot_changes
            ),
            get_settings_header_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settings_header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(settings_header_slot, local);
      current = false;
    },
    d(detaching) {
      if (settings_header_slot)
        settings_header_slot.d(detaching);
    }
  };
}
function create_settings_footer_slot$1(ctx) {
  let current;
  const settings_footer_slot_template = (
    /*#slots*/
    ctx[4]["settings-footer"]
  );
  const settings_footer_slot = create_slot(
    settings_footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_settings_footer_slot_context
  );
  return {
    c() {
      if (settings_footer_slot)
        settings_footer_slot.c();
    },
    m(target2, anchor) {
      if (settings_footer_slot) {
        settings_footer_slot.m(target2, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (settings_footer_slot) {
        if (settings_footer_slot.p && (!current || dirty & /*$$scope, settings, options, uiSettings*/
        99)) {
          update_slot_base(
            settings_footer_slot,
            settings_footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              settings_footer_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_settings_footer_slot_changes
            ),
            get_settings_footer_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settings_footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(settings_footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (settings_footer_slot)
        settings_footer_slot.d(detaching);
    }
  };
}
function create_fragment$1n(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$h, create_else_block$d];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$showSettings*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if_blocks[current_block_type_index].m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1f($$self, $$props, $$invalidate) {
  let $showSettings;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { settings = void 0 } = $$props;
  let { options: options2 = void 0 } = $$props;
  const showSettings = settings.uiControl.stores.showSettings;
  component_subscribe($$self, showSettings, (value) => $$invalidate(2, $showSettings = value));
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
    if ("options" in $$props2)
      $$invalidate(1, options2 = $$props2.options);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [settings, options2, $showSettings, showSettings, slots, $$scope];
}
class TJSSettingsSwap extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1f, create_fragment$1n, safe_not_equal, { settings: 0, options: 1 });
  }
}
cssVariables.setProperties({
  // For components w/ transparent background checkered pattern.
  "--tjs-checkerboard-background-dark": "rgb(205, 205, 205)",
  "--tjs-checkerboard-background-10": `url('data:image/svg+xml;utf8,<svg preserveAspectRatio="none"  viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="5" height="5" fill="transparent" /><rect x="5" y="5" width="5" height="5" fill="transparent" /><rect x="5" y="0" width="5" height="5" fill="white" /><rect x="0" y="5" width="5" height="5" fill="white" /></svg>') 0 0 / 10px 10px, var(--tjs-checkerboard-background-dark, rgb(205, 205, 205))`
}, false);
cssVariables.setProperties({
  "--tjs-action-ripple-background": "rgba(0, 0, 0, 0.35)"
}, false);
cssVariables.setProperties({
  "--tjs-icon-button-background-hover": "rgba(0, 0, 0, 0.10)",
  "--tjs-icon-button-background-selected": "rgba(0, 0, 0, 0.20)"
}, false);
{
  const props = FoundryStyles.getProperties('input[type="text"], input[type="number"]');
  if (typeof props === "object") {
    cssVariables.setProperties({
      "--tjs-input-background": "background" in props ? props.background : "rgba(0, 0, 0, 0.05)",
      "--tjs-input-border": "border" in props ? props.border : "1px solid var(--color-border-light-tertiary)",
      "--tjs-input-border-radius": "border-radius" in props ? props["border-radius"] : "3px",
      "--tjs-input-height": "height" in props ? props.height : "var(--form-field-height)",
      "--tjs-input-min-width": "min-width" in props ? props["min-width"] : "20px",
      "--tjs-input-padding": "padding" in props ? props["padding"] : "1px 3px",
      "--tjs-input-width": "width" in props ? props.width : "calc(100% - 2px)",
      // Set default values that are only to be referenced and not set.
      "--_tjs-default-input-height": "height" in props ? props.height : "var(--form-field-height)",
      // Set directly / no lookup:
      "--tjs-input-border-color": "var(--color-border-light-tertiary)"
    }, false);
  }
}
cssVariables.setProperties({
  // `popup` is for components that are slightly elevated, but connected to an application;
  // see: TJSMenu / TJSContextMenu / TJSColordPicker
  "--tjs-default-popup-background": "var(--color-text-dark-header, #23221d)",
  "--tjs-default-popup-border": "1px solid var(--color-border-dark, #000)",
  "--tjs-default-popup-box-shadow": "0 0 2px var(--color-shadow-dark, #000)",
  "--tjs-default-popup-primary-color": "var(--color-text-light-primary, #b5b3a4)",
  "--tjs-default-popup-highlight-color": "var(--color-text-light-highlight, #f0f0e0)",
  // `popover` is for components that are elevated and independent; see: TJSContextMenu
  "--tjs-default-popover-border": "1px solid var(--color-border-dark, #000)",
  "--tjs-default-popover-box-shadow": "0 0 10px var(--color-shadow-dark, #000)"
}, false);
Hooks.on("PopOut:loading", (app, popout) => {
  if (app instanceof SvelteApplication) {
    popout.document.addEventListener("DOMContentLoaded", () => cssVariables.clone(popout.document));
  }
});
const CustomPicker_svelte_svelte_type_style_lang = "";
function create_fragment$1m(ctx) {
  let table;
  let tr;
  let td0;
  let div;
  let label_1;
  let t1;
  let input0;
  let input0_id_value;
  let t2;
  let td1;
  let input1;
  let input1_disabled_value;
  let td1_class_value;
  let t3;
  let td2;
  let i0;
  let t4;
  let i1;
  let td2_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      table = element("table");
      tr = element("tr");
      td0 = element("td");
      div = element("div");
      label_1 = element("label");
      label_1.textContent = `${/*label*/
      ctx[7]}`;
      t1 = space();
      input0 = element("input");
      t2 = space();
      td1 = element("td");
      input1 = element("input");
      t3 = space();
      td2 = element("td");
      i0 = element("i");
      t4 = space();
      i1 = element("i");
      attr(label_1, "for", "");
      attr(label_1, "class", "aa-customFont svelte-auto-aftvs4");
      attr(input0, "type", "checkbox");
      attr(input0, "id", input0_id_value = /*section*/
      ctx[0] + " " + /*section02*/
      ctx[1] + " " + /*animation*/
      ctx[4]._data.id);
      attr(div, "class", "flexrow");
      set_style(td0, "width", "6em");
      set_style(td0, "border", "none");
      input1.disabled = input1_disabled_value = !/*isCustom*/
      ctx[3];
      attr(input1, "type", "text");
      set_style(input1, "font-weight", "normal");
      set_style(input1, "font-size", "small");
      set_style(input1, "border-radius", "5px");
      set_style(input1, "text-align", "left");
      set_style(input1, "width", "100%");
      set_style(input1, "height", "1.75em");
      set_style(td1, "border", "none");
      attr(td1, "class", td1_class_value = /*isCustom*/
      ctx[3] ? "" : "aa-disableOpacity");
      attr(i0, "class", "fas fa-file-import");
      attr(i0, "title", "File Picker");
      set_style(i0, "font-size", "1.5em");
      attr(i0, "role", "presentation");
      attr(i1, "class", "fas fa-database");
      attr(i1, "title", "Sequencer Database Viewer");
      set_style(i1, "font-size", "1.5em");
      set_style(i1, "margin-left", "5px");
      attr(i1, "role", "presentation");
      set_style(td2, "width", "4em");
      set_style(td2, "border", "none");
      attr(td2, "class", td2_class_value = /*isCustom*/
      ctx[3] ? "" : "aa-disableOpacity");
      attr(table, "class", "c svelte-auto-aftvs4");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr);
      append(tr, td0);
      append(td0, div);
      append(div, label_1);
      append(div, t1);
      append(div, input0);
      input0.checked = /*$animation*/
      ctx[2][
        /*section*/
        ctx[0]
      ][
        /*section02*/
        ctx[1]
      ].enableCustom;
      append(tr, t2);
      append(tr, td1);
      append(td1, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[2][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].customPath
      );
      append(tr, t3);
      append(tr, td2);
      append(td2, i0);
      append(td2, t4);
      append(td2, i1);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[9]
          ),
          listen(
            input0,
            "change",
            /*change_handler*/
            ctx[10]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[11]
          ),
          listen(
            input1,
            "change",
            /*change_handler_1*/
            ctx[12]
          ),
          listen(i0, "click", prevent_default(
            /*click_handler*/
            ctx[13]
          )),
          listen(i1, "click", prevent_default(
            /*click_handler_1*/
            ctx[14]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*section, section02*/
      3 && input0_id_value !== (input0_id_value = /*section*/
      ctx2[0] + " " + /*section02*/
      ctx2[1] + " " + /*animation*/
      ctx2[4]._data.id)) {
        attr(input0, "id", input0_id_value);
      }
      if (dirty & /*$animation, section, section02*/
      7) {
        input0.checked = /*$animation*/
        ctx2[2][
          /*section*/
          ctx2[0]
        ][
          /*section02*/
          ctx2[1]
        ].enableCustom;
      }
      if (dirty & /*isCustom*/
      8 && input1_disabled_value !== (input1_disabled_value = !/*isCustom*/
      ctx2[3])) {
        input1.disabled = input1_disabled_value;
      }
      if (dirty & /*$animation, section, section02*/
      7 && input1.value !== /*$animation*/
      ctx2[2][
        /*section*/
        ctx2[0]
      ][
        /*section02*/
        ctx2[1]
      ].customPath) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[2][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].customPath
        );
      }
      if (dirty & /*isCustom*/
      8 && td1_class_value !== (td1_class_value = /*isCustom*/
      ctx2[3] ? "" : "aa-disableOpacity")) {
        attr(td1, "class", td1_class_value);
      }
      if (dirty & /*isCustom*/
      8 && td2_class_value !== (td2_class_value = /*isCustom*/
      ctx2[3] ? "" : "aa-disableOpacity")) {
        attr(td2, "class", td2_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(table);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1e($$self, $$props, $$invalidate) {
  let isCustom;
  let $animation;
  let { section: section2 } = $$props;
  let { section02 } = $$props;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(2, $animation = value));
  const label = game.i18n.localize("autoanimations.menus.custom");
  function removeMetaData() {
    delete $animation.metaData;
  }
  function input0_change_handler() {
    $animation[section2][section02].enableCustom = this.checked;
    animation.set($animation);
  }
  const change_handler = () => removeMetaData();
  function input1_input_handler() {
    $animation[section2][section02].customPath = this.value;
    animation.set($animation);
  }
  const change_handler_1 = () => removeMetaData();
  const click_handler = () => category.selectCustom(section2, section02, idx);
  const click_handler_1 = () => category.openSequencerViewer();
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
    if ("section02" in $$props2)
      $$invalidate(1, section02 = $$props2.section02);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation, section, section02*/
    7) {
      $$invalidate(3, isCustom = $animation[section2][section02].enableCustom);
    }
  };
  return [
    section2,
    section02,
    $animation,
    isCustom,
    animation,
    category,
    idx,
    label,
    removeMetaData,
    input0_change_handler,
    change_handler,
    input1_input_handler,
    change_handler_1,
    click_handler,
    click_handler_1
  ];
}
class CustomPicker extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1e, create_fragment$1m, safe_not_equal, { section: 0, section02: 1 });
  }
}
const SectionHeader_svelte_svelte_type_style_lang = "";
function create_fragment$1l(ctx) {
  let div1;
  let div0;
  let label;
  let t;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      label = element("label");
      t = text(
        /*title*/
        ctx[0]
      );
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-1rha2ro");
      attr(div0, "class", "flexcol");
      attr(div1, "class", "aa-SectionHeader svelte-auto-1rha2ro");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, div0);
      append(div0, label);
      append(label, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*title*/
      1)
        set_data(
          t,
          /*title*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function instance$1d($$self, $$props, $$invalidate) {
  let { title: title2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title2 = $$props2.title);
  };
  return [title2];
}
class SectionHeader extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1d, create_fragment$1l, safe_not_equal, { title: 0 });
  }
}
function get_each_context$c(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i][0];
  child_ctx[22] = list[i][1];
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i][0];
  child_ctx[22] = list[i][1];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i][0];
  child_ctx[22] = list[i][1];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i][0];
  child_ctx[22] = list[i][1];
  return child_ctx;
}
function create_each_block_3(ctx) {
  let option;
  let t_value = (
    /*name*/
    ctx[22] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*key*/
      ctx[21];
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation, section, section02*/
      11 && t_value !== (t_value = /*name*/
      ctx2[22] + ""))
        set_data(t, t_value);
      if (dirty & /*$animation, section, section02, category*/
      523 && option_value_value !== (option_value_value = /*key*/
      ctx2[21])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block_2(ctx) {
  let option;
  let t_value = (
    /*name*/
    ctx[22] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*key*/
      ctx[21];
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*dbSection, menuType*/
      192 && t_value !== (t_value = /*name*/
      ctx2[22] + ""))
        set_data(t, t_value);
      if (dirty & /*dbSection, menuType*/
      192 && option_value_value !== (option_value_value = /*key*/
      ctx2[21])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block_1$1(ctx) {
  let option;
  let t_value = (
    /*name*/
    ctx[22] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*key*/
      ctx[21];
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*dbSection, menuType, anim*/
      224 && t_value !== (t_value = /*name*/
      ctx2[22] + ""))
        set_data(t, t_value);
      if (dirty & /*dbSection, menuType, anim*/
      224 && option_value_value !== (option_value_value = /*key*/
      ctx2[21])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block$c(ctx) {
  let option;
  let t_value = (
    /*name*/
    ctx[22] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*key*/
      ctx[21];
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*dbSection, menuType, anim, variant*/
      240 && t_value !== (t_value = /*name*/
      ctx2[22] + ""))
        set_data(t, t_value);
      if (dirty & /*dbSection, menuType, anim, variant*/
      240 && option_value_value !== (option_value_value = /*key*/
      ctx2[21])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$1k(ctx) {
  let sectionheader;
  let t0;
  let div8;
  let table;
  let tr0;
  let td0;
  let t1;
  let td1;
  let div0;
  let label0;
  let t3;
  let div1;
  let select0;
  let t4;
  let td2;
  let t5;
  let tr1;
  let td3;
  let div2;
  let label1;
  let t7;
  let div3;
  let select1;
  let t8;
  let td4;
  let div4;
  let label2;
  let t10;
  let div5;
  let select2;
  let t11;
  let td5;
  let div6;
  let label3;
  let t13;
  let div7;
  let select3;
  let table_class_value;
  let t14;
  let custompicker;
  let current;
  let mounted;
  let dispose;
  sectionheader = new SectionHeader({ props: { title: (
    /*title*/
    ctx[2]
  ) } });
  let each_value_3 = (
    /*category*/
    ctx[9].typeMenu[
      /*$animation*/
      ctx[3][
        /*section*/
        ctx[0]
      ][
        /*section02*/
        ctx[1]
      ].dbSection
    ] ?? []
  );
  let each_blocks_3 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_3[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_2 = (
    /*category*/
    ctx[9].animationMenu[
      /*dbSection*/
      ctx[7]
    ]?.[
      /*menuType*/
      ctx[6]
    ] ?? []
  );
  let each_blocks_2 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value_1 = (
    /*category*/
    ctx[9].variantMenu[
      /*dbSection*/
      ctx[7]
    ]?.[
      /*menuType*/
      ctx[6]
    ]?.[
      /*anim*/
      ctx[5]
    ] ?? []
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
  }
  let each_value = (
    /*category*/
    ctx[9].colorMenu[
      /*dbSection*/
      ctx[7]
    ]?.[
      /*menuType*/
      ctx[6]
    ]?.[
      /*anim*/
      ctx[5]
    ]?.[
      /*variant*/
      ctx[4]
    ] ?? []
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
  }
  custompicker = new CustomPicker({
    props: {
      section: (
        /*section*/
        ctx[0]
      ),
      section02: (
        /*section02*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(sectionheader.$$.fragment);
      t0 = space();
      div8 = element("div");
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      t1 = space();
      td1 = element("td");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.type")}`;
      t3 = space();
      div1 = element("div");
      select0 = element("select");
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        each_blocks_3[i].c();
      }
      t4 = space();
      td2 = element("td");
      t5 = space();
      tr1 = element("tr");
      td3 = element("td");
      div2 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.animation")}`;
      t7 = space();
      div3 = element("div");
      select1 = element("select");
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].c();
      }
      t8 = space();
      td4 = element("td");
      div4 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.variant")}`;
      t10 = space();
      div5 = element("div");
      select2 = element("select");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t11 = space();
      td5 = element("td");
      div6 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.color")}`;
      t13 = space();
      div7 = element("div");
      select3 = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t14 = space();
      create_component(custompicker.$$.fragment);
      attr(label0, "for", "");
      if (
        /*$animation*/
        ctx[3][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].menuType === void 0
      )
        add_render_callback(() => (
          /*select0_change_handler*/
          ctx[13].call(select0)
        ));
      attr(div1, "class", "flexcol");
      attr(label1, "for", "");
      if (
        /*$animation*/
        ctx[3][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].animation === void 0
      )
        add_render_callback(() => (
          /*select1_change_handler*/
          ctx[15].call(select1)
        ));
      attr(div3, "class", "flexcol");
      attr(label2, "for", "");
      if (
        /*$animation*/
        ctx[3][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].variant === void 0
      )
        add_render_callback(() => (
          /*select2_change_handler*/
          ctx[17].call(select2)
        ));
      attr(div5, "class", "flexcol");
      attr(label3, "for", "");
      if (
        /*$animation*/
        ctx[3][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].color === void 0
      )
        add_render_callback(() => (
          /*select3_change_handler*/
          ctx[19].call(select3)
        ));
      attr(div7, "class", "flexcol");
      attr(table, "class", table_class_value = "aaMenu " + /*$animation*/
      (ctx[3][
        /*section*/
        ctx[0]
      ][
        /*section02*/
        ctx[1]
      ].enableCustom ? "aa-disableOpacity" : ""));
      attr(div8, "class", "aaSelect");
    },
    m(target2, anchor) {
      mount_component(sectionheader, target2, anchor);
      insert(target2, t0, anchor);
      insert(target2, div8, anchor);
      append(div8, table);
      append(table, tr0);
      append(tr0, td0);
      append(tr0, t1);
      append(tr0, td1);
      append(td1, div0);
      append(div0, label0);
      append(td1, t3);
      append(td1, div1);
      append(div1, select0);
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        if (each_blocks_3[i]) {
          each_blocks_3[i].m(select0, null);
        }
      }
      select_option(
        select0,
        /*$animation*/
        ctx[3][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].menuType,
        true
      );
      append(tr0, t4);
      append(tr0, td2);
      append(table, t5);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div2);
      append(div2, label1);
      append(td3, t7);
      append(td3, div3);
      append(div3, select1);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        if (each_blocks_2[i]) {
          each_blocks_2[i].m(select1, null);
        }
      }
      select_option(
        select1,
        /*$animation*/
        ctx[3][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].animation,
        true
      );
      append(tr1, t8);
      append(tr1, td4);
      append(td4, div4);
      append(div4, label2);
      append(td4, t10);
      append(td4, div5);
      append(div5, select2);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(select2, null);
        }
      }
      select_option(
        select2,
        /*$animation*/
        ctx[3][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].variant,
        true
      );
      append(tr1, t11);
      append(tr1, td5);
      append(td5, div6);
      append(div6, label3);
      append(td5, t13);
      append(td5, div7);
      append(div7, select3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select3, null);
        }
      }
      select_option(
        select3,
        /*$animation*/
        ctx[3][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].color,
        true
      );
      insert(target2, t14, anchor);
      mount_component(custompicker, target2, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select0,
            "change",
            /*select0_change_handler*/
            ctx[13]
          ),
          listen(
            select0,
            "change",
            /*change_handler*/
            ctx[14]
          ),
          listen(
            select1,
            "change",
            /*select1_change_handler*/
            ctx[15]
          ),
          listen(
            select1,
            "change",
            /*change_handler_1*/
            ctx[16]
          ),
          listen(
            select2,
            "change",
            /*select2_change_handler*/
            ctx[17]
          ),
          listen(
            select2,
            "change",
            /*change_handler_2*/
            ctx[18]
          ),
          listen(
            select3,
            "change",
            /*select3_change_handler*/
            ctx[19]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const sectionheader_changes = {};
      if (dirty & /*title*/
      4)
        sectionheader_changes.title = /*title*/
        ctx2[2];
      sectionheader.$set(sectionheader_changes);
      if (dirty & /*category, $animation, section, section02*/
      523) {
        each_value_3 = /*category*/
        ctx2[9].typeMenu[
          /*$animation*/
          ctx2[3][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].dbSection
        ] ?? [];
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_3[i]) {
            each_blocks_3[i].p(child_ctx, dirty);
          } else {
            each_blocks_3[i] = create_each_block_3(child_ctx);
            each_blocks_3[i].c();
            each_blocks_3[i].m(select0, null);
          }
        }
        for (; i < each_blocks_3.length; i += 1) {
          each_blocks_3[i].d(1);
        }
        each_blocks_3.length = each_value_3.length;
      }
      if (dirty & /*$animation, section, section02, category*/
      523) {
        select_option(
          select0,
          /*$animation*/
          ctx2[3][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].menuType
        );
      }
      if (dirty & /*category, dbSection, menuType*/
      704) {
        each_value_2 = /*category*/
        ctx2[9].animationMenu[
          /*dbSection*/
          ctx2[7]
        ]?.[
          /*menuType*/
          ctx2[6]
        ] ?? [];
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_2[i]) {
            each_blocks_2[i].p(child_ctx, dirty);
          } else {
            each_blocks_2[i] = create_each_block_2(child_ctx);
            each_blocks_2[i].c();
            each_blocks_2[i].m(select1, null);
          }
        }
        for (; i < each_blocks_2.length; i += 1) {
          each_blocks_2[i].d(1);
        }
        each_blocks_2.length = each_value_2.length;
      }
      if (dirty & /*$animation, section, section02, category*/
      523) {
        select_option(
          select1,
          /*$animation*/
          ctx2[3][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].animation
        );
      }
      if (dirty & /*category, dbSection, menuType, anim*/
      736) {
        each_value_1 = /*category*/
        ctx2[9].variantMenu[
          /*dbSection*/
          ctx2[7]
        ]?.[
          /*menuType*/
          ctx2[6]
        ]?.[
          /*anim*/
          ctx2[5]
        ] ?? [];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1$1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(select2, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*$animation, section, section02, category*/
      523) {
        select_option(
          select2,
          /*$animation*/
          ctx2[3][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].variant
        );
      }
      if (dirty & /*category, dbSection, menuType, anim, variant*/
      752) {
        each_value = /*category*/
        ctx2[9].colorMenu[
          /*dbSection*/
          ctx2[7]
        ]?.[
          /*menuType*/
          ctx2[6]
        ]?.[
          /*anim*/
          ctx2[5]
        ]?.[
          /*variant*/
          ctx2[4]
        ] ?? [];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$c(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$c(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select3, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$animation, section, section02, category*/
      523) {
        select_option(
          select3,
          /*$animation*/
          ctx2[3][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].color
        );
      }
      if (!current || dirty & /*$animation, section, section02, category*/
      523 && table_class_value !== (table_class_value = "aaMenu " + /*$animation*/
      (ctx2[3][
        /*section*/
        ctx2[0]
      ][
        /*section02*/
        ctx2[1]
      ].enableCustom ? "aa-disableOpacity" : ""))) {
        attr(table, "class", table_class_value);
      }
      const custompicker_changes = {};
      if (dirty & /*section*/
      1)
        custompicker_changes.section = /*section*/
        ctx2[0];
      if (dirty & /*section02*/
      2)
        custompicker_changes.section02 = /*section02*/
        ctx2[1];
      custompicker.$set(custompicker_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sectionheader.$$.fragment, local);
      transition_in(custompicker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sectionheader.$$.fragment, local);
      transition_out(custompicker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sectionheader, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div8);
      destroy_each(each_blocks_3, detaching);
      destroy_each(each_blocks_2, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t14);
      destroy_component(custompicker, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1c($$self, $$props, $$invalidate) {
  let dbSection;
  let menuType;
  let anim;
  let variant;
  let $animation;
  let { section: section2 } = $$props;
  let { section02 = "video" } = $$props;
  let { title: title2 } = $$props;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(3, $animation = value));
  function typeUpdate() {
    set_store_value(animation, $animation[section2][section02].animation = category.animationMenu[$animation[section2][section02].dbSection][$animation[section2][section02].menuType][0][0], $animation);
    set_store_value(animation, $animation[section2][section02].variant = category.variantMenu[$animation[section2][section02].dbSection][$animation[section2][section02].menuType][$animation[section2][section02].animation][0][0], $animation);
    set_store_value(animation, $animation[section2][section02].color = category.colorMenu[$animation[section2][section02].dbSection][$animation[section2][section02].menuType][$animation[section2][section02].animation][$animation[section2][section02].variant][0][0], $animation);
  }
  function animationUpdate() {
    set_store_value(animation, $animation[section2][section02].variant = category.variantMenu[$animation[section2][section02].dbSection][$animation[section2][section02].menuType][$animation[section2][section02].animation][0][0], $animation);
    set_store_value(animation, $animation[section2][section02].color = category.colorMenu[$animation[section2][section02].dbSection][$animation[section2][section02].menuType][$animation[section2][section02].animation][$animation[section2][section02].variant][0][0], $animation);
  }
  function variantUpdate() {
    set_store_value(animation, $animation[section2][section02].color = category.colorMenu[$animation[section2][section02].dbSection][$animation[section2][section02].menuType][$animation[section2][section02].animation][$animation[section2][section02].variant][0][0], $animation);
  }
  function select0_change_handler() {
    $animation[section2][section02].menuType = select_value(this);
    animation.set($animation);
    $$invalidate(9, category);
    $$invalidate(0, section2);
    $$invalidate(1, section02);
  }
  const change_handler = async () => (
    //await category.menuTypeChange(section, idx, section02, dbSection)
    typeUpdate()
  );
  function select1_change_handler() {
    $animation[section2][section02].animation = select_value(this);
    animation.set($animation);
    $$invalidate(9, category);
    $$invalidate(0, section2);
    $$invalidate(1, section02);
  }
  const change_handler_1 = async () => (
    //await category.animationChange(section, idx, section02, dbSection)
    animationUpdate()
  );
  function select2_change_handler() {
    $animation[section2][section02].variant = select_value(this);
    animation.set($animation);
    $$invalidate(9, category);
    $$invalidate(0, section2);
    $$invalidate(1, section02);
  }
  const change_handler_2 = async () => (
    //await category.variantChange(section, idx, section02, dbSection)
    variantUpdate()
  );
  function select3_change_handler() {
    $animation[section2][section02].color = select_value(this);
    animation.set($animation);
    $$invalidate(9, category);
    $$invalidate(0, section2);
    $$invalidate(1, section02);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
    if ("section02" in $$props2)
      $$invalidate(1, section02 = $$props2.section02);
    if ("title" in $$props2)
      $$invalidate(2, title2 = $$props2.title);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation, section, section02*/
    11) {
      $$invalidate(7, dbSection = $animation[section2][section02].dbSection);
    }
    if ($$self.$$.dirty & /*$animation, section, section02*/
    11) {
      $$invalidate(6, menuType = $animation[section2][section02].menuType);
    }
    if ($$self.$$.dirty & /*$animation, section, section02*/
    11) {
      $$invalidate(5, anim = $animation[section2][section02].animation);
    }
    if ($$self.$$.dirty & /*$animation, section, section02*/
    11) {
      $$invalidate(4, variant = $animation[section2][section02].variant);
    }
  };
  return [
    section2,
    section02,
    title2,
    $animation,
    variant,
    anim,
    menuType,
    dbSection,
    animation,
    category,
    typeUpdate,
    animationUpdate,
    variantUpdate,
    select0_change_handler,
    change_handler,
    select1_change_handler,
    change_handler_1,
    select2_change_handler,
    change_handler_2,
    select3_change_handler
  ];
}
class VideoSelect extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1c, create_fragment$1k, safe_not_equal, { section: 0, section02: 1, title: 2 });
  }
}
function create_fragment$1j(ctx) {
  let div2;
  let div0;
  let label_1;
  let t0;
  let t1;
  let div1;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[2]
      );
      t1 = space();
      div1 = element("div");
      input = element("input");
      attr(label_1, "for", "");
      attr(input, "type", "number");
      attr(
        input,
        "placeholder",
        /*placeholder*/
        ctx[4]
      );
      attr(
        input,
        "step",
        /*step*/
        ctx[5]
      );
      attr(
        div2,
        "class",
        /*isDisabled*/
        ctx[3]
      );
    },
    m(target2, anchor) {
      insert(target2, div2, anchor);
      append(div2, div0);
      append(div0, label_1);
      append(label_1, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, input);
      set_input_value(
        input,
        /*$animation*/
        ctx[6][
          /*section*/
          ctx[0]
        ].options[
          /*field*/
          ctx[1]
        ]
      );
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*label*/
      4)
        set_data(
          t0,
          /*label*/
          ctx2[2]
        );
      if (dirty & /*placeholder*/
      16) {
        attr(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[4]
        );
      }
      if (dirty & /*step*/
      32) {
        attr(
          input,
          "step",
          /*step*/
          ctx2[5]
        );
      }
      if (dirty & /*$animation, section, field*/
      67 && to_number(input.value) !== /*$animation*/
      ctx2[6][
        /*section*/
        ctx2[0]
      ].options[
        /*field*/
        ctx2[1]
      ]) {
        set_input_value(
          input,
          /*$animation*/
          ctx2[6][
            /*section*/
            ctx2[0]
          ].options[
            /*field*/
            ctx2[1]
          ]
        );
      }
      if (dirty & /*isDisabled*/
      8) {
        attr(
          div2,
          "class",
          /*isDisabled*/
          ctx2[3]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      dispose();
    }
  };
}
function instance$1b($$self, $$props, $$invalidate) {
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(6, $animation = value));
  let { section: section2 = "primary" } = $$props;
  let { field } = $$props;
  let { label } = $$props;
  let { isDisabled = "" } = $$props;
  let { placeholder = 1 } = $$props;
  let { step = 1 } = $$props;
  function input_input_handler() {
    $animation[section2].options[field] = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("isDisabled" in $$props2)
      $$invalidate(3, isDisabled = $$props2.isDisabled);
    if ("placeholder" in $$props2)
      $$invalidate(4, placeholder = $$props2.placeholder);
    if ("step" in $$props2)
      $$invalidate(5, step = $$props2.step);
  };
  return [
    section2,
    field,
    label,
    isDisabled,
    placeholder,
    step,
    $animation,
    animation,
    input_input_handler
  ];
}
class NumberInput extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1b, create_fragment$1j, safe_not_equal, {
      section: 0,
      field: 1,
      label: 2,
      isDisabled: 3,
      placeholder: 4,
      step: 5
    });
  }
}
const Elevation_svelte_svelte_type_style_lang$1 = "";
function create_fragment$1i(ctx) {
  let div2;
  let div0;
  let label0;
  let t0;
  let label0_for_value;
  let label0_class_value;
  let t1;
  let input0;
  let input0_id_value;
  let t2;
  let label1;
  let t4;
  let div1;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      t0 = text("ABS");
      t1 = space();
      input0 = element("input");
      t2 = space();
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.elevation")}`;
      t4 = space();
      div1 = element("div");
      input1 = element("input");
      attr(label0, "for", label0_for_value = "Relative " + /*section*/
      ctx[0] + " " + /*animation*/
      ctx[3]._data.id);
      set_style(label0, "font-size", "10px");
      attr(label0, "class", label0_class_value = "aaLabelBorder " + /*isAbsolute*/
      (ctx[2] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv");
      attr(input0, "id", input0_id_value = "Relative " + /*section*/
      ctx[0] + " " + /*animation*/
      ctx[3]._data.id);
      attr(input0, "type", "checkbox");
      set_style(input0, "display", "none");
      attr(label1, "for", "");
      set_style(label1, "font-size", "13px");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "1000");
      attr(input1, "step", "1");
    },
    m(target2, anchor) {
      insert(target2, div2, anchor);
      append(div2, div0);
      append(div0, label0);
      append(label0, t0);
      append(div0, t1);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[1][
        /*section*/
        ctx[0]
      ].options.isAbsolute;
      append(div0, t2);
      append(div0, label1);
      append(div2, t4);
      append(div2, div1);
      append(div1, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[1][
          /*section*/
          ctx[0]
        ].options.elevation
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[4]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*section*/
      1 && label0_for_value !== (label0_for_value = "Relative " + /*section*/
      ctx2[0] + " " + /*animation*/
      ctx2[3]._data.id)) {
        attr(label0, "for", label0_for_value);
      }
      if (dirty & /*isAbsolute*/
      4 && label0_class_value !== (label0_class_value = "aaLabelBorder " + /*isAbsolute*/
      (ctx2[2] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv")) {
        attr(label0, "class", label0_class_value);
      }
      if (dirty & /*section*/
      1 && input0_id_value !== (input0_id_value = "Relative " + /*section*/
      ctx2[0] + " " + /*animation*/
      ctx2[3]._data.id)) {
        attr(input0, "id", input0_id_value);
      }
      if (dirty & /*$animation, section*/
      3) {
        input0.checked = /*$animation*/
        ctx2[1][
          /*section*/
          ctx2[0]
        ].options.isAbsolute;
      }
      if (dirty & /*$animation, section*/
      3 && to_number(input1.value) !== /*$animation*/
      ctx2[1][
        /*section*/
        ctx2[0]
      ].options.elevation) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[1][
            /*section*/
            ctx2[0]
          ].options.elevation
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1a($$self, $$props, $$invalidate) {
  let isAbsolute;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(1, $animation = value));
  let { section: section2 = "primary" } = $$props;
  function input0_change_handler() {
    $animation[section2].options.isAbsolute = this.checked;
    animation.set($animation);
  }
  function input1_input_handler() {
    $animation[section2].options.elevation = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation, section*/
    3) {
      $$invalidate(2, isAbsolute = $animation[section2].options.isAbsolute);
    }
  };
  return [
    section2,
    $animation,
    isAbsolute,
    animation,
    input0_change_handler,
    input1_input_handler
  ];
}
let Elevation$1 = class Elevation2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1a, create_fragment$1i, safe_not_equal, { section: 0 });
  }
};
function create_fragment$1h(ctx) {
  let div1;
  let label_1;
  let t0;
  let t1;
  let div0;
  let input0;
  let t2;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[6]
      );
      t1 = space();
      div0 = element("div");
      input0 = element("input");
      t2 = space();
      input1 = element("input");
      attr(label_1, "for", "");
      attr(input0, "type", "number");
      attr(
        input0,
        "placeholder",
        /*placeDefault*/
        ctx[5]
      );
      attr(
        input0,
        "min",
        /*min*/
        ctx[2]
      );
      attr(
        input0,
        "max",
        /*max*/
        ctx[3]
      );
      attr(
        input0,
        "step",
        /*step*/
        ctx[4]
      );
      set_style(input1, "border", "none");
      set_style(input1, "background", "none");
      set_style(input1, "margin-left", "3px");
      attr(input1, "type", "range");
      attr(
        input1,
        "min",
        /*min*/
        ctx[2]
      );
      attr(
        input1,
        "max",
        /*max*/
        ctx[3]
      );
      attr(
        input1,
        "step",
        /*step*/
        ctx[4]
      );
      set_style(div0, "display", "flex");
      set_style(div0, "margin-right", "1.5em");
      set_style(div0, "margin-left", "1.5em");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label_1);
      append(label_1, t0);
      append(div1, t1);
      append(div1, div0);
      append(div0, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[7][
          /*section*/
          ctx[0]
        ].options[
          /*field*/
          ctx[1]
        ]
      );
      append(div0, t2);
      append(div0, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[7][
          /*section*/
          ctx[0]
        ].options[
          /*field*/
          ctx[1]
        ]
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[9]
          ),
          listen(
            input1,
            "change",
            /*input1_change_input_handler*/
            ctx[10]
          ),
          listen(
            input1,
            "input",
            /*input1_change_input_handler*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*label*/
      64)
        set_data(
          t0,
          /*label*/
          ctx2[6]
        );
      if (dirty & /*placeDefault*/
      32) {
        attr(
          input0,
          "placeholder",
          /*placeDefault*/
          ctx2[5]
        );
      }
      if (dirty & /*min*/
      4) {
        attr(
          input0,
          "min",
          /*min*/
          ctx2[2]
        );
      }
      if (dirty & /*max*/
      8) {
        attr(
          input0,
          "max",
          /*max*/
          ctx2[3]
        );
      }
      if (dirty & /*step*/
      16) {
        attr(
          input0,
          "step",
          /*step*/
          ctx2[4]
        );
      }
      if (dirty & /*$animation, section, field*/
      131 && to_number(input0.value) !== /*$animation*/
      ctx2[7][
        /*section*/
        ctx2[0]
      ].options[
        /*field*/
        ctx2[1]
      ]) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[7][
            /*section*/
            ctx2[0]
          ].options[
            /*field*/
            ctx2[1]
          ]
        );
      }
      if (dirty & /*min*/
      4) {
        attr(
          input1,
          "min",
          /*min*/
          ctx2[2]
        );
      }
      if (dirty & /*max*/
      8) {
        attr(
          input1,
          "max",
          /*max*/
          ctx2[3]
        );
      }
      if (dirty & /*step*/
      16) {
        attr(
          input1,
          "step",
          /*step*/
          ctx2[4]
        );
      }
      if (dirty & /*$animation, section, field*/
      131) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[7][
            /*section*/
            ctx2[0]
          ].options[
            /*field*/
            ctx2[1]
          ]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$19($$self, $$props, $$invalidate) {
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(7, $animation = value));
  let { section: section2 = "primary" } = $$props;
  let { field = "opacity" } = $$props;
  let { min = 0 } = $$props;
  let { max = 1 } = $$props;
  let { step = 0.01 } = $$props;
  let { placeDefault = 1 } = $$props;
  let { label = game.i18n.localize("autoanimations.menus.effect") + " " + game.i18n.localize("autoanimations.menus.opacity") } = $$props;
  function input0_input_handler() {
    $animation[section2].options[field] = to_number(this.value);
    animation.set($animation);
  }
  function input1_change_input_handler() {
    $animation[section2].options[field] = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
    if ("min" in $$props2)
      $$invalidate(2, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(3, max = $$props2.max);
    if ("step" in $$props2)
      $$invalidate(4, step = $$props2.step);
    if ("placeDefault" in $$props2)
      $$invalidate(5, placeDefault = $$props2.placeDefault);
    if ("label" in $$props2)
      $$invalidate(6, label = $$props2.label);
  };
  return [
    section2,
    field,
    min,
    max,
    step,
    placeDefault,
    label,
    $animation,
    animation,
    input0_input_handler,
    input1_change_input_handler
  ];
}
let Opacity$1 = class Opacity2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$19, create_fragment$1h, safe_not_equal, {
      section: 0,
      field: 1,
      min: 2,
      max: 3,
      step: 4,
      placeDefault: 5,
      label: 6
    });
  }
};
function create_fragment$1g(ctx) {
  let table;
  let tr0;
  let t1;
  let tr1;
  let td0;
  let strong0;
  let t5;
  let td1;
  let t7;
  let tr2;
  let td2;
  let strong1;
  let t9;
  let td3;
  let t15;
  let tr3;
  let td4;
  let strong3;
  let t17;
  let td5;
  let t19;
  let tr4;
  let td6;
  let strong4;
  let t21;
  let td7;
  let t25;
  let tr5;
  let td8;
  let strong6;
  let t29;
  let td9;
  let t31;
  let tr6;
  let td10;
  let strong7;
  let t33;
  let td11;
  let t35;
  let tr7;
  let td12;
  let strong8;
  let t39;
  let td13;
  let t46;
  let tr8;
  let td14;
  let strong11;
  let t48;
  let td15;
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2">Melee Options</th>`;
      t1 = space();
      tr1 = element("tr");
      td0 = element("td");
      strong0 = element("strong");
      strong0.textContent = `${localize("autoanimations.menus.effect")}  ${localize("autoanimations.menus.opacity")}`;
      t5 = space();
      td1 = element("td");
      td1.textContent = "Set the Alpha (transparency) level of the Animation";
      t7 = space();
      tr2 = element("tr");
      td2 = element("td");
      strong1 = element("strong");
      strong1.textContent = `${localize("autoanimations.menus.elevation")}`;
      t9 = space();
      td3 = element("td");
      td3.innerHTML = `Set the Elevation for the Animation relative to the Source Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t15 = space();
      tr3 = element("tr");
      td4 = element("td");
      strong3 = element("strong");
      strong3.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t17 = space();
      td5 = element("td");
      td5.textContent = "Default 1: Set the playback speed of the animation";
      t19 = space();
      tr4 = element("tr");
      td6 = element("td");
      strong4 = element("strong");
      strong4.textContent = `${localize("autoanimations.menus.repeat")}`;
      t21 = space();
      td7 = element("td");
      td7.innerHTML = `Causes the effect to be repeated <strong>N</strong> times, with an optional delay.
            A Repeat of 1 only plays the effect once.`;
      t25 = space();
      tr5 = element("tr");
      td8 = element("td");
      strong6 = element("strong");
      strong6.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t29 = space();
      td9 = element("td");
      td9.textContent = "Sets the Delay between each Repeat in milliseconds.";
      t31 = space();
      tr6 = element("tr");
      td10 = element("td");
      strong7 = element("strong");
      strong7.textContent = `${localize("autoanimations.menus.scale")}`;
      t33 = space();
      td11 = element("td");
      td11.textContent = "Sets the scale of the effect. Inital scale is based off of the\n            Token Size.";
      t35 = space();
      tr7 = element("tr");
      td12 = element("td");
      strong8 = element("strong");
      strong8.textContent = `${localize("autoanimations.menus.delay")} / ${localize("autoanimations.menus.wait")}`;
      t39 = space();
      td13 = element("td");
      td13.innerHTML = `<strong>Delay</strong> causes the start of the animation section to be delayed (milliseconds) <br/>  <br/> 
            <strong>Wait</strong> causes the following animation section to play AFTER the current is finished. Accepts Negative and Positive Numbers`;
      t46 = space();
      tr8 = element("tr");
      td14 = element("td");
      strong11 = element("strong");
      strong11.textContent = `${localize("autoanimations.menus.z-index")}`;
      t48 = space();
      td15 = element("td");
      td15.textContent = "Index of the animation when they are played at the same elevation";
      attr(td0, "class", "aa-table");
      attr(td2, "class", "aa-table");
      attr(td4, "class", "aa-table");
      attr(td6, "class", "aa-table");
      attr(td8, "class", "aa-table");
      attr(td10, "class", "aa-table");
      attr(td12, "class", "aa-table");
      attr(td14, "class", "aa-table");
      attr(table, "id", "aa-options-table");
      attr(table, "cellpadding", "0");
      attr(table, "cellspacing", "0");
      attr(table, "border", "1");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(table, t1);
      append(table, tr1);
      append(tr1, td0);
      append(td0, strong0);
      append(tr1, t5);
      append(tr1, td1);
      append(table, t7);
      append(table, tr2);
      append(tr2, td2);
      append(td2, strong1);
      append(tr2, t9);
      append(tr2, td3);
      append(table, t15);
      append(table, tr3);
      append(tr3, td4);
      append(td4, strong3);
      append(tr3, t17);
      append(tr3, td5);
      append(table, t19);
      append(table, tr4);
      append(tr4, td6);
      append(td6, strong4);
      append(tr4, t21);
      append(tr4, td7);
      append(table, t25);
      append(table, tr5);
      append(tr5, td8);
      append(td8, strong6);
      append(tr5, t29);
      append(tr5, td9);
      append(table, t31);
      append(table, tr6);
      append(tr6, td10);
      append(td10, strong7);
      append(tr6, t33);
      append(tr6, td11);
      append(table, t35);
      append(table, tr7);
      append(tr7, td12);
      append(td12, strong8);
      append(tr7, t39);
      append(tr7, td13);
      append(table, t46);
      append(table, tr8);
      append(tr8, td14);
      append(td14, strong11);
      append(tr8, t48);
      append(tr8, td15);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(table);
    }
  };
}
class Melee extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, null, create_fragment$1g, safe_not_equal, {});
  }
}
function create_fragment$1f(ctx) {
  let table;
  let tr0;
  let t1;
  let tr1;
  let td0;
  let strong0;
  let t5;
  let td1;
  let t13;
  let tr2;
  let td2;
  let strong3;
  let t17;
  let td3;
  let t19;
  let tr3;
  let td4;
  let strong4;
  let t21;
  let td5;
  let t27;
  let tr4;
  let td6;
  let strong6;
  let t30;
  let td7;
  let t32;
  let tr5;
  let td8;
  let strong7;
  let t34;
  let td9;
  let t36;
  let tr6;
  let td10;
  let strong8;
  let t38;
  let td11;
  let t40;
  let tr7;
  let td12;
  let strong9;
  let t42;
  let td13;
  let t46;
  let tr8;
  let td14;
  let strong11;
  let t50;
  let td15;
  let t52;
  let tr9;
  let td16;
  let strong12;
  let t56;
  let td17;
  let t58;
  let tr10;
  let td18;
  let strong13;
  let t62;
  let td19;
  let t64;
  let tr11;
  let td20;
  let strong14;
  let t68;
  let td21;
  let t75;
  let tr12;
  let td22;
  let strong17;
  let t77;
  let td23;
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2">Range Options</th>`;
      t1 = space();
      tr1 = element("tr");
      td0 = element("td");
      strong0 = element("strong");
      strong0.textContent = `${localize("autoanimations.menus.animation")}  ${localize("autoanimations.menus.source")}`;
      t5 = space();
      td1 = element("td");
      td1.innerHTML = `<strong>Experimental</strong>  <br/>  <strong>Available only in the Global Automatic Recognition Menu for DnD5e and PF2e!</strong>  <br/>
            Use this for Spells like Black Tentacles and Storm Sphere to use a placed persistent Animation as the Source of a ranged attack <br/>
            Requires an entry in both the Templates and Ranged menu that match for the Item.`;
      t13 = space();
      tr2 = element("tr");
      td2 = element("td");
      strong3 = element("strong");
      strong3.textContent = `${localize("autoanimations.menus.effect")}  ${localize("autoanimations.menus.opacity")}`;
      t17 = space();
      td3 = element("td");
      td3.textContent = "Set the Alpha (transparency) level of the Animation";
      t19 = space();
      tr3 = element("tr");
      td4 = element("td");
      strong4 = element("strong");
      strong4.textContent = `${localize("autoanimations.menus.elevation")}`;
      t21 = space();
      td5 = element("td");
      td5.innerHTML = `Set the Elevation for the Animation relative to the Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t27 = space();
      tr4 = element("tr");
      td6 = element("td");
      strong6 = element("strong");
      strong6.textContent = `${localize("autoanimations.menus.only")} X`;
      t30 = space();
      td7 = element("td");
      td7.textContent = 'When using a "custom" animation, this allows you to keep the Y scale of the video constant.';
      t32 = space();
      tr5 = element("tr");
      td8 = element("td");
      strong7 = element("strong");
      strong7.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t34 = space();
      td9 = element("td");
      td9.textContent = "Default 1: Set the playback speed of the animation";
      t36 = space();
      tr6 = element("tr");
      td10 = element("td");
      strong8 = element("strong");
      strong8.textContent = `${localize("autoanimations.menus.randomOffset")}`;
      t38 = space();
      td11 = element("td");
      td11.textContent = "Randomly offsets the impact point within the bounds of the Target";
      t40 = space();
      tr7 = element("tr");
      td12 = element("td");
      strong9 = element("strong");
      strong9.textContent = `${localize("autoanimations.menus.repeat")}`;
      t42 = space();
      td13 = element("td");
      td13.innerHTML = `Causes the effect to be repeated <strong>N</strong> times, with an optional delay.
            A Repeat of 1 only plays the effect once.`;
      t46 = space();
      tr8 = element("tr");
      td14 = element("td");
      strong11 = element("strong");
      strong11.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t50 = space();
      td15 = element("td");
      td15.textContent = "Sets the Delay between each Repeat in milliseconds.";
      t52 = space();
      tr9 = element("tr");
      td16 = element("td");
      strong12 = element("strong");
      strong12.textContent = `${localize("autoanimations.menus.return")}  ${localize("autoanimations.menus.animation")}`;
      t56 = space();
      td17 = element("td");
      td17.textContent = 'For built-in Select menus ONLY. If a "return" animation is availble for the given Weapon, enabling this will play it.';
      t58 = space();
      tr10 = element("tr");
      td18 = element("td");
      strong13 = element("strong");
      strong13.textContent = `${localize("autoanimations.animations.reverse")}  ${localize("autoanimations.menus.animation")}`;
      t62 = space();
      td19 = element("td");
      td19.textContent = "Reverse the Animation to start from the Target and go to the Source Token";
      t64 = space();
      tr11 = element("tr");
      td20 = element("td");
      strong14 = element("strong");
      strong14.textContent = `${localize("autoanimations.menus.delay")} / ${localize("autoanimations.menus.wait")}`;
      t68 = space();
      td21 = element("td");
      td21.innerHTML = `<strong>Delay</strong> causes the start of the animation section to be delayed (milliseconds) <br/>  <br/> 
            <strong>Wait</strong> causes the following animation section to play AFTER the current is finished. Accepts Negative and Positive Numbers`;
      t75 = space();
      tr12 = element("tr");
      td22 = element("td");
      strong17 = element("strong");
      strong17.textContent = `${localize("autoanimations.menus.z-index")}`;
      t77 = space();
      td23 = element("td");
      td23.textContent = "Index of the animation when they are played at the same elevation";
      attr(td2, "class", "aa-table");
      attr(td4, "class", "aa-table");
      attr(td6, "class", "aa-table");
      attr(td8, "class", "aa-table");
      attr(td10, "class", "aa-table");
      attr(td12, "class", "aa-table");
      attr(td14, "class", "aa-table");
      attr(td16, "class", "aa-table");
      attr(td18, "class", "aa-table");
      attr(td20, "class", "aa-table");
      attr(td22, "class", "aa-table");
      attr(table, "id", "aa-options-table");
      attr(table, "cellpadding", "0");
      attr(table, "cellspacing", "0");
      attr(table, "border", "1");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(table, t1);
      append(table, tr1);
      append(tr1, td0);
      append(td0, strong0);
      append(tr1, t5);
      append(tr1, td1);
      append(table, t13);
      append(table, tr2);
      append(tr2, td2);
      append(td2, strong3);
      append(tr2, t17);
      append(tr2, td3);
      append(table, t19);
      append(table, tr3);
      append(tr3, td4);
      append(td4, strong4);
      append(tr3, t21);
      append(tr3, td5);
      append(table, t27);
      append(table, tr4);
      append(tr4, td6);
      append(td6, strong6);
      append(tr4, t30);
      append(tr4, td7);
      append(table, t32);
      append(table, tr5);
      append(tr5, td8);
      append(td8, strong7);
      append(tr5, t34);
      append(tr5, td9);
      append(table, t36);
      append(table, tr6);
      append(tr6, td10);
      append(td10, strong8);
      append(tr6, t38);
      append(tr6, td11);
      append(table, t40);
      append(table, tr7);
      append(tr7, td12);
      append(td12, strong9);
      append(tr7, t42);
      append(tr7, td13);
      append(table, t46);
      append(table, tr8);
      append(tr8, td14);
      append(td14, strong11);
      append(tr8, t50);
      append(tr8, td15);
      append(table, t52);
      append(table, tr9);
      append(tr9, td16);
      append(td16, strong12);
      append(tr9, t56);
      append(tr9, td17);
      append(table, t58);
      append(table, tr10);
      append(tr10, td18);
      append(td18, strong13);
      append(tr10, t62);
      append(tr10, td19);
      append(table, t64);
      append(table, tr11);
      append(tr11, td20);
      append(td20, strong14);
      append(tr11, t68);
      append(tr11, td21);
      append(table, t75);
      append(table, tr12);
      append(tr12, td22);
      append(td22, strong17);
      append(tr12, t77);
      append(tr12, td23);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(table);
    }
  };
}
class Range extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, null, create_fragment$1f, safe_not_equal, {});
  }
}
function create_fragment$1e(ctx) {
  let table;
  let tr0;
  let t1;
  let tr1;
  let td0;
  let strong0;
  let t3;
  let td1;
  let t5;
  let tr2;
  let td2;
  let strong1;
  let t9;
  let td3;
  let t11;
  let tr3;
  let td4;
  let strong2;
  let t13;
  let td5;
  let t19;
  let tr4;
  let td6;
  let strong4;
  let t21;
  let td7;
  let t23;
  let tr5;
  let td8;
  let strong5;
  let t25;
  let td9;
  let t27;
  let tr6;
  let td10;
  let strong6;
  let t29;
  let td11;
  let t31;
  let tr7;
  let td12;
  let strong7;
  let t33;
  let td13;
  let t35;
  let tr8;
  let td14;
  let strong8;
  let t37;
  let td15;
  let t39;
  let tr9;
  let td16;
  let strong9;
  let t41;
  let td17;
  let t43;
  let tr10;
  let td18;
  let strong10;
  let t45;
  let td19;
  let t49;
  let tr11;
  let td20;
  let strong12;
  let t53;
  let td21;
  let t55;
  let tr12;
  let td22;
  let strong13;
  let t59;
  let td23;
  let t66;
  let tr13;
  let td24;
  let strong16;
  let t68;
  let td25;
  let t70;
  let tr14;
  let td26;
  let strong17;
  let t76;
  let td27;
  let t78;
  let tr15;
  let td28;
  let strong18;
  let t80;
  let td29;
  let t83;
  let tr16;
  let td30;
  let strong20;
  let t85;
  let td31;
  let t88;
  let tr17;
  let td32;
  let strong22;
  let t92;
  let td33;
  let t99;
  let tr18;
  let td34;
  let strong25;
  let t101;
  let td35;
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2">On Token Options</th>`;
      t1 = space();
      tr1 = element("tr");
      td0 = element("td");
      strong0 = element("strong");
      strong0.textContent = `${localize("autoanimations.menus.anchor")}`;
      t3 = space();
      td1 = element("td");
      td1.textContent = "Adjust the anchor position of the Effect. Default: 0.5 is center. Accepts two numbers separated by a comma. Ex: 0.5, 1 returns x: 0.5, y:1, and using one number such as 0.5 returns x: 0.5, y: 0.5";
      t5 = space();
      tr2 = element("tr");
      td2 = element("td");
      strong1 = element("strong");
      strong1.textContent = `${localize("autoanimations.menus.effect")}  ${localize("autoanimations.menus.opacity")}`;
      t9 = space();
      td3 = element("td");
      td3.textContent = "Set the Alpha (transparency) level of the Animation";
      t11 = space();
      tr3 = element("tr");
      td4 = element("td");
      strong2 = element("strong");
      strong2.textContent = `${localize("autoanimations.menus.elevation")}`;
      t13 = space();
      td5 = element("td");
      td5.innerHTML = `Set the Elevation for the Animation relative to the Source Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t19 = space();
      tr4 = element("tr");
      td6 = element("td");
      strong4 = element("strong");
      strong4.textContent = `${localize("autoanimations.menus.fadeIn")}`;
      t21 = space();
      td7 = element("td");
      td7.textContent = "Sets the fadeIn time of the effect in milliseconds";
      t23 = space();
      tr5 = element("tr");
      td8 = element("td");
      strong5 = element("strong");
      strong5.textContent = `${localize("autoanimations.menus.fadeOut")}`;
      t25 = space();
      td9 = element("td");
      td9.textContent = "Sets the fadeOut time of the effect in milliseconds";
      t27 = space();
      tr6 = element("tr");
      td10 = element("td");
      strong6 = element("strong");
      strong6.textContent = `${localize("autoanimations.menus.mask")}`;
      t29 = space();
      td11 = element("td");
      td11.textContent = "If enabled, the effect will be masked to the given Object";
      t31 = space();
      tr7 = element("tr");
      td12 = element("td");
      strong7 = element("strong");
      strong7.textContent = `${localize("autoanimations.menus.persistant")}`;
      t33 = space();
      td13 = element("td");
      td13.textContent = "This will cause the effect to become permanent on the canvas.\n            You can end the effect with the Sequencer Effect Manager.";
      t35 = space();
      tr8 = element("tr");
      td14 = element("td");
      strong8 = element("strong");
      strong8.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t37 = space();
      td15 = element("td");
      td15.textContent = "Default 1: Set the playback speed of the animation";
      t39 = space();
      tr9 = element("tr");
      td16 = element("td");
      strong9 = element("strong");
      strong9.textContent = `${localize("autoanimations.menus.playOn")}`;
      t41 = space();
      td17 = element("td");
      td17.textContent = "Tells A-A how to play this animation";
      t43 = space();
      tr10 = element("tr");
      td18 = element("td");
      strong10 = element("strong");
      strong10.textContent = `${localize("autoanimations.menus.repeat")}`;
      t45 = space();
      td19 = element("td");
      td19.innerHTML = `Causes the effect to be repeated <strong>N</strong> times, with an optional delay.
            A Repeat of 1 only plays the effect once.`;
      t49 = space();
      tr11 = element("tr");
      td20 = element("td");
      strong12 = element("strong");
      strong12.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t53 = space();
      td21 = element("td");
      td21.textContent = "Sets the Delay between each Repeat in milliseconds.";
      t55 = space();
      tr12 = element("tr");
      td22 = element("td");
      strong13 = element("strong");
      strong13.textContent = `${localize("autoanimations.menus.scale")} / ${localize("autoanimations.menus.radius")}`;
      t59 = space();
      td23 = element("td");
      td23.innerHTML = `<strong>Scale: </strong>Sets the scale of the effect. Inital scale is based off of the
            Token Size. <br/>  <br/> 
            <strong>Radius: </strong>Set the radius of the effect in Grid Squares`;
      t66 = space();
      tr13 = element("tr");
      td24 = element("td");
      strong16 = element("strong");
      strong16.textContent = `${localize("autoanimations.menus.sideImpact")}`;
      t68 = space();
      td25 = element("td");
      td25.textContent = 'Where available, causes the effect to be rotated back towards the Source Token. Primarily useful for the JB2A "side fracture" type effects';
      t70 = space();
      tr14 = element("tr");
      td26 = element("td");
      strong17 = element("strong");
      strong17.textContent = `${localize("autoanimations.menus.add")}  ${localize("autoanimations.menus.token")}  ${localize("autoanimations.menus.width")}`;
      t76 = space();
      td27 = element("td");
      td27.textContent = 'Adds the Token width into the Size calculation for Animations set with "Radius"';
      t78 = space();
      tr15 = element("tr");
      td28 = element("td");
      strong18 = element("strong");
      strong18.textContent = `${localize("autoanimations.menus.bind") + " " + localize("autoanimations.menus.alpha")}`;
      t80 = space();
      td29 = element("td");
      td29.innerHTML = `<strong>Persistent Effects Only:</strong> If enabled, the Alpha level of the Effect will match that
            of the Token or Object (This overrides any Opacity settings).
            Unchecked will use the Opacity level for the effect`;
      t83 = space();
      tr16 = element("tr");
      td30 = element("td");
      strong20 = element("strong");
      strong20.textContent = `${localize("autoanimations.menus.bind") + " " + localize("autoanimations.menus.visibility")}`;
      t85 = space();
      td31 = element("td");
      td31.innerHTML = `<strong>Persistent Effects Only:</strong> If enabled, the Visibility of the Effect will match that of
            the Token or Object. Unchecked will make the effect always visible`;
      t88 = space();
      tr17 = element("tr");
      td32 = element("td");
      strong22 = element("strong");
      strong22.textContent = `${localize("autoanimations.menus.delay")} / ${localize("autoanimations.menus.wait")}`;
      t92 = space();
      td33 = element("td");
      td33.innerHTML = `<strong>Delay</strong> causes the start of the animation section to be delayed (milliseconds) <br/>  <br/> 
            <strong>Wait</strong> causes the following animation section to play AFTER the current is finished. Accepts Negative and Positive Numbers`;
      t99 = space();
      tr18 = element("tr");
      td34 = element("td");
      strong25 = element("strong");
      strong25.textContent = `${localize("autoanimations.menus.z-index")}`;
      t101 = space();
      td35 = element("td");
      td35.textContent = "Index of the animation when they are played at the same elevation";
      attr(td2, "class", "aa-table");
      attr(td4, "class", "aa-table");
      attr(td6, "class", "aa-table");
      attr(td8, "class", "aa-table");
      attr(td10, "class", "aa-table");
      attr(td12, "class", "aa-table");
      attr(td14, "class", "aa-table");
      attr(td16, "class", "aa-table");
      attr(td18, "class", "aa-table");
      attr(td20, "class", "aa-table");
      attr(td22, "class", "aa-table");
      attr(td26, "class", "aa-table");
      attr(td28, "class", "aa-table");
      attr(td30, "class", "aa-table");
      attr(td32, "class", "aa-table");
      attr(td34, "class", "aa-table");
      attr(table, "id", "aa-options-table");
      attr(table, "cellpadding", "0");
      attr(table, "cellspacing", "0");
      attr(table, "border", "1");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(table, t1);
      append(table, tr1);
      append(tr1, td0);
      append(td0, strong0);
      append(tr1, t3);
      append(tr1, td1);
      append(table, t5);
      append(table, tr2);
      append(tr2, td2);
      append(td2, strong1);
      append(tr2, t9);
      append(tr2, td3);
      append(table, t11);
      append(table, tr3);
      append(tr3, td4);
      append(td4, strong2);
      append(tr3, t13);
      append(tr3, td5);
      append(table, t19);
      append(table, tr4);
      append(tr4, td6);
      append(td6, strong4);
      append(tr4, t21);
      append(tr4, td7);
      append(table, t23);
      append(table, tr5);
      append(tr5, td8);
      append(td8, strong5);
      append(tr5, t25);
      append(tr5, td9);
      append(table, t27);
      append(table, tr6);
      append(tr6, td10);
      append(td10, strong6);
      append(tr6, t29);
      append(tr6, td11);
      append(table, t31);
      append(table, tr7);
      append(tr7, td12);
      append(td12, strong7);
      append(tr7, t33);
      append(tr7, td13);
      append(table, t35);
      append(table, tr8);
      append(tr8, td14);
      append(td14, strong8);
      append(tr8, t37);
      append(tr8, td15);
      append(table, t39);
      append(table, tr9);
      append(tr9, td16);
      append(td16, strong9);
      append(tr9, t41);
      append(tr9, td17);
      append(table, t43);
      append(table, tr10);
      append(tr10, td18);
      append(td18, strong10);
      append(tr10, t45);
      append(tr10, td19);
      append(table, t49);
      append(table, tr11);
      append(tr11, td20);
      append(td20, strong12);
      append(tr11, t53);
      append(tr11, td21);
      append(table, t55);
      append(table, tr12);
      append(tr12, td22);
      append(td22, strong13);
      append(tr12, t59);
      append(tr12, td23);
      append(table, t66);
      append(table, tr13);
      append(tr13, td24);
      append(td24, strong16);
      append(tr13, t68);
      append(tr13, td25);
      append(table, t70);
      append(table, tr14);
      append(tr14, td26);
      append(td26, strong17);
      append(tr14, t76);
      append(tr14, td27);
      append(table, t78);
      append(table, tr15);
      append(tr15, td28);
      append(td28, strong18);
      append(tr15, t80);
      append(tr15, td29);
      append(table, t83);
      append(table, tr16);
      append(tr16, td30);
      append(td30, strong20);
      append(tr16, t85);
      append(tr16, td31);
      append(table, t88);
      append(table, tr17);
      append(tr17, td32);
      append(td32, strong22);
      append(tr17, t92);
      append(tr17, td33);
      append(table, t99);
      append(table, tr18);
      append(tr18, td34);
      append(td34, strong25);
      append(tr18, t101);
      append(tr18, td35);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(table);
    }
  };
}
class Ontoken extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, null, create_fragment$1e, safe_not_equal, {});
  }
}
function create_fragment$1d(ctx) {
  let table1;
  let tr0;
  let t1;
  let tr1;
  let t5;
  let tr2;
  let td2;
  let strong1;
  let t7;
  let td3;
  let t18;
  let tr3;
  let td4;
  let strong6;
  let t22;
  let td5;
  let t24;
  let tr4;
  let td6;
  let strong7;
  let t26;
  let td7;
  let t32;
  let tr5;
  let td8;
  let strong9;
  let t34;
  let td9;
  let t36;
  let tr6;
  let td10;
  let strong10;
  let t40;
  let td11;
  let t42;
  let tr7;
  let td12;
  let strong11;
  let t44;
  let td13;
  let t46;
  let tr8;
  let td14;
  let strong12;
  let t48;
  let td15;
  let t50;
  let tr9;
  let td16;
  let strong13;
  let t52;
  let td17;
  let t56;
  let tr10;
  let td18;
  let strong15;
  let t60;
  let td19;
  let t62;
  let tr11;
  let td20;
  let strong16;
  let t64;
  let td21;
  let t66;
  let tr12;
  let td22;
  let strong17;
  let t68;
  let td23;
  let t70;
  let tr13;
  let td24;
  let strong18;
  let t74;
  let td25;
  let t81;
  let tr14;
  let td26;
  let strong21;
  let t83;
  let td27;
  let t85;
  let tr15;
  let t87;
  let tr21;
  let td28;
  let strong22;
  let t91;
  let td37;
  let table0;
  let tr16;
  let t93;
  let tr17;
  let td29;
  let strong23;
  let t95;
  let td30;
  let t97;
  let tr18;
  let td31;
  let strong24;
  let t99;
  let td32;
  let t101;
  let tr19;
  let td33;
  let strong25;
  let t103;
  let td34;
  let t105;
  let tr20;
  let td35;
  let strong26;
  let t107;
  let td36;
  let t109;
  let tr22;
  let td38;
  let strong27;
  let t111;
  let td39;
  let t113;
  let tr23;
  let td40;
  let strong28;
  let t115;
  let td41;
  return {
    c() {
      table1 = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2">Templates Options</th>`;
      t1 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<td class="aa-table"><strong>Adjust Rotation</strong></td> 
        <td>Adjusts the rotation of the animation</td>`;
      t5 = space();
      tr2 = element("tr");
      td2 = element("td");
      strong1 = element("strong");
      strong1.textContent = `${localize("autoanimations.menus.anchor")}`;
      t7 = space();
      td3 = element("td");
      td3.innerHTML = `Adjust the anchor position of the Effect. Default: <strong>0.5, 0.5</strong> for Square/Circle Templates, <strong>0, 0.5</strong> for Cone/Ray templates. <br/> 
            Accepts two numbers separated by a comma. Ex: <strong>0.5, 1</strong> returns x: 0.5, y:1, and using one number such as <strong>0.5</strong> returns x: 0.5, y: 0.5`;
      t18 = space();
      tr3 = element("tr");
      td4 = element("td");
      strong6 = element("strong");
      strong6.textContent = `${localize("autoanimations.menus.effect")}  ${localize("autoanimations.menus.opacity")}`;
      t22 = space();
      td5 = element("td");
      td5.textContent = "Set the Alpha (transparency) level of the Animation";
      t24 = space();
      tr4 = element("tr");
      td6 = element("td");
      strong7 = element("strong");
      strong7.textContent = `${localize("autoanimations.menus.elevation")}`;
      t26 = space();
      td7 = element("td");
      td7.innerHTML = `Set the Elevation for the Animation relative to the Source Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t32 = space();
      tr5 = element("tr");
      td8 = element("td");
      strong9 = element("strong");
      strong9.textContent = `${localize("autoanimations.menus.mask")}`;
      t34 = space();
      td9 = element("td");
      td9.textContent = "If enabled, the effect will be masked to the Template";
      t36 = space();
      tr6 = element("tr");
      td10 = element("td");
      strong10 = element("strong");
      strong10.textContent = `${localize("autoanimations.variants.above")}  ${localize("autoanimations.animTypes.templatefx")}`;
      t40 = space();
      td11 = element("td");
      td11.textContent = "This setting will override Elevation to play the animation Above the template using the .aboveLightning() Sequencer method";
      t42 = space();
      tr7 = element("tr");
      td12 = element("td");
      strong11 = element("strong");
      strong11.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t44 = space();
      td13 = element("td");
      td13.textContent = "Default 1: Set the playback speed of the animation";
      t46 = space();
      tr8 = element("tr");
      td14 = element("td");
      strong12 = element("strong");
      strong12.textContent = `${localize("autoanimations.menus.remove")}`;
      t48 = space();
      td15 = element("td");
      td15.textContent = "Removes the Template immediately after placement on the game canvas.";
      t50 = space();
      tr9 = element("tr");
      td16 = element("td");
      strong13 = element("strong");
      strong13.textContent = `${localize("autoanimations.menus.repeat")}`;
      t52 = space();
      td17 = element("td");
      td17.innerHTML = `Causes the effect to be repeated <strong>N</strong> times, with an optional delay.
            A Repeat of 1 only plays the effect once.`;
      t56 = space();
      tr10 = element("tr");
      td18 = element("td");
      strong15 = element("strong");
      strong15.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t60 = space();
      td19 = element("td");
      td19.textContent = "Sets the Delay between each Repeat in milliseconds.";
      t62 = space();
      tr11 = element("tr");
      td20 = element("td");
      strong16 = element("strong");
      strong16.textContent = `${localize("autoanimations.menus.scale")}`;
      t64 = space();
      td21 = element("td");
      td21.textContent = "Sets the Scale of the Effect. Default: 1. Accepts two numbers separated by a comma. Ex: 1, 2 to set the X and Y scaling x: 1, y:2, or a Single number to set both as the same scale.";
      t66 = space();
      tr12 = element("tr");
      td22 = element("td");
      strong17 = element("strong");
      strong17.textContent = `${localize("autoanimations.menus.persistant")}`;
      t68 = space();
      td23 = element("td");
      td23.textContent = "This will cause the effect to become permanent on the canvas.\n            You can end the effect with the Sequencer Effect Manager.";
      t70 = space();
      tr13 = element("tr");
      td24 = element("td");
      strong18 = element("strong");
      strong18.textContent = `${localize("autoanimations.menus.delay")} / ${localize("autoanimations.menus.wait")}`;
      t74 = space();
      td25 = element("td");
      td25.innerHTML = `<strong>Delay</strong> causes the start of the animation section to be delayed (milliseconds) <br/>  <br/> 
            <strong>Wait</strong> causes the following animation section to play AFTER the current is finished. Accepts Negative and Positive Numbers`;
      t81 = space();
      tr14 = element("tr");
      td26 = element("td");
      strong21 = element("strong");
      strong21.textContent = `${localize("autoanimations.menus.z-index")}`;
      t83 = space();
      td27 = element("td");
      td27.textContent = "Index of the animation when they are played at the same elevation";
      t85 = space();
      tr15 = element("tr");
      tr15.innerHTML = `<th colspan="2" style="background: rgba(17, 0, 148, .5)">Persistent Options</th>`;
      t87 = space();
      tr21 = element("tr");
      td28 = element("td");
      strong22 = element("strong");
      strong22.textContent = `${localize("autoanimations.menus.persistant")}  ${localize("autoanimations.menus.type")}`;
      t91 = space();
      td37 = element("td");
      table0 = element("table");
      tr16 = element("tr");
      tr16.innerHTML = `<th colspan="2">If Persistent is enabled, you can choose the type here.</th>`;
      t93 = space();
      tr17 = element("tr");
      td29 = element("td");
      strong23 = element("strong");
      strong23.textContent = `${localize("autoanimations.menus.overheadtile")}`;
      t95 = space();
      td30 = element("td");
      td30.textContent = "Creates effect as an Overhead Tile";
      t97 = space();
      tr18 = element("tr");
      td31 = element("td");
      strong24 = element("strong");
      strong24.textContent = `${localize("autoanimations.menus.groundtile")}`;
      t99 = space();
      td32 = element("td");
      td32.textContent = "Creates Effect as a Tile below tokens";
      t101 = space();
      tr19 = element("tr");
      td33 = element("td");
      strong25 = element("strong");
      strong25.textContent = `${localize("autoanimations.menus.sequencereffect")}`;
      t103 = space();
      td34 = element("td");
      td34.textContent = "Creates a Persistent Sequencer effect";
      t105 = space();
      tr20 = element("tr");
      td35 = element("td");
      strong26 = element("strong");
      strong26.textContent = `${localize("autoanimations.menus.attachtotemplate")}`;
      t107 = space();
      td36 = element("td");
      td36.textContent = "Creates a Persistent Sequencer effect and attaches to the template (draggable)";
      t109 = space();
      tr22 = element("tr");
      td38 = element("td");
      strong27 = element("strong");
      strong27.textContent = `${localize("autoanimations.menus.occlusionMode")}`;
      t111 = space();
      td39 = element("td");
      td39.textContent = "If Persistent and Type is set to Overhead Tile, choose the Occlusion Mode";
      t113 = space();
      tr23 = element("tr");
      td40 = element("td");
      strong28 = element("strong");
      strong28.textContent = `${localize("autoanimations.menus.occlusionAlpha")}`;
      t115 = space();
      td41 = element("td");
      td41.textContent = "If Persistent and Type is set to Overhead Tile, choose the Occlusion Alpha";
      attr(td4, "class", "aa-table");
      attr(td6, "class", "aa-table");
      attr(td8, "class", "aa-table");
      attr(td10, "class", "aa-table");
      attr(td12, "class", "aa-table");
      attr(td14, "class", "aa-table");
      attr(td16, "class", "aa-table");
      attr(td18, "class", "aa-table");
      attr(td20, "class", "aa-table");
      attr(td22, "class", "aa-table");
      attr(td24, "class", "aa-table");
      attr(td26, "class", "aa-table");
      attr(td28, "class", "aa-table");
      attr(td29, "class", "aa-table");
      attr(td31, "class", "aa-table");
      attr(td33, "class", "aa-table");
      attr(td35, "class", "aa-table");
      attr(table0, "id", "options-table");
      attr(table0, "cellpadding", "0");
      attr(table0, "cellspacing", "0");
      attr(table0, "border", "1");
      attr(td38, "class", "aa-table");
      attr(td40, "class", "aa-table");
      attr(table1, "id", "aa-options-table");
      attr(table1, "cellpadding", "0");
      attr(table1, "cellspacing", "0");
      attr(table1, "border", "1");
    },
    m(target2, anchor) {
      insert(target2, table1, anchor);
      append(table1, tr0);
      append(table1, t1);
      append(table1, tr1);
      append(table1, t5);
      append(table1, tr2);
      append(tr2, td2);
      append(td2, strong1);
      append(tr2, t7);
      append(tr2, td3);
      append(table1, t18);
      append(table1, tr3);
      append(tr3, td4);
      append(td4, strong6);
      append(tr3, t22);
      append(tr3, td5);
      append(table1, t24);
      append(table1, tr4);
      append(tr4, td6);
      append(td6, strong7);
      append(tr4, t26);
      append(tr4, td7);
      append(table1, t32);
      append(table1, tr5);
      append(tr5, td8);
      append(td8, strong9);
      append(tr5, t34);
      append(tr5, td9);
      append(table1, t36);
      append(table1, tr6);
      append(tr6, td10);
      append(td10, strong10);
      append(tr6, t40);
      append(tr6, td11);
      append(table1, t42);
      append(table1, tr7);
      append(tr7, td12);
      append(td12, strong11);
      append(tr7, t44);
      append(tr7, td13);
      append(table1, t46);
      append(table1, tr8);
      append(tr8, td14);
      append(td14, strong12);
      append(tr8, t48);
      append(tr8, td15);
      append(table1, t50);
      append(table1, tr9);
      append(tr9, td16);
      append(td16, strong13);
      append(tr9, t52);
      append(tr9, td17);
      append(table1, t56);
      append(table1, tr10);
      append(tr10, td18);
      append(td18, strong15);
      append(tr10, t60);
      append(tr10, td19);
      append(table1, t62);
      append(table1, tr11);
      append(tr11, td20);
      append(td20, strong16);
      append(tr11, t64);
      append(tr11, td21);
      append(table1, t66);
      append(table1, tr12);
      append(tr12, td22);
      append(td22, strong17);
      append(tr12, t68);
      append(tr12, td23);
      append(table1, t70);
      append(table1, tr13);
      append(tr13, td24);
      append(td24, strong18);
      append(tr13, t74);
      append(tr13, td25);
      append(table1, t81);
      append(table1, tr14);
      append(tr14, td26);
      append(td26, strong21);
      append(tr14, t83);
      append(tr14, td27);
      append(table1, t85);
      append(table1, tr15);
      append(table1, t87);
      append(table1, tr21);
      append(tr21, td28);
      append(td28, strong22);
      append(tr21, t91);
      append(tr21, td37);
      append(td37, table0);
      append(table0, tr16);
      append(table0, t93);
      append(table0, tr17);
      append(tr17, td29);
      append(td29, strong23);
      append(tr17, t95);
      append(tr17, td30);
      append(table0, t97);
      append(table0, tr18);
      append(tr18, td31);
      append(td31, strong24);
      append(tr18, t99);
      append(tr18, td32);
      append(table0, t101);
      append(table0, tr19);
      append(tr19, td33);
      append(td33, strong25);
      append(tr19, t103);
      append(tr19, td34);
      append(table0, t105);
      append(table0, tr20);
      append(tr20, td35);
      append(td35, strong26);
      append(tr20, t107);
      append(tr20, td36);
      append(table1, t109);
      append(table1, tr22);
      append(tr22, td38);
      append(td38, strong27);
      append(tr22, t111);
      append(tr22, td39);
      append(table1, t113);
      append(table1, tr23);
      append(tr23, td40);
      append(td40, strong28);
      append(tr23, t115);
      append(tr23, td41);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(table1);
    }
  };
}
class Templatefx extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, null, create_fragment$1d, safe_not_equal, {});
  }
}
function create_fragment$1c(ctx) {
  let table;
  let tr0;
  let t1;
  let tr1;
  let td0;
  let strong0;
  let t7;
  let td1;
  let t9;
  let tr2;
  let td2;
  let strong1;
  let t13;
  let td3;
  let t15;
  let tr3;
  let td4;
  let strong2;
  let t17;
  let td5;
  let t23;
  let tr4;
  let td6;
  let strong4;
  let t25;
  let td7;
  let t27;
  let tr5;
  let td8;
  let strong5;
  let t29;
  let td9;
  let t31;
  let tr6;
  let td10;
  let strong6;
  let t33;
  let td11;
  let t35;
  let tr7;
  let td12;
  let strong7;
  let t37;
  let td13;
  let t40;
  let tr8;
  let td14;
  let strong9;
  let t44;
  let td15;
  let t51;
  let tr9;
  let td16;
  let strong12;
  let t53;
  let td17;
  let t56;
  let tr10;
  let td18;
  let strong14;
  let t58;
  let td19;
  let t61;
  let tr11;
  let td20;
  let strong16;
  let t63;
  let td21;
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2">Aura Options</th>`;
      t1 = space();
      tr1 = element("tr");
      td0 = element("td");
      strong0 = element("strong");
      strong0.textContent = `${localize("autoanimations.menus.add")}  ${localize("autoanimations.menus.token")}  ${localize("autoanimations.menus.width")}`;
      t7 = space();
      td1 = element("td");
      td1.textContent = 'Adds the Token width into the Size calculation for Animations set with "Radius"';
      t9 = space();
      tr2 = element("tr");
      td2 = element("td");
      strong1 = element("strong");
      strong1.textContent = `${localize("autoanimations.menus.effect")}  ${localize("autoanimations.menus.opacity")}`;
      t13 = space();
      td3 = element("td");
      td3.textContent = "Set the Alpha (transparency) level of the Animation";
      t15 = space();
      tr3 = element("tr");
      td4 = element("td");
      strong2 = element("strong");
      strong2.textContent = `${localize("autoanimations.menus.elevation")}`;
      t17 = space();
      td5 = element("td");
      td5.innerHTML = `Set the Elevation for the Animation relative to the Source Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t23 = space();
      tr4 = element("tr");
      td6 = element("td");
      strong4 = element("strong");
      strong4.textContent = `${localize("autoanimations.menus.ignoreTargets")}`;
      t25 = space();
      td7 = element("td");
      td7.textContent = "Disregards targets and always plays this effect on the Source Token";
      t27 = space();
      tr5 = element("tr");
      td8 = element("td");
      strong5 = element("strong");
      strong5.textContent = `${localize("autoanimations.menus.mask")}`;
      t29 = space();
      td9 = element("td");
      td9.textContent = "If enabled, the effect will be masked to the given Object";
      t31 = space();
      tr6 = element("tr");
      td10 = element("td");
      strong6 = element("strong");
      strong6.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t33 = space();
      td11 = element("td");
      td11.textContent = "Default 1: Set the playback speed of the animation";
      t35 = space();
      tr7 = element("tr");
      td12 = element("td");
      strong7 = element("strong");
      strong7.textContent = `${localize("autoanimations.menus.radius")}`;
      t37 = space();
      td13 = element("td");
      td13.innerHTML = `<strong>Radius: </strong>Set the radius of the effect in Grid Squares`;
      t40 = space();
      tr8 = element("tr");
      td14 = element("td");
      strong9 = element("strong");
      strong9.textContent = `${localize("autoanimations.menus.delay")} / ${localize("autoanimations.menus.wait")}`;
      t44 = space();
      td15 = element("td");
      td15.innerHTML = `<strong>Delay</strong> causes the start of the animation section to be delayed (milliseconds) <br/>  <br/> 
            <strong>Wait</strong> causes the following animation section to play AFTER the current is finished. Accepts Negative and Positive Numbers`;
      t51 = space();
      tr9 = element("tr");
      td16 = element("td");
      strong12 = element("strong");
      strong12.textContent = `${localize("autoanimations.menus.bind") + " " + localize("autoanimations.menus.alpha")}`;
      t53 = space();
      td17 = element("td");
      td17.innerHTML = `<strong>Persistent Effects Only:</strong> If enabled, the Alpha level of the Effect will match that
            of the Token or Object (This overrides any Opacity settings).
            Unchecked will use the Opacity level for the effect`;
      t56 = space();
      tr10 = element("tr");
      td18 = element("td");
      strong14 = element("strong");
      strong14.textContent = `${localize("autoanimations.menus.bind") + " " + localize("autoanimations.menus.visibility")}`;
      t58 = space();
      td19 = element("td");
      td19.innerHTML = `<strong>Persistent Effects Only:</strong> If enabled, the Visibility of the Effect will match that of
            the Token or Object. Unchecked will make the effect always visible`;
      t61 = space();
      tr11 = element("tr");
      td20 = element("td");
      strong16 = element("strong");
      strong16.textContent = `${localize("autoanimations.menus.z-index")}`;
      t63 = space();
      td21 = element("td");
      td21.textContent = "Index of the animation when they are played at the same elevation";
      attr(td0, "class", "aa-table");
      attr(td2, "class", "aa-table");
      attr(td4, "class", "aa-table");
      attr(td6, "class", "aa-table");
      attr(td8, "class", "aa-table");
      attr(td10, "class", "aa-table");
      attr(td12, "class", "aa-table");
      attr(td14, "class", "aa-table");
      attr(td16, "class", "aa-table");
      attr(td18, "class", "aa-table");
      attr(td20, "class", "aa-table");
      attr(table, "id", "aa-options-table");
      attr(table, "cellpadding", "0");
      attr(table, "cellspacing", "0");
      attr(table, "border", "1");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(table, t1);
      append(table, tr1);
      append(tr1, td0);
      append(td0, strong0);
      append(tr1, t7);
      append(tr1, td1);
      append(table, t9);
      append(table, tr2);
      append(tr2, td2);
      append(td2, strong1);
      append(tr2, t13);
      append(tr2, td3);
      append(table, t15);
      append(table, tr3);
      append(tr3, td4);
      append(td4, strong2);
      append(tr3, t17);
      append(tr3, td5);
      append(table, t23);
      append(table, tr4);
      append(tr4, td6);
      append(td6, strong4);
      append(tr4, t25);
      append(tr4, td7);
      append(table, t27);
      append(table, tr5);
      append(tr5, td8);
      append(td8, strong5);
      append(tr5, t29);
      append(tr5, td9);
      append(table, t31);
      append(table, tr6);
      append(tr6, td10);
      append(td10, strong6);
      append(tr6, t33);
      append(tr6, td11);
      append(table, t35);
      append(table, tr7);
      append(tr7, td12);
      append(td12, strong7);
      append(tr7, t37);
      append(tr7, td13);
      append(table, t40);
      append(table, tr8);
      append(tr8, td14);
      append(td14, strong9);
      append(tr8, t44);
      append(tr8, td15);
      append(table, t51);
      append(table, tr9);
      append(tr9, td16);
      append(td16, strong12);
      append(tr9, t53);
      append(tr9, td17);
      append(table, t56);
      append(table, tr10);
      append(tr10, td18);
      append(td18, strong14);
      append(tr10, t58);
      append(tr10, td19);
      append(table, t61);
      append(table, tr11);
      append(tr11, td20);
      append(td20, strong16);
      append(tr11, t63);
      append(tr11, td21);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(table);
    }
  };
}
class Aura extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, null, create_fragment$1c, safe_not_equal, {});
  }
}
const preset_svelte_svelte_type_style_lang = "";
function get_each_context$b(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_each_block$b(ctx) {
  let li;
  let t0_value = (
    /*section*/
    ctx[4].label + ""
  );
  let t0;
  let t1;
  let span;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[3](
        /*section*/
        ctx[4]
      )
    );
  }
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      span = element("span");
      attr(li, "role", "presentation");
      attr(li, "class", "svelte-auto-fs6c3j");
      toggle_class(
        li,
        "active",
        /*$presetStore*/
        ctx[1] === /*section*/
        ctx[4].section
      );
      attr(span, "class", "svelte-auto-fs6c3j");
    },
    m(target2, anchor) {
      insert(target2, li, anchor);
      append(li, t0);
      insert(target2, t1, anchor);
      insert(target2, span, anchor);
      if (!mounted) {
        dispose = listen(li, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$presetStore, headerList*/
      6) {
        toggle_class(
          li,
          "active",
          /*$presetStore*/
          ctx[1] === /*section*/
          ctx[4].section
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$4(ctx) {
  let table;
  let tr0;
  let t1;
  let tr1;
  let t3;
  let tr2;
  let td0;
  let strong0;
  let t5;
  let td1;
  let t11;
  let tr3;
  let td2;
  let strong2;
  let t13;
  let td3;
  let t15;
  let tr4;
  let td4;
  let strong3;
  let t17;
  let td5;
  let t21;
  let tr5;
  let td6;
  let strong5;
  let t25;
  let td7;
  let t27;
  let tr6;
  let td8;
  let strong6;
  let t29;
  let td9;
  let t31;
  let tr7;
  let td10;
  let strong7;
  let t33;
  let td11;
  let t35;
  let tr8;
  let td12;
  let strong8;
  let t39;
  let td13;
  let t41;
  let tr9;
  let t43;
  let tr10;
  let td14;
  let strong9;
  let t45;
  let td15;
  let t51;
  let tr11;
  let td16;
  let strong11;
  let t53;
  let td17;
  let t55;
  let tr12;
  let td18;
  let strong12;
  let t57;
  let td19;
  let t61;
  let tr13;
  let td20;
  let strong14;
  let t65;
  let td21;
  let t67;
  let tr14;
  let td22;
  let strong15;
  let t69;
  let td23;
  let t71;
  let tr15;
  let td24;
  let strong16;
  let t73;
  let td25;
  let t75;
  let tr16;
  let td26;
  let strong17;
  let t79;
  let td27;
  let t81;
  let tr17;
  let t83;
  let tr18;
  let td28;
  let strong18;
  let t85;
  let td29;
  let t91;
  let tr19;
  let td30;
  let strong20;
  let t93;
  let td31;
  let t95;
  let tr20;
  let td32;
  let strong21;
  let t97;
  let td33;
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2">Projectile to Template</th>`;
      t1 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<th colspan="2" style="background: rgba(17, 0, 148, .5)">Projectile Animation</th>`;
      t3 = space();
      tr2 = element("tr");
      td0 = element("td");
      strong0 = element("strong");
      strong0.textContent = `${localize("autoanimations.menus.elevation")}`;
      t5 = space();
      td1 = element("td");
      td1.innerHTML = `Set the Elevation for the Animation relative to the Source Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t11 = space();
      tr3 = element("tr");
      td2 = element("td");
      strong2 = element("strong");
      strong2.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t13 = space();
      td3 = element("td");
      td3.textContent = "Default 1: Set the playback speed of the animation";
      t15 = space();
      tr4 = element("tr");
      td4 = element("td");
      strong3 = element("strong");
      strong3.textContent = `${localize("autoanimations.menus.repeat")}`;
      t17 = space();
      td5 = element("td");
      td5.innerHTML = `Causes the effect to be repeated <strong>N</strong> times, with an optional delay.
            A Repeat of 1 only plays the effect once.`;
      t21 = space();
      tr5 = element("tr");
      td6 = element("td");
      strong5 = element("strong");
      strong5.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t25 = space();
      td7 = element("td");
      td7.textContent = "Sets the Delay between each Repeat in milliseconds.";
      t27 = space();
      tr6 = element("tr");
      td8 = element("td");
      strong6 = element("strong");
      strong6.textContent = `${localize("autoanimations.menus.remove")}`;
      t29 = space();
      td9 = element("td");
      td9.textContent = "Removes the Template immediately after placement on the game canvas.";
      t31 = space();
      tr7 = element("tr");
      td10 = element("td");
      strong7 = element("strong");
      strong7.textContent = `${localize("autoanimations.menus.wait")}`;
      t33 = space();
      td11 = element("td");
      td11.textContent = "Causes the following animation section to play AFTER the current is finished. Accepts Negative and Positive Numbers";
      t35 = space();
      tr8 = element("tr");
      td12 = element("td");
      strong8 = element("strong");
      strong8.textContent = `${localize("autoanimations.menus.effect")}  ${localize("autoanimations.menus.opacity")}`;
      t39 = space();
      td13 = element("td");
      td13.textContent = "Set the Alpha (transparency) level of the Animation";
      t41 = space();
      tr9 = element("tr");
      tr9.innerHTML = `<th colspan="2" style="background: rgba(17, 0, 148, .5)">Explosion / Pre-Explosion Animation</th>`;
      t43 = space();
      tr10 = element("tr");
      td14 = element("td");
      strong9 = element("strong");
      strong9.textContent = `${localize("autoanimations.menus.elevation")}`;
      t45 = space();
      td15 = element("td");
      td15.innerHTML = `Set the Elevation for the Animation relative to the Source Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t51 = space();
      tr11 = element("tr");
      td16 = element("td");
      strong11 = element("strong");
      strong11.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t53 = space();
      td17 = element("td");
      td17.textContent = "Default 1: Set the playback speed of the animation";
      t55 = space();
      tr12 = element("tr");
      td18 = element("td");
      strong12 = element("strong");
      strong12.textContent = `${localize("autoanimations.menus.repeat")}`;
      t57 = space();
      td19 = element("td");
      td19.innerHTML = `Causes the effect to be repeated <strong>N</strong> times, with an optional delay.
            A Repeat of 1 only plays the effect once.`;
      t61 = space();
      tr13 = element("tr");
      td20 = element("td");
      strong14 = element("strong");
      strong14.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t65 = space();
      td21 = element("td");
      td21.textContent = "Sets the Delay between each Repeat in milliseconds.";
      t67 = space();
      tr14 = element("tr");
      td22 = element("td");
      strong15 = element("strong");
      strong15.textContent = `${localize("autoanimations.menus.scale")}`;
      t69 = space();
      td23 = element("td");
      td23.textContent = "Sets the scale of the effect. Inital scale is based off of the\n            Token Size.";
      t71 = space();
      tr15 = element("tr");
      td24 = element("td");
      strong16 = element("strong");
      strong16.textContent = `${localize("autoanimations.menus.wait")}`;
      t73 = space();
      td25 = element("td");
      td25.textContent = "Causes the following animation section to play AFTER the current is finished. Accepts Negative and Positive Numbers";
      t75 = space();
      tr16 = element("tr");
      td26 = element("td");
      strong17 = element("strong");
      strong17.textContent = `${localize("autoanimations.menus.effect")}  ${localize("autoanimations.menus.opacity")}`;
      t79 = space();
      td27 = element("td");
      td27.textContent = "Set the Alpha (transparency) level of the Animation";
      t81 = space();
      tr17 = element("tr");
      tr17.innerHTML = `<th colspan="2" style="background: rgba(17, 0, 148, .5)">After Image</th>`;
      t83 = space();
      tr18 = element("tr");
      td28 = element("td");
      strong18 = element("strong");
      strong18.textContent = `${localize("autoanimations.menus.elevation")}`;
      t85 = space();
      td29 = element("td");
      td29.innerHTML = `Set the Elevation for the Animation relative to the Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t91 = space();
      tr19 = element("tr");
      td30 = element("td");
      strong20 = element("strong");
      strong20.textContent = `${localize("autoanimations.menus.persistant")}`;
      t93 = space();
      td31 = element("td");
      td31.textContent = "This will cause the effect to become permanent on the canvas.\n            You can end the effect with the Sequencer Effect Manager.";
      t95 = space();
      tr20 = element("tr");
      td32 = element("td");
      strong21 = element("strong");
      strong21.textContent = `${localize("autoanimations.menus.scale")}`;
      t97 = space();
      td33 = element("td");
      td33.textContent = "Sets the scale of the effect. Inital scale is based off of the\n            Token Size.";
      attr(td0, "class", "aa-table");
      attr(td2, "class", "aa-table");
      attr(td4, "class", "aa-table");
      attr(td6, "class", "aa-table");
      attr(td8, "class", "aa-table");
      attr(td10, "class", "aa-table");
      attr(td12, "class", "aa-table");
      attr(td14, "class", "aa-table");
      attr(td16, "class", "aa-table");
      attr(td18, "class", "aa-table");
      attr(td20, "class", "aa-table");
      attr(td22, "class", "aa-table");
      attr(td24, "class", "aa-table");
      attr(td26, "class", "aa-table");
      attr(td28, "class", "aa-table");
      attr(td30, "class", "aa-table");
      attr(td32, "class", "aa-table");
      attr(table, "class", "aa-options-table");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(table, t1);
      append(table, tr1);
      append(table, t3);
      append(table, tr2);
      append(tr2, td0);
      append(td0, strong0);
      append(tr2, t5);
      append(tr2, td1);
      append(table, t11);
      append(table, tr3);
      append(tr3, td2);
      append(td2, strong2);
      append(tr3, t13);
      append(tr3, td3);
      append(table, t15);
      append(table, tr4);
      append(tr4, td4);
      append(td4, strong3);
      append(tr4, t17);
      append(tr4, td5);
      append(table, t21);
      append(table, tr5);
      append(tr5, td6);
      append(td6, strong5);
      append(tr5, t25);
      append(tr5, td7);
      append(table, t27);
      append(table, tr6);
      append(tr6, td8);
      append(td8, strong6);
      append(tr6, t29);
      append(tr6, td9);
      append(table, t31);
      append(table, tr7);
      append(tr7, td10);
      append(td10, strong7);
      append(tr7, t33);
      append(tr7, td11);
      append(table, t35);
      append(table, tr8);
      append(tr8, td12);
      append(td12, strong8);
      append(tr8, t39);
      append(tr8, td13);
      append(table, t41);
      append(table, tr9);
      append(table, t43);
      append(table, tr10);
      append(tr10, td14);
      append(td14, strong9);
      append(tr10, t45);
      append(tr10, td15);
      append(table, t51);
      append(table, tr11);
      append(tr11, td16);
      append(td16, strong11);
      append(tr11, t53);
      append(tr11, td17);
      append(table, t55);
      append(table, tr12);
      append(tr12, td18);
      append(td18, strong12);
      append(tr12, t57);
      append(tr12, td19);
      append(table, t61);
      append(table, tr13);
      append(tr13, td20);
      append(td20, strong14);
      append(tr13, t65);
      append(tr13, td21);
      append(table, t67);
      append(table, tr14);
      append(tr14, td22);
      append(td22, strong15);
      append(tr14, t69);
      append(tr14, td23);
      append(table, t71);
      append(table, tr15);
      append(tr15, td24);
      append(td24, strong16);
      append(tr15, t73);
      append(tr15, td25);
      append(table, t75);
      append(table, tr16);
      append(tr16, td26);
      append(td26, strong17);
      append(tr16, t79);
      append(tr16, td27);
      append(table, t81);
      append(table, tr17);
      append(table, t83);
      append(table, tr18);
      append(tr18, td28);
      append(td28, strong18);
      append(tr18, t85);
      append(tr18, td29);
      append(table, t91);
      append(table, tr19);
      append(tr19, td30);
      append(td30, strong20);
      append(tr19, t93);
      append(tr19, td31);
      append(table, t95);
      append(table, tr20);
      append(tr20, td32);
      append(td32, strong21);
      append(tr20, t97);
      append(tr20, td33);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(table);
    }
  };
}
function create_if_block_2$6(ctx) {
  let table;
  let colgroup;
  let t1;
  let tr0;
  let t3;
  let tr1;
  let td0;
  let strong0;
  let t5;
  let td1;
  let t11;
  let tr2;
  let td2;
  let strong2;
  let t15;
  let td3;
  let t17;
  let tr3;
  let td4;
  let strong3;
  let t19;
  let td5;
  let t21;
  let tr4;
  let td6;
  let strong4;
  let t24;
  let td7;
  return {
    c() {
      table = element("table");
      colgroup = element("colgroup");
      colgroup.innerHTML = `<col span="1" style="width: 20%;"/> 
        <col span="1" style="width: 50%;"/>`;
      t1 = space();
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2">Dual Attach</th>`;
      t3 = space();
      tr1 = element("tr");
      td0 = element("td");
      strong0 = element("strong");
      strong0.textContent = `${localize("autoanimations.menus.elevation")}`;
      t5 = space();
      td1 = element("td");
      td1.innerHTML = `Set the Elevation for the Animation relative to the Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t11 = space();
      tr2 = element("tr");
      td2 = element("td");
      strong2 = element("strong");
      strong2.textContent = `${localize("autoanimations.menus.effect")}  ${localize("autoanimations.menus.opacity")}`;
      t15 = space();
      td3 = element("td");
      td3.textContent = "Set the Alpha (transparency) level of the Animation";
      t17 = space();
      tr3 = element("tr");
      td4 = element("td");
      strong3 = element("strong");
      strong3.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t19 = space();
      td5 = element("td");
      td5.textContent = "Speeds up or Slows down the Animation effect. Positive numbers only";
      t21 = space();
      tr4 = element("tr");
      td6 = element("td");
      strong4 = element("strong");
      strong4.textContent = `${localize("autoanimations.menus.only")} X`;
      t24 = space();
      td7 = element("td");
      td7.textContent = "Limits the Y scaling of the effect to no changes";
      attr(td0, "class", "aa-table");
      attr(td2, "class", "aa-table");
      attr(td4, "class", "aa-table");
      attr(td6, "class", "aa-table");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, colgroup);
      append(table, t1);
      append(table, tr0);
      append(table, t3);
      append(table, tr1);
      append(tr1, td0);
      append(td0, strong0);
      append(tr1, t5);
      append(tr1, td1);
      append(table, t11);
      append(table, tr2);
      append(tr2, td2);
      append(td2, strong2);
      append(tr2, t15);
      append(tr2, td3);
      append(table, t17);
      append(table, tr3);
      append(tr3, td4);
      append(td4, strong3);
      append(tr3, t19);
      append(tr3, td5);
      append(table, t21);
      append(table, tr4);
      append(tr4, td6);
      append(td6, strong4);
      append(tr4, t24);
      append(tr4, td7);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(table);
    }
  };
}
function create_if_block_1$8(ctx) {
  let table;
  let tr0;
  let t1;
  let tr1;
  let t3;
  let tr2;
  let t7;
  let tr3;
  let t11;
  let tr4;
  let td4;
  let strong2;
  let t13;
  let td5;
  let t15;
  let tr5;
  let t19;
  let tr6;
  let t23;
  let tr7;
  let t27;
  let tr8;
  let t31;
  let tr9;
  let t35;
  let tr10;
  let t39;
  let tr11;
  let t43;
  let tr12;
  let t45;
  let tr13;
  let td20;
  let strong10;
  let t47;
  let td21;
  let t49;
  let tr14;
  let td22;
  let strong11;
  let t51;
  let td23;
  let t57;
  let tr15;
  let td24;
  let strong13;
  let t61;
  let td25;
  let t68;
  let tr16;
  let td26;
  let strong16;
  let t72;
  let td27;
  let t74;
  let tr17;
  let td28;
  let strong17;
  let t76;
  let td29;
  let t78;
  let tr18;
  let td30;
  let strong18;
  let t80;
  let td31;
  let t82;
  let tr19;
  let td32;
  let strong19;
  let t84;
  let td33;
  let t86;
  let tr20;
  let td34;
  let strong20;
  let t88;
  let td35;
  let t90;
  let tr21;
  let t92;
  let tr22;
  let td36;
  let strong21;
  let t94;
  let td37;
  let t100;
  let tr23;
  let td38;
  let strong23;
  let t102;
  let td39;
  let t104;
  let tr24;
  let td40;
  let strong24;
  let t108;
  let td41;
  let t110;
  let tr25;
  let td42;
  let strong25;
  let t112;
  let td43;
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2">Teleportation</th>`;
      t1 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<th colspan="2" style="background: rgba(17, 0, 148, .5)">Movement Options</th>`;
      t3 = space();
      tr2 = element("tr");
      tr2.innerHTML = `<td class="aa-table"><strong>Range Marker</strong></td> 
        <td>Determines if Measurement type to be used. Alternating vs Equidistant</td>`;
      t7 = space();
      tr3 = element("tr");
      tr3.innerHTML = `<td class="aa-table"><strong>Hide from Players</strong></td> 
        <td>Causes the Range Marker to be hidden from Players. Only a GM can configure this</td>`;
      t11 = space();
      tr4 = element("tr");
      td4 = element("td");
      strong2 = element("strong");
      strong2.textContent = `${localize("autoanimations.animTypes.range")}`;
      t13 = space();
      td5 = element("td");
      td5.textContent = "Distance limitation for the Teleportation";
      t15 = space();
      tr5 = element("tr");
      tr5.innerHTML = `<td class="aa-table"><strong>Teleport Token</strong></td> 
        <td>Toggle whether the Token should be teleported or moved</td>`;
      t19 = space();
      tr6 = element("tr");
      tr6.innerHTML = `<td class="aa-table"><strong>Delay Movement</strong></td> 
        <td>Sets the delay before the Token should move</td>`;
      t23 = space();
      tr7 = element("tr");
      tr7.innerHTML = `<td class="aa-table"><strong>Speed</strong></td> 
        <td>If not teleporting, set the speed for token movement</td>`;
      t27 = space();
      tr8 = element("tr");
      tr8.innerHTML = `<td class="aa-table"><strong>Token Alpha</strong></td> 
        <td>Sets the Opacity the token should fade to</td>`;
      t31 = space();
      tr9 = element("tr");
      tr9.innerHTML = `<td class="aa-table"><strong>Delay Fade Out</strong></td> 
        <td>Sets the delay for when the token should begin changin Opacity</td>`;
      t35 = space();
      tr10 = element("tr");
      tr10.innerHTML = `<td class="aa-table"><strong>Delay Fade In</strong></td> 
        <td>Sets the delay for when the Token should return to full opacity (minimum 250)</td>`;
      t39 = space();
      tr11 = element("tr");
      tr11.innerHTML = `<td class="aa-table"><strong>Check for Collision</strong></td> 
        <td>Checks the path for any collisions with walls, and does not move if any are found</td>`;
      t43 = space();
      tr12 = element("tr");
      tr12.innerHTML = `<th colspan="2" style="background: rgba(17, 0, 148, .5)">Start / End Animation</th>`;
      t45 = space();
      tr13 = element("tr");
      td20 = element("td");
      strong10 = element("strong");
      strong10.textContent = `${localize("autoanimations.menus.mask")}`;
      t47 = space();
      td21 = element("td");
      td21.textContent = "If enabled, the effect will be masked to the given Object";
      t49 = space();
      tr14 = element("tr");
      td22 = element("td");
      strong11 = element("strong");
      strong11.textContent = `${localize("autoanimations.menus.elevation")}`;
      t51 = space();
      td23 = element("td");
      td23.innerHTML = `Set the Elevation for the Animation relative to the Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t57 = space();
      tr15 = element("tr");
      td24 = element("td");
      strong13 = element("strong");
      strong13.textContent = `${localize("autoanimations.menus.scale")} / ${localize("autoanimations.menus.radius")}`;
      t61 = space();
      td25 = element("td");
      td25.innerHTML = `<strong>Scale: </strong>Sets the scale of the effect. Inital scale is based off of the
            Token Size. <br/>  <br/> 
            <strong>Radius: </strong>Set the radius of the effect in Grid Squares`;
      t68 = space();
      tr16 = element("tr");
      td26 = element("td");
      strong16 = element("strong");
      strong16.textContent = `${localize("autoanimations.menus.effect")}  ${localize("autoanimations.menus.opacity")}`;
      t72 = space();
      td27 = element("td");
      td27.textContent = "Set the Alpha (transparency) level of the Animation";
      t74 = space();
      tr17 = element("tr");
      td28 = element("td");
      strong17 = element("strong");
      strong17.textContent = `${localize("autoanimations.menus.fadeIn")}`;
      t76 = space();
      td29 = element("td");
      td29.textContent = "Sets the fadeIn time of the effect in milliseconds";
      t78 = space();
      tr18 = element("tr");
      td30 = element("td");
      strong18 = element("strong");
      strong18.textContent = `${localize("autoanimations.menus.fadeOut")}`;
      t80 = space();
      td31 = element("td");
      td31.textContent = "Sets the fadeOut time of the effect in milliseconds";
      t82 = space();
      tr19 = element("tr");
      td32 = element("td");
      strong19 = element("strong");
      strong19.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t84 = space();
      td33 = element("td");
      td33.textContent = "Default 1: Set the playback speed of the animation";
      t86 = space();
      tr20 = element("tr");
      td34 = element("td");
      strong20 = element("strong");
      strong20.textContent = `${localize("autoanimations.menus.delay")}`;
      t88 = space();
      td35 = element("td");
      td35.textContent = "Causes the start of the animation section to be delayed (milliseconds)";
      t90 = space();
      tr21 = element("tr");
      tr21.innerHTML = `<th colspan="2" style="background: rgba(17, 0, 148, .5)">Between Animation</th>`;
      t92 = space();
      tr22 = element("tr");
      td36 = element("td");
      strong21 = element("strong");
      strong21.textContent = `${localize("autoanimations.menus.elevation")}`;
      t94 = space();
      td37 = element("td");
      td37.innerHTML = `Set the Elevation for the Animation relative to the Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t100 = space();
      tr23 = element("tr");
      td38 = element("td");
      strong23 = element("strong");
      strong23.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t102 = space();
      td39 = element("td");
      td39.textContent = "Speeds up or Slows down the Animation effect. Positive numbers only";
      t104 = space();
      tr24 = element("tr");
      td40 = element("td");
      strong24 = element("strong");
      strong24.textContent = `${localize("autoanimations.menus.effect")}  ${localize("autoanimations.menus.opacity")}`;
      t108 = space();
      td41 = element("td");
      td41.textContent = "Set the Alpha (transparency) level of the Animation";
      t110 = space();
      tr25 = element("tr");
      td42 = element("td");
      strong25 = element("strong");
      strong25.textContent = `${localize("autoanimations.menus.delay")}`;
      t112 = space();
      td43 = element("td");
      td43.textContent = "Causes the start of the animation section to be delayed (milliseconds)";
      attr(td4, "class", "aa-table");
      attr(td20, "class", "aa-table");
      attr(td22, "class", "aa-table");
      attr(td24, "class", "aa-table");
      attr(td26, "class", "aa-table");
      attr(td28, "class", "aa-table");
      attr(td30, "class", "aa-table");
      attr(td32, "class", "aa-table");
      attr(td34, "class", "aa-table");
      attr(td36, "class", "aa-table");
      attr(td38, "class", "aa-table");
      attr(td40, "class", "aa-table");
      attr(td42, "class", "aa-table");
      attr(table, "class", "aa-options-table");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(table, t1);
      append(table, tr1);
      append(table, t3);
      append(table, tr2);
      append(table, t7);
      append(table, tr3);
      append(table, t11);
      append(table, tr4);
      append(tr4, td4);
      append(td4, strong2);
      append(tr4, t13);
      append(tr4, td5);
      append(table, t15);
      append(table, tr5);
      append(table, t19);
      append(table, tr6);
      append(table, t23);
      append(table, tr7);
      append(table, t27);
      append(table, tr8);
      append(table, t31);
      append(table, tr9);
      append(table, t35);
      append(table, tr10);
      append(table, t39);
      append(table, tr11);
      append(table, t43);
      append(table, tr12);
      append(table, t45);
      append(table, tr13);
      append(tr13, td20);
      append(td20, strong10);
      append(tr13, t47);
      append(tr13, td21);
      append(table, t49);
      append(table, tr14);
      append(tr14, td22);
      append(td22, strong11);
      append(tr14, t51);
      append(tr14, td23);
      append(table, t57);
      append(table, tr15);
      append(tr15, td24);
      append(td24, strong13);
      append(tr15, t61);
      append(tr15, td25);
      append(table, t68);
      append(table, tr16);
      append(tr16, td26);
      append(td26, strong16);
      append(tr16, t72);
      append(tr16, td27);
      append(table, t74);
      append(table, tr17);
      append(tr17, td28);
      append(td28, strong17);
      append(tr17, t76);
      append(tr17, td29);
      append(table, t78);
      append(table, tr18);
      append(tr18, td30);
      append(td30, strong18);
      append(tr18, t80);
      append(tr18, td31);
      append(table, t82);
      append(table, tr19);
      append(tr19, td32);
      append(td32, strong19);
      append(tr19, t84);
      append(tr19, td33);
      append(table, t86);
      append(table, tr20);
      append(tr20, td34);
      append(td34, strong20);
      append(tr20, t88);
      append(tr20, td35);
      append(table, t90);
      append(table, tr21);
      append(table, t92);
      append(table, tr22);
      append(tr22, td36);
      append(td36, strong21);
      append(tr22, t94);
      append(tr22, td37);
      append(table, t100);
      append(table, tr23);
      append(tr23, td38);
      append(td38, strong23);
      append(tr23, t102);
      append(tr23, td39);
      append(table, t104);
      append(table, tr24);
      append(tr24, td40);
      append(td40, strong24);
      append(tr24, t108);
      append(tr24, td41);
      append(table, t110);
      append(table, tr25);
      append(tr25, td42);
      append(td42, strong25);
      append(tr25, t112);
      append(tr25, td43);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(table);
    }
  };
}
function create_if_block$g(ctx) {
  let table;
  let tr0;
  let t1;
  let tr1;
  let td0;
  let strong0;
  let t3;
  let td1;
  let t9;
  let tr2;
  let td2;
  let strong2;
  let t11;
  let td3;
  let t15;
  let tr3;
  let td4;
  let strong4;
  let t19;
  let td5;
  let t21;
  let tr4;
  let td6;
  let strong5;
  let t25;
  let td7;
  let t27;
  let tr5;
  let td8;
  let strong6;
  let t30;
  let td9;
  let t32;
  let tr6;
  let td10;
  let strong7;
  let t35;
  let td11;
  let t37;
  let tr7;
  let td12;
  let strong8;
  let t39;
  let td13;
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2">Thunderwave</th>`;
      t1 = space();
      tr1 = element("tr");
      td0 = element("td");
      strong0 = element("strong");
      strong0.textContent = `${localize("autoanimations.menus.elevation")}`;
      t3 = space();
      td1 = element("td");
      td1.innerHTML = `Set the Elevation for the Animation relative to the Token. Elevation of &quot;0&quot; is below the token <br/> 
            <strong>ABS</strong>: <i>If Enabled, switches Elevation to be Absolute and disregard the Token elevation</i>`;
      t9 = space();
      tr2 = element("tr");
      td2 = element("td");
      strong2 = element("strong");
      strong2.textContent = `${localize("autoanimations.menus.repeat")}`;
      t11 = space();
      td3 = element("td");
      td3.innerHTML = `Causes the effect to be repeated <strong>N</strong> times, with an optional delay.
            A Repeat of 1 only plays the effect once.`;
      t15 = space();
      tr3 = element("tr");
      td4 = element("td");
      strong4 = element("strong");
      strong4.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t19 = space();
      td5 = element("td");
      td5.textContent = "Sets the Delay between each Repeat in milliseconds.";
      t21 = space();
      tr4 = element("tr");
      td6 = element("td");
      strong5 = element("strong");
      strong5.textContent = `${localize("autoanimations.menus.effect")}  ${localize("autoanimations.menus.opacity")}`;
      t25 = space();
      td7 = element("td");
      td7.textContent = "Set the Alpha (transparency) level of the Animation";
      t27 = space();
      tr5 = element("tr");
      td8 = element("td");
      strong6 = element("strong");
      strong6.textContent = `${localize("autoanimations.menus.scale")} X`;
      t30 = space();
      td9 = element("td");
      td9.textContent = "Sets the X Scale of the effect";
      t32 = space();
      tr6 = element("tr");
      td10 = element("td");
      strong7 = element("strong");
      strong7.textContent = `${localize("autoanimations.menus.scale")} Y`;
      t35 = space();
      td11 = element("td");
      td11.textContent = "Sets the Y Scale of the effect";
      t37 = space();
      tr7 = element("tr");
      td12 = element("td");
      strong8 = element("strong");
      strong8.textContent = `${localize("autoanimations.menus.remove")}`;
      t39 = space();
      td13 = element("td");
      td13.textContent = "Removes the Template immediately after placement on the game canvas.";
      attr(td0, "class", "aa-table");
      attr(td2, "class", "aa-table");
      attr(td4, "class", "aa-table");
      attr(td6, "class", "aa-table");
      attr(td8, "class", "aa-table");
      attr(td10, "class", "aa-table");
      attr(td12, "class", "aa-table");
      attr(table, "class", "aa-options-table");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(table, t1);
      append(table, tr1);
      append(tr1, td0);
      append(td0, strong0);
      append(tr1, t3);
      append(tr1, td1);
      append(table, t9);
      append(table, tr2);
      append(tr2, td2);
      append(td2, strong2);
      append(tr2, t11);
      append(tr2, td3);
      append(table, t15);
      append(table, tr3);
      append(tr3, td4);
      append(td4, strong4);
      append(tr3, t19);
      append(tr3, td5);
      append(table, t21);
      append(table, tr4);
      append(tr4, td6);
      append(td6, strong5);
      append(tr4, t25);
      append(tr4, td7);
      append(table, t27);
      append(table, tr5);
      append(tr5, td8);
      append(td8, strong6);
      append(tr5, t30);
      append(tr5, td9);
      append(table, t32);
      append(table, tr6);
      append(tr6, td10);
      append(td10, strong7);
      append(tr6, t35);
      append(tr6, td11);
      append(table, t37);
      append(table, tr7);
      append(tr7, td12);
      append(td12, strong8);
      append(tr7, t39);
      append(tr7, td13);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(table);
    }
  };
}
function create_fragment$1b(ctx) {
  let header;
  let ul;
  let t0;
  let t1;
  let t2;
  let t3;
  let if_block3_anchor;
  let each_value = (
    /*headerList*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
  }
  let if_block0 = (
    /*$presetStore*/
    ctx[1] === "proToTemp" && create_if_block_3$4()
  );
  let if_block1 = (
    /*$presetStore*/
    ctx[1] === "dualattach" && create_if_block_2$6()
  );
  let if_block2 = (
    /*$presetStore*/
    ctx[1] === "teleportation" && create_if_block_1$8()
  );
  let if_block3 = (
    /*$presetStore*/
    ctx[1] === "thunderwave" && create_if_block$g()
  );
  return {
    c() {
      header = element("header");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      attr(ul, "class", "svelte-auto-fs6c3j");
      attr(header, "class", "svelte-auto-fs6c3j");
    },
    m(target2, anchor) {
      insert(target2, header, anchor);
      append(header, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      insert(target2, t0, anchor);
      if (if_block0)
        if_block0.m(target2, anchor);
      insert(target2, t1, anchor);
      if (if_block1)
        if_block1.m(target2, anchor);
      insert(target2, t2, anchor);
      if (if_block2)
        if_block2.m(target2, anchor);
      insert(target2, t3, anchor);
      if (if_block3)
        if_block3.m(target2, anchor);
      insert(target2, if_block3_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$presetStore, headerList*/
      6) {
        each_value = /*headerList*/
        ctx2[2];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$b(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$b(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (
        /*$presetStore*/
        ctx2[1] === "proToTemp"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$4();
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$presetStore*/
        ctx2[1] === "dualattach"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$6();
          if_block1.c();
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$presetStore*/
        ctx2[1] === "teleportation"
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$8();
          if_block2.c();
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*$presetStore*/
        ctx2[1] === "thunderwave"
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block$g();
          if_block3.c();
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(header);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(if_block3_anchor);
    }
  };
}
function instance$18($$self, $$props, $$invalidate) {
  let $presetStore, $$unsubscribe_presetStore = noop, $$subscribe_presetStore = () => ($$unsubscribe_presetStore(), $$unsubscribe_presetStore = subscribe(presetStore, ($$value) => $$invalidate(1, $presetStore = $$value)), presetStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_presetStore());
  let { presetStore } = $$props;
  $$subscribe_presetStore();
  let headerList = [
    {
      label: "Projectile to Template",
      section: "proToTemp"
    },
    {
      label: "Dual Attach",
      section: "dualattach"
    },
    {
      label: "Teleportation",
      section: "teleportation"
    },
    {
      label: "Thunderwave 5e",
      section: "thunderwave"
    }
  ];
  const click_handler = (section2) => set_store_value(presetStore, $presetStore = section2.section, $presetStore);
  $$self.$$set = ($$props2) => {
    if ("presetStore" in $$props2)
      $$subscribe_presetStore($$invalidate(0, presetStore = $$props2.presetStore));
  };
  return [presetStore, $presetStore, headerList, click_handler];
}
class Preset extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$18, create_fragment$1b, safe_not_equal, { presetStore: 0 });
  }
}
function create_fragment$1a(ctx) {
  let table;
  let tr0;
  let t1;
  let tr1;
  let td0;
  let strong0;
  let t3;
  let td1;
  let t5;
  let tr2;
  let td2;
  let strong1;
  let t7;
  let td3;
  let t9;
  let tr3;
  let td4;
  let strong2;
  let t11;
  let td5;
  let t15;
  let tr4;
  let td6;
  let strong4;
  let t19;
  let td7;
  let t21;
  let tr5;
  let td8;
  let strong5;
  let t23;
  let td9;
  let t25;
  let tr6;
  let td10;
  let strong6;
  let t27;
  let td11;
  let t29;
  let tr7;
  let td12;
  let strong7;
  let t31;
  let td13;
  let t33;
  let tr8;
  let td14;
  let strong8;
  let t35;
  let td15;
  let t37;
  let tr9;
  let td16;
  let strong9;
  let t39;
  let td17;
  let t41;
  let tr10;
  let td18;
  let strong10;
  let t43;
  let td19;
  let t45;
  let tr11;
  let td20;
  let strong11;
  let t47;
  let td21;
  let t49;
  let tr12;
  let td22;
  let strong12;
  let t51;
  let td23;
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2">3D Canvas Options</th>`;
      t1 = space();
      tr1 = element("tr");
      td0 = element("td");
      strong0 = element("strong");
      strong0.textContent = `${localize("autoanimations.menus.color")}`;
      t3 = space();
      td1 = element("td");
      td1.textContent = "Set the dual color options for the Particle effect";
      t5 = space();
      tr2 = element("tr");
      td2 = element("td");
      strong1 = element("strong");
      strong1.textContent = `${localize("autoanimations.menus.speed")}`;
      t7 = space();
      td3 = element("td");
      td3.textContent = "Sets the speed of the particle effect";
      t9 = space();
      tr3 = element("tr");
      td4 = element("td");
      strong2 = element("strong");
      strong2.textContent = `${localize("autoanimations.menus.repeat")}`;
      t11 = space();
      td5 = element("td");
      td5.innerHTML = `Causes the effect to be repeated <strong>N</strong> times, with an optional delay.
            A Repeat of 1 only plays the effect once.`;
      t15 = space();
      tr4 = element("tr");
      td6 = element("td");
      strong4 = element("strong");
      strong4.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t19 = space();
      td7 = element("td");
      td7.textContent = "Sets the Delay between each Repeat in milliseconds.";
      t21 = space();
      tr5 = element("tr");
      td8 = element("td");
      strong5 = element("strong");
      strong5.textContent = `${localize("autoanimations.menus.scale")}`;
      t23 = space();
      td9 = element("td");
      td9.textContent = "Set the scale of the Particle Effect";
      t25 = space();
      tr6 = element("tr");
      td10 = element("td");
      strong6 = element("strong");
      strong6.textContent = `${localize("autoanimations.menus.arc")}`;
      t27 = space();
      td11 = element("td");
      td11.textContent = "Determine the arcing amplitude of the effect";
      t29 = space();
      tr7 = element("tr");
      td12 = element("td");
      strong7 = element("strong");
      strong7.textContent = `${localize("autoanimations.menus.alpha")}`;
      t31 = space();
      td13 = element("td");
      td13.textContent = "Set the Alpha/Opacity level of the effect";
      t33 = space();
      tr8 = element("tr");
      td14 = element("td");
      strong8 = element("strong");
      strong8.textContent = `${localize("autoanimations.menus.gravity")}`;
      t35 = space();
      td15 = element("td");
      td15.textContent = "Determines the falling speeed for the particles";
      t37 = space();
      tr9 = element("tr");
      td16 = element("td");
      strong9 = element("strong");
      strong9.textContent = `${localize("autoanimations.menus.mass")}`;
      t39 = space();
      td17 = element("td");
      td17.textContent = "Sets the overall Particle size";
      t41 = space();
      tr10 = element("tr");
      td18 = element("td");
      strong10 = element("strong");
      strong10.textContent = `${localize("autoanimations.menus.life")}`;
      t43 = space();
      td19 = element("td");
      td19.textContent = "How long the particle last in milliseconds";
      t45 = space();
      tr11 = element("tr");
      td20 = element("td");
      strong11 = element("strong");
      strong11.textContent = `${localize("autoanimations.menus.emiterSize")}`;
      t47 = space();
      td21 = element("td");
      td21.textContent = "Size of the emitter source";
      t49 = space();
      tr12 = element("tr");
      td22 = element("td");
      strong12 = element("strong");
      strong12.textContent = `${localize("autoanimations.menus.rate")}`;
      t51 = space();
      td23 = element("td");
      td23.textContent = "Rate at which the particles are spawned";
      attr(td0, "class", "aa-table");
      attr(td2, "class", "aa-table");
      attr(td4, "class", "aa-table");
      attr(td6, "class", "aa-table");
      attr(td8, "class", "aa-table");
      attr(td10, "class", "aa-table");
      attr(td12, "class", "aa-table");
      attr(td14, "class", "aa-table");
      attr(td16, "class", "aa-table");
      attr(td18, "class", "aa-table");
      attr(td20, "class", "aa-table");
      attr(td22, "class", "aa-table");
      attr(table, "id", "aa-options-table");
      attr(table, "cellpadding", "0");
      attr(table, "cellspacing", "0");
      attr(table, "border", "1");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(table, t1);
      append(table, tr1);
      append(tr1, td0);
      append(td0, strong0);
      append(tr1, t3);
      append(tr1, td1);
      append(table, t5);
      append(table, tr2);
      append(tr2, td2);
      append(td2, strong1);
      append(tr2, t7);
      append(tr2, td3);
      append(table, t9);
      append(table, tr3);
      append(tr3, td4);
      append(td4, strong2);
      append(tr3, t11);
      append(tr3, td5);
      append(table, t15);
      append(table, tr4);
      append(tr4, td6);
      append(td6, strong4);
      append(tr4, t19);
      append(tr4, td7);
      append(table, t21);
      append(table, tr5);
      append(tr5, td8);
      append(td8, strong5);
      append(tr5, t23);
      append(tr5, td9);
      append(table, t25);
      append(table, tr6);
      append(tr6, td10);
      append(td10, strong6);
      append(tr6, t27);
      append(tr6, td11);
      append(table, t29);
      append(table, tr7);
      append(tr7, td12);
      append(td12, strong7);
      append(tr7, t31);
      append(tr7, td13);
      append(table, t33);
      append(table, tr8);
      append(tr8, td14);
      append(td14, strong8);
      append(tr8, t35);
      append(tr8, td15);
      append(table, t37);
      append(table, tr9);
      append(tr9, td16);
      append(td16, strong9);
      append(tr9, t39);
      append(tr9, td17);
      append(table, t41);
      append(table, tr10);
      append(tr10, td18);
      append(td18, strong10);
      append(tr10, t43);
      append(tr10, td19);
      append(table, t45);
      append(table, tr11);
      append(tr11, td20);
      append(td20, strong11);
      append(tr11, t47);
      append(tr11, td21);
      append(table, t49);
      append(table, tr12);
      append(tr12, td22);
      append(td22, strong12);
      append(tr12, t51);
      append(tr12, td23);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(table);
    }
  };
}
class Canvas3d extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, null, create_fragment$1a, safe_not_equal, {});
  }
}
const options = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aura: Aura,
  canvas3d: Canvas3d,
  melee: Melee,
  ontoken: Ontoken,
  preset: Preset,
  range: Range,
  templatefx: Templatefx
}, Symbol.toStringTag, { value: "Module" }));
const OptionsInformation_svelte_svelte_type_style_lang = "";
const optionsInfo_svelte_svelte_type_style_lang = "";
function get_each_context$a(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_each_block$a(ctx) {
  let li;
  let i;
  let t0_value = localize(
    /*section*/
    ctx[11].label
  ) + "";
  let t0;
  let t1;
  let span;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[7](
        /*section*/
        ctx[11]
      )
    );
  }
  return {
    c() {
      li = element("li");
      i = element("i");
      t0 = text(t0_value);
      t1 = space();
      span = element("span");
      attr(i, "class", null_to_empty(
        /*section*/
        ctx[11].icon
      ) + " svelte-auto-10ilu8l");
      attr(li, "role", "presentation");
      attr(li, "class", "svelte-auto-10ilu8l");
      toggle_class(
        li,
        "active",
        /*$tabStore*/
        ctx[3] === /*section*/
        ctx[11].section
      );
      attr(span, "class", "svelte-auto-10ilu8l");
    },
    m(target2, anchor) {
      insert(target2, li, anchor);
      append(li, i);
      append(li, t0);
      insert(target2, t1, anchor);
      insert(target2, span, anchor);
      if (!mounted) {
        dispose = listen(li, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$tabStore, headerList*/
      24) {
        toggle_class(
          li,
          "active",
          /*$tabStore*/
          ctx[3] === /*section*/
          ctx[11].section
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$c(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = options[
    /*$tabStore*/
    ctx[3]
  ];
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$tabStore*/
      8 && switch_value !== (switch_value = options[
        /*$tabStore*/
        ctx2[3]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block$f(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = options[
    /*$tabStore*/
    ctx[3]
  ];
  function switch_props(ctx2) {
    return {
      props: { presetStore: (
        /*presetStore*/
        ctx2[2]
      ) }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*presetStore*/
      4)
        switch_instance_changes.presetStore = /*presetStore*/
        ctx2[2];
      if (dirty & /*$tabStore*/
      8 && switch_value !== (switch_value = options[
        /*$tabStore*/
        ctx2[3]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$19(ctx) {
  let header;
  let ul;
  let t;
  let main2;
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  let each_value = (
    /*headerList*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
  }
  const if_block_creators = [create_if_block$f, create_else_block$c];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$tabStore*/
      ctx2[3] === "preset"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      header = element("header");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      main2 = element("main");
      div = element("div");
      if_block.c();
      attr(ul, "class", "svelte-auto-10ilu8l");
      attr(header, "class", "svelte-auto-10ilu8l");
      attr(div, "class", "aa-options-info svelte-auto-10ilu8l");
      attr(main2, "class", "svelte-auto-10ilu8l");
    },
    m(target2, anchor) {
      insert(target2, header, anchor);
      append(header, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      insert(target2, t, anchor);
      insert(target2, main2, anchor);
      append(main2, div);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$tabStore, headerList, localize*/
      24) {
        each_value = /*headerList*/
        ctx2[4];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$a(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$a(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(header);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(main2);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$17($$self, $$props, $$invalidate) {
  let $position;
  let $storageStore, $$unsubscribe_storageStore = noop, $$subscribe_storageStore = () => ($$unsubscribe_storageStore(), $$unsubscribe_storageStore = subscribe(storageStore, ($$value) => $$invalidate(8, $storageStore = $$value)), storageStore);
  let $tabStore, $$unsubscribe_tabStore = noop, $$subscribe_tabStore = () => ($$unsubscribe_tabStore(), $$unsubscribe_tabStore = subscribe(tabStore, ($$value) => $$invalidate(3, $tabStore = $$value)), tabStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_storageStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_tabStore());
  let { storageStore } = $$props;
  $$subscribe_storageStore();
  let { tabStore } = $$props;
  $$subscribe_tabStore();
  let { presetStore = "proToTemp" } = $$props;
  let headerList = [
    {
      label: "autoanimations.animTypes.melee",
      icon: "fas fa-shield-alt",
      section: "melee"
    },
    {
      label: "autoanimations.animTypes.range",
      icon: "fas fa-people-arrows",
      section: "range"
    },
    {
      label: "autoanimations.animTypes.ontoken",
      icon: "fas fa-child",
      section: "ontoken"
    },
    {
      label: "autoanimations.animTypes.templatefx",
      icon: "fas fa-shapes",
      section: "templatefx"
    },
    {
      label: "autoanimations.animTypes.aura",
      icon: "fab fa-creative-commons-by",
      section: "aura"
    },
    {
      label: "autoanimations.app.aaAutorec-preset.label",
      icon: "fas fa-gift",
      section: "preset"
    },
    {
      label: "autoanimations.menus.3dcanvas",
      icon: "fas fa-cube",
      section: "canvas3d"
    }
  ];
  const { application } = getContext("#external");
  const position = application.position;
  component_subscribe($$self, position, (value) => $$invalidate(6, $position = value));
  const storeAppState = foundry.utils.debounce(() => set_store_value(storageStore, $storageStore = application.state.get(), $storageStore), 500);
  const click_handler = (section2) => set_store_value(tabStore, $tabStore = section2.section, $tabStore);
  $$self.$$set = ($$props2) => {
    if ("storageStore" in $$props2)
      $$subscribe_storageStore($$invalidate(0, storageStore = $$props2.storageStore));
    if ("tabStore" in $$props2)
      $$subscribe_tabStore($$invalidate(1, tabStore = $$props2.tabStore));
    if ("presetStore" in $$props2)
      $$invalidate(2, presetStore = $$props2.presetStore);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$position*/
    64) {
      storeAppState($position);
    }
  };
  return [
    storageStore,
    tabStore,
    presetStore,
    $tabStore,
    headerList,
    position,
    $position,
    click_handler
  ];
}
class OptionsInfo extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$17, create_fragment$19, safe_not_equal, {
      storageStore: 0,
      tabStore: 1,
      presetStore: 2
    });
  }
}
class OptionsDialog extends TJSDialog {
  static #app;
  static #tabStore = writable$1("melee");
  static #presetStore = writable$1("proToTemp");
  constructor(data2) {
    super({
      title: "Options Info",
      resizable: true,
      content: {
        class: OptionsInfo,
        props: {
          ...data2,
          storageStore: aaSessionStorage.getStore(sessionConstants.optionsInfoAppState),
          tabStore: OptionsDialog.#tabStore,
          presetStore: OptionsDialog.#presetStore
        }
      }
    });
    try {
      this.state.set(aaSessionStorage.getItem(sessionConstants.optionsInfoAppState));
    } catch (err) {
    }
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      minimizable: true,
      width: 600,
      height: 600,
      closeOnSubmit: true,
      id: `OptionsInformation`
    });
  }
  /**
   * Close the instance of OptionsInformation and remove reference to single static app reference.
   *
   * @inheritDoc
   */
  async close(options2) {
    await super.close(options2);
    OptionsDialog.#app = void 0;
  }
  /**
   * Show a single static instance of OptionsInformation; if it is already open then bring it to top.
   */
  static show(tabId, presetId) {
    OptionsDialog.#tabStore.set(tabId);
    OptionsDialog.#presetStore.set(presetId || "proToTemp");
    if (this.#app) {
      this.#app.bringToTop();
    } else {
      this.#app = new OptionsDialog().render(true, { focus: true });
    }
  }
}
const WaitDelay_svelte_svelte_type_style_lang = "";
function create_fragment$18(ctx) {
  let div2;
  let div0;
  let label0;
  let t0;
  let label0_class_value;
  let t1;
  let label1;
  let t3;
  let label2;
  let t4;
  let label2_class_value;
  let t5;
  let div1;
  let input;
  let div2_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      t0 = text(
        /*delayLabel*/
        ctx[8]
      );
      t1 = space();
      label1 = element("label");
      label1.textContent = "|";
      t3 = space();
      label2 = element("label");
      t4 = text(
        /*waitLabel*/
        ctx[9]
      );
      t5 = space();
      div1 = element("div");
      input = element("input");
      attr(label0, "for", "");
      attr(label0, "class", label0_class_value = "aaLabelBorder " + (!/*isWait*/
      ctx[6] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv");
      attr(label0, "role", "presentation");
      attr(label1, "for", "");
      attr(label2, "for", "");
      attr(label2, "class", label2_class_value = "aaLabelBorder " + /*isWait*/
      (ctx[6] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv");
      attr(label2, "role", "presentation");
      attr(input, "type", "number");
      attr(
        input,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      attr(
        input,
        "step",
        /*step*/
        ctx[4]
      );
      attr(div2, "class", div2_class_value = null_to_empty(
        /*isDisabled*/
        ctx[2]
      ) + " svelte-auto-bsgjrv");
    },
    m(target2, anchor) {
      insert(target2, div2, anchor);
      append(div2, div0);
      append(div0, label0);
      append(label0, t0);
      append(div0, t1);
      append(div0, label1);
      append(div0, t3);
      append(div0, label2);
      append(label2, t4);
      append(div2, t5);
      append(div2, div1);
      append(div1, input);
      set_input_value(
        input,
        /*$animation*/
        ctx[5][
          /*section*/
          ctx[0]
        ].options[
          /*field*/
          ctx[1]
        ]
      );
      if (!mounted) {
        dispose = [
          listen(
            label0,
            "click",
            /*click_handler*/
            ctx[12]
          ),
          listen(
            label2,
            "click",
            /*click_handler_1*/
            ctx[13]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isWait*/
      64 && label0_class_value !== (label0_class_value = "aaLabelBorder " + (!/*isWait*/
      ctx2[6] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv")) {
        attr(label0, "class", label0_class_value);
      }
      if (dirty & /*isWait*/
      64 && label2_class_value !== (label2_class_value = "aaLabelBorder " + /*isWait*/
      (ctx2[6] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv")) {
        attr(label2, "class", label2_class_value);
      }
      if (dirty & /*placeholder*/
      8) {
        attr(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (dirty & /*step*/
      16) {
        attr(
          input,
          "step",
          /*step*/
          ctx2[4]
        );
      }
      if (dirty & /*$animation, section, field*/
      35 && to_number(input.value) !== /*$animation*/
      ctx2[5][
        /*section*/
        ctx2[0]
      ].options[
        /*field*/
        ctx2[1]
      ]) {
        set_input_value(
          input,
          /*$animation*/
          ctx2[5][
            /*section*/
            ctx2[0]
          ].options[
            /*field*/
            ctx2[1]
          ]
        );
      }
      if (dirty & /*isDisabled*/
      4 && div2_class_value !== (div2_class_value = null_to_empty(
        /*isDisabled*/
        ctx2[2]
      ) + " svelte-auto-bsgjrv")) {
        attr(div2, "class", div2_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$16($$self, $$props, $$invalidate) {
  let isWait;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(5, $animation = value));
  let { section: section2 = "primary" } = $$props;
  let { field = "delay" } = $$props;
  let { isDisabled = "" } = $$props;
  let { placeholder = 0 } = $$props;
  let { step = 1 } = $$props;
  const delayLabel = game.i18n.localize("autoanimations.menus.delay");
  const waitLabel = game.i18n.localize("autoanimations.menus.wait");
  function switchWait() {
    if (!animation._data[section2].options.isWait) {
      return;
    }
    set_store_value(animation, $animation[section2].options.isWait = false, $animation);
  }
  function switchDelay() {
    if (animation._data[section2].options.isWait) {
      return;
    }
    set_store_value(animation, $animation[section2].options.isWait = true, $animation);
  }
  const click_handler = () => switchWait();
  const click_handler_1 = () => switchDelay();
  function input_input_handler() {
    $animation[section2].options[field] = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
    if ("isDisabled" in $$props2)
      $$invalidate(2, isDisabled = $$props2.isDisabled);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("step" in $$props2)
      $$invalidate(4, step = $$props2.step);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation, section*/
    33) {
      $$invalidate(6, isWait = $animation[section2].options.isWait);
    }
  };
  return [
    section2,
    field,
    isDisabled,
    placeholder,
    step,
    $animation,
    isWait,
    animation,
    delayLabel,
    waitLabel,
    switchWait,
    switchDelay,
    click_handler,
    click_handler_1,
    input_input_handler
  ];
}
class WaitDelay extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$16, create_fragment$18, safe_not_equal, {
      section: 0,
      field: 1,
      isDisabled: 2,
      placeholder: 3,
      step: 4
    });
  }
}
function create_default_slot$w(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let div0;
  let label0;
  let t1_value = localize("autoanimations.menus.bind") + " " + localize("autoanimations.menus.visibility");
  let t1;
  let t2;
  let input0;
  let t3;
  let td2;
  let div1;
  let label1;
  let t4_value = localize("autoanimations.menus.bind") + " " + localize("autoanimations.menus.alpha");
  let t4;
  let t5;
  let input1;
  let t6;
  let tr1;
  let td3;
  let opacity;
  let t7;
  let td4;
  let numberinput0;
  let t8;
  let td5;
  let div2;
  let label2;
  let strong;
  let t10;
  let div3;
  let label3;
  let t12;
  let tr2;
  let td6;
  let numberinput1;
  let t13;
  let td7;
  let div4;
  let label4;
  let t14_value = localize("autoanimations.menus.add") + "";
  let t14;
  let t15;
  let t16_value = localize("autoanimations.menus.token") + "";
  let t16;
  let t17;
  let t18_value = localize("autoanimations.menus.width") + "";
  let t18;
  let t19;
  let input2;
  let t20;
  let td8;
  let numberinput2;
  let t21;
  let tr3;
  let td9;
  let numberinput3;
  let t22;
  let td10;
  let waitdelay;
  let t23;
  let td11;
  let numberinput4;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation$1({ props: { section: "primary" } });
  opacity = new Opacity$1({ props: { section: "primary" } });
  numberinput0 = new NumberInput({
    props: {
      label: localize("autoanimations.menus.z-index"),
      section: "primary",
      field: "zIndex",
      step: "1"
    }
  });
  numberinput1 = new NumberInput({
    props: {
      label: localize("autoanimations.menus.radius"),
      section: "primary",
      field: "size",
      step: "0.01"
    }
  });
  numberinput2 = new NumberInput({
    props: {
      label: localize("autoanimations.menus.fadeIn"),
      section: "primary",
      field: "fadeIn",
      step: "1"
    }
  });
  numberinput3 = new NumberInput({
    props: {
      label: localize("autoanimations.menus.fadeOut"),
      section: "primary",
      field: "fadeOut",
      step: "1"
    }
  });
  waitdelay = new WaitDelay({ props: { section: "primary" } });
  numberinput4 = new NumberInput({
    props: {
      label: localize("autoanimations.menus.playbackRate"),
      section: "primary",
      field: "playbackRate"
    }
  });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      div0 = element("div");
      label0 = element("label");
      t1 = text(t1_value);
      t2 = space();
      input0 = element("input");
      t3 = space();
      td2 = element("td");
      div1 = element("div");
      label1 = element("label");
      t4 = text(t4_value);
      t5 = space();
      input1 = element("input");
      t6 = space();
      tr1 = element("tr");
      td3 = element("td");
      create_component(opacity.$$.fragment);
      t7 = space();
      td4 = element("td");
      create_component(numberinput0.$$.fragment);
      t8 = space();
      td5 = element("td");
      div2 = element("div");
      label2 = element("label");
      strong = element("strong");
      strong.textContent = `${localize("autoanimations.menus.playOn")}`;
      t10 = space();
      div3 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.source")}`;
      t12 = space();
      tr2 = element("tr");
      td6 = element("td");
      create_component(numberinput1.$$.fragment);
      t13 = space();
      td7 = element("td");
      div4 = element("div");
      label4 = element("label");
      t14 = text(t14_value);
      t15 = space();
      t16 = text(t16_value);
      t17 = space();
      t18 = text(t18_value);
      t19 = space();
      input2 = element("input");
      t20 = space();
      td8 = element("td");
      create_component(numberinput2.$$.fragment);
      t21 = space();
      tr3 = element("tr");
      td9 = element("td");
      create_component(numberinput3.$$.fragment);
      t22 = space();
      td10 = element("td");
      create_component(waitdelay.$$.fragment);
      t23 = space();
      td11 = element("td");
      create_component(numberinput4.$$.fragment);
      attr(label0, "for", "Vis " + /*animation*/
      ctx[1]._data.id);
      attr(input0, "type", "checkbox");
      attr(input0, "id", "Vis " + /*animation*/
      ctx[1]._data.id);
      attr(label1, "for", "Alpha " + /*animation*/
      ctx[1]._data.id);
      attr(input1, "type", "checkbox");
      attr(input1, "id", "Alpha " + /*animation*/
      ctx[1]._data.id);
      attr(label2, "for", "");
      attr(label3, "for", "");
      attr(label4, "for", "Width " + /*animation*/
      ctx[1]._data.id);
      attr(input2, "type", "checkbox");
      attr(input2, "id", "Width " + /*animation*/
      ctx[1]._data.id);
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      append(td1, div0);
      append(div0, label0);
      append(label0, t1);
      append(div0, t2);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[0].primary.options.unbindVisibility;
      append(tr0, t3);
      append(tr0, td2);
      append(td2, div1);
      append(div1, label1);
      append(label1, t4);
      append(div1, t5);
      append(div1, input1);
      input1.checked = /*$animation*/
      ctx[0].primary.options.unbindAlpha;
      append(table, t6);
      append(table, tr1);
      append(tr1, td3);
      mount_component(opacity, td3, null);
      append(tr1, t7);
      append(tr1, td4);
      mount_component(numberinput0, td4, null);
      append(tr1, t8);
      append(tr1, td5);
      append(td5, div2);
      append(div2, label2);
      append(label2, strong);
      append(td5, t10);
      append(td5, div3);
      append(div3, label3);
      append(table, t12);
      append(table, tr2);
      append(tr2, td6);
      mount_component(numberinput1, td6, null);
      append(tr2, t13);
      append(tr2, td7);
      append(td7, div4);
      append(div4, label4);
      append(label4, t14);
      append(label4, t15);
      append(label4, t16);
      append(label4, t17);
      append(label4, t18);
      append(div4, t19);
      append(div4, input2);
      input2.checked = /*$animation*/
      ctx[0].primary.options.addTokenWidth;
      append(tr2, t20);
      append(tr2, td8);
      mount_component(numberinput2, td8, null);
      append(table, t21);
      append(table, tr3);
      append(tr3, td9);
      mount_component(numberinput3, td9, null);
      append(tr3, t22);
      append(tr3, td10);
      mount_component(waitdelay, td10, null);
      append(tr3, t23);
      append(tr3, td11);
      mount_component(numberinput4, td11, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[5]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[6]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].primary.options.unbindVisibility;
      }
      if (dirty & /*$animation*/
      1) {
        input1.checked = /*$animation*/
        ctx2[0].primary.options.unbindAlpha;
      }
      if (dirty & /*$animation*/
      1) {
        input2.checked = /*$animation*/
        ctx2[0].primary.options.addTokenWidth;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(waitdelay.$$.fragment, local);
      transition_in(numberinput4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(waitdelay.$$.fragment, local);
      transition_out(numberinput4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(opacity);
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(numberinput2);
      destroy_component(numberinput3);
      destroy_component(waitdelay);
      destroy_component(numberinput4);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$o(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[3]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[4]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$17(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[2]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$o],
        default: [create_default_slot$w]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation*/
      513) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$15($$self, $$props, $$invalidate) {
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    },
    label: game.i18n.localize("autoanimations.menus.options")
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    }
  };
  const click_handler = () => OptionsDialog.show("aura");
  function input0_change_handler() {
    $animation.primary.options.unbindVisibility = this.checked;
    animation.set($animation);
  }
  function input1_change_handler() {
    $animation.primary.options.unbindAlpha = this.checked;
    animation.set($animation);
  }
  function input2_change_handler() {
    $animation.primary.options.addTokenWidth = this.checked;
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $animation.primary.options.enableFilter;
    }
  };
  return [
    $animation,
    animation,
    folder,
    optionsInfo,
    click_handler,
    input0_change_handler,
    input1_change_handler,
    input2_change_handler
  ];
}
let AuraOptions$1 = class AuraOptions2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$15, create_fragment$17, safe_not_equal, {});
  }
};
function create_default_slot$v(ctx) {
  let div14;
  let div3;
  let div0;
  let i0;
  let i0_class_value;
  let t0;
  let div1;
  let input0;
  let t1;
  let div2;
  let i1;
  let t2;
  let table;
  let tr0;
  let td0;
  let div4;
  let label0;
  let t7;
  let div5;
  let input1;
  let t8;
  let td1;
  let div6;
  let label1;
  let t10;
  let div7;
  let input2;
  let t11;
  let td2;
  let div8;
  let label2;
  let t13;
  let div9;
  let input3;
  let t14;
  let tr1;
  let td3;
  let div10;
  let label3;
  let t16;
  let div11;
  let input4;
  let t17;
  let td4;
  let div12;
  let label4;
  let t21;
  let div13;
  let input5;
  let div14_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div14 = element("div");
      div3 = element("div");
      div0 = element("div");
      i0 = element("i");
      t0 = space();
      div1 = element("div");
      input0 = element("input");
      t1 = space();
      div2 = element("div");
      i1 = element("i");
      t2 = space();
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div4 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.start")} 
                                ${localize("autoanimations.menus.time")} (ms)`;
      t7 = space();
      div5 = element("div");
      input1 = element("input");
      t8 = space();
      td1 = element("td");
      div6 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.volume")}`;
      t10 = space();
      div7 = element("div");
      input2 = element("input");
      t11 = space();
      td2 = element("td");
      div8 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.delay")}`;
      t13 = space();
      div9 = element("div");
      input3 = element("input");
      t14 = space();
      tr1 = element("tr");
      td3 = element("td");
      div10 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.repeat")}`;
      t16 = space();
      div11 = element("div");
      input4 = element("input");
      t17 = space();
      td4 = element("td");
      div12 = element("div");
      label4 = element("label");
      label4.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t21 = space();
      div13 = element("div");
      input5 = element("input");
      attr(i0, "class", i0_class_value = "fas fa-music aa-blue " + /*isValid*/
      (ctx[2] ? "" : "aa-disableOpacity"));
      set_style(i0, "font-size", "1.5em");
      attr(i0, "title", "Play Sound");
      attr(i0, "role", "presentation");
      set_style(div0, "grid-row", "1/2");
      set_style(div0, "grid-column", "1/2");
      attr(input0, "type", "text");
      set_style(input0, "font-weight", "normal");
      set_style(input0, "font-size", "small");
      set_style(div1, "grid-row", "1/2");
      set_style(div1, "grid-column", "2/3");
      attr(i1, "class", "fas fa-file-import");
      attr(i1, "title", "File Picker");
      set_style(i1, "font-size", "1.5em");
      attr(i1, "role", "presentation");
      set_style(div2, "grid-row", "1/2");
      set_style(div2, "grid-column", "3/4");
      attr(div3, "class", "aa-Sound-container");
      attr(label0, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "0");
      attr(input1, "step", "0.01");
      attr(label1, "for", "");
      attr(input2, "type", "number");
      attr(input2, "placeholder", "0.5");
      attr(input2, "step", "0.01");
      attr(label2, "for", "");
      attr(input3, "type", "number");
      attr(input3, "placeholder", "0");
      attr(input3, "step", "0.01");
      attr(label3, "for", "");
      attr(input4, "type", "number");
      attr(input4, "placeholder", "1");
      attr(input4, "step", "1");
      attr(label4, "for", "");
      attr(input5, "type", "number");
      attr(input5, "placeholder", "250");
      attr(input5, "step", "1");
      attr(table, "class", "d");
      attr(div14, "class", div14_class_value = !/*$animation*/
      ctx[1][
        /*section*/
        ctx[0]
      ].sound.enable ? "aa-disableOpacity" : "");
    },
    m(target2, anchor) {
      insert(target2, div14, anchor);
      append(div14, div3);
      append(div3, div0);
      append(div0, i0);
      append(div3, t0);
      append(div3, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[1][
          /*section*/
          ctx[0]
        ].sound.file
      );
      append(div3, t1);
      append(div3, div2);
      append(div2, i1);
      append(div14, t2);
      append(div14, table);
      append(table, tr0);
      append(tr0, td0);
      append(td0, div4);
      append(div4, label0);
      append(td0, t7);
      append(td0, div5);
      append(div5, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[1][
          /*section*/
          ctx[0]
        ].sound.startTime
      );
      append(tr0, t8);
      append(tr0, td1);
      append(td1, div6);
      append(div6, label1);
      append(td1, t10);
      append(td1, div7);
      append(div7, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[1][
          /*section*/
          ctx[0]
        ].sound.volume
      );
      append(tr0, t11);
      append(tr0, td2);
      append(td2, div8);
      append(div8, label2);
      append(td2, t13);
      append(td2, div9);
      append(div9, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[1][
          /*section*/
          ctx[0]
        ].sound.delay
      );
      append(table, t14);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div10);
      append(div10, label3);
      append(td3, t16);
      append(td3, div11);
      append(div11, input4);
      set_input_value(
        input4,
        /*$animation*/
        ctx[1][
          /*section*/
          ctx[0]
        ].sound.repeat
      );
      append(tr1, t17);
      append(tr1, td4);
      append(td4, div12);
      append(div12, label4);
      append(td4, t21);
      append(td4, div13);
      append(div13, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[1][
          /*section*/
          ctx[0]
        ].sound.repeatDelay
      );
      if (!mounted) {
        dispose = [
          listen(
            i0,
            "click",
            /*click_handler*/
            ctx[10]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[11]
          ),
          listen(i1, "click", prevent_default(
            /*click_handler_1*/
            ctx[12]
          )),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[13]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[14]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[15]
          ),
          listen(
            input4,
            "input",
            /*input4_input_handler*/
            ctx[16]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler*/
            ctx[17]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*isValid*/
      4 && i0_class_value !== (i0_class_value = "fas fa-music aa-blue " + /*isValid*/
      (ctx2[2] ? "" : "aa-disableOpacity"))) {
        attr(i0, "class", i0_class_value);
      }
      if (dirty & /*$animation, section*/
      3 && input0.value !== /*$animation*/
      ctx2[1][
        /*section*/
        ctx2[0]
      ].sound.file) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[1][
            /*section*/
            ctx2[0]
          ].sound.file
        );
      }
      if (dirty & /*$animation, section*/
      3 && to_number(input1.value) !== /*$animation*/
      ctx2[1][
        /*section*/
        ctx2[0]
      ].sound.startTime) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[1][
            /*section*/
            ctx2[0]
          ].sound.startTime
        );
      }
      if (dirty & /*$animation, section*/
      3 && to_number(input2.value) !== /*$animation*/
      ctx2[1][
        /*section*/
        ctx2[0]
      ].sound.volume) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[1][
            /*section*/
            ctx2[0]
          ].sound.volume
        );
      }
      if (dirty & /*$animation, section*/
      3 && to_number(input3.value) !== /*$animation*/
      ctx2[1][
        /*section*/
        ctx2[0]
      ].sound.delay) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[1][
            /*section*/
            ctx2[0]
          ].sound.delay
        );
      }
      if (dirty & /*$animation, section*/
      3 && to_number(input4.value) !== /*$animation*/
      ctx2[1][
        /*section*/
        ctx2[0]
      ].sound.repeat) {
        set_input_value(
          input4,
          /*$animation*/
          ctx2[1][
            /*section*/
            ctx2[0]
          ].sound.repeat
        );
      }
      if (dirty & /*$animation, section*/
      3 && to_number(input5.value) !== /*$animation*/
      ctx2[1][
        /*section*/
        ctx2[0]
      ].sound.repeatDelay) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[1][
            /*section*/
            ctx2[0]
          ].sound.repeatDelay
        );
      }
      if (dirty & /*$animation, section*/
      3 && div14_class_value !== (div14_class_value = !/*$animation*/
      ctx2[1][
        /*section*/
        ctx2[0]
      ].sound.enable ? "aa-disableOpacity" : "")) {
        attr(div14, "class", div14_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div14);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$n(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Sound On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[1][
        /*section*/
        ctx[0]
      ].sound.enable;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[8]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation, section*/
      3) {
        input.checked = /*$animation*/
        ctx2[1][
          /*section*/
          ctx2[0]
        ].sound.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$16(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[6]
      ),
      label: localize("autoanimations.menus.sound"),
      $$slots: {
        "summary-end": [create_summary_end_slot$n],
        default: [create_default_slot$v]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-sound-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, section, isValid*/
      262151) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$14($$self, $$props, $$invalidate) {
  let isValid;
  let $animation;
  let { section: section2 } = $$props;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(1, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  if (!$animation[section2].sound) {
    set_store_value(
      animation,
      $animation[section2].sound = {
        enable: false,
        delay: 0,
        file: "",
        repeat: 1,
        repeatDelay: 250,
        startTime: 0,
        volume: 0.75
      },
      $animation
    );
  }
  function checkMeta() {
    delete $animation.metaData;
  }
  function input_change_handler() {
    $animation[section2].sound.enable = this.checked;
    animation.set($animation);
  }
  const change_handler = () => checkMeta();
  const click_handler = () => category.playSound(animation._data[section2].sound);
  function input0_input_handler() {
    $animation[section2].sound.file = this.value;
    animation.set($animation);
  }
  const click_handler_1 = () => category.selectSound(section2, idx);
  function input1_input_handler() {
    $animation[section2].sound.startTime = to_number(this.value);
    animation.set($animation);
  }
  function input2_input_handler() {
    $animation[section2].sound.volume = to_number(this.value);
    animation.set($animation);
  }
  function input3_input_handler() {
    $animation[section2].sound.delay = to_number(this.value);
    animation.set($animation);
  }
  function input4_input_handler() {
    $animation[section2].sound.repeat = to_number(this.value);
    animation.set($animation);
  }
  function input5_input_handler() {
    $animation[section2].sound.repeatDelay = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation, section*/
    3) {
      $$invalidate(2, isValid = $animation[section2].sound.file && $animation[section2].sound.enable);
    }
  };
  return [
    section2,
    $animation,
    isValid,
    animation,
    category,
    idx,
    folder,
    checkMeta,
    input_change_handler,
    change_handler,
    click_handler,
    input0_input_handler,
    click_handler_1,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    input4_input_handler,
    input5_input_handler
  ];
}
class SoundSettings extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$14, create_fragment$16, safe_not_equal, { section: 0 });
  }
}
const ScaleRadius_svelte_svelte_type_style_lang$1 = "";
function create_fragment$15(ctx) {
  let div2;
  let div0;
  let label0;
  let t0;
  let label0_class_value;
  let t1;
  let label1;
  let t3;
  let label2;
  let t4;
  let label2_class_value;
  let t5;
  let div1;
  let input;
  let div2_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      t0 = text(
        /*scaleLabel*/
        ctx[8]
      );
      t1 = space();
      label1 = element("label");
      label1.textContent = "|";
      t3 = space();
      label2 = element("label");
      t4 = text(
        /*radiusLabel*/
        ctx[9]
      );
      t5 = space();
      div1 = element("div");
      input = element("input");
      attr(label0, "for", "");
      attr(label0, "class", label0_class_value = "aaLabelBorder " + (!/*isRadius*/
      ctx[6] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv");
      attr(label0, "role", "presentation");
      attr(label1, "for", "");
      attr(label2, "for", "");
      attr(label2, "class", label2_class_value = "aaLabelBorder " + /*isRadius*/
      (ctx[6] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv");
      attr(label2, "role", "presentation");
      attr(input, "type", "number");
      attr(
        input,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      attr(
        input,
        "step",
        /*step*/
        ctx[4]
      );
      attr(div2, "class", div2_class_value = null_to_empty(
        /*isDisabled*/
        ctx[2]
      ) + " svelte-auto-bsgjrv");
    },
    m(target2, anchor) {
      insert(target2, div2, anchor);
      append(div2, div0);
      append(div0, label0);
      append(label0, t0);
      append(div0, t1);
      append(div0, label1);
      append(div0, t3);
      append(div0, label2);
      append(label2, t4);
      append(div2, t5);
      append(div2, div1);
      append(div1, input);
      set_input_value(
        input,
        /*$animation*/
        ctx[5][
          /*section*/
          ctx[0]
        ].options[
          /*field*/
          ctx[1]
        ]
      );
      if (!mounted) {
        dispose = [
          listen(
            label0,
            "click",
            /*click_handler*/
            ctx[12]
          ),
          listen(
            label2,
            "click",
            /*click_handler_1*/
            ctx[13]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isRadius*/
      64 && label0_class_value !== (label0_class_value = "aaLabelBorder " + (!/*isRadius*/
      ctx2[6] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv")) {
        attr(label0, "class", label0_class_value);
      }
      if (dirty & /*isRadius*/
      64 && label2_class_value !== (label2_class_value = "aaLabelBorder " + /*isRadius*/
      (ctx2[6] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv")) {
        attr(label2, "class", label2_class_value);
      }
      if (dirty & /*placeholder*/
      8) {
        attr(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (dirty & /*step*/
      16) {
        attr(
          input,
          "step",
          /*step*/
          ctx2[4]
        );
      }
      if (dirty & /*$animation, section, field*/
      35 && to_number(input.value) !== /*$animation*/
      ctx2[5][
        /*section*/
        ctx2[0]
      ].options[
        /*field*/
        ctx2[1]
      ]) {
        set_input_value(
          input,
          /*$animation*/
          ctx2[5][
            /*section*/
            ctx2[0]
          ].options[
            /*field*/
            ctx2[1]
          ]
        );
      }
      if (dirty & /*isDisabled*/
      4 && div2_class_value !== (div2_class_value = null_to_empty(
        /*isDisabled*/
        ctx2[2]
      ) + " svelte-auto-bsgjrv")) {
        attr(div2, "class", div2_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$13($$self, $$props, $$invalidate) {
  let isRadius;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(5, $animation = value));
  let { section: section2 } = $$props;
  let { field } = $$props;
  let { isDisabled = "" } = $$props;
  let { placeholder = 1 } = $$props;
  let { step = 1 } = $$props;
  const scaleLabel = game.i18n.localize("autoanimations.menus.scale");
  const radiusLabel = game.i18n.localize("autoanimations.menus.radius");
  function switchScale() {
    if (!animation._data[section2].options.isRadius) {
      return;
    }
    set_store_value(animation, $animation[section2].options.isRadius = false, $animation);
  }
  function switchRadius() {
    if (animation._data[section2].options.isRadius) {
      return;
    }
    set_store_value(animation, $animation[section2].options.isRadius = true, $animation);
  }
  const click_handler = () => switchScale();
  const click_handler_1 = () => switchRadius();
  function input_input_handler() {
    $animation[section2].options[field] = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
    if ("isDisabled" in $$props2)
      $$invalidate(2, isDisabled = $$props2.isDisabled);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("step" in $$props2)
      $$invalidate(4, step = $$props2.step);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation, section*/
    33) {
      $$invalidate(6, isRadius = $animation[section2].options.isRadius);
    }
  };
  return [
    section2,
    field,
    isDisabled,
    placeholder,
    step,
    $animation,
    isRadius,
    animation,
    scaleLabel,
    radiusLabel,
    switchScale,
    switchRadius,
    click_handler,
    click_handler_1,
    input_input_handler
  ];
}
let ScaleRadius$1 = class ScaleRadius2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$13, create_fragment$15, safe_not_equal, {
      section: 0,
      field: 1,
      isDisabled: 2,
      placeholder: 3,
      step: 4
    });
  }
};
function create_default_slot$u(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let numberinput0;
  let t1;
  let td2;
  let numberinput1;
  let t2;
  let tr1;
  let td3;
  let div0;
  let label0;
  let t3_value = localize("autoanimations.menus.mask") + "";
  let t3;
  let t4;
  let input0;
  let t5;
  let td4;
  let opacity;
  let t6;
  let td5;
  let numberinput2;
  let t7;
  let tr2;
  let td6;
  let scaleradius;
  let t8;
  let td7;
  let div1;
  let label1;
  let t9_value = localize("autoanimations.menus.add") + "";
  let t9;
  let t10;
  let t11_value = localize("autoanimations.menus.token") + "";
  let t11;
  let t12;
  let t13_value = localize("autoanimations.menus.width") + "";
  let t13;
  let t14;
  let input1;
  let div1_class_value;
  let t15;
  let td8;
  let div2;
  let label2;
  let t17;
  let div3;
  let input2;
  let t18;
  let tr3;
  let td9;
  let numberinput3;
  let t19;
  let td10;
  let numberinput4;
  let t20;
  let td11;
  let numberinput5;
  let t21;
  let tr4;
  let td12;
  let div4;
  let label3;
  let t22_value = localize("autoanimations.menus.persistant") + "";
  let t22;
  let t23;
  let input3;
  let t24;
  let td13;
  let waitdelay;
  let t25;
  let td14;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation$1({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      section: "source"
    }
  });
  numberinput0 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.repeat"),
      section: "source",
      field: "repeat"
    }
  });
  numberinput1 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.repeat") + " " + localize("autoanimations.menus.delay"),
      section: "source",
      field: "repeatDelay",
      placeholder: "250"
    }
  });
  opacity = new Opacity$1({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      section: "source"
    }
  });
  numberinput2 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.z-index"),
      section: "source",
      field: "zIndex"
    }
  });
  scaleradius = new ScaleRadius$1({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      section: "source",
      field: "size",
      step: "0.01"
    }
  });
  numberinput3 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.fadeIn"),
      section: "source",
      field: "fadeIn",
      placeholder: "250"
    }
  });
  numberinput4 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.playbackRate"),
      section: "source",
      field: "playbackRate"
    }
  });
  numberinput5 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.fadeOut"),
      section: "source",
      field: "fadeOut",
      placeholder: "500"
    }
  });
  waitdelay = new WaitDelay({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      section: "source"
    }
  });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      create_component(numberinput0.$$.fragment);
      t1 = space();
      td2 = element("td");
      create_component(numberinput1.$$.fragment);
      t2 = space();
      tr1 = element("tr");
      td3 = element("td");
      div0 = element("div");
      label0 = element("label");
      t3 = text(t3_value);
      t4 = space();
      input0 = element("input");
      t5 = space();
      td4 = element("td");
      create_component(opacity.$$.fragment);
      t6 = space();
      td5 = element("td");
      create_component(numberinput2.$$.fragment);
      t7 = space();
      tr2 = element("tr");
      td6 = element("td");
      create_component(scaleradius.$$.fragment);
      t8 = space();
      td7 = element("td");
      div1 = element("div");
      label1 = element("label");
      t9 = text(t9_value);
      t10 = space();
      t11 = text(t11_value);
      t12 = space();
      t13 = text(t13_value);
      t14 = space();
      input1 = element("input");
      t15 = space();
      td8 = element("td");
      div2 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.anchor")}`;
      t17 = space();
      div3 = element("div");
      input2 = element("input");
      t18 = space();
      tr3 = element("tr");
      td9 = element("td");
      create_component(numberinput3.$$.fragment);
      t19 = space();
      td10 = element("td");
      create_component(numberinput4.$$.fragment);
      t20 = space();
      td11 = element("td");
      create_component(numberinput5.$$.fragment);
      t21 = space();
      tr4 = element("tr");
      td12 = element("td");
      div4 = element("div");
      label3 = element("label");
      t22 = text(t22_value);
      t23 = space();
      input3 = element("input");
      t24 = space();
      td13 = element("td");
      create_component(waitdelay.$$.fragment);
      t25 = space();
      td14 = element("td");
      attr(input0, "type", "checkbox");
      attr(input0, "id", "SMasked " + /*animation*/
      ctx[2]._data.id);
      attr(label0, "for", "SMasked " + /*animation*/
      ctx[2]._data.id);
      attr(label1, "for", "SWidth " + /*animation*/
      ctx[2]._data.id);
      attr(input1, "type", "checkbox");
      attr(input1, "id", "SWidth " + /*animation*/
      ctx[2]._data.id);
      attr(div1, "class", div1_class_value = /*isRadius*/
      ctx[1] ? "" : "aa-disableOpacity");
      attr(label2, "for", "");
      attr(input2, "type", "text");
      attr(input2, "placeholder", "0.5");
      attr(input3, "type", "checkbox");
      attr(input3, "id", "Persist " + /*animation*/
      ctx[2]._data.id);
      attr(label3, "for", "Persist " + /*animation*/
      ctx[2]._data.id);
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      mount_component(numberinput0, td1, null);
      append(tr0, t1);
      append(tr0, td2);
      mount_component(numberinput1, td2, null);
      append(table, t2);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div0);
      append(div0, label0);
      append(label0, t3);
      append(label0, t4);
      append(label0, input0);
      input0.checked = /*$animation*/
      ctx[0].source.options.isMasked;
      append(tr1, t5);
      append(tr1, td4);
      mount_component(opacity, td4, null);
      append(tr1, t6);
      append(tr1, td5);
      mount_component(numberinput2, td5, null);
      append(table, t7);
      append(table, tr2);
      append(tr2, td6);
      mount_component(scaleradius, td6, null);
      append(tr2, t8);
      append(tr2, td7);
      append(td7, div1);
      append(div1, label1);
      append(label1, t9);
      append(label1, t10);
      append(label1, t11);
      append(label1, t12);
      append(label1, t13);
      append(div1, t14);
      append(div1, input1);
      input1.checked = /*$animation*/
      ctx[0].source.options.addTokenWidth;
      append(tr2, t15);
      append(tr2, td8);
      append(td8, div2);
      append(div2, label2);
      append(td8, t17);
      append(td8, div3);
      append(div3, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].source.options.anchor
      );
      append(table, t18);
      append(table, tr3);
      append(tr3, td9);
      mount_component(numberinput3, td9, null);
      append(tr3, t19);
      append(tr3, td10);
      mount_component(numberinput4, td10, null);
      append(tr3, t20);
      append(tr3, td11);
      mount_component(numberinput5, td11, null);
      append(table, t21);
      append(table, tr4);
      append(tr4, td12);
      append(td12, div4);
      append(div4, label3);
      append(label3, t22);
      append(label3, t23);
      append(label3, input3);
      input3.checked = /*$animation*/
      ctx[0].source.options.persistent;
      append(tr4, t24);
      append(tr4, td13);
      mount_component(waitdelay, td13, null);
      append(tr4, t25);
      append(tr4, td14);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[7]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[8]
          ),
          listen(
            input3,
            "change",
            /*input3_change_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].source.options.isMasked;
      }
      if (dirty & /*$animation*/
      1) {
        input1.checked = /*$animation*/
        ctx2[0].source.options.addTokenWidth;
      }
      if (!current || dirty & /*isRadius*/
      2 && div1_class_value !== (div1_class_value = /*isRadius*/
      ctx2[1] ? "" : "aa-disableOpacity")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*$animation*/
      1 && input2.value !== /*$animation*/
      ctx2[0].source.options.anchor) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].source.options.anchor
        );
      }
      if (dirty & /*$animation*/
      1) {
        input3.checked = /*$animation*/
        ctx2[0].source.options.persistent;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(scaleradius.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(numberinput4.$$.fragment, local);
      transition_in(numberinput5.$$.fragment, local);
      transition_in(waitdelay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(scaleradius.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(numberinput4.$$.fragment, local);
      transition_out(numberinput5.$$.fragment, local);
      transition_out(waitdelay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(opacity);
      destroy_component(numberinput2);
      destroy_component(scaleradius);
      destroy_component(numberinput3);
      destroy_component(numberinput4);
      destroy_component(numberinput5);
      destroy_component(waitdelay);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$m(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[4]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[5]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$14(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[3]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$m],
        default: [create_default_slot$u]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, isRadius*/
      1027) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$12($$self, $$props, $$invalidate) {
  let isRadius;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    },
    label: game.i18n.localize("autoanimations.menus.options")
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    },
    onClickPropagate: false
  };
  const click_handler = () => OptionsDialog.show("ontoken");
  function input0_change_handler() {
    $animation.source.options.isMasked = this.checked;
    animation.set($animation);
  }
  function input1_change_handler() {
    $animation.source.options.addTokenWidth = this.checked;
    animation.set($animation);
  }
  function input2_input_handler() {
    $animation.source.options.anchor = this.value;
    animation.set($animation);
  }
  function input3_change_handler() {
    $animation.source.options.persistent = this.checked;
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, isRadius = $animation.source.options.isRadius);
    }
  };
  return [
    $animation,
    isRadius,
    animation,
    folder,
    optionsInfo,
    click_handler,
    input0_change_handler,
    input1_change_handler,
    input2_input_handler,
    input3_change_handler
  ];
}
class SourceFXOptions extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$12, create_fragment$14, safe_not_equal, {});
  }
}
function create_default_slot$t(ctx) {
  let table;
  let tr;
  let td0;
  let opacity0;
  let t0;
  let td1;
  let opacity1;
  let t1;
  let td2;
  let div0;
  let input0;
  let t2;
  let div1;
  let input1;
  let table_class_value;
  let current;
  let mounted;
  let dispose;
  opacity0 = new Opacity$1({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.contrast"),
      field: "contrast",
      min: "0",
      max: "1",
      placeDefault: "0",
      section: (
        /*section*/
        ctx[0]
      )
    }
  });
  opacity1 = new Opacity$1({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.saturation"),
      field: "saturation",
      min: "-1",
      max: "1",
      placeDefault: "0",
      section: (
        /*section*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      table = element("table");
      tr = element("tr");
      td0 = element("td");
      create_component(opacity0.$$.fragment);
      t0 = space();
      td1 = element("td");
      create_component(opacity1.$$.fragment);
      t1 = space();
      td2 = element("td");
      div0 = element("div");
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      input1 = element("input");
      attr(input0, "type", "Text");
      set_style(input0, "width", "10em");
      set_style(input0, "margin", "auto");
      attr(div0, "class", "flexcol");
      attr(input1, "type", "color");
      attr(input1, "data-edit", "color");
      attr(input1, "id", "tint");
      set_style(input1, "width", "10em");
      set_style(input1, "margin-left", "0");
      attr(div1, "class", "form-group");
      attr(table, "class", table_class_value = "d " + /*tintEnabled*/
      (ctx[2] ? "" : "aa-disableOpacity"));
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr);
      append(tr, td0);
      mount_component(opacity0, td0, null);
      append(tr, t0);
      append(tr, td1);
      mount_component(opacity1, td1, null);
      append(tr, t1);
      append(tr, td2);
      append(td2, div0);
      append(div0, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[1][
          /*section*/
          ctx[0]
        ].options.tintColor
      );
      append(td2, t2);
      append(td2, div1);
      append(div1, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[1][
          /*section*/
          ctx[0]
        ].options.tintColor
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const opacity0_changes = {};
      if (dirty & /*section*/
      1)
        opacity0_changes.section = /*section*/
        ctx2[0];
      opacity0.$set(opacity0_changes);
      const opacity1_changes = {};
      if (dirty & /*section*/
      1)
        opacity1_changes.section = /*section*/
        ctx2[0];
      opacity1.$set(opacity1_changes);
      if (dirty & /*$animation, section*/
      3) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[1][
            /*section*/
            ctx2[0]
          ].options.tintColor
        );
      }
      if (dirty & /*$animation, section*/
      3) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[1][
            /*section*/
            ctx2[0]
          ].options.tintColor
        );
      }
      if (!current || dirty & /*tintEnabled*/
      4 && table_class_value !== (table_class_value = "d " + /*tintEnabled*/
      (ctx2[2] ? "" : "aa-disableOpacity"))) {
        attr(table, "class", table_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(opacity0.$$.fragment, local);
      transition_in(opacity1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(opacity0.$$.fragment, local);
      transition_out(opacity1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(opacity0);
      destroy_component(opacity1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$l(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Enable Color Tint");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[1][
        /*section*/
        ctx[0]
      ].options.tint;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation, section*/
      3) {
        input.checked = /*$animation*/
        ctx2[1][
          /*section*/
          ctx2[0]
        ].options.tint;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$13(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[4]
      ),
      label: localize("autoanimations.menus.colorTint"),
      $$slots: {
        "summary-end": [create_summary_end_slot$l],
        default: [create_default_slot$t]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-effect-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, section, tintEnabled*/
      263) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$11($$self, $$props, $$invalidate) {
  let tintEnabled;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(1, $animation = value));
  let { section: section2 = "primary" } = $$props;
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  function input_change_handler() {
    $animation[section2].options.tint = this.checked;
    animation.set($animation);
  }
  function input0_input_handler() {
    $animation[section2].options.tintColor = this.value;
    animation.set($animation);
  }
  function input1_input_handler() {
    $animation[section2].options.tintColor = this.value;
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation, section*/
    3) {
      $$invalidate(2, tintEnabled = $animation[section2].options.tint);
    }
  };
  return [
    section2,
    $animation,
    tintEnabled,
    animation,
    folder,
    input_change_handler,
    input0_input_handler,
    input1_input_handler
  ];
}
class EffectColor extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$11, create_fragment$13, safe_not_equal, { section: 0 });
  }
}
const ExtraSource_svelte_svelte_type_style_lang = "";
function create_default_slot$s(ctx) {
  let div;
  let videoselect;
  let t0;
  let sourcefxoptions;
  let t1;
  let switch_instance;
  let t2;
  let soundsettings;
  let div_class_value;
  let current;
  videoselect = new VideoSelect({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      section: "source",
      title: (
        /*title*/
        ctx[4]
      ),
      idx: (
        /*idx*/
        ctx[3]
      ),
      category: (
        /*category*/
        ctx[2]
      )
    }
  });
  sourcefxoptions = new SourceFXOptions({
    props: { animation: (
      /*animation*/
      ctx[1]
    ) }
  });
  var switch_value = EffectColor;
  function switch_props(ctx2) {
    return { props: { section: "source" } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  soundsettings = new SoundSettings({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      category: (
        /*category*/
        ctx[2]
      ),
      idx: (
        /*idx*/
        ctx[3]
      ),
      section: "source"
    }
  });
  return {
    c() {
      div = element("div");
      create_component(videoselect.$$.fragment);
      t0 = space();
      create_component(sourcefxoptions.$$.fragment);
      t1 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t2 = space();
      create_component(soundsettings.$$.fragment);
      attr(div, "class", div_class_value = null_to_empty(!/*$animation*/
      ctx[0].source.enable ? "aa-isDisabled" : "") + " svelte-auto-1yddlio");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(videoselect, div, null);
      append(div, t0);
      mount_component(sourcefxoptions, div, null);
      append(div, t1);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append(div, t2);
      mount_component(soundsettings, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = EffectColor)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t2);
        } else {
          switch_instance = null;
        }
      }
      if (!current || dirty & /*$animation*/
      1 && div_class_value !== (div_class_value = null_to_empty(!/*$animation*/
      ctx2[0].source.enable ? "aa-isDisabled" : "") + " svelte-auto-1yddlio")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(videoselect.$$.fragment, local);
      transition_in(sourcefxoptions.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(soundsettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(videoselect.$$.fragment, local);
      transition_out(sourcefxoptions.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(soundsettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(videoselect);
      destroy_component(sourcefxoptions);
      if (switch_instance)
        destroy_component(switch_instance);
      destroy_component(soundsettings);
    }
  };
}
function create_summary_end_slot$k(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Source FX On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[0].source.enable;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[7]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      1) {
        input.checked = /*$animation*/
        ctx2[0].source.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$12(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folderOptions*/
        ctx[5]
      ),
      label: localize("autoanimations.menus.source") + " " + localize("autoanimations.menus.animation"),
      $$slots: {
        "summary-end": [create_summary_end_slot$k],
        default: [create_default_slot$s]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-section-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation*/
      513) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$10($$self, $$props, $$invalidate) {
  let $animation;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  let title2 = "Source " + game.i18n.localize("autoanimations.menus.animation");
  const folderOptions = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  function checkMeta() {
    delete $animation.metaData;
  }
  function input_change_handler() {
    $animation.source.enable = this.checked;
    animation.set($animation);
  }
  const change_handler = () => checkMeta();
  return [
    $animation,
    animation,
    category,
    idx,
    title2,
    folderOptions,
    checkMeta,
    input_change_handler,
    change_handler
  ];
}
class ExtraSource extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$10, create_fragment$12, safe_not_equal, {});
  }
}
function create_default_slot$r(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let numberinput0;
  let t1;
  let td2;
  let numberinput1;
  let t2;
  let tr1;
  let td3;
  let div0;
  let label0;
  let t3_value = localize("autoanimations.menus.mask") + "";
  let t3;
  let t4;
  let input0;
  let t5;
  let td4;
  let opacity;
  let t6;
  let td5;
  let numberinput2;
  let t7;
  let tr2;
  let td6;
  let scaleradius;
  let t8;
  let td7;
  let div1;
  let label1;
  let t9_value = localize("autoanimations.menus.add") + "";
  let t9;
  let t10;
  let t11_value = localize("autoanimations.menus.token") + "";
  let t11;
  let t12;
  let t13_value = localize("autoanimations.menus.width") + "";
  let t13;
  let t14;
  let input1;
  let div1_class_value;
  let t15;
  let td8;
  let numberinput3;
  let t16;
  let tr3;
  let td9;
  let numberinput4;
  let t17;
  let td10;
  let div2;
  let label2;
  let t19;
  let div3;
  let input2;
  let t20;
  let td11;
  let div4;
  let label3;
  let t21_value = localize("autoanimations.menus.sideImpact") + "";
  let t21;
  let t22;
  let input3;
  let t23;
  let tr4;
  let td12;
  let numberinput5;
  let t24;
  let td13;
  let waitdelay;
  let t25;
  let td14;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation$1({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      section: "secondary"
    }
  });
  numberinput0 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.repeat"),
      section: "secondary",
      field: "repeat"
    }
  });
  numberinput1 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.repeat") + " " + localize("autoanimations.menus.delay"),
      section: "secondary",
      field: "repeatDelay"
    }
  });
  opacity = new Opacity$1({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      section: "secondary"
    }
  });
  numberinput2 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.z-index"),
      section: "secondary",
      field: "zIndex"
    }
  });
  scaleradius = new ScaleRadius$1({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      section: "secondary",
      field: "size",
      placeholder: "1.5",
      step: "0.01"
    }
  });
  numberinput3 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.fadeIn"),
      section: "secondary",
      field: "fadeIn",
      placeholder: "250"
    }
  });
  numberinput4 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.fadeOut"),
      section: "secondary",
      field: "fadeOut",
      placeholder: "250"
    }
  });
  numberinput5 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      label: localize("autoanimations.menus.playbackRate"),
      section: "secondary",
      field: "playbackRate"
    }
  });
  waitdelay = new WaitDelay({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      section: "secondary"
    }
  });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      create_component(numberinput0.$$.fragment);
      t1 = space();
      td2 = element("td");
      create_component(numberinput1.$$.fragment);
      t2 = space();
      tr1 = element("tr");
      td3 = element("td");
      div0 = element("div");
      label0 = element("label");
      t3 = text(t3_value);
      t4 = space();
      input0 = element("input");
      t5 = space();
      td4 = element("td");
      create_component(opacity.$$.fragment);
      t6 = space();
      td5 = element("td");
      create_component(numberinput2.$$.fragment);
      t7 = space();
      tr2 = element("tr");
      td6 = element("td");
      create_component(scaleradius.$$.fragment);
      t8 = space();
      td7 = element("td");
      div1 = element("div");
      label1 = element("label");
      t9 = text(t9_value);
      t10 = space();
      t11 = text(t11_value);
      t12 = space();
      t13 = text(t13_value);
      t14 = space();
      input1 = element("input");
      t15 = space();
      td8 = element("td");
      create_component(numberinput3.$$.fragment);
      t16 = space();
      tr3 = element("tr");
      td9 = element("td");
      create_component(numberinput4.$$.fragment);
      t17 = space();
      td10 = element("td");
      div2 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.anchor")}`;
      t19 = space();
      div3 = element("div");
      input2 = element("input");
      t20 = space();
      td11 = element("td");
      div4 = element("div");
      label3 = element("label");
      t21 = text(t21_value);
      t22 = space();
      input3 = element("input");
      t23 = space();
      tr4 = element("tr");
      td12 = element("td");
      create_component(numberinput5.$$.fragment);
      t24 = space();
      td13 = element("td");
      create_component(waitdelay.$$.fragment);
      t25 = space();
      td14 = element("td");
      attr(label0, "for", "EMasked " + /*animation*/
      ctx[2]._data.id);
      attr(input0, "type", "checkbox");
      attr(input0, "id", "EMasked " + /*animation*/
      ctx[2]._data.id);
      attr(label1, "for", "Width2 " + /*animation*/
      ctx[2]._data.id);
      attr(input1, "type", "checkbox");
      attr(input1, "id", "Width2 " + /*animation*/
      ctx[2]._data.id);
      attr(div1, "class", div1_class_value = /*isRadius*/
      ctx[1] ? "" : "aa-disableOpacity");
      attr(label2, "for", "");
      attr(input2, "type", "text");
      attr(input2, "placeholder", "0.5");
      attr(label3, "for", "SecRotate " + /*animation*/
      ctx[2]._data.id);
      attr(input3, "type", "checkbox");
      attr(input3, "id", "SecRotate " + /*animation*/
      ctx[2]._data.id);
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      mount_component(numberinput0, td1, null);
      append(tr0, t1);
      append(tr0, td2);
      mount_component(numberinput1, td2, null);
      append(table, t2);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div0);
      append(div0, label0);
      append(label0, t3);
      append(div0, t4);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[0].secondary.options.isMasked;
      append(tr1, t5);
      append(tr1, td4);
      mount_component(opacity, td4, null);
      append(tr1, t6);
      append(tr1, td5);
      mount_component(numberinput2, td5, null);
      append(table, t7);
      append(table, tr2);
      append(tr2, td6);
      mount_component(scaleradius, td6, null);
      append(tr2, t8);
      append(tr2, td7);
      append(td7, div1);
      append(div1, label1);
      append(label1, t9);
      append(label1, t10);
      append(label1, t11);
      append(label1, t12);
      append(label1, t13);
      append(div1, t14);
      append(div1, input1);
      input1.checked = /*$animation*/
      ctx[0].secondary.options.addTokenWidth;
      append(tr2, t15);
      append(tr2, td8);
      mount_component(numberinput3, td8, null);
      append(table, t16);
      append(table, tr3);
      append(tr3, td9);
      mount_component(numberinput4, td9, null);
      append(tr3, t17);
      append(tr3, td10);
      append(td10, div2);
      append(div2, label2);
      append(td10, t19);
      append(td10, div3);
      append(div3, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].secondary.options.anchor
      );
      append(tr3, t20);
      append(tr3, td11);
      append(td11, div4);
      append(div4, label3);
      append(label3, t21);
      append(div4, t22);
      append(div4, input3);
      input3.checked = /*$animation*/
      ctx[0].secondary.options.rotateSource;
      append(table, t23);
      append(table, tr4);
      append(tr4, td12);
      mount_component(numberinput5, td12, null);
      append(tr4, t24);
      append(tr4, td13);
      mount_component(waitdelay, td13, null);
      append(tr4, t25);
      append(tr4, td14);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[7]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[8]
          ),
          listen(
            input3,
            "change",
            /*input3_change_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].secondary.options.isMasked;
      }
      if (dirty & /*$animation*/
      1) {
        input1.checked = /*$animation*/
        ctx2[0].secondary.options.addTokenWidth;
      }
      if (!current || dirty & /*isRadius*/
      2 && div1_class_value !== (div1_class_value = /*isRadius*/
      ctx2[1] ? "" : "aa-disableOpacity")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*$animation*/
      1 && input2.value !== /*$animation*/
      ctx2[0].secondary.options.anchor) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].secondary.options.anchor
        );
      }
      if (dirty & /*$animation*/
      1) {
        input3.checked = /*$animation*/
        ctx2[0].secondary.options.rotateSource;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(scaleradius.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(numberinput4.$$.fragment, local);
      transition_in(numberinput5.$$.fragment, local);
      transition_in(waitdelay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(scaleradius.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(numberinput4.$$.fragment, local);
      transition_out(numberinput5.$$.fragment, local);
      transition_out(waitdelay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(opacity);
      destroy_component(numberinput2);
      destroy_component(scaleradius);
      destroy_component(numberinput3);
      destroy_component(numberinput4);
      destroy_component(numberinput5);
      destroy_component(waitdelay);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$j(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[4]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[5]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$11(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[3]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$j],
        default: [create_default_slot$r]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, isRadius*/
      1027) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$$($$self, $$props, $$invalidate) {
  let isRadius;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    label: game.i18n.localize("autoanimations.menus.options"),
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    },
    onClickPropagate: false
  };
  const click_handler = () => OptionsDialog.show("ontoken");
  function input0_change_handler() {
    $animation.secondary.options.isMasked = this.checked;
    animation.set($animation);
  }
  function input1_change_handler() {
    $animation.secondary.options.addTokenWidth = this.checked;
    animation.set($animation);
  }
  function input2_input_handler() {
    $animation.secondary.options.anchor = this.value;
    animation.set($animation);
  }
  function input3_change_handler() {
    $animation.secondary.options.rotateSource = this.checked;
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, isRadius = $animation.secondary.options.isRadius);
    }
  };
  return [
    $animation,
    isRadius,
    animation,
    folder,
    optionsInfo,
    click_handler,
    input0_change_handler,
    input1_change_handler,
    input2_input_handler,
    input3_change_handler
  ];
}
class SecondaryOptions extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$$, create_fragment$11, safe_not_equal, {});
  }
}
const Secondary_svelte_svelte_type_style_lang = "";
function create_default_slot$q(ctx) {
  let div;
  let videoselect;
  let t0;
  let secondaryoptions;
  let t1;
  let switch_instance;
  let t2;
  let soundsettings;
  let div_class_value;
  let current;
  videoselect = new VideoSelect({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      section: "secondary",
      title: (
        /*title*/
        ctx[4]
      ),
      idx: (
        /*idx*/
        ctx[3]
      ),
      category: (
        /*category*/
        ctx[2]
      )
    }
  });
  secondaryoptions = new SecondaryOptions({
    props: { animation: (
      /*animation*/
      ctx[1]
    ) }
  });
  var switch_value = EffectColor;
  function switch_props(ctx2) {
    return { props: { section: "secondary" } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  soundsettings = new SoundSettings({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      category: (
        /*category*/
        ctx[2]
      ),
      idx: (
        /*idx*/
        ctx[3]
      ),
      section: "secondary"
    }
  });
  return {
    c() {
      div = element("div");
      create_component(videoselect.$$.fragment);
      t0 = space();
      create_component(secondaryoptions.$$.fragment);
      t1 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t2 = space();
      create_component(soundsettings.$$.fragment);
      attr(div, "class", div_class_value = null_to_empty(!/*$animation*/
      ctx[0].secondary.enable ? "aa-isDisabled" : "") + " svelte-auto-1yddlio");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(videoselect, div, null);
      append(div, t0);
      mount_component(secondaryoptions, div, null);
      append(div, t1);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append(div, t2);
      mount_component(soundsettings, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = EffectColor)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t2);
        } else {
          switch_instance = null;
        }
      }
      if (!current || dirty & /*$animation*/
      1 && div_class_value !== (div_class_value = null_to_empty(!/*$animation*/
      ctx2[0].secondary.enable ? "aa-isDisabled" : "") + " svelte-auto-1yddlio")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(videoselect.$$.fragment, local);
      transition_in(secondaryoptions.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(soundsettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(videoselect.$$.fragment, local);
      transition_out(secondaryoptions.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(soundsettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(videoselect);
      destroy_component(secondaryoptions);
      if (switch_instance)
        destroy_component(switch_instance);
      destroy_component(soundsettings);
    }
  };
}
function create_summary_end_slot$i(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Secondary On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[0].secondary.enable;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[7]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      1) {
        input.checked = /*$animation*/
        ctx2[0].secondary.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$10(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folderOptions*/
        ctx[5]
      ),
      label: localize("autoanimations.variants.secondary") + " " + localize("autoanimations.menus.animation"),
      $$slots: {
        "summary-end": [create_summary_end_slot$i],
        default: [create_default_slot$q]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-section-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation*/
      513) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$_($$self, $$props, $$invalidate) {
  let $animation;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  let title2 = "Secondary " + game.i18n.localize("autoanimations.menus.animation");
  const folderOptions = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  function checkMeta() {
    delete $animation.metaData;
  }
  function input_change_handler() {
    $animation.secondary.enable = this.checked;
    animation.set($animation);
  }
  const change_handler = () => checkMeta();
  return [
    $animation,
    animation,
    category,
    idx,
    title2,
    folderOptions,
    checkMeta,
    input_change_handler,
    change_handler
  ];
}
class Secondary extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$_, create_fragment$10, safe_not_equal, {});
  }
}
function create_default_slot$p(ctx) {
  let table0;
  let tr0;
  let th0;
  let t0;
  let th1;
  let div0;
  let label0;
  let t4;
  let input0;
  let t5;
  let th2;
  let t6;
  let tr1;
  let td0;
  let t7;
  let td1;
  let opacity;
  let td1_class_value;
  let t8;
  let td2;
  let div1;
  let input1;
  let t9;
  let div2;
  let input2;
  let td2_class_value;
  let t10;
  let table1;
  let tr2;
  let th3;
  let t11;
  let th4;
  let div3;
  let label1;
  let t13;
  let input3;
  let t14;
  let th5;
  let t15;
  let tr3;
  let td3;
  let numberinput0;
  let t16;
  let td4;
  let numberinput1;
  let t17;
  let td5;
  let numberinput2;
  let tr3_class_value;
  let t18;
  let table2;
  let tr4;
  let th6;
  let t19;
  let th7;
  let div4;
  let label2;
  let t21;
  let input4;
  let t22;
  let th8;
  let t23;
  let tr5;
  let td6;
  let numberinput3;
  let t24;
  let td7;
  let numberinput4;
  let t25;
  let td8;
  let numberinput5;
  let tr5_class_value;
  let current;
  let mounted;
  let dispose;
  opacity = new Opacity$1({
    props: {
      animation: (
        /*animation*/
        ctx[4]
      ),
      label: localize("autoanimations.menus.saturate"),
      field: "tintSaturate",
      min: "-1",
      max: "1"
    }
  });
  numberinput0 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[4]
      ),
      label: "From",
      section: "primary",
      field: "breathMin",
      step: "0.01"
    }
  });
  numberinput1 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[4]
      ),
      label: "To",
      section: "primary",
      field: "breathMax",
      step: "0.01"
    }
  });
  numberinput2 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[4]
      ),
      label: "Duration",
      section: "primary",
      field: "breathDuration",
      step: "1"
    }
  });
  numberinput3 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[4]
      ),
      label: "From",
      section: "primary",
      field: "alphaMin",
      step: "0.01"
    }
  });
  numberinput4 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[4]
      ),
      label: "To",
      section: "primary",
      field: "alphaMax",
      step: "0.01"
    }
  });
  numberinput5 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[4]
      ),
      label: "Duration",
      section: "primary",
      field: "alphaDuration",
      step: "1"
    }
  });
  return {
    c() {
      table0 = element("table");
      tr0 = element("tr");
      th0 = element("th");
      t0 = space();
      th1 = element("th");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.color")}  ${localize("autoanimations.menus.tint")}`;
      t4 = space();
      input0 = element("input");
      t5 = space();
      th2 = element("th");
      t6 = space();
      tr1 = element("tr");
      td0 = element("td");
      t7 = space();
      td1 = element("td");
      create_component(opacity.$$.fragment);
      t8 = space();
      td2 = element("td");
      div1 = element("div");
      input1 = element("input");
      t9 = space();
      div2 = element("div");
      input2 = element("input");
      t10 = space();
      table1 = element("table");
      tr2 = element("tr");
      th3 = element("th");
      t11 = space();
      th4 = element("th");
      div3 = element("div");
      label1 = element("label");
      label1.textContent = "Breath Effect";
      t13 = space();
      input3 = element("input");
      t14 = space();
      th5 = element("th");
      t15 = space();
      tr3 = element("tr");
      td3 = element("td");
      create_component(numberinput0.$$.fragment);
      t16 = space();
      td4 = element("td");
      create_component(numberinput1.$$.fragment);
      t17 = space();
      td5 = element("td");
      create_component(numberinput2.$$.fragment);
      t18 = space();
      table2 = element("table");
      tr4 = element("tr");
      th6 = element("th");
      t19 = space();
      th7 = element("th");
      div4 = element("div");
      label2 = element("label");
      label2.textContent = "Alpha Effect";
      t21 = space();
      input4 = element("input");
      t22 = space();
      th8 = element("th");
      t23 = space();
      tr5 = element("tr");
      td6 = element("td");
      create_component(numberinput3.$$.fragment);
      t24 = space();
      td7 = element("td");
      create_component(numberinput4.$$.fragment);
      t25 = space();
      td8 = element("td");
      create_component(numberinput5.$$.fragment);
      attr(label0, "for", "");
      set_style(label0, "font-size", "1.2em");
      attr(input0, "type", "checkbox");
      set_style(input0, "position", "relative");
      set_style(input0, "right", "10px");
      set_style(input0, "bottom", "2px");
      attr(input0, "id", "Filter " + /*animation*/
      ctx[4]._data.id);
      attr(div0, "class", "flexrow");
      set_style(th1, "text-align", "center");
      attr(td1, "class", td1_class_value = /*tintEnabled*/
      ctx[3] ? "" : "aa-disableOpacity");
      attr(input1, "type", "Text");
      set_style(input1, "width", "10em");
      set_style(input1, "margin", "auto");
      attr(div1, "class", "flexcol");
      attr(input2, "type", "color");
      attr(input2, "data-edit", "color");
      attr(input2, "id", "tint");
      set_style(input2, "width", "10em");
      set_style(input2, "margin-left", "0");
      attr(div2, "class", "form-group");
      attr(td2, "class", td2_class_value = /*tintEnabled*/
      ctx[3] ? "" : "aa-disableOpacity");
      attr(table0, "class", "d");
      attr(label1, "for", "");
      set_style(label1, "font-size", "1.2em");
      attr(input3, "type", "checkbox");
      set_style(input3, "position", "relative");
      set_style(input3, "right", "10px");
      set_style(input3, "bottom", "2px");
      attr(input3, "id", "Breath " + /*animation*/
      ctx[4]._data.id);
      attr(div3, "class", "flexrow");
      set_style(th4, "text-align", "center");
      set_style(th5, "align-content", "center");
      set_style(th5, "font-weight", "normal");
      attr(tr3, "class", tr3_class_value = /*breathEnabled*/
      ctx[2] ? "" : "aa-disableOpacity");
      attr(table1, "class", "d");
      attr(label2, "for", "");
      set_style(label2, "font-size", "1.2em");
      attr(input4, "type", "checkbox");
      set_style(input4, "position", "relative");
      set_style(input4, "right", "10px");
      set_style(input4, "bottom", "2px");
      attr(input4, "id", "Fade " + /*animation*/
      ctx[4]._data.id);
      attr(div4, "class", "flexrow");
      set_style(th7, "text-align", "center");
      attr(tr5, "class", tr5_class_value = /*alphaEnabled*/
      ctx[1] ? "" : "aa-disableOpacity");
      attr(table2, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table0, anchor);
      append(table0, tr0);
      append(tr0, th0);
      append(tr0, t0);
      append(tr0, th1);
      append(th1, div0);
      append(div0, label0);
      append(div0, t4);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[0].primary.options.tint;
      append(tr0, t5);
      append(tr0, th2);
      append(table0, t6);
      append(table0, tr1);
      append(tr1, td0);
      append(tr1, t7);
      append(tr1, td1);
      mount_component(opacity, td1, null);
      append(tr1, t8);
      append(tr1, td2);
      append(td2, div1);
      append(div1, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].primary.options.tintColor
      );
      append(td2, t9);
      append(td2, div2);
      append(div2, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].primary.options.tintColor
      );
      insert(target2, t10, anchor);
      insert(target2, table1, anchor);
      append(table1, tr2);
      append(tr2, th3);
      append(tr2, t11);
      append(tr2, th4);
      append(th4, div3);
      append(div3, label1);
      append(div3, t13);
      append(div3, input3);
      input3.checked = /*$animation*/
      ctx[0].primary.options.breath;
      append(tr2, t14);
      append(tr2, th5);
      append(table1, t15);
      append(table1, tr3);
      append(tr3, td3);
      mount_component(numberinput0, td3, null);
      append(tr3, t16);
      append(tr3, td4);
      mount_component(numberinput1, td4, null);
      append(tr3, t17);
      append(tr3, td5);
      mount_component(numberinput2, td5, null);
      insert(target2, t18, anchor);
      insert(target2, table2, anchor);
      append(table2, tr4);
      append(tr4, th6);
      append(tr4, t19);
      append(tr4, th7);
      append(th7, div4);
      append(div4, label2);
      append(div4, t21);
      append(div4, input4);
      input4.checked = /*$animation*/
      ctx[0].primary.options.alpha;
      append(tr4, t22);
      append(tr4, th8);
      append(table2, t23);
      append(table2, tr5);
      append(tr5, td6);
      mount_component(numberinput3, td6, null);
      append(tr5, t24);
      append(tr5, td7);
      mount_component(numberinput4, td7, null);
      append(tr5, t25);
      append(tr5, td8);
      mount_component(numberinput5, td8, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[7]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[8]
          ),
          listen(
            input3,
            "change",
            /*input3_change_handler*/
            ctx[9]
          ),
          listen(
            input4,
            "change",
            /*input4_change_handler*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].primary.options.tint;
      }
      if (!current || dirty & /*tintEnabled*/
      8 && td1_class_value !== (td1_class_value = /*tintEnabled*/
      ctx2[3] ? "" : "aa-disableOpacity")) {
        attr(td1, "class", td1_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].primary.options.tintColor
        );
      }
      if (dirty & /*$animation*/
      1) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].primary.options.tintColor
        );
      }
      if (!current || dirty & /*tintEnabled*/
      8 && td2_class_value !== (td2_class_value = /*tintEnabled*/
      ctx2[3] ? "" : "aa-disableOpacity")) {
        attr(td2, "class", td2_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input3.checked = /*$animation*/
        ctx2[0].primary.options.breath;
      }
      if (!current || dirty & /*breathEnabled*/
      4 && tr3_class_value !== (tr3_class_value = /*breathEnabled*/
      ctx2[2] ? "" : "aa-disableOpacity")) {
        attr(tr3, "class", tr3_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input4.checked = /*$animation*/
        ctx2[0].primary.options.alpha;
      }
      if (!current || dirty & /*alphaEnabled*/
      2 && tr5_class_value !== (tr5_class_value = /*alphaEnabled*/
      ctx2[1] ? "" : "aa-disableOpacity")) {
        attr(tr5, "class", tr5_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(opacity.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(numberinput4.$$.fragment, local);
      transition_in(numberinput5.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(opacity.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(numberinput4.$$.fragment, local);
      transition_out(numberinput5.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table0);
      destroy_component(opacity);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(table1);
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(numberinput2);
      if (detaching)
        detach(t18);
      if (detaching)
        detach(table2);
      destroy_component(numberinput3);
      destroy_component(numberinput4);
      destroy_component(numberinput5);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$$(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot$p] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, alphaEnabled, $animation, breathEnabled, tintEnabled*/
      2063) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$Z($$self, $$props, $$invalidate) {
  let tintEnabled;
  let breathEnabled;
  let alphaEnabled;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    },
    label: "Effects"
  };
  function input0_change_handler() {
    $animation.primary.options.tint = this.checked;
    animation.set($animation);
  }
  function input1_input_handler() {
    $animation.primary.options.tintColor = this.value;
    animation.set($animation);
  }
  function input2_input_handler() {
    $animation.primary.options.tintColor = this.value;
    animation.set($animation);
  }
  function input3_change_handler() {
    $animation.primary.options.breath = this.checked;
    animation.set($animation);
  }
  function input4_change_handler() {
    $animation.primary.options.alpha = this.checked;
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(3, tintEnabled = $animation.primary.options.tint);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(2, breathEnabled = $animation.primary.options.breath);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, alphaEnabled = $animation.primary.options.alpha);
    }
  };
  return [
    $animation,
    alphaEnabled,
    breathEnabled,
    tintEnabled,
    animation,
    folder,
    input0_change_handler,
    input1_input_handler,
    input2_input_handler,
    input3_change_handler,
    input4_change_handler
  ];
}
class AuraEffects extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$Z, create_fragment$$, safe_not_equal, {});
  }
}
function create_fragment$_(ctx) {
  let extrasource;
  let t0;
  let div;
  let videoselect;
  let t1;
  let auraoptions;
  let t2;
  let auraeffects;
  let t3;
  let soundsettings;
  let t4;
  let secondary2;
  let current;
  extrasource = new ExtraSource({});
  videoselect = new VideoSelect({
    props: {
      section: "primary",
      title: (
        /*title*/
        ctx[0]
      )
    }
  });
  auraoptions = new AuraOptions$1({});
  auraeffects = new AuraEffects({});
  soundsettings = new SoundSettings({ props: { section: "primary" } });
  secondary2 = new Secondary({});
  return {
    c() {
      create_component(extrasource.$$.fragment);
      t0 = space();
      div = element("div");
      create_component(videoselect.$$.fragment);
      t1 = space();
      create_component(auraoptions.$$.fragment);
      t2 = space();
      create_component(auraeffects.$$.fragment);
      t3 = space();
      create_component(soundsettings.$$.fragment);
      t4 = space();
      create_component(secondary2.$$.fragment);
      attr(div, "class", "aa-primary-border");
    },
    m(target2, anchor) {
      mount_component(extrasource, target2, anchor);
      insert(target2, t0, anchor);
      insert(target2, div, anchor);
      mount_component(videoselect, div, null);
      append(div, t1);
      mount_component(auraoptions, div, null);
      append(div, t2);
      mount_component(auraeffects, div, null);
      append(div, t3);
      mount_component(soundsettings, div, null);
      insert(target2, t4, anchor);
      mount_component(secondary2, target2, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(extrasource.$$.fragment, local);
      transition_in(videoselect.$$.fragment, local);
      transition_in(auraoptions.$$.fragment, local);
      transition_in(auraeffects.$$.fragment, local);
      transition_in(soundsettings.$$.fragment, local);
      transition_in(secondary2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(extrasource.$$.fragment, local);
      transition_out(videoselect.$$.fragment, local);
      transition_out(auraoptions.$$.fragment, local);
      transition_out(auraeffects.$$.fragment, local);
      transition_out(soundsettings.$$.fragment, local);
      transition_out(secondary2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(extrasource, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      destroy_component(videoselect);
      destroy_component(auraoptions);
      destroy_component(auraeffects);
      destroy_component(soundsettings);
      if (detaching)
        detach(t4);
      destroy_component(secondary2, detaching);
    }
  };
}
function instance$Y($$self) {
  let title2 = game.i18n.localize("autoanimations.menus.primary") + " " + game.i18n.localize("autoanimations.menus.animation");
  return [title2];
}
class BuildAEAura extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$Y, create_fragment$_, safe_not_equal, {});
  }
}
function create_default_slot$o(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let numberinput0;
  let t1;
  let td2;
  let numberinput1;
  let t2;
  let tr1;
  let td3;
  let div0;
  let label0;
  let t3_value = localize("autoanimations.menus.persistant") + "";
  let t3;
  let t4;
  let input0;
  let t5;
  let td4;
  let div1;
  let label1;
  let t6_value = localize("autoanimations.menus.bind") + "";
  let t6;
  let t7;
  let t8_value = localize("autoanimations.menus.visibility") + "";
  let t8;
  let t9;
  let input1;
  let div1_class_value;
  let t10;
  let td5;
  let div2;
  let label2;
  let t11_value = localize("autoanimations.menus.bind") + "";
  let t11;
  let t12;
  let t13_value = localize("autoanimations.menus.alpha") + "";
  let t13;
  let t14;
  let input2;
  let div2_class_value;
  let t15;
  let tr2;
  let td6;
  let div3;
  let label3;
  let t16_value = localize("autoanimations.menus.mask") + "";
  let t16;
  let t17;
  let input3;
  let t18;
  let td7;
  let opacity;
  let t19;
  let td8;
  let numberinput2;
  let t20;
  let tr3;
  let td9;
  let scaleradius;
  let t21;
  let td10;
  let div4;
  let label4;
  let t22_value = localize("autoanimations.menus.add") + "";
  let t22;
  let t23;
  let t24_value = localize("autoanimations.menus.token") + "";
  let t24;
  let t25;
  let t26_value = localize("autoanimations.menus.width") + "";
  let t26;
  let t27;
  let input4;
  let div4_class_value;
  let t28;
  let td11;
  let numberinput3;
  let t29;
  let tr4;
  let td12;
  let numberinput4;
  let t30;
  let td13;
  let div5;
  let label5;
  let t32;
  let div6;
  let input5;
  let t33;
  let td14;
  let div7;
  let label6;
  let strong;
  let t35;
  let div8;
  let label7;
  let t37;
  let tr5;
  let td15;
  let numberinput5;
  let t38;
  let td16;
  let waitdelay;
  let t39;
  let td17;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation$1({ props: { section: "primary" } });
  numberinput0 = new NumberInput({
    props: {
      label: localize("autoanimations.menus.repeat"),
      section: "primary",
      field: "repeat",
      isDisabled: (
        /*persistent*/
        ctx[2] ? "aa-disableOpacity" : ""
      )
    }
  });
  numberinput1 = new NumberInput({
    props: {
      label: localize("autoanimations.menus.repeat") + " " + localize("autoanimations.menus.delay"),
      section: "primary",
      field: "repeatDelay",
      isDisabled: (
        /*persistent*/
        ctx[2] ? "aa-disableOpacity" : ""
      )
    }
  });
  opacity = new Opacity$1({});
  numberinput2 = new NumberInput({
    props: {
      label: localize("autoanimations.menus.z-index"),
      section: "primary",
      field: "zIndex"
    }
  });
  scaleradius = new ScaleRadius$1({
    props: {
      section: "primary",
      field: "size",
      step: "0.01"
    }
  });
  numberinput3 = new NumberInput({
    props: {
      label: localize("autoanimations.menus.fadeIn"),
      section: "primary",
      field: "fadeIn",
      placeholder: "250",
      step: "0.01"
    }
  });
  numberinput4 = new NumberInput({
    props: {
      label: localize("autoanimations.menus.fadeOut"),
      section: "primary",
      field: "fadeOut",
      placeholder: "500",
      step: "0.01"
    }
  });
  numberinput5 = new NumberInput({
    props: {
      label: localize("autoanimations.menus.playbackRate"),
      section: "primary",
      field: "playbackRate"
    }
  });
  waitdelay = new WaitDelay({ props: { section: "primary" } });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      create_component(numberinput0.$$.fragment);
      t1 = space();
      td2 = element("td");
      create_component(numberinput1.$$.fragment);
      t2 = space();
      tr1 = element("tr");
      td3 = element("td");
      div0 = element("div");
      label0 = element("label");
      t3 = text(t3_value);
      t4 = space();
      input0 = element("input");
      t5 = space();
      td4 = element("td");
      div1 = element("div");
      label1 = element("label");
      t6 = text(t6_value);
      t7 = space();
      t8 = text(t8_value);
      t9 = space();
      input1 = element("input");
      t10 = space();
      td5 = element("td");
      div2 = element("div");
      label2 = element("label");
      t11 = text(t11_value);
      t12 = space();
      t13 = text(t13_value);
      t14 = space();
      input2 = element("input");
      t15 = space();
      tr2 = element("tr");
      td6 = element("td");
      div3 = element("div");
      label3 = element("label");
      t16 = text(t16_value);
      t17 = space();
      input3 = element("input");
      t18 = space();
      td7 = element("td");
      create_component(opacity.$$.fragment);
      t19 = space();
      td8 = element("td");
      create_component(numberinput2.$$.fragment);
      t20 = space();
      tr3 = element("tr");
      td9 = element("td");
      create_component(scaleradius.$$.fragment);
      t21 = space();
      td10 = element("td");
      div4 = element("div");
      label4 = element("label");
      t22 = text(t22_value);
      t23 = space();
      t24 = text(t24_value);
      t25 = space();
      t26 = text(t26_value);
      t27 = space();
      input4 = element("input");
      t28 = space();
      td11 = element("td");
      create_component(numberinput3.$$.fragment);
      t29 = space();
      tr4 = element("tr");
      td12 = element("td");
      create_component(numberinput4.$$.fragment);
      t30 = space();
      td13 = element("td");
      div5 = element("div");
      label5 = element("label");
      label5.textContent = `${localize("autoanimations.menus.anchor")}`;
      t32 = space();
      div6 = element("div");
      input5 = element("input");
      t33 = space();
      td14 = element("td");
      div7 = element("div");
      label6 = element("label");
      strong = element("strong");
      strong.textContent = `${localize("autoanimations.menus.playOn")}`;
      t35 = space();
      div8 = element("div");
      label7 = element("label");
      label7.textContent = `${localize("autoanimations.menus.source")}`;
      t37 = space();
      tr5 = element("tr");
      td15 = element("td");
      create_component(numberinput5.$$.fragment);
      t38 = space();
      td16 = element("td");
      create_component(waitdelay.$$.fragment);
      t39 = space();
      td17 = element("td");
      attr(label0, "for", "Persist " + /*animation*/
      ctx[3]._data.id);
      attr(input0, "type", "checkbox");
      attr(input0, "id", "Persist " + /*animation*/
      ctx[3]._data.id);
      attr(label1, "for", "Vis " + /*animation*/
      ctx[3]._data.id);
      attr(input1, "type", "checkbox");
      attr(input1, "id", "Vis " + /*animation*/
      ctx[3]._data.id);
      attr(div1, "class", div1_class_value = /*persistent*/
      ctx[2] ? "" : "aa-disableOpacity");
      attr(label2, "for", "Alpha " + /*animation*/
      ctx[3]._data.id);
      attr(input2, "type", "checkbox");
      attr(input2, "id", "Alpha " + /*animation*/
      ctx[3]._data.id);
      attr(div2, "class", div2_class_value = /*persistent*/
      ctx[2] ? "" : "aa-disableOpacity");
      attr(label3, "for", "Masked " + /*animation*/
      ctx[3]._data.id);
      attr(input3, "type", "checkbox");
      attr(input3, "id", "Masked " + /*animation*/
      ctx[3]._data.id);
      attr(label4, "for", "Width " + /*animation*/
      ctx[3]._data.id);
      attr(input4, "type", "checkbox");
      attr(input4, "id", "Width " + /*animation*/
      ctx[3]._data.id);
      attr(div4, "class", div4_class_value = /*isRadius*/
      ctx[1] ? "" : "aa-disableOpacity");
      attr(label5, "for", "");
      attr(input5, "type", "text");
      attr(input5, "placeholder", "0.5");
      attr(label6, "for", "");
      attr(label7, "for", "");
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      mount_component(numberinput0, td1, null);
      append(tr0, t1);
      append(tr0, td2);
      mount_component(numberinput1, td2, null);
      append(table, t2);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div0);
      append(div0, label0);
      append(label0, t3);
      append(div0, t4);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[0].primary.options.persistent;
      append(tr1, t5);
      append(tr1, td4);
      append(td4, div1);
      append(div1, label1);
      append(label1, t6);
      append(label1, t7);
      append(label1, t8);
      append(div1, t9);
      append(div1, input1);
      input1.checked = /*$animation*/
      ctx[0].primary.options.unbindVisibility;
      append(tr1, t10);
      append(tr1, td5);
      append(td5, div2);
      append(div2, label2);
      append(label2, t11);
      append(label2, t12);
      append(label2, t13);
      append(div2, t14);
      append(div2, input2);
      input2.checked = /*$animation*/
      ctx[0].primary.options.unbindAlpha;
      append(table, t15);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div3);
      append(div3, label3);
      append(label3, t16);
      append(div3, t17);
      append(div3, input3);
      input3.checked = /*$animation*/
      ctx[0].primary.options.isMasked;
      append(tr2, t18);
      append(tr2, td7);
      mount_component(opacity, td7, null);
      append(tr2, t19);
      append(tr2, td8);
      mount_component(numberinput2, td8, null);
      append(table, t20);
      append(table, tr3);
      append(tr3, td9);
      mount_component(scaleradius, td9, null);
      append(tr3, t21);
      append(tr3, td10);
      append(td10, div4);
      append(div4, label4);
      append(label4, t22);
      append(label4, t23);
      append(label4, t24);
      append(label4, t25);
      append(label4, t26);
      append(div4, t27);
      append(div4, input4);
      input4.checked = /*$animation*/
      ctx[0].primary.options.addTokenWidth;
      append(tr3, t28);
      append(tr3, td11);
      mount_component(numberinput3, td11, null);
      append(table, t29);
      append(table, tr4);
      append(tr4, td12);
      mount_component(numberinput4, td12, null);
      append(tr4, t30);
      append(tr4, td13);
      append(td13, div5);
      append(div5, label5);
      append(td13, t32);
      append(td13, div6);
      append(div6, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[0].primary.options.anchor
      );
      append(tr4, t33);
      append(tr4, td14);
      append(td14, div7);
      append(div7, label6);
      append(label6, strong);
      append(td14, t35);
      append(td14, div8);
      append(div8, label7);
      append(table, t37);
      append(table, tr5);
      append(tr5, td15);
      mount_component(numberinput5, td15, null);
      append(tr5, t38);
      append(tr5, td16);
      mount_component(waitdelay, td16, null);
      append(tr5, t39);
      append(tr5, td17);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[7]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[8]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[9]
          ),
          listen(
            input3,
            "change",
            /*input3_change_handler*/
            ctx[10]
          ),
          listen(
            input4,
            "change",
            /*input4_change_handler*/
            ctx[11]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const numberinput0_changes = {};
      if (dirty & /*persistent*/
      4)
        numberinput0_changes.isDisabled = /*persistent*/
        ctx2[2] ? "aa-disableOpacity" : "";
      numberinput0.$set(numberinput0_changes);
      const numberinput1_changes = {};
      if (dirty & /*persistent*/
      4)
        numberinput1_changes.isDisabled = /*persistent*/
        ctx2[2] ? "aa-disableOpacity" : "";
      numberinput1.$set(numberinput1_changes);
      if (dirty & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].primary.options.persistent;
      }
      if (dirty & /*$animation*/
      1) {
        input1.checked = /*$animation*/
        ctx2[0].primary.options.unbindVisibility;
      }
      if (!current || dirty & /*persistent*/
      4 && div1_class_value !== (div1_class_value = /*persistent*/
      ctx2[2] ? "" : "aa-disableOpacity")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input2.checked = /*$animation*/
        ctx2[0].primary.options.unbindAlpha;
      }
      if (!current || dirty & /*persistent*/
      4 && div2_class_value !== (div2_class_value = /*persistent*/
      ctx2[2] ? "" : "aa-disableOpacity")) {
        attr(div2, "class", div2_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input3.checked = /*$animation*/
        ctx2[0].primary.options.isMasked;
      }
      if (dirty & /*$animation*/
      1) {
        input4.checked = /*$animation*/
        ctx2[0].primary.options.addTokenWidth;
      }
      if (!current || dirty & /*isRadius*/
      2 && div4_class_value !== (div4_class_value = /*isRadius*/
      ctx2[1] ? "" : "aa-disableOpacity")) {
        attr(div4, "class", div4_class_value);
      }
      if (dirty & /*$animation*/
      1 && input5.value !== /*$animation*/
      ctx2[0].primary.options.anchor) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[0].primary.options.anchor
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(scaleradius.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(numberinput4.$$.fragment, local);
      transition_in(numberinput5.$$.fragment, local);
      transition_in(waitdelay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(scaleradius.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(numberinput4.$$.fragment, local);
      transition_out(numberinput5.$$.fragment, local);
      transition_out(waitdelay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(opacity);
      destroy_component(numberinput2);
      destroy_component(scaleradius);
      destroy_component(numberinput3);
      destroy_component(numberinput4);
      destroy_component(numberinput5);
      destroy_component(waitdelay);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$h(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[5]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[6]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$Z(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[4]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$h],
        default: [create_default_slot$o]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, isRadius, persistent*/
      16391) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$X($$self, $$props, $$invalidate) {
  let persistent;
  let isRadius;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    },
    label: game.i18n.localize("autoanimations.menus.options")
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    }
  };
  game.i18n.localize("autoanimations.menus.add") + " " + game.i18n.localize("autoanimations.menus.token") + " " + game.i18n.localize("autoanimations.menus.width");
  const click_handler = () => OptionsDialog.show("ontoken");
  function input0_change_handler() {
    $animation.primary.options.persistent = this.checked;
    animation.set($animation);
  }
  function input1_change_handler() {
    $animation.primary.options.unbindVisibility = this.checked;
    animation.set($animation);
  }
  function input2_change_handler() {
    $animation.primary.options.unbindAlpha = this.checked;
    animation.set($animation);
  }
  function input3_change_handler() {
    $animation.primary.options.isMasked = this.checked;
    animation.set($animation);
  }
  function input4_change_handler() {
    $animation.primary.options.addTokenWidth = this.checked;
    animation.set($animation);
  }
  function input5_input_handler() {
    $animation.primary.options.anchor = this.value;
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(2, persistent = $animation.primary.options.persistent);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, isRadius = $animation.primary.options.isRadius);
    }
  };
  return [
    $animation,
    isRadius,
    persistent,
    animation,
    folder,
    optionsInfo,
    click_handler,
    input0_change_handler,
    input1_change_handler,
    input2_change_handler,
    input3_change_handler,
    input4_change_handler,
    input5_input_handler
  ];
}
let OnTokenOptions$1 = class OnTokenOptions2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$X, create_fragment$Z, safe_not_equal, {});
  }
};
function create_fragment$Y(ctx) {
  let div1;
  let extrasource;
  let t0;
  let div0;
  let videoselect;
  let t1;
  let ontokenoptions;
  let t2;
  let switch_instance;
  let t3;
  let soundsettings;
  let t4;
  let secondary2;
  let div1_hidden_value;
  let current;
  extrasource = new ExtraSource({});
  videoselect = new VideoSelect({
    props: {
      section: "primary",
      title: (
        /*title*/
        ctx[2]
      )
    }
  });
  ontokenoptions = new OnTokenOptions$1({});
  var switch_value = EffectColor;
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  soundsettings = new SoundSettings({ props: { section: "primary" } });
  secondary2 = new Secondary({});
  return {
    c() {
      div1 = element("div");
      create_component(extrasource.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(videoselect.$$.fragment);
      t1 = space();
      create_component(ontokenoptions.$$.fragment);
      t2 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t3 = space();
      create_component(soundsettings.$$.fragment);
      t4 = space();
      create_component(secondary2.$$.fragment);
      attr(div0, "class", "aa-primary-border");
      div1.hidden = div1_hidden_value = /*$animation*/
      ctx[0].macro.enable && /*$animation*/
      ctx[0].macro.playWhen === "2";
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      mount_component(extrasource, div1, null);
      append(div1, t0);
      append(div1, div0);
      mount_component(videoselect, div0, null);
      append(div0, t1);
      mount_component(ontokenoptions, div0, null);
      append(div0, t2);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      append(div0, t3);
      mount_component(soundsettings, div0, null);
      append(div1, t4);
      mount_component(secondary2, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (switch_value !== (switch_value = EffectColor)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, t3);
        } else {
          switch_instance = null;
        }
      }
      if (!current || dirty & /*$animation*/
      1 && div1_hidden_value !== (div1_hidden_value = /*$animation*/
      ctx2[0].macro.enable && /*$animation*/
      ctx2[0].macro.playWhen === "2")) {
        div1.hidden = div1_hidden_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(extrasource.$$.fragment, local);
      transition_in(videoselect.$$.fragment, local);
      transition_in(ontokenoptions.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(soundsettings.$$.fragment, local);
      transition_in(secondary2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(extrasource.$$.fragment, local);
      transition_out(videoselect.$$.fragment, local);
      transition_out(ontokenoptions.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(soundsettings.$$.fragment, local);
      transition_out(secondary2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(extrasource);
      destroy_component(videoselect);
      destroy_component(ontokenoptions);
      if (switch_instance)
        destroy_component(switch_instance);
      destroy_component(soundsettings);
      destroy_component(secondary2);
    }
  };
}
function instance$W($$self, $$props, $$invalidate) {
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  let title2 = game.i18n.localize("autoanimations.menus.primary") + " " + game.i18n.localize("autoanimations.menus.animation");
  return [$animation, animation, title2];
}
class BuildAEOnToken extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$W, create_fragment$Y, safe_not_equal, {});
  }
}
const SectionButtons02_svelte_svelte_type_style_lang = "";
function create_fragment$X(ctx) {
  let div3;
  let div0;
  let label0;
  let t0_value = localize("autoanimations.menus.preview") + "";
  let t0;
  let t1;
  let i0;
  let t2;
  let div1;
  let label1;
  let t3_value = localize("autoanimations.menus.sound") + "";
  let t3;
  let t4;
  let t5_value = localize("autoanimations.menus.only") + "";
  let t5;
  let t6;
  let i1;
  let i1_class_value;
  let t7;
  let input0;
  let t8;
  let div2;
  let label2;
  let t9_value = localize("autoanimations.menus.add") + "";
  let t9;
  let t10;
  let t11_value = localize("autoanimations.menus.macro") + "";
  let t11;
  let t12;
  let i2;
  let i2_class_value;
  let t13;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      label0 = element("label");
      t0 = text(t0_value);
      t1 = space();
      i0 = element("i");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      t3 = text(t3_value);
      t4 = space();
      t5 = text(t5_value);
      t6 = space();
      i1 = element("i");
      t7 = space();
      input0 = element("input");
      t8 = space();
      div2 = element("div");
      label2 = element("label");
      t9 = text(t9_value);
      t10 = space();
      t11 = text(t11_value);
      t12 = space();
      i2 = element("i");
      t13 = space();
      input1 = element("input");
      attr(i0, "class", "fas fa-film fa-lg aa-zoom");
      attr(label0, "for", "");
      attr(label0, "role", "presentation");
      attr(label0, "class", "svelte-auto-1pixf6p");
      set_style(div0, "grid-row", "1/2");
      set_style(div0, "grid-column", "1/2");
      attr(div0, "class", "sectionButton svelte-auto-1pixf6p");
      attr(i1, "class", i1_class_value = "fas fa-music fa-lg aa-zoom " + /*$animation*/
      (ctx[0].soundOnly.sound.enable ? "aa-green" : ""));
      attr(label1, "for", "SoundOnly " + /*animation*/
      ctx[1]._data.id);
      attr(label1, "class", "svelte-auto-1pixf6p");
      attr(input0, "type", "checkbox");
      input0.hidden = true;
      attr(input0, "id", "SoundOnly " + /*animation*/
      ctx[1]._data.id);
      set_style(div1, "grid-row", "1/2");
      set_style(div1, "grid-column", "2/3");
      attr(div1, "class", "sectionButton svelte-auto-1pixf6p");
      attr(i2, "class", i2_class_value = "far fa-keyboard fa-lg aa-zoom " + /*$animation*/
      (ctx[0].macro.enable ? "aa-green" : ""));
      attr(label2, "for", "Macro " + /*animation*/
      ctx[1]._data.id);
      attr(label2, "class", "svelte-auto-1pixf6p");
      attr(input1, "type", "checkbox");
      input1.hidden = true;
      attr(input1, "id", "Macro " + /*animation*/
      ctx[1]._data.id);
      set_style(div2, "grid-row", "1/2");
      set_style(div2, "grid-column", "3/4");
      attr(div2, "class", "sectionButton svelte-auto-1pixf6p");
      attr(div3, "class", "aa-autorec-headerButton02 svelte-auto-1pixf6p");
    },
    m(target2, anchor) {
      insert(target2, div3, anchor);
      append(div3, div0);
      append(div0, label0);
      append(label0, t0);
      append(label0, t1);
      append(label0, i0);
      append(div3, t2);
      append(div3, div1);
      append(div1, label1);
      append(label1, t3);
      append(label1, t4);
      append(label1, t5);
      append(label1, t6);
      append(label1, i1);
      append(div1, t7);
      append(div1, input0);
      input0.checked = /*$animation*/
      ctx[0].soundOnly.sound.enable;
      append(div3, t8);
      append(div3, div2);
      append(div2, label2);
      append(label2, t9);
      append(label2, t10);
      append(label2, t11);
      append(label2, t12);
      append(label2, i2);
      append(div2, t13);
      append(div2, input1);
      input1.checked = /*$animation*/
      ctx[0].macro.enable;
      if (!mounted) {
        dispose = [
          listen(
            label0,
            "click",
            /*click_handler*/
            ctx[5]
          ),
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[6]
          ),
          listen(
            input0,
            "change",
            /*change_handler*/
            ctx[7]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[8]
          ),
          listen(
            input1,
            "change",
            /*change_handler_1*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$animation*/
      1 && i1_class_value !== (i1_class_value = "fas fa-music fa-lg aa-zoom " + /*$animation*/
      (ctx2[0].soundOnly.sound.enable ? "aa-green" : ""))) {
        attr(i1, "class", i1_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].soundOnly.sound.enable;
      }
      if (dirty & /*$animation*/
      1 && i2_class_value !== (i2_class_value = "far fa-keyboard fa-lg aa-zoom " + /*$animation*/
      (ctx2[0].macro.enable ? "aa-green" : ""))) {
        attr(i2, "class", i2_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input1.checked = /*$animation*/
        ctx2[0].macro.enable;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$V($$self, $$props, $$invalidate) {
  let currentIDX;
  let $animation;
  let { type = "autorec" } = $$props;
  let { animation, category } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  async function seePreview() {
    if (type === "item") {
      currentIDX.set("item");
    } else {
      const index = category._data.findIndex((x) => x.id === $animation.id);
      currentIDX.set(index);
    }
    currentStore.set(category);
    category.loadPreviews(category);
  }
  function removeMetaData() {
    delete $animation.metaData;
  }
  const click_handler = () => seePreview();
  function input0_change_handler() {
    $animation.soundOnly.sound.enable = this.checked;
    animation.set($animation);
  }
  const change_handler = () => removeMetaData();
  function input1_change_handler() {
    $animation.macro.enable = this.checked;
    animation.set($animation);
  }
  const change_handler_1 = () => removeMetaData();
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(4, type = $$props2.type);
  };
  currentIDX = category.stores.videoIDX;
  return [
    $animation,
    animation,
    seePreview,
    removeMetaData,
    type,
    click_handler,
    input0_change_handler,
    change_handler,
    input1_change_handler,
    change_handler_1
  ];
}
class SectionButtons02 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$V, create_fragment$X, safe_not_equal, { type: 4 });
  }
}
const AutoCompleteMacro_svelte_svelte_type_style_lang = "";
function get_each_context$9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_each_block$9(key_1, ctx) {
  let option;
  let t_value = (
    /*m*/
    (ctx[13].text ?? "") + ""
  );
  let t;
  let option_value_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*m*/
      ctx[13].name;
      option.value = option.__value;
      this.first = option;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$macros*/
      2 && t_value !== (t_value = /*m*/
      (ctx[13].text ?? "") + ""))
        set_data(t, t_value);
      if (dirty & /*$macros*/
      2 && option_value_value !== (option_value_value = /*m*/
      ctx[13].name)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$W(ctx) {
  let div;
  let input;
  let t0;
  let datalist;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let i;
  let mounted;
  let dispose;
  let each_value = (
    /*$macros*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*m*/
    ctx2[13].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$9(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$9(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      datalist = element("datalist");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      i = element("i");
      attr(input, "type", "text");
      attr(input, "class", "aa-MacroInput svelte-auto-j7d5qn");
      attr(
        input,
        "list",
        /*id*/
        ctx[5]
      );
      set_style(input, "flex", "1");
      set_style(input, "margin-right", "5px");
      attr(input, "placeholder", localize("autoanimations.menus.insertMacro"));
      attr(
        datalist,
        "id",
        /*id*/
        ctx[5]
      );
      attr(i, "title", "Open Macro");
      set_style(i, "font-size", "20px");
      set_style(i, "flex", "0");
      attr(i, "class", "fas fa-edit aa-zoom");
      attr(i, "role", "presentation");
      attr(div, "class", "aa-flexrow svelte-auto-j7d5qn");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      set_input_value(
        input,
        /*$animation*/
        ctx[0].macro.name
      );
      append(div, t0);
      append(div, datalist);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(datalist, null);
        }
      }
      append(div, t1);
      append(div, i);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[8]
          ),
          listen(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[9]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[10]
          ),
          listen(
            input,
            "focus",
            /*focus_handler*/
            ctx[11]
          ),
          listen(
            i,
            "click",
            /*click_handler*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$animation*/
      1 && input.value !== /*$animation*/
      ctx2[0].macro.name) {
        set_input_value(
          input,
          /*$animation*/
          ctx2[0].macro.name
        );
      }
      if (dirty & /*$macros*/
      2) {
        each_value = /*$macros*/
        ctx2[1];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, datalist, destroy_block, create_each_block$9, null, get_each_context$9);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$U($$self, $$props, $$invalidate) {
  let $animation;
  let $macros;
  let { animation, category } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  let { macro: macro2 } = $$props;
  let macros = writable$1([]);
  component_subscribe($$self, macros, (value) => $$invalidate(1, $macros = value));
  const id = randomID() + "-list";
  function filterMacros() {
    let allResults = Array.from(game.macros).map((m) => ({ id: m.id, name: m.name }));
    const compendiums = Array.from(game.packs).filter((pack) => pack.documentName === "Macro").map((pack) => ({
      id: pack.metadata.id,
      name: "Compendium." + pack.metadata.id
    }));
    allResults = allResults.concat(compendiums);
    allResults = allResults.filter((m) => {
      return m.name?.toLowerCase().includes(macro2?.toLowerCase()) || !macro2;
    });
    if (macro2?.startsWith("Compendium.") && allResults.length === 1) {
      allResults = Array.from(game.packs.get(allResults[0].id).index).map((m) => {
        return {
          id: allResults[0].id + "." + m._id,
          name: allResults[0].name + "." + m.name
        };
      });
    }
    macros.set(allResults);
  }
  function input_input_handler() {
    $animation.macro.name = this.value;
    animation.set($animation);
  }
  const keyup_handler = () => {
    filterMacros();
  };
  const change_handler = () => {
    filterMacros();
  };
  const focus_handler = () => filterMacros();
  const click_handler = () => category.openMacro(animation._data.macro.name);
  $$self.$$set = ($$props2) => {
    if ("macro" in $$props2)
      $$invalidate(7, macro2 = $$props2.macro);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(7, macro2 = $animation.macro.name);
    }
  };
  return [
    $animation,
    $macros,
    animation,
    category,
    macros,
    id,
    filterMacros,
    macro2,
    input_input_handler,
    keyup_handler,
    change_handler,
    focus_handler,
    click_handler
  ];
}
class AutoCompleteMacro extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$U, create_fragment$W, safe_not_equal, { macro: 7 });
  }
}
const Macro_svelte_svelte_type_style_lang = "";
function create_fragment$V(ctx) {
  let div5;
  let div0;
  let h1;
  let t1;
  let div2;
  let div1;
  let label0;
  let t3;
  let select;
  let option0;
  let option1;
  let option2;
  let option3;
  let t10;
  let autocompletemacro;
  let t11;
  let div3;
  let label1;
  let t13;
  let div4;
  let textarea;
  let current;
  let mounted;
  let dispose;
  autocompletemacro = new AutoCompleteMacro({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      category: (
        /*category*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      h1 = element("h1");
      h1.textContent = `${localize("autoanimations.menus.macro")}`;
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.playwhen")}`;
      t3 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.menus.macroconcurrent")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.menus.awaitmacro")}`;
      option2 = element("option");
      option2.textContent = `${localize("autoanimations.menus.macroonly")}`;
      option3 = element("option");
      option3.textContent = `${localize("autoanimations.menus.await")}  ${localize("autoanimations.menus.animation")}`;
      t10 = space();
      create_component(autocompletemacro.$$.fragment);
      t11 = space();
      div3 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.args")}`;
      t13 = space();
      div4 = element("div");
      textarea = element("textarea");
      attr(h1, "class", "svelte-auto-104qrpg");
      set_style(div0, "padding-top", "3px");
      attr(label0, "for", "");
      attr(label0, "class", "svelte-auto-104qrpg");
      option0.__value = "0";
      option0.value = option0.__value;
      option1.__value = "1";
      option1.value = option1.__value;
      option2.__value = "2";
      option2.value = option2.__value;
      option3.__value = "3";
      option3.value = option3.__value;
      set_style(select, "text-align", "center");
      set_style(select, "width", "100%");
      attr(select, "class", "svelte-auto-104qrpg");
      if (
        /*$animation*/
        ctx[0].macro.playWhen === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[4].call(select)
        ));
      attr(div1, "class", "flexcol");
      set_style(div1, "grid-row", "1 / 2");
      set_style(div1, "grid-column", "2 / 3");
      attr(div2, "class", "aa-macro svelte-auto-104qrpg");
      attr(label1, "for", "");
      attr(label1, "class", "svelte-auto-104qrpg");
      set_style(div3, "text-align", "center");
      set_style(textarea, "margin-bottom", "1em");
      attr(div4, "class", "flexrow");
      attr(div5, "class", "aa-macro-border svelte-auto-104qrpg");
    },
    m(target2, anchor) {
      insert(target2, div5, anchor);
      append(div5, div0);
      append(div0, h1);
      append(div5, t1);
      append(div5, div2);
      append(div2, div1);
      append(div1, label0);
      append(div1, t3);
      append(div1, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      append(select, option3);
      select_option(
        select,
        /*$animation*/
        ctx[0].macro.playWhen,
        true
      );
      append(div5, t10);
      mount_component(autocompletemacro, div5, null);
      append(div5, t11);
      append(div5, div3);
      append(div3, label1);
      append(div5, t13);
      append(div5, div4);
      append(div4, textarea);
      set_input_value(
        textarea,
        /*$animation*/
        ctx[0].macro.args
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[4]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[5]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$animation*/
      1) {
        select_option(
          select,
          /*$animation*/
          ctx2[0].macro.playWhen
        );
      }
      if (dirty & /*$animation*/
      1) {
        set_input_value(
          textarea,
          /*$animation*/
          ctx2[0].macro.args
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(autocompletemacro.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(autocompletemacro.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(autocompletemacro);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$T($$self, $$props, $$invalidate) {
  let $animation;
  let { animation, category } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  function removeMetaData() {
    delete $animation.metaData;
  }
  function select_change_handler() {
    $animation.macro.playWhen = select_value(this);
    animation.set($animation);
  }
  const change_handler = () => removeMetaData();
  function textarea_input_handler() {
    $animation.macro.args = this.value;
    animation.set($animation);
  }
  return [
    $animation,
    animation,
    category,
    removeMetaData,
    select_change_handler,
    change_handler,
    textarea_input_handler
  ];
}
let Macro$1 = class Macro2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$T, create_fragment$V, safe_not_equal, {});
  }
};
const SoundOnly_svelte_svelte_type_style_lang = "";
function create_fragment$U(ctx) {
  let div15;
  let div0;
  let h1;
  let t3;
  let div4;
  let div1;
  let i0;
  let i0_class_value;
  let t4;
  let div2;
  let input0;
  let t5;
  let div3;
  let i1;
  let t6;
  let table;
  let tr0;
  let td0;
  let div5;
  let label0;
  let t11;
  let div6;
  let input1;
  let t12;
  let td1;
  let div7;
  let label1;
  let t14;
  let div8;
  let input2;
  let t15;
  let td2;
  let div9;
  let label2;
  let t17;
  let div10;
  let input3;
  let t18;
  let tr1;
  let td3;
  let div11;
  let label3;
  let t20;
  let div12;
  let input4;
  let t21;
  let td4;
  let div13;
  let label4;
  let t25;
  let div14;
  let input5;
  let mounted;
  let dispose;
  return {
    c() {
      div15 = element("div");
      div0 = element("div");
      h1 = element("h1");
      h1.textContent = `${localize("autoanimations.menus.sound")} 
            ${localize("autoanimations.menus.only")}`;
      t3 = space();
      div4 = element("div");
      div1 = element("div");
      i0 = element("i");
      t4 = space();
      div2 = element("div");
      input0 = element("input");
      t5 = space();
      div3 = element("div");
      i1 = element("i");
      t6 = space();
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div5 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.start")} 
                        ${localize("autoanimations.menus.time")} (ms)`;
      t11 = space();
      div6 = element("div");
      input1 = element("input");
      t12 = space();
      td1 = element("td");
      div7 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.volume")}`;
      t14 = space();
      div8 = element("div");
      input2 = element("input");
      t15 = space();
      td2 = element("td");
      div9 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.delay")}`;
      t17 = space();
      div10 = element("div");
      input3 = element("input");
      t18 = space();
      tr1 = element("tr");
      td3 = element("td");
      div11 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.repeat")}`;
      t20 = space();
      div12 = element("div");
      input4 = element("input");
      t21 = space();
      td4 = element("td");
      div13 = element("div");
      label4 = element("label");
      label4.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t25 = space();
      div14 = element("div");
      input5 = element("input");
      attr(h1, "class", "svelte-auto-18n1thr");
      set_style(div0, "padding-top", "10px");
      attr(i0, "class", i0_class_value = "fas fa-music aa-blue " + /*isValid*/
      (ctx[1] ? "" : "aa-disableOpacity"));
      set_style(i0, "font-size", "1.5em");
      attr(i0, "title", "Play Sound");
      attr(i0, "role", "presentation");
      set_style(div1, "grid-row", "1/2");
      set_style(div1, "grid-column", "1/2");
      attr(input0, "type", "text");
      set_style(input0, "font-weight", "normal");
      set_style(input0, "font-size", "small");
      set_style(div2, "grid-row", "1/2");
      set_style(div2, "grid-column", "2/3");
      attr(i1, "class", "fas fa-file-import");
      attr(i1, "title", "File Picker");
      set_style(i1, "font-size", "1.5em");
      attr(i1, "role", "presentation");
      set_style(div3, "grid-row", "1/2");
      set_style(div3, "grid-column", "3/4");
      attr(div4, "class", "aa-Sound-container");
      attr(label0, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "0");
      attr(input1, "step", "0.01");
      attr(label1, "for", "");
      attr(input2, "type", "number");
      attr(input2, "placeholder", "0.5");
      attr(input2, "step", "0.01");
      attr(label2, "for", "");
      attr(input3, "type", "number");
      attr(input3, "placeholder", "0");
      attr(input3, "step", "0.01");
      attr(label3, "for", "");
      attr(input4, "type", "number");
      attr(input4, "placeholder", "1");
      attr(input4, "step", "1");
      attr(label4, "for", "");
      attr(input5, "type", "number");
      attr(input5, "placeholder", "250");
      attr(input5, "step", "1");
      attr(table, "class", "d");
      set_style(table, "padding-left", "2em");
      set_style(table, "padding-right", "2em");
      attr(div15, "class", "aa-soundOnly-border svelte-auto-18n1thr");
    },
    m(target2, anchor) {
      insert(target2, div15, anchor);
      append(div15, div0);
      append(div0, h1);
      append(div15, t3);
      append(div15, div4);
      append(div4, div1);
      append(div1, i0);
      append(div4, t4);
      append(div4, div2);
      append(div2, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].soundOnly.sound.file
      );
      append(div4, t5);
      append(div4, div3);
      append(div3, i1);
      append(div15, t6);
      append(div15, table);
      append(table, tr0);
      append(tr0, td0);
      append(td0, div5);
      append(div5, label0);
      append(td0, t11);
      append(td0, div6);
      append(div6, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].soundOnly.sound.startTime
      );
      append(tr0, t12);
      append(tr0, td1);
      append(td1, div7);
      append(div7, label1);
      append(td1, t14);
      append(td1, div8);
      append(div8, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].soundOnly.sound.volume
      );
      append(tr0, t15);
      append(tr0, td2);
      append(td2, div9);
      append(div9, label2);
      append(td2, t17);
      append(td2, div10);
      append(div10, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[0].soundOnly.sound.delay
      );
      append(table, t18);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div11);
      append(div11, label3);
      append(td3, t20);
      append(td3, div12);
      append(div12, input4);
      set_input_value(
        input4,
        /*$animation*/
        ctx[0].soundOnly.sound.repeat
      );
      append(tr1, t21);
      append(tr1, td4);
      append(td4, div13);
      append(div13, label4);
      append(td4, t25);
      append(td4, div14);
      append(div14, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[0].soundOnly.sound.repeatDelay
      );
      if (!mounted) {
        dispose = [
          listen(
            i0,
            "click",
            /*click_handler*/
            ctx[5]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[6]
          ),
          listen(i1, "click", prevent_default(
            /*click_handler_1*/
            ctx[7]
          )),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[8]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[9]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[10]
          ),
          listen(
            input4,
            "input",
            /*input4_input_handler*/
            ctx[11]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isValid*/
      2 && i0_class_value !== (i0_class_value = "fas fa-music aa-blue " + /*isValid*/
      (ctx2[1] ? "" : "aa-disableOpacity"))) {
        attr(i0, "class", i0_class_value);
      }
      if (dirty & /*$animation*/
      1 && input0.value !== /*$animation*/
      ctx2[0].soundOnly.sound.file) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].soundOnly.sound.file
        );
      }
      if (dirty & /*$animation*/
      1 && to_number(input1.value) !== /*$animation*/
      ctx2[0].soundOnly.sound.startTime) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].soundOnly.sound.startTime
        );
      }
      if (dirty & /*$animation*/
      1 && to_number(input2.value) !== /*$animation*/
      ctx2[0].soundOnly.sound.volume) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].soundOnly.sound.volume
        );
      }
      if (dirty & /*$animation*/
      1 && to_number(input3.value) !== /*$animation*/
      ctx2[0].soundOnly.sound.delay) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[0].soundOnly.sound.delay
        );
      }
      if (dirty & /*$animation*/
      1 && to_number(input4.value) !== /*$animation*/
      ctx2[0].soundOnly.sound.repeat) {
        set_input_value(
          input4,
          /*$animation*/
          ctx2[0].soundOnly.sound.repeat
        );
      }
      if (dirty & /*$animation*/
      1 && to_number(input5.value) !== /*$animation*/
      ctx2[0].soundOnly.sound.repeatDelay) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[0].soundOnly.sound.repeatDelay
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div15);
      mounted = false;
      run_all(dispose);
    }
  };
}
let section = "soundOnly";
function instance$S($$self, $$props, $$invalidate) {
  let isValid;
  let $animation;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const click_handler = () => category.playSound(animation._data[section].sound);
  function input0_input_handler() {
    $animation.soundOnly.sound.file = this.value;
    animation.set($animation);
  }
  const click_handler_1 = () => category.selectSound(section, idx);
  function input1_input_handler() {
    $animation.soundOnly.sound.startTime = to_number(this.value);
    animation.set($animation);
  }
  function input2_input_handler() {
    $animation.soundOnly.sound.volume = to_number(this.value);
    animation.set($animation);
  }
  function input3_input_handler() {
    $animation.soundOnly.sound.delay = to_number(this.value);
    animation.set($animation);
  }
  function input4_input_handler() {
    $animation.soundOnly.sound.repeat = to_number(this.value);
    animation.set($animation);
  }
  function input5_input_handler() {
    $animation.soundOnly.sound.repeatDelay = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, isValid = $animation.soundOnly.sound.enable && $animation.soundOnly.sound.file);
    }
  };
  return [
    $animation,
    isValid,
    animation,
    category,
    idx,
    click_handler,
    input0_input_handler,
    click_handler_1,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    input4_input_handler,
    input5_input_handler
  ];
}
class SoundOnly extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$S, create_fragment$U, safe_not_equal, {});
  }
}
const CategoryList_svelte_svelte_type_style_lang$2 = "";
function create_fragment$T(ctx) {
  let div5;
  let div4;
  let sectionbuttons;
  let t0;
  let div0;
  let soundonly;
  let div0_hidden_value;
  let t1;
  let div1;
  let macro2;
  let div1_hidden_value;
  let t2;
  let div3;
  let div2;
  let switch_instance;
  let div2_hidden_value;
  let div5_class_value;
  let current;
  sectionbuttons = new SectionButtons02({ props: { type: "item" } });
  soundonly = new SoundOnly({});
  macro2 = new Macro$1({});
  var switch_value = (
    /*menuRoute*/
    ctx[5]
  );
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      create_component(sectionbuttons.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(soundonly.$$.fragment);
      t1 = space();
      div1 = element("div");
      create_component(macro2.$$.fragment);
      t2 = space();
      div3 = element("div");
      div2 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      div0.hidden = div0_hidden_value = !/*soundOnly*/
      ctx[2];
      div1.hidden = div1_hidden_value = !/*macroEnabled*/
      ctx[1];
      div2.hidden = div2_hidden_value = /*$animation*/
      ctx[0].macro.enable && /*$animation*/
      ctx[0].macro.playWhen === "2";
      div3.hidden = /*soundOnly*/
      ctx[2];
      attr(div4, "class", "sectionBorder svelte-auto-1cwie9g");
      attr(div5, "class", div5_class_value = "animation " + (!/*isEnabled*/
      ctx[4] || !/*isCustomized*/
      ctx[3] ? "aa-disableOpacity" : ""));
    },
    m(target2, anchor) {
      insert(target2, div5, anchor);
      append(div5, div4);
      mount_component(sectionbuttons, div4, null);
      append(div4, t0);
      append(div4, div0);
      mount_component(soundonly, div0, null);
      append(div4, t1);
      append(div4, div1);
      mount_component(macro2, div1, null);
      append(div4, t2);
      append(div4, div3);
      append(div3, div2);
      if (switch_instance)
        mount_component(switch_instance, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*soundOnly*/
      4 && div0_hidden_value !== (div0_hidden_value = !/*soundOnly*/
      ctx2[2])) {
        div0.hidden = div0_hidden_value;
      }
      if (!current || dirty & /*macroEnabled*/
      2 && div1_hidden_value !== (div1_hidden_value = !/*macroEnabled*/
      ctx2[1])) {
        div1.hidden = div1_hidden_value;
      }
      if (dirty & /*menuRoute*/
      32 && switch_value !== (switch_value = /*menuRoute*/
      ctx2[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div2, null);
        } else {
          switch_instance = null;
        }
      }
      if (!current || dirty & /*$animation*/
      1 && div2_hidden_value !== (div2_hidden_value = /*$animation*/
      ctx2[0].macro.enable && /*$animation*/
      ctx2[0].macro.playWhen === "2")) {
        div2.hidden = div2_hidden_value;
      }
      if (!current || dirty & /*soundOnly*/
      4) {
        div3.hidden = /*soundOnly*/
        ctx2[2];
      }
      if (!current || dirty & /*isEnabled, isCustomized*/
      24 && div5_class_value !== (div5_class_value = "animation " + (!/*isEnabled*/
      ctx2[4] || !/*isCustomized*/
      ctx2[3] ? "aa-disableOpacity" : ""))) {
        attr(div5, "class", div5_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sectionbuttons.$$.fragment, local);
      transition_in(soundonly.$$.fragment, local);
      transition_in(macro2.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sectionbuttons.$$.fragment, local);
      transition_out(soundonly.$$.fragment, local);
      transition_out(macro2.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(sectionbuttons);
      destroy_component(soundonly);
      destroy_component(macro2);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function instance$R($$self, $$props, $$invalidate) {
  let menuRoute;
  let isEnabled;
  let isCustomized;
  let soundOnly;
  let macroEnabled;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  let newContentOptions = {
    ontoken: { component: BuildAEOnToken },
    aura: { component: BuildAEAura }
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(5, menuRoute = newContentOptions[$animation.activeEffectType].component);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(4, isEnabled = $animation.isEnabled);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(3, isCustomized = $animation.isCustomized);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(2, soundOnly = $animation.soundOnly.sound.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, macroEnabled = $animation.macro.enable);
    }
  };
  return [
    $animation,
    macroEnabled,
    soundOnly,
    isCustomized,
    isEnabled,
    menuRoute,
    animation
  ];
}
let CategoryList$2 = class CategoryList2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$R, create_fragment$T, safe_not_equal, {});
  }
};
const Slider_svelte_svelte_type_style_lang = "";
function create_fragment$S(ctx) {
  let div;
  let button;
  let t0;
  let span;
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      t0 = space();
      span = element("span");
      t1 = text(
        /*label*/
        ctx[0]
      );
      attr(button, "role", "switch");
      attr(
        button,
        "aria-checked",
        /*isChecked*/
        ctx[1]
      );
      attr(button, "aria-labelledby", `switch-${/*uniqueID*/
      ctx[3]}`);
      set_style(button, "margin-right", ".5em");
      attr(button, "class", "svelte-auto-34arqj");
      attr(span, "id", `switch-${/*uniqueID*/
      ctx[3]}`);
      attr(div, "class", "aa-SliderBox svelte-auto-34arqj");
      set_style(div, "font-size", "16px");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, button);
      append(div, t0);
      append(div, span);
      append(span, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isChecked*/
      2) {
        attr(
          button,
          "aria-checked",
          /*isChecked*/
          ctx2[1]
        );
      }
      if (dirty & /*label*/
      1)
        set_data(
          t1,
          /*label*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function instance$Q($$self, $$props, $$invalidate) {
  let isChecked;
  let $animation;
  let { label } = $$props;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(6, $animation = value));
  let { field } = $$props;
  const uniqueID = Math.floor(Math.random() * 100);
  function clickThis() {
    let isChecked2 = $animation[field];
    set_store_value(animation, $animation[field] = !isChecked2, $animation);
  }
  const click_handler = () => clickThis();
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("field" in $$props2)
      $$invalidate(5, field = $$props2.field);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation, field*/
    96) {
      $$invalidate(1, isChecked = $animation[field]);
    }
  };
  return [
    label,
    isChecked,
    animation,
    uniqueID,
    clickThis,
    field,
    $animation,
    click_handler
  ];
}
class Slider extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$Q, create_fragment$S, safe_not_equal, { label: 0, field: 5 });
  }
}
const CopyToAutorec_svelte_svelte_type_style_lang = "";
function create_else_block$b(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      set_style(div, "height", "2em");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$e(ctx) {
  let div;
  let label;
  let t0;
  let t1;
  let t2_value = localize(`autoanimations.animTypes.${/*menu*/
  ctx[2]}`) + "";
  let t2;
  let t3;
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(
        /*nameToAdd*/
        ctx[0]
      );
      t1 = text(" already exists in the Global ");
      t2 = text(t2_value);
      t3 = text(" Menu!!");
      attr(label, "for", "");
      set_style(label, "margin-top", "1em");
      set_style(div, "height", "2em");
      set_style(div, "font-weight", "bold");
      set_style(div, "font-size", "1em");
      set_style(div, "color", "red");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, label);
      append(label, t0);
      append(label, t1);
      append(label, t2);
      append(label, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*nameToAdd*/
      1)
        set_data(
          t0,
          /*nameToAdd*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$R(ctx) {
  let div3;
  let div0;
  let label0;
  let strong0;
  let t1;
  let br;
  let t2;
  let strong1;
  let t5;
  let div1;
  let label1;
  let t9;
  let div2;
  let input;
  let t10;
  let t11;
  let button;
  let t12;
  let button_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*checkAutorec*/
      ctx2[1]
    )
      return create_if_block$e;
    return create_else_block$b;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      label0 = element("label");
      strong0 = element("strong");
      strong0.textContent = "Adding entry to Global Automatic Recognition";
      t1 = space();
      br = element("br");
      t2 = space();
      strong1 = element("strong");
      strong1.textContent = `${localize(`autoanimations.animTypes.${/*menu*/
      ctx[2]}`)} Menu`;
      t5 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = `Input Label for the new ${localize(`autoanimations.animTypes.${/*menu*/
      ctx[2]}`)} Section`;
      t9 = space();
      div2 = element("div");
      input = element("input");
      t10 = space();
      if_block.c();
      t11 = space();
      button = element("button");
      t12 = text("Submit");
      attr(label0, "for", "");
      set_style(div0, "font-size", "1.3em");
      attr(label1, "for", "");
      set_style(div1, "margin-top", "1em");
      attr(input, "type", "text");
      set_style(input, "width", "25em");
      set_style(input, "margin", "auto");
      set_style(input, "border-radius", "1em");
      attr(button, "class", button_class_value = "aa-copySubmitButton " + /*checkAutorec*/
      (ctx[1] ? "aa-disableOpacity" : "") + " svelte-auto-ef9uc6");
      attr(div3, "class", "aa-CopyToAutorec svelte-auto-ef9uc6");
    },
    m(target2, anchor) {
      insert(target2, div3, anchor);
      append(div3, div0);
      append(div0, label0);
      append(label0, strong0);
      append(label0, t1);
      append(label0, br);
      append(label0, t2);
      append(label0, strong1);
      append(div3, t5);
      append(div3, div1);
      append(div1, label1);
      append(div3, t9);
      append(div3, div2);
      append(div2, input);
      set_input_value(
        input,
        /*nameToAdd*/
        ctx[0]
      );
      append(div3, t10);
      if_block.m(div3, null);
      append(div3, t11);
      append(div3, button);
      append(button, t12);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*nameToAdd*/
      1 && input.value !== /*nameToAdd*/
      ctx2[0]) {
        set_input_value(
          input,
          /*nameToAdd*/
          ctx2[0]
        );
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div3, t11);
        }
      }
      if (dirty & /*checkAutorec*/
      2 && button_class_value !== (button_class_value = "aa-copySubmitButton " + /*checkAutorec*/
      (ctx2[1] ? "aa-disableOpacity" : "") + " svelte-auto-ef9uc6")) {
        attr(button, "class", button_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$P($$self, $$props, $$invalidate) {
  let nameToAdd;
  let checkAutorec;
  let { animation } = $$props;
  let { item: item2 } = $$props;
  const { application } = getContext("#external");
  const currentLabel = item2.name;
  const menu = animation._data.menu;
  const currentMenu = game.settings.get("autoanimations", `aaAutorec-${menu}`);
  function submitNewEntry() {
    animation.copyToAutorec(nameToAdd);
    application.close();
  }
  function input_input_handler() {
    nameToAdd = this.value;
    $$invalidate(0, nameToAdd);
  }
  const click_handler = () => submitNewEntry();
  $$self.$$set = ($$props2) => {
    if ("animation" in $$props2)
      $$invalidate(4, animation = $$props2.animation);
    if ("item" in $$props2)
      $$invalidate(5, item2 = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*nameToAdd*/
    1) {
      $$invalidate(1, checkAutorec = AAAutorecFunctions.singleMenuStrictSearch(currentMenu, AAAutorecFunctions.rinseName(nameToAdd)));
    }
  };
  $$invalidate(0, nameToAdd = currentLabel);
  return [
    nameToAdd,
    checkAutorec,
    menu,
    submitNewEntry,
    animation,
    item2,
    input_input_handler,
    click_handler
  ];
}
class CopyToAutorec extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$P, create_fragment$R, safe_not_equal, { animation: 4, item: 5 });
  }
}
class ItemToAutorec extends TJSDialog {
  constructor(data2) {
    super({
      title: "Item to Autorec",
      resizable: true,
      modal: true,
      draggable: true,
      content: {
        class: CopyToAutorec,
        props: {
          ...data2
        }
      }
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      width: "auto",
      height: "auto",
      closeOnSubmit: true,
      id: `AA-Copy-Item-To-Global`
    });
  }
}
function copyToFrom(animation, item2, autorecSettings, isAE) {
  let contents = [];
  let copyFrom = {
    label: "Copy From Autorec",
    icon: "far fa-clone",
    onPress: async () => {
      if (!animation._data.isEnabled) {
        return;
      }
      let name = isAE ? item2.label : item2.name;
      const isInAutorec = isAE ? AAAutorecFunctions.singleMenuSearch(AAAutorecFunctions.sortAndFilterMenus(autorecSettings), AAAutorecFunctions.rinseName(name)) : AAAutorecFunctions.allMenuSearch(AAAutorecFunctions.sortAndFilterMenus(autorecSettings), AAAutorecFunctions.rinseName(name));
      if (!isInAutorec) {
        custom_notify("There is no matching Global entry to copy from");
        return;
      }
      let menu = game.i18n.localize(`autoanimations.animTypes.${isInAutorec.menu}`);
      const label = isInAutorec.label;
      const result = await TJSDialog.confirm({
        title: "Copy Item From Global Menu",
        content: `Are you sure you want copy <strong>${label}</strong> from the <strong>Global ${menu} Menu?</strong>`,
        draggable: false,
        modal: true
      });
      if (result) {
        animation.copyFromAutorec(isInAutorec);
      }
    }
  };
  let copyTo = {
    label: "Copy To Autorec",
    // TODO: localize,
    icon: "far fa-clone",
    onPress: async () => {
      if (!animation._data.isEnabled) {
        return;
      }
      if (!game.user.isGM) {
        console.error("Automated Animations | NON-GM users cannot copy items to the Global Automatic Recognition Menu");
        return;
      }
      if (!animation._data.isEnabled || !animation._data.isCustomized) {
        ui.notifications.info("Automated Animations | There is no data present on this item to copy to the Global Automatic Recognition Menu");
        return;
      }
      new ItemToAutorec({ animation, item: item2 }).render(true);
    }
  };
  if (game.user.isGM) {
    contents.push(copyFrom);
    contents.push(copyTo);
  } else {
    contents.push(copyFrom);
  }
  return contents;
}
const NoneChosen_svelte_svelte_type_style_lang$1 = "";
function create_else_block_1$4(ctx) {
  let ul;
  return {
    c() {
      ul = element("ul");
      ul.innerHTML = `<li><strong>Animations are disabled for this item</strong>   <i class="fas fa-xmark aa-red"></i></li>`;
    },
    m(target2, anchor) {
      insert(target2, ul, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(ul);
    }
  };
}
function create_if_block_2$5(ctx) {
  let ul;
  let t2;
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*isInAutorec*/
      ctx2[2]
    )
      return create_if_block_3$3;
    return create_else_block$a;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      ul = element("ul");
      ul.innerHTML = `<li><strong>Item Animation is enabled but not configured!!</strong>   <i class="fas fa-xmark aa-red"></i></li>`;
      t2 = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      insert(target2, ul, anchor);
      insert(target2, t2, anchor);
      if_block.m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      if (detaching)
        detach(t2);
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$7(ctx) {
  let ul0;
  let t2;
  let ul1;
  return {
    c() {
      ul0 = element("ul");
      ul0.innerHTML = `<li><strong>Item Animation is enabled but not customized</strong>   <i class="fas fa-check aa-green"></i></li>`;
      t2 = space();
      ul1 = element("ul");
      ul1.innerHTML = `<li><strong>No Global Automatic Recognition is matched</strong>   <i class="fas fa-xmark aa-red"></i></li>`;
    },
    m(target2, anchor) {
      insert(target2, ul0, anchor);
      insert(target2, t2, anchor);
      insert(target2, ul1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(ul0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(ul1);
    }
  };
}
function create_if_block$d(ctx) {
  let ul0;
  let t2;
  let ul1;
  let t5;
  let ul2;
  let li2;
  let strong2;
  let t6;
  let t7;
  let t8;
  let t9_value = (
    /*isInAutorec*/
    ctx[2].label + ""
  );
  let t9;
  let t10;
  let i2;
  return {
    c() {
      ul0 = element("ul");
      ul0.innerHTML = `<li><strong>Item Animation is enabled but not customized</strong>   <i class="fas fa-check aa-green"></i></li>`;
      t2 = space();
      ul1 = element("ul");
      ul1.innerHTML = `<li><strong>Global Automatic Recogntion is matched</strong>   <i class="fas fa-check aa-green"></i></li>`;
      t5 = space();
      ul2 = element("ul");
      li2 = element("li");
      strong2 = element("strong");
      t6 = text("Menu: ");
      t7 = text(
        /*autorecLabel*/
        ctx[3]
      );
      t8 = text(" - Label: ");
      t9 = text(t9_value);
      t10 = space();
      i2 = element("i");
      attr(i2, "class", "fas fa-check aa-green");
    },
    m(target2, anchor) {
      insert(target2, ul0, anchor);
      insert(target2, t2, anchor);
      insert(target2, ul1, anchor);
      insert(target2, t5, anchor);
      insert(target2, ul2, anchor);
      append(ul2, li2);
      append(li2, strong2);
      append(strong2, t6);
      append(strong2, t7);
      append(strong2, t8);
      append(strong2, t9);
      append(li2, t10);
      append(li2, i2);
    },
    p(ctx2, dirty) {
      if (dirty & /*isInAutorec*/
      4 && t9_value !== (t9_value = /*isInAutorec*/
      ctx2[2].label + ""))
        set_data(t9, t9_value);
    },
    d(detaching) {
      if (detaching)
        detach(ul0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(ul1);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(ul2);
    }
  };
}
function create_else_block$a(ctx) {
  let ul;
  return {
    c() {
      ul = element("ul");
      ul.innerHTML = `<li><strong>No Global Automatic Recognition is matched</strong>   <i class="fas fa-xmark aa-red"></i></li>`;
    },
    m(target2, anchor) {
      insert(target2, ul, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(ul);
    }
  };
}
function create_if_block_3$3(ctx) {
  let ul0;
  let t1;
  let ul1;
  let t4;
  let ul2;
  let li2;
  let strong2;
  let t5;
  let t6;
  let t7;
  let t8_value = (
    /*isInAutorec*/
    ctx[2].label + ""
  );
  let t8;
  let t9;
  let i1;
  return {
    c() {
      ul0 = element("ul");
      ul0.innerHTML = `<li><strong>Global Automatic Recognition will be used</strong></li>`;
      t1 = space();
      ul1 = element("ul");
      ul1.innerHTML = `<li><strong>Global Automatic Recogntion is matched</strong>   <i class="fas fa-check aa-green"></i></li>`;
      t4 = space();
      ul2 = element("ul");
      li2 = element("li");
      strong2 = element("strong");
      t5 = text("Menu: ");
      t6 = text(
        /*autorecLabel*/
        ctx[3]
      );
      t7 = text(" - Label: ");
      t8 = text(t8_value);
      t9 = space();
      i1 = element("i");
      attr(i1, "class", "fas fa-check aa-green");
    },
    m(target2, anchor) {
      insert(target2, ul0, anchor);
      insert(target2, t1, anchor);
      insert(target2, ul1, anchor);
      insert(target2, t4, anchor);
      insert(target2, ul2, anchor);
      append(ul2, li2);
      append(li2, strong2);
      append(strong2, t5);
      append(strong2, t6);
      append(strong2, t7);
      append(strong2, t8);
      append(li2, t9);
      append(li2, i1);
    },
    p(ctx2, dirty) {
      if (dirty & /*isInAutorec*/
      4 && t8_value !== (t8_value = /*isInAutorec*/
      ctx2[2].label + ""))
        set_data(t8, t8_value);
    },
    d(detaching) {
      if (detaching)
        detach(ul0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(ul1);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(ul2);
    }
  };
}
function create_fragment$Q(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (
      /*isEnabled*/
      ctx2[0] && !/*isCustomized*/
      ctx2[1] && /*isInAutorec*/
      ctx2[2]
    )
      return create_if_block$d;
    if (
      /*isEnabled*/
      ctx2[0] && !/*isCustomized*/
      ctx2[1] && !/*isInAutorec*/
      ctx2[2]
    )
      return create_if_block_1$7;
    if (
      /*isEnabled*/
      ctx2[0] && /*isCustomized*/
      ctx2[1]
    )
      return create_if_block_2$5;
    return create_else_block_1$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "aa-Info svelte-auto-2ogv0j");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function instance$O($$self, $$props, $$invalidate) {
  let { isEnabled } = $$props;
  let { isCustomized } = $$props;
  let { isInAutorec } = $$props;
  let autorecLabel = isInAutorec ? game.i18n.localize(`autoanimations.animTypes.${isInAutorec.menu}`) : "";
  $$self.$$set = ($$props2) => {
    if ("isEnabled" in $$props2)
      $$invalidate(0, isEnabled = $$props2.isEnabled);
    if ("isCustomized" in $$props2)
      $$invalidate(1, isCustomized = $$props2.isCustomized);
    if ("isInAutorec" in $$props2)
      $$invalidate(2, isInAutorec = $$props2.isInAutorec);
  };
  return [isEnabled, isCustomized, isInAutorec, autorecLabel];
}
let NoneChosen$1 = class NoneChosen2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$O, create_fragment$Q, safe_not_equal, {
      isEnabled: 0,
      isCustomized: 1,
      isInAutorec: 2
    });
  }
};
const CategoryControl_svelte_svelte_type_style_lang$2 = "";
function create_else_block_1$3(ctx) {
  let label;
  return {
    c() {
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.globalNotFound")}`;
      attr(label, "for", "");
      set_style(label, "font-size", "15px");
      set_style(label, "font-weight", "bold");
    },
    m(target2, anchor) {
      insert(target2, label, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_if_block_1$6(ctx) {
  let label;
  let t0_value = localize("autoanimations.menus.globalFound") + "";
  let t0;
  let t1;
  let br;
  return {
    c() {
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      br = element("br");
      attr(label, "for", "");
      set_style(label, "font-size", "15px");
      set_style(label, "font-weight", "bold");
    },
    m(target2, anchor) {
      insert(target2, label, anchor);
      append(label, t0);
      append(label, t1);
      append(label, br);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_default_slot$n(ctx) {
  let tjsmenu;
  let current;
  tjsmenu = new TJSMenu({ props: { menu: (
    /*subMenu*/
    ctx[11]
  ) } });
  return {
    c() {
      create_component(tjsmenu.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjsmenu, target2, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsmenu, detaching);
    }
  };
}
function create_else_block$9(ctx) {
  let categorylist;
  let current;
  categorylist = new CategoryList$2({});
  return {
    c() {
      create_component(categorylist.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(categorylist, target2, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(categorylist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(categorylist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(categorylist, detaching);
    }
  };
}
function create_if_block$c(ctx) {
  let div;
  let switch_instance;
  let current;
  var switch_value = NoneChosen$1;
  function switch_props(ctx2) {
    return {
      props: {
        isEnabled: (
          /*isEnabled*/
          ctx2[4]
        ),
        isCustomized: (
          /*isCustomized*/
          ctx2[3]
        ),
        isInAutorec: (
          /*isInAutorec*/
          ctx2[6]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", "sectionBorder svelte-auto-1iu6c13");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*isEnabled*/
      16)
        switch_instance_changes.isEnabled = /*isEnabled*/
        ctx2[4];
      if (dirty & /*isCustomized*/
      8)
        switch_instance_changes.isCustomized = /*isCustomized*/
        ctx2[3];
      if (dirty & /*isInAutorec*/
      64)
        switch_instance_changes.isInAutorec = /*isInAutorec*/
        ctx2[6];
      if (switch_value !== (switch_value = NoneChosen$1)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment$P(ctx) {
  let header;
  let ul0;
  let div0;
  let slider0;
  let t0;
  let div1;
  let slider1;
  let div1_class_value;
  let t1;
  let div2;
  let div2_class_value;
  let t2;
  let div3;
  let tjstoggleiconbutton;
  let div3_class_value;
  let t3;
  let div4;
  let label;
  let t7;
  let select;
  let option0;
  let option1;
  let div4_class_value;
  let t10;
  let main2;
  let current_block_type_index;
  let if_block1;
  let t11;
  let footer;
  let ul1;
  let button0;
  let t13;
  let button1;
  let current;
  let mounted;
  let dispose;
  slider0 = new Slider({
    props: {
      label: (
        /*disabledLabel*/
        ctx[5]
      ),
      field: "isEnabled"
    }
  });
  slider1 = new Slider({
    props: {
      label: localize("autoanimations.menus.customize") + " Item",
      field: "isCustomized"
    }
  });
  function select_block_type(ctx2, dirty) {
    if (
      /*isInAutorec*/
      ctx2[6]
    )
      return create_if_block_1$6;
    return create_else_block_1$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  tjstoggleiconbutton = new TJSToggleIconButton({
    props: {
      button: (
        /*buttonOverflow*/
        ctx[10]
      ),
      slot: "summary-end",
      $$slots: { default: [create_default_slot$n] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block$c, create_else_block$9];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (!/*menuType*/
    ctx2[2] || !/*isEnabled*/
    ctx2[4] || !/*isCustomized*/
    ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      header = element("header");
      ul0 = element("ul");
      div0 = element("div");
      create_component(slider0.$$.fragment);
      t0 = space();
      div1 = element("div");
      create_component(slider1.$$.fragment);
      t1 = space();
      div2 = element("div");
      if_block0.c();
      t2 = space();
      div3 = element("div");
      create_component(tjstoggleiconbutton.$$.fragment);
      t3 = space();
      div4 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.animation")} 
        ${localize("autoanimations.menus.type")}`;
      t7 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.animTypes.ontoken")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.animTypes.aura")}`;
      t10 = space();
      main2 = element("main");
      if_block1.c();
      t11 = space();
      footer = element("footer");
      ul1 = element("ul");
      button0 = element("button");
      button0.textContent = "Submit";
      t13 = space();
      button1 = element("button");
      button1.textContent = "Submit and Close";
      set_style(div0, "grid-row", "1/2");
      set_style(div0, "grid-column", "1/2");
      set_style(div1, "grid-row", "2/3");
      set_style(div1, "grid-column", "1/2");
      attr(div1, "class", div1_class_value = !/*isEnabled*/
      ctx[4] ? "aa-disableOpacity" : "");
      set_style(div2, "grid-row", "1 / 2");
      set_style(div2, "grid-column", "2/3");
      attr(div2, "class", div2_class_value = "autorecLabel " + /*isInAutorec*/
      (ctx[6] ? "aa-bgGreen" : "aa-bgRed") + " " + (!/*isEnabled*/
      ctx[4] ? "aa-disableOpacity" : "") + " svelte-auto-1iu6c13");
      set_style(div3, "grid-row", "1/2");
      set_style(div3, "grid-column", "3/4");
      attr(div3, "class", div3_class_value = !/*isEnabled*/
      ctx[4] ? "aa-disableOpacity" : "");
      attr(label, "for", "");
      set_style(label, "font-weight", "bold");
      option0.__value = "ontoken";
      option0.value = option0.__value;
      option1.__value = "aura";
      option1.value = option1.__value;
      if (
        /*$animation*/
        ctx[1].activeEffectType === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[13].call(select)
        ));
      set_style(div4, "grid-row", "2/3");
      set_style(div4, "grid-column", "2/4");
      set_style(div4, "padding-bottom", "10px");
      set_style(div4, "margin-left", "1.5em");
      attr(div4, "class", div4_class_value = !/*isEnabled*/
      ctx[4] || !/*isCustomized*/
      ctx[3] ? "aa-disableOpacity" : "");
      attr(ul0, "class", "svelte-auto-1iu6c13");
      attr(header, "class", "animation svelte-auto-1iu6c13");
      attr(main2, "class", "svelte-auto-1iu6c13");
      set_style(button0, "background-color", "rgba(0, 0, 0, 0.2)");
      attr(button0, "class", "svelte-auto-1iu6c13");
      attr(button1, "class", "svelte-auto-1iu6c13");
      attr(ul1, "class", "svelte-auto-1iu6c13");
      attr(footer, "class", "svelte-auto-1iu6c13");
    },
    m(target2, anchor) {
      insert(target2, header, anchor);
      append(header, ul0);
      append(ul0, div0);
      mount_component(slider0, div0, null);
      append(ul0, t0);
      append(ul0, div1);
      mount_component(slider1, div1, null);
      append(ul0, t1);
      append(ul0, div2);
      if_block0.m(div2, null);
      append(ul0, t2);
      append(ul0, div3);
      mount_component(tjstoggleiconbutton, div3, null);
      append(ul0, t3);
      append(ul0, div4);
      append(div4, label);
      append(div4, t7);
      append(div4, select);
      append(select, option0);
      append(select, option1);
      select_option(
        select,
        /*$animation*/
        ctx[1].activeEffectType,
        true
      );
      insert(target2, t10, anchor);
      insert(target2, main2, anchor);
      if_blocks[current_block_type_index].m(main2, null);
      insert(target2, t11, anchor);
      insert(target2, footer, anchor);
      append(footer, ul1);
      append(ul1, button0);
      append(ul1, t13);
      append(ul1, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[13]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[14]
          ),
          listen(button0, "click", prevent_default(
            /*click_handler*/
            ctx[15]
          )),
          listen(button1, "click", prevent_default(
            /*click_handler_1*/
            ctx[16]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const slider0_changes = {};
      if (dirty & /*disabledLabel*/
      32)
        slider0_changes.label = /*disabledLabel*/
        ctx2[5];
      slider0.$set(slider0_changes);
      if (!current || dirty & /*isEnabled*/
      16 && div1_class_value !== (div1_class_value = !/*isEnabled*/
      ctx2[4] ? "aa-disableOpacity" : "")) {
        attr(div1, "class", div1_class_value);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div2, null);
        }
      }
      if (!current || dirty & /*isInAutorec, isEnabled*/
      80 && div2_class_value !== (div2_class_value = "autorecLabel " + /*isInAutorec*/
      (ctx2[6] ? "aa-bgGreen" : "aa-bgRed") + " " + (!/*isEnabled*/
      ctx2[4] ? "aa-disableOpacity" : "") + " svelte-auto-1iu6c13")) {
        attr(div2, "class", div2_class_value);
      }
      const tjstoggleiconbutton_changes = {};
      if (dirty & /*$$scope*/
      2097152) {
        tjstoggleiconbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjstoggleiconbutton.$set(tjstoggleiconbutton_changes);
      if (!current || dirty & /*isEnabled*/
      16 && div3_class_value !== (div3_class_value = !/*isEnabled*/
      ctx2[4] ? "aa-disableOpacity" : "")) {
        attr(div3, "class", div3_class_value);
      }
      if (dirty & /*$animation*/
      2) {
        select_option(
          select,
          /*$animation*/
          ctx2[1].activeEffectType
        );
      }
      if (!current || dirty & /*isEnabled, isCustomized*/
      24 && div4_class_value !== (div4_class_value = !/*isEnabled*/
      ctx2[4] || !/*isCustomized*/
      ctx2[3] ? "aa-disableOpacity" : "")) {
        attr(div4, "class", div4_class_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(main2, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(slider0.$$.fragment, local);
      transition_in(slider1.$$.fragment, local);
      transition_in(tjstoggleiconbutton.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(slider0.$$.fragment, local);
      transition_out(slider1.$$.fragment, local);
      transition_out(tjstoggleiconbutton.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(header);
      destroy_component(slider0);
      destroy_component(slider1);
      if_block0.d();
      destroy_component(tjstoggleiconbutton);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(main2);
      if_blocks[current_block_type_index].d();
      if (detaching)
        detach(t11);
      if (detaching)
        detach(footer);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$N($$self, $$props, $$invalidate) {
  let isInAutorec;
  let disabledLabel;
  let isEnabled;
  let isCustomized;
  let menuType;
  let $animation, $$unsubscribe_animation = noop, $$subscribe_animation = () => ($$unsubscribe_animation(), $$unsubscribe_animation = subscribe(animation, ($$value) => $$invalidate(1, $animation = $$value)), animation);
  $$self.$$.on_destroy.push(() => $$unsubscribe_animation());
  async function switchVideo() {
    let newMenu = $animation.activeEffectType;
    if (!newMenu) {
      return;
    }
    let newData = aefx($animation, newMenu);
    switch (newMenu) {
      case "ontoken":
        set_store_value(animation, $animation.macro = newData.macro, $animation);
        set_store_value(animation, $animation.primary = newData.primary, $animation);
        set_store_value(animation, $animation.secondary = newData.secondary, $animation);
        set_store_value(animation, $animation.soundOnly = newData.soundOnly, $animation);
        set_store_value(animation, $animation.source = newData.source, $animation);
        break;
      default:
        set_store_value(animation, $animation.macro = newData.macro, $animation);
        set_store_value(animation, $animation.primary = newData.primary, $animation);
        set_store_value(animation, $animation.secondary = newData.secondary, $animation);
        set_store_value(animation, $animation.soundOnly = newData.soundOnly, $animation);
        set_store_value(animation, $animation.source = newData.source, $animation);
        break;
    }
  }
  let { animation } = $$props;
  $$subscribe_animation();
  setContext("animation-data", { animation, category: animation, idx: 0 });
  let { item: item2 } = $$props;
  const { application } = getContext("#external");
  let aefxMenu = game.settings.get("autoanimations", "aaAutorec-aefx");
  async function applyFlags() {
    await item2.update({ "flags.-=autoanimations": null });
    await item2.update({ "flags.autoanimations": $animation });
  }
  async function closeApp() {
    await item2.update({ "flags.-=autoanimations": null });
    await item2.update({ "flags.autoanimations": $animation });
    application.close();
  }
  let menu = isInAutorec ? game.i18n.localize(`autoanimations.animTypes.${isInAutorec.menu}`) : "";
  isInAutorec ? `Menu: ${menu} - Label: ${isInAutorec.label}` : `No Autorec match found`;
  const buttonOverflow = {
    icon: "fas fa-ellipsis-v",
    efx: ripple(),
    title: "Copy To/From",
    styles: { "margin-left": "0.5em" },
    onClickPropagate: false
    // Necessary to capture click for Firefox.
  };
  const subMenu = {
    items: copyToFrom(animation, item2, aefxMenu, true)
  };
  function select_change_handler() {
    $animation.activeEffectType = select_value(this);
    animation.set($animation);
  }
  const change_handler = async () => await switchVideo();
  const click_handler = () => applyFlags();
  const click_handler_1 = () => closeApp();
  $$self.$$set = ($$props2) => {
    if ("animation" in $$props2)
      $$subscribe_animation($$invalidate(0, animation = $$props2.animation));
    if ("item" in $$props2)
      $$invalidate(12, item2 = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(6, isInAutorec = AAAutorecFunctions.singleMenuSearch(aefxMenu, AAAutorecFunctions.rinseName($animation.label), $animation.label));
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(5, disabledLabel = $animation.isEnabled ? game.i18n.localize("autoanimations.menus.animation") + " " + game.i18n.localize("autoanimations.menus.enabled") : game.i18n.localize("autoanimations.menus.animation") + " " + game.i18n.localize("autoanimations.menus.disabled"));
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(4, isEnabled = $animation.isEnabled);
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(3, isCustomized = $animation.isCustomized);
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(2, menuType = $animation.activeEffectType);
    }
  };
  return [
    animation,
    $animation,
    menuType,
    isCustomized,
    isEnabled,
    disabledLabel,
    isInAutorec,
    switchVideo,
    applyFlags,
    closeApp,
    buttonOverflow,
    subMenu,
    item2,
    select_change_handler,
    change_handler,
    click_handler,
    click_handler_1
  ];
}
let CategoryControl$2 = class CategoryControl2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$N, create_fragment$P, safe_not_equal, { animation: 0, item: 12 });
  }
};
function create_default_slot$m(ctx) {
  let categorycontrol;
  let current;
  categorycontrol = new CategoryControl$2({
    props: {
      item: (
        /*item*/
        ctx[2]
      ),
      animation: (
        /*animation*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(categorycontrol.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(categorycontrol, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const categorycontrol_changes = {};
      if (dirty & /*item*/
      4)
        categorycontrol_changes.item = /*item*/
        ctx2[2];
      categorycontrol.$set(categorycontrol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(categorycontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(categorycontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(categorycontrol, detaching);
    }
  };
}
function create_fragment$O(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[9](value);
  }
  let applicationshell_props = {
    stylesContent: { color: "black" },
    $$slots: { default: [create_default_slot$m] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(applicationshell, target2, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope, item*/
      65540) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
function instance$M($$self, $$props, $$invalidate) {
  let $position;
  let $storageStore, $$unsubscribe_storageStore = noop, $$subscribe_storageStore = () => ($$unsubscribe_storageStore(), $$unsubscribe_storageStore = subscribe(storageStore, ($$value) => $$invalidate(11, $storageStore = $$value)), storageStore);
  let $doc;
  let $animation;
  $$self.$$.on_destroy.push(() => $$unsubscribe_storageStore());
  let { elementRoot } = $$props;
  let { storageStore = void 0 } = $$props;
  $$subscribe_storageStore();
  let { item: item2 } = $$props;
  let { itemFlags } = $$props;
  const doc = new TJSDocument(item2);
  component_subscribe($$self, doc, (value) => $$invalidate(8, $doc = value));
  let aaFlags = itemFlags.autoanimations || {};
  const { application } = getContext("#external");
  let newFlagData = foundry.utils.deepClone(aaFlags);
  if (!newFlagData.hasOwnProperty("activeEffectType")) {
    newFlagData = aefx("ontoken");
    newFlagData.activeEffectType = "ontoken";
  }
  if (!newFlagData.hasOwnProperty("isEnabled")) {
    newFlagData.isEnabled = true;
  }
  if (!newFlagData.hasOwnProperty("isCustomized")) {
    newFlagData.isCustomized = false;
  }
  if (!newFlagData.hasOwnProperty("version")) {
    newFlagData.version = Object.keys(flagMigrations.migrations).map((n) => Number(n)).reverse()[0];
  }
  newFlagData.label = item2.label;
  let animation = new AnimationStore$2(newFlagData);
  component_subscribe($$self, animation, (value) => $$invalidate(12, $animation = value));
  const position = application.position;
  component_subscribe($$self, position, (value) => $$invalidate(7, $position = value));
  const storeAppState = foundry.utils.debounce(() => set_store_value(storageStore, $storageStore = application.state.get(), $storageStore), 500);
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("storageStore" in $$props2)
      $$subscribe_storageStore($$invalidate(1, storageStore = $$props2.storageStore));
    if ("item" in $$props2)
      $$invalidate(2, item2 = $$props2.item);
    if ("itemFlags" in $$props2)
      $$invalidate(6, itemFlags = $$props2.itemFlags);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$doc*/
    256) {
      {
        set_store_value(animation, $animation.label = $doc.label || $doc.name, $animation);
      }
    }
    if ($$self.$$.dirty & /*$position*/
    128) {
      storeAppState($position);
    }
  };
  return [
    elementRoot,
    storageStore,
    item2,
    doc,
    animation,
    position,
    itemFlags,
    $position,
    $doc,
    applicationshell_elementRoot_binding
  ];
}
class AEAppShell extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$M, create_fragment$O, safe_not_equal, {
      elementRoot: 0,
      storageStore: 1,
      item: 2,
      itemFlags: 6
    });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get storageStore() {
    return this.$$.ctx[1];
  }
  set storageStore(storageStore) {
    this.$$set({ storageStore });
    flush();
  }
  get item() {
    return this.$$.ctx[2];
  }
  set item(item2) {
    this.$$set({ item: item2 });
    flush();
  }
  get itemFlags() {
    return this.$$.ctx[6];
  }
  set itemFlags(itemFlags) {
    this.$$set({ itemFlags });
    flush();
  }
}
function create_fragment$N(ctx) {
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: {
      button: (
        /*button*/
        ctx[3]
      ),
      icon: (
        /*icon*/
        ctx[0]
      ),
      title: (
        /*title*/
        ctx[1]
      )
    }
  });
  tjsiconbutton.$on(
    "click",
    /*onClick*/
    ctx[4]
  );
  return {
    c() {
      create_component(tjsiconbutton.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjsiconbutton, target2, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjsiconbutton_changes = {};
      if (dirty & /*icon*/
      1)
        tjsiconbutton_changes.icon = /*icon*/
        ctx2[0];
      if (dirty & /*title*/
      2)
        tjsiconbutton_changes.title = /*title*/
        ctx2[1];
      tjsiconbutton.$set(tjsiconbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsiconbutton, detaching);
    }
  };
}
function instance$L($$self, $$props, $$invalidate) {
  let dataReducer;
  let $dataReducer, $$unsubscribe_dataReducer = noop, $$subscribe_dataReducer = () => ($$unsubscribe_dataReducer(), $$unsubscribe_dataReducer = subscribe(dataReducer, ($$value) => $$invalidate(6, $dataReducer = $$value)), dataReducer);
  $$self.$$.on_destroy.push(() => $$unsubscribe_dataReducer());
  let { category } = $$props;
  const stringCloseAll = game.i18n.localize("autoanimations.menus.close") + " " + game.i18n.localize("autoanimations.menus.all");
  let icon, title2;
  icon = "fas fa-angle-double-up";
  title2 = stringCloseAll;
  const button = {
    efx: ripple(),
    styles: {
      "margin-left": "0.5em",
      "margin-right": "auto"
    }
  };
  function onClick() {
    for (const animationStore of $dataReducer) {
      animationStore.folderState = false;
    }
  }
  $$self.$$set = ($$props2) => {
    if ("category" in $$props2)
      $$invalidate(5, category = $$props2.category);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*category*/
    32) {
      $$subscribe_dataReducer($$invalidate(2, dataReducer = category.dataReducer));
    }
  };
  return [icon, title2, dataReducer, button, onClick, category];
}
class ButtonOpenCloseAll extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$L, create_fragment$N, safe_not_equal, { category: 5 });
  }
}
function createOverflowItems$1(category) {
  return [
    {
      label: "Delete All",
      // TODO: localize,
      icon: "far fa-trash-alt",
      onPress: async () => {
        const result = await TJSDialog.confirm({
          title: "Delete All Animations?",
          content: `Are you sure you want to delete all animations from '${category.label}'?`,
          draggable: false,
          modal: true
        });
        if (result) {
          category.clearEntries();
        }
      }
    }
  ];
}
const CategoryControl_svelte_svelte_type_style_lang$1 = "";
function create_default_slot$l(ctx) {
  let tjsmenu;
  let current;
  tjsmenu = new TJSMenu({ props: { menu: (
    /*menu*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(tjsmenu.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjsmenu, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjsmenu_changes = {};
      if (dirty & /*menu*/
      2)
        tjsmenu_changes.menu = /*menu*/
        ctx2[1];
      tjsmenu.$set(tjsmenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsmenu, detaching);
    }
  };
}
function create_fragment$M(ctx) {
  let header;
  let tjsiconbutton0;
  let t0;
  let buttonopencloseall;
  let t1;
  let tjsinput;
  let t2;
  let tjsiconbutton1;
  let t3;
  let tjstoggleiconbutton;
  let current;
  tjsiconbutton0 = new TJSIconButton({ props: { button: (
    /*buttonAdd*/
    ctx[2]
  ) } });
  tjsiconbutton0.$on(
    "click",
    /*click_handler*/
    ctx[7]
  );
  buttonopencloseall = new ButtonOpenCloseAll({ props: { category: (
    /*category*/
    ctx[0]
  ) } });
  tjsinput = new TJSInput({ props: { input: (
    /*input*/
    ctx[3]
  ) } });
  tjsiconbutton1 = new TJSIconButton({ props: { button: (
    /*buttonSort*/
    ctx[4]
  ) } });
  tjsiconbutton1.$on(
    "click",
    /*click_handler_1*/
    ctx[8]
  );
  tjstoggleiconbutton = new TJSToggleIconButton({
    props: {
      button: (
        /*buttonOverflow*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot$l] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      header = element("header");
      create_component(tjsiconbutton0.$$.fragment);
      t0 = space();
      create_component(buttonopencloseall.$$.fragment);
      t1 = space();
      create_component(tjsinput.$$.fragment);
      t2 = space();
      create_component(tjsiconbutton1.$$.fragment);
      t3 = space();
      create_component(tjstoggleiconbutton.$$.fragment);
      attr(header, "class", "svelte-auto-1vbjp39");
    },
    m(target2, anchor) {
      insert(target2, header, anchor);
      mount_component(tjsiconbutton0, header, null);
      append(header, t0);
      mount_component(buttonopencloseall, header, null);
      append(header, t1);
      mount_component(tjsinput, header, null);
      append(header, t2);
      mount_component(tjsiconbutton1, header, null);
      append(header, t3);
      mount_component(tjstoggleiconbutton, header, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const buttonopencloseall_changes = {};
      if (dirty & /*category*/
      1)
        buttonopencloseall_changes.category = /*category*/
        ctx2[0];
      buttonopencloseall.$set(buttonopencloseall_changes);
      const tjstoggleiconbutton_changes = {};
      if (dirty & /*$$scope, menu*/
      1026) {
        tjstoggleiconbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjstoggleiconbutton.$set(tjstoggleiconbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton0.$$.fragment, local);
      transition_in(buttonopencloseall.$$.fragment, local);
      transition_in(tjsinput.$$.fragment, local);
      transition_in(tjsiconbutton1.$$.fragment, local);
      transition_in(tjstoggleiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton0.$$.fragment, local);
      transition_out(buttonopencloseall.$$.fragment, local);
      transition_out(tjsinput.$$.fragment, local);
      transition_out(tjsiconbutton1.$$.fragment, local);
      transition_out(tjstoggleiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(header);
      destroy_component(tjsiconbutton0);
      destroy_component(buttonopencloseall);
      destroy_component(tjsinput);
      destroy_component(tjsiconbutton1);
      destroy_component(tjstoggleiconbutton);
    }
  };
}
function instance$K($$self, $$props, $$invalidate) {
  let menu;
  let menuTab;
  let { category } = $$props;
  const buttonAdd = {
    icon: "fas fa-plus",
    efx: ripple(),
    title: "autoanimations.menus.add"
  };
  const input = {
    store: category.filterSearch,
    efx: rippleFocus(),
    placeholder: "autoanimations.menus.search",
    type: "search"
  };
  const buttonSort = {
    icon: "fas fa-sort-alpha-down",
    efx: ripple(),
    styles: { "margin-left": "auto" },
    title: "autoanimations.menus.sortmenu"
  };
  const buttonOverflow = {
    icon: "fas fa-ellipsis-v",
    efx: ripple(),
    styles: { "margin-left": "0.5em" }
  };
  function addEntry() {
    let newData = changeSection[menuTab]();
    category.createEntry(newData);
  }
  const click_handler = () => addEntry();
  const click_handler_1 = () => category.sortAlpha();
  $$self.$$set = ($$props2) => {
    if ("category" in $$props2)
      $$invalidate(0, category = $$props2.category);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*category*/
    1) {
      $$invalidate(1, menu = { items: createOverflowItems$1(category) });
    }
    if ($$self.$$.dirty & /*category*/
    1) {
      menuTab = category.key.split("-")[1];
    }
  };
  return [
    category,
    menu,
    buttonAdd,
    input,
    buttonSort,
    buttonOverflow,
    addEntry,
    click_handler,
    click_handler_1
  ];
}
let CategoryControl$1 = class CategoryControl3 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$K, create_fragment$M, safe_not_equal, { category: 0 });
  }
};
function flip(node, { from, to }, params = {}) {
  const style = getComputedStyle(node);
  const transform = style.transform === "none" ? "" : style.transform;
  const [ox, oy] = style.transformOrigin.split(" ").map(parseFloat);
  const dx = from.left + from.width * ox / to.width - (to.left + ox);
  const dy = from.top + from.height * oy / to.height - (to.top + oy);
  const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
  return {
    delay,
    duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
    easing,
    css: (t, u) => {
      const x = u * dx;
      const y = u * dy;
      const sx = t + u * from.width / to.width;
      const sy = t + u * from.height / to.height;
      return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
    }
  };
}
const OverflowSlot_svelte_svelte_type_style_lang = "";
function create_default_slot$k(ctx) {
  let tjsmenu;
  let current;
  tjsmenu = new TJSMenu({ props: { menu: (
    /*menu*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(tjsmenu.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjsmenu, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjsmenu_changes = {};
      if (dirty & /*menu*/
      1)
        tjsmenu_changes.menu = /*menu*/
        ctx2[0];
      tjsmenu.$set(tjsmenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsmenu, detaching);
    }
  };
}
function create_fragment$L(ctx) {
  let div0;
  let i;
  let i_class_value;
  let i_title_value;
  let t;
  let div1;
  let tjstoggleiconbutton;
  let current;
  tjstoggleiconbutton = new TJSToggleIconButton({
    props: {
      button: (
        /*buttonOverflow*/
        ctx[2]
      ),
      slot: "summary-end",
      $$slots: { default: [create_default_slot$k] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      i = element("i");
      t = space();
      div1 = element("div");
      create_component(tjstoggleiconbutton.$$.fragment);
      attr(i, "class", i_class_value = null_to_empty(
        /*info*/
        ctx[1]?.icon
      ) + " svelte-auto-1hdz18j");
      attr(i, "title", i_title_value = /*info*/
      ctx[1].title);
      attr(div0, "class", "quickView svelte-auto-1hdz18j");
    },
    m(target2, anchor) {
      insert(target2, div0, anchor);
      append(div0, i);
      insert(target2, t, anchor);
      insert(target2, div1, anchor);
      mount_component(tjstoggleiconbutton, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*info*/
      2 && i_class_value !== (i_class_value = null_to_empty(
        /*info*/
        ctx2[1]?.icon
      ) + " svelte-auto-1hdz18j")) {
        attr(i, "class", i_class_value);
      }
      if (!current || dirty & /*info*/
      2 && i_title_value !== (i_title_value = /*info*/
      ctx2[1].title)) {
        attr(i, "title", i_title_value);
      }
      const tjstoggleiconbutton_changes = {};
      if (dirty & /*$$scope, menu*/
      9) {
        tjstoggleiconbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjstoggleiconbutton.$set(tjstoggleiconbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjstoggleiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjstoggleiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div1);
      destroy_component(tjstoggleiconbutton);
    }
  };
}
function instance$J($$self, $$props, $$invalidate) {
  let { menu } = $$props;
  let { info = {} } = $$props;
  const buttonOverflow = {
    icon: "fas fa-ellipsis-v",
    efx: ripple(),
    styles: { "margin-left": "0.5em" },
    onClickPropagate: false
    // Necessary to capture click for Firefox.
  };
  $$self.$$set = ($$props2) => {
    if ("menu" in $$props2)
      $$invalidate(0, menu = $$props2.menu);
    if ("info" in $$props2)
      $$invalidate(1, info = $$props2.info);
  };
  return [menu, info, buttonOverflow];
}
class OverflowSlot extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$J, create_fragment$L, safe_not_equal, { menu: 0, info: 1 });
  }
}
const AdvancedAutorec_svelte_svelte_type_style_lang = "";
function get_each_context$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  child_ctx[16] = list;
  child_ctx[17] = i;
  return child_ctx;
}
function create_each_block$8(ctx) {
  let div;
  let input;
  let t;
  let tjsiconbutton;
  let current;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[7].call(
      input,
      /*each_value*/
      ctx[16],
      /*i*/
      ctx[17]
    );
  }
  function click_handler() {
    return (
      /*click_handler*/
      ctx[8](
        /*i*/
        ctx[17]
      )
    );
  }
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*removeButton*/
      ctx[5]
    ) }
  });
  tjsiconbutton.$on("click", click_handler);
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      create_component(tjsiconbutton.$$.fragment);
      attr(input, "type", "text");
      attr(div, "class", "flexrow");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      set_input_value(
        input,
        /*term*/
        ctx[15]
      );
      append(div, t);
      mount_component(tjsiconbutton, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$animation*/
      2 && input.value !== /*term*/
      ctx[15]) {
        set_input_value(
          input,
          /*term*/
          ctx[15]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$K(ctx) {
  let header;
  let div0;
  let label0;
  let t5;
  let table0;
  let tr0;
  let th0;
  let div1;
  let input0;
  let t6;
  let label1;
  let t9;
  let table1;
  let tr1;
  let th1;
  let div3;
  let div2;
  let label2;
  let t11;
  let t12;
  let button;
  let div3_class_value;
  let t14;
  let table2;
  let tr2;
  let th2;
  let div4;
  let input1;
  let t15;
  let label3;
  let t21;
  let tr3;
  let th3;
  let t23;
  let th4;
  let div8;
  let div6;
  let t24_value = localize("autoanimations.menus.path") + "";
  let t24;
  let t25;
  let input2;
  let t26;
  let div7;
  let t27_value = localize("autoanimations.menus.property") + "";
  let t27;
  let t28;
  let input3;
  let tr3_class_value;
  let t29;
  let div9;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*$animation*/
    ctx[1].advanced.excludedTerms
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      header = element("header");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.advanced")}  ${localize("autoanimations.menus.recognition")}  ${localize("autoanimations.menus.features")}`;
      t5 = space();
      table0 = element("table");
      tr0 = element("tr");
      th0 = element("th");
      div1 = element("div");
      input0 = element("input");
      t6 = space();
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.forceExact")}?`;
      t9 = space();
      table1 = element("table");
      tr1 = element("tr");
      th1 = element("th");
      div3 = element("div");
      div2 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.excludedSearchWords")}`;
      t11 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t12 = space();
      button = element("button");
      button.textContent = "Add";
      t14 = space();
      table2 = element("table");
      tr2 = element("tr");
      th2 = element("th");
      div4 = element("div");
      input1 = element("input");
      t15 = space();
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.exclude")}  ${localize("autoanimations.menus.item")}  ${localize("autoanimations.menus.property")}`;
      t21 = space();
      tr3 = element("tr");
      th3 = element("th");
      th3.innerHTML = `<div style="margin-top: 1.5em">item.</div>`;
      t23 = space();
      th4 = element("th");
      div8 = element("div");
      div6 = element("div");
      t24 = text(t24_value);
      t25 = space();
      input2 = element("input");
      t26 = space();
      div7 = element("div");
      t27 = text(t27_value);
      t28 = space();
      input3 = element("input");
      t29 = space();
      div9 = element("div");
      attr(label0, "for", "");
      set_style(div0, "text-align", "center");
      set_style(div0, "font-size", "1.5em");
      attr(input0, "type", "checkbox");
      attr(label1, "for", "");
      set_style(label1, "font-size", "1.25em");
      attr(label1, "class", "svelte-auto-4e9x60");
      attr(th0, "colspan", "2");
      attr(table0, "class", "c svelte-auto-4e9x60");
      attr(label2, "for", "");
      set_style(label2, "font-size", "1.25em");
      attr(label2, "class", "svelte-auto-4e9x60");
      attr(div3, "class", div3_class_value = /*isExactMatch*/
      ctx[2] ? "aa-disableOpacity" : "");
      attr(th1, "colspan", "2");
      set_style(th1, "padding-top", "1em");
      attr(table1, "class", "c svelte-auto-4e9x60");
      attr(input1, "type", "checkbox");
      attr(label3, "for", "");
      set_style(label3, "font-size", "1.25em");
      attr(label3, "class", "svelte-auto-4e9x60");
      attr(th2, "colspan", "2");
      set_style(th2, "padding-top", "1em");
      attr(input2, "type", "text");
      set_style(input2, "text-align", "left");
      attr(input3, "type", "text");
      attr(div8, "class", "flexrow");
      attr(tr3, "class", tr3_class_value = /*$animation*/
      ctx[1].advanced.excludedType.enabled ? "" : "aa-disableOpacity");
      attr(table2, "class", "c svelte-auto-4e9x60");
      attr(div9, "class", "aa-list");
    },
    m(target2, anchor) {
      insert(target2, header, anchor);
      append(header, div0);
      append(div0, label0);
      insert(target2, t5, anchor);
      insert(target2, table0, anchor);
      append(table0, tr0);
      append(tr0, th0);
      append(th0, div1);
      append(div1, input0);
      input0.checked = /*$animation*/
      ctx[1].advanced.exactMatch;
      append(div1, t6);
      append(div1, label1);
      insert(target2, t9, anchor);
      insert(target2, table1, anchor);
      append(table1, tr1);
      append(tr1, th1);
      append(th1, div3);
      append(div3, div2);
      append(div2, label2);
      append(div3, t11);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div3, null);
        }
      }
      append(div3, t12);
      append(div3, button);
      insert(target2, t14, anchor);
      insert(target2, table2, anchor);
      append(table2, tr2);
      append(tr2, th2);
      append(th2, div4);
      append(div4, input1);
      input1.checked = /*$animation*/
      ctx[1].advanced.excludedType.enabled;
      append(div4, t15);
      append(div4, label3);
      append(table2, t21);
      append(table2, tr3);
      append(tr3, th3);
      append(tr3, t23);
      append(tr3, th4);
      append(th4, div8);
      append(div8, div6);
      append(div6, t24);
      append(div6, t25);
      append(div6, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[1].advanced.excludedType.path
      );
      append(div8, t26);
      append(div8, div7);
      append(div7, t27);
      append(div7, t28);
      append(div7, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[1].advanced.excludedType.property
      );
      insert(target2, t29, anchor);
      insert(target2, div9, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[6]
          ),
          listen(
            button,
            "click",
            /*click_handler_1*/
            ctx[9]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[10]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[11]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$animation*/
      2) {
        input0.checked = /*$animation*/
        ctx2[1].advanced.exactMatch;
      }
      if (dirty & /*removeButton, removeThis, $animation*/
      50) {
        each_value = /*$animation*/
        ctx2[1].advanced.excludedTerms;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$8(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div3, t12);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*isExactMatch*/
      4 && div3_class_value !== (div3_class_value = /*isExactMatch*/
      ctx2[2] ? "aa-disableOpacity" : "")) {
        attr(div3, "class", div3_class_value);
      }
      if (dirty & /*$animation*/
      2) {
        input1.checked = /*$animation*/
        ctx2[1].advanced.excludedType.enabled;
      }
      if (dirty & /*$animation*/
      2 && input2.value !== /*$animation*/
      ctx2[1].advanced.excludedType.path) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[1].advanced.excludedType.path
        );
      }
      if (dirty & /*$animation*/
      2 && input3.value !== /*$animation*/
      ctx2[1].advanced.excludedType.property) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[1].advanced.excludedType.property
        );
      }
      if (!current || dirty & /*$animation*/
      2 && tr3_class_value !== (tr3_class_value = /*$animation*/
      ctx2[1].advanced.excludedType.enabled ? "" : "aa-disableOpacity")) {
        attr(tr3, "class", tr3_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(header);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(table0);
      if (detaching)
        detach(t9);
      if (detaching)
        detach(table1);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t14);
      if (detaching)
        detach(table2);
      if (detaching)
        detach(t29);
      if (detaching)
        detach(div9);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$I($$self, $$props, $$invalidate) {
  let isExactMatch;
  let excludedTerms;
  let $animation, $$unsubscribe_animation = noop, $$subscribe_animation = () => ($$unsubscribe_animation(), $$unsubscribe_animation = subscribe(animation, ($$value) => $$invalidate(1, $animation = $$value)), animation);
  $$self.$$.on_destroy.push(() => $$unsubscribe_animation());
  getContext("#external");
  let { animation } = $$props;
  $$subscribe_animation();
  if (!animation._data.advanced) {
    set_store_value(
      animation,
      $animation.advanced = {
        exactMatch: false,
        excludedTerms: [],
        excludedType: { enabled: false, path: "", property: "" }
      },
      $animation
    );
  }
  function addSection() {
    set_store_value(animation, $animation.advanced.excludedTerms = [...excludedTerms, ""], $animation);
  }
  function removeThis(idx) {
    excludedTerms.splice(idx, 1);
    set_store_value(animation, $animation.advanced.excludedTerms = [...excludedTerms], $animation);
  }
  const removeButton = {
    icon: "far fa-trash-can",
    efx: ripple(),
    title: "Delete"
  };
  function input0_change_handler() {
    $animation.advanced.exactMatch = this.checked;
    animation.set($animation);
  }
  function input_input_handler(each_value, i) {
    each_value[i] = this.value;
    animation.set($animation);
  }
  const click_handler = (i) => removeThis(i);
  const click_handler_1 = () => addSection();
  function input1_change_handler() {
    $animation.advanced.excludedType.enabled = this.checked;
    animation.set($animation);
  }
  function input2_input_handler() {
    $animation.advanced.excludedType.path = this.value;
    animation.set($animation);
  }
  function input3_input_handler() {
    $animation.advanced.excludedType.property = this.value;
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("animation" in $$props2)
      $$subscribe_animation($$invalidate(0, animation = $$props2.animation));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(2, isExactMatch = $animation.advanced.exactMatch);
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      excludedTerms = $animation.advanced.excludedTerms;
    }
  };
  return [
    animation,
    $animation,
    isExactMatch,
    addSection,
    removeThis,
    removeButton,
    input0_change_handler,
    input_input_handler,
    click_handler,
    click_handler_1,
    input1_change_handler,
    input2_input_handler,
    input3_input_handler
  ];
}
class AdvancedAutorec extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$I, create_fragment$K, safe_not_equal, { animation: 0 });
  }
}
function createOverflowItems(animation, category) {
  return [
    {
      label: "autoanimations.menus.duplicate",
      icon: "far fa-clone",
      onPress: () => category.duplicateEntry(animation.id)
    },
    {
      label: "Delete",
      // TODO: localize,
      icon: "far fa-trash-alt",
      onPress: async () => {
        const label = animation.label !== "" ? `'${animation.label}'` : "'No Item Name'";
        const result = await TJSDialog.confirm({
          title: "Delete Animation?",
          content: `Are you sure you want to delete: ${label}`,
          draggable: false,
          modal: true
        });
        if (result) {
          category.deleteEntry(animation.id);
        }
      }
    },
    {
      label: "Metadata",
      icon: "fas fa-heart-pulse",
      onPress: () => animation.getSource()
    },
    {
      label: "Advanced",
      icon: "fab fa-searchengin",
      onPress: async () => {
        new TJSDialog({
          modal: true,
          title: `Advanced Features: ${animation._data.label}`,
          content: {
            class: AdvancedAutorec,
            props: {
              animation
            }
          },
          defaultYes: false
        }).render(true);
      }
    }
  ];
}
function create_default_slot$j(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let numberinput0;
  let t1;
  let td2;
  let numberinput1;
  let t2;
  let tr1;
  let td3;
  let div0;
  let label0;
  let t3_value = localize("autoanimations.menus.persistant") + "";
  let t3;
  let t4;
  let input0;
  let t5;
  let td4;
  let div1;
  let label1;
  let t6_value = localize("autoanimations.menus.bind") + "";
  let t6;
  let t7;
  let t8_value = localize("autoanimations.menus.visibility") + "";
  let t8;
  let t9;
  let input1;
  let div1_class_value;
  let t10;
  let td5;
  let div2;
  let label2;
  let t11_value = localize("autoanimations.menus.bind") + "";
  let t11;
  let t12;
  let t13_value = localize("autoanimations.menus.alpha") + "";
  let t13;
  let t14;
  let input2;
  let div2_class_value;
  let t15;
  let tr2;
  let td6;
  let div3;
  let label3;
  let t16_value = localize("autoanimations.menus.mask") + "";
  let t16;
  let t17;
  let input3;
  let t18;
  let td7;
  let opacity;
  let t19;
  let td8;
  let numberinput2;
  let t20;
  let tr3;
  let td9;
  let scaleradius;
  let t21;
  let td10;
  let div4;
  let label4;
  let t22_value = localize("autoanimations.menus.add") + "";
  let t22;
  let t23;
  let t24_value = localize("autoanimations.menus.token") + "";
  let t24;
  let t25;
  let t26_value = localize("autoanimations.menus.width") + "";
  let t26;
  let t27;
  let input4;
  let div4_class_value;
  let t28;
  let td11;
  let numberinput3;
  let t29;
  let tr4;
  let td12;
  let numberinput4;
  let t30;
  let td13;
  let div5;
  let label5;
  let t32;
  let div6;
  let input5;
  let t33;
  let td14;
  let div7;
  let label6;
  let t34_value = localize("autoanimations.menus.sideImpact") + "";
  let t34;
  let t35;
  let input6;
  let t36;
  let tr5;
  let td15;
  let numberinput5;
  let t37;
  let td16;
  let numberinput6;
  let t38;
  let td17;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation$1({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      section: "target"
    }
  });
  numberinput0 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.repeat"),
      section: "target",
      field: "repeat",
      isDisabled: (
        /*persistent*/
        ctx[2] ? "aa-disableOpacity" : ""
      )
    }
  });
  numberinput1 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.repeat") + " " + localize("autoanimations.menus.delay"),
      section: "target",
      field: "repeatDelay",
      placeholder: "250",
      isDisabled: (
        /*persistent*/
        ctx[2] ? "aa-disableOpacity" : ""
      )
    }
  });
  opacity = new Opacity$1({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      section: "target"
    }
  });
  numberinput2 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.z-index"),
      section: "target",
      field: "zIndex"
    }
  });
  scaleradius = new ScaleRadius$1({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      section: "target",
      field: "size",
      step: "0.01"
    }
  });
  numberinput3 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.fadeIn"),
      section: "target",
      field: "fadeIn",
      placeholder: "250"
    }
  });
  numberinput4 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.fadeOut"),
      section: "target",
      field: "fadeOut",
      placeholder: "500"
    }
  });
  numberinput5 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.playbackRate"),
      section: "target",
      field: "playbackRate"
    }
  });
  numberinput6 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.delay"),
      section: "target",
      field: "delay"
    }
  });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      create_component(numberinput0.$$.fragment);
      t1 = space();
      td2 = element("td");
      create_component(numberinput1.$$.fragment);
      t2 = space();
      tr1 = element("tr");
      td3 = element("td");
      div0 = element("div");
      label0 = element("label");
      t3 = text(t3_value);
      t4 = space();
      input0 = element("input");
      t5 = space();
      td4 = element("td");
      div1 = element("div");
      label1 = element("label");
      t6 = text(t6_value);
      t7 = space();
      t8 = text(t8_value);
      t9 = space();
      input1 = element("input");
      t10 = space();
      td5 = element("td");
      div2 = element("div");
      label2 = element("label");
      t11 = text(t11_value);
      t12 = space();
      t13 = text(t13_value);
      t14 = space();
      input2 = element("input");
      t15 = space();
      tr2 = element("tr");
      td6 = element("td");
      div3 = element("div");
      label3 = element("label");
      t16 = text(t16_value);
      t17 = space();
      input3 = element("input");
      t18 = space();
      td7 = element("td");
      create_component(opacity.$$.fragment);
      t19 = space();
      td8 = element("td");
      create_component(numberinput2.$$.fragment);
      t20 = space();
      tr3 = element("tr");
      td9 = element("td");
      create_component(scaleradius.$$.fragment);
      t21 = space();
      td10 = element("td");
      div4 = element("div");
      label4 = element("label");
      t22 = text(t22_value);
      t23 = space();
      t24 = text(t24_value);
      t25 = space();
      t26 = text(t26_value);
      t27 = space();
      input4 = element("input");
      t28 = space();
      td11 = element("td");
      create_component(numberinput3.$$.fragment);
      t29 = space();
      tr4 = element("tr");
      td12 = element("td");
      create_component(numberinput4.$$.fragment);
      t30 = space();
      td13 = element("td");
      div5 = element("div");
      label5 = element("label");
      label5.textContent = `${localize("autoanimations.menus.anchor")}`;
      t32 = space();
      div6 = element("div");
      input5 = element("input");
      t33 = space();
      td14 = element("td");
      div7 = element("div");
      label6 = element("label");
      t34 = text(t34_value);
      t35 = space();
      input6 = element("input");
      t36 = space();
      tr5 = element("tr");
      td15 = element("td");
      create_component(numberinput5.$$.fragment);
      t37 = space();
      td16 = element("td");
      create_component(numberinput6.$$.fragment);
      t38 = space();
      td17 = element("td");
      attr(label0, "for", "TPersist " + /*animation*/
      ctx[3]._data.id);
      attr(input0, "type", "checkbox");
      attr(input0, "id", "TPersist " + /*animation*/
      ctx[3]._data.id);
      attr(label1, "for", "TVis " + /*animation*/
      ctx[3]._data.id);
      attr(input1, "type", "checkbox");
      attr(input1, "id", "TVis " + /*animation*/
      ctx[3]._data.id);
      attr(div1, "class", div1_class_value = /*persistent*/
      ctx[2] ? "" : "aa-disableOpacity");
      attr(label2, "for", "TAlpha " + /*animation*/
      ctx[3]._data.id);
      attr(input2, "type", "checkbox");
      attr(input2, "id", "TAlpha " + /*animation*/
      ctx[3]._data.id);
      attr(div2, "class", div2_class_value = /*persistent*/
      ctx[2] ? "" : "aa-disableOpacity");
      attr(label3, "for", "SMasked " + /*animation*/
      ctx[3]._data.id);
      attr(input3, "type", "checkbox");
      attr(input3, "id", "SMasked " + /*animation*/
      ctx[3]._data.id);
      attr(label4, "for", "TWidth " + /*animation*/
      ctx[3]._data.id);
      attr(input4, "type", "checkbox");
      attr(input4, "id", "TWidth " + /*animation*/
      ctx[3]._data.id);
      attr(div4, "class", div4_class_value = /*isRadius*/
      ctx[1] ? "" : "aa-disableOpacity");
      attr(label5, "for", "");
      attr(input5, "type", "text");
      attr(input5, "placeholder", "0.5");
      attr(label6, "for", "TarRotate " + /*animation*/
      ctx[3]._data.id);
      attr(input6, "type", "checkbox");
      attr(input6, "id", "TarRotate " + /*animation*/
      ctx[3]._data.id);
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      mount_component(numberinput0, td1, null);
      append(tr0, t1);
      append(tr0, td2);
      mount_component(numberinput1, td2, null);
      append(table, t2);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div0);
      append(div0, label0);
      append(label0, t3);
      append(div0, t4);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[0].target.options.persistent;
      append(tr1, t5);
      append(tr1, td4);
      append(td4, div1);
      append(div1, label1);
      append(label1, t6);
      append(label1, t7);
      append(label1, t8);
      append(div1, t9);
      append(div1, input1);
      input1.checked = /*$animation*/
      ctx[0].target.options.unbindVisibility;
      append(tr1, t10);
      append(tr1, td5);
      append(td5, div2);
      append(div2, label2);
      append(label2, t11);
      append(label2, t12);
      append(label2, t13);
      append(div2, t14);
      append(div2, input2);
      input2.checked = /*$animation*/
      ctx[0].target.options.unbindAlpha;
      append(table, t15);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div3);
      append(div3, label3);
      append(label3, t16);
      append(div3, t17);
      append(div3, input3);
      input3.checked = /*$animation*/
      ctx[0].target.options.isMasked;
      append(tr2, t18);
      append(tr2, td7);
      mount_component(opacity, td7, null);
      append(tr2, t19);
      append(tr2, td8);
      mount_component(numberinput2, td8, null);
      append(table, t20);
      append(table, tr3);
      append(tr3, td9);
      mount_component(scaleradius, td9, null);
      append(tr3, t21);
      append(tr3, td10);
      append(td10, div4);
      append(div4, label4);
      append(label4, t22);
      append(label4, t23);
      append(label4, t24);
      append(label4, t25);
      append(label4, t26);
      append(div4, t27);
      append(div4, input4);
      input4.checked = /*$animation*/
      ctx[0].target.options.addTokenWidth;
      append(tr3, t28);
      append(tr3, td11);
      mount_component(numberinput3, td11, null);
      append(table, t29);
      append(table, tr4);
      append(tr4, td12);
      mount_component(numberinput4, td12, null);
      append(tr4, t30);
      append(tr4, td13);
      append(td13, div5);
      append(div5, label5);
      append(td13, t32);
      append(td13, div6);
      append(div6, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[0].target.options.anchor
      );
      append(tr4, t33);
      append(tr4, td14);
      append(td14, div7);
      append(div7, label6);
      append(label6, t34);
      append(div7, t35);
      append(div7, input6);
      input6.checked = /*$animation*/
      ctx[0].target.options.rotateSource;
      append(table, t36);
      append(table, tr5);
      append(tr5, td15);
      mount_component(numberinput5, td15, null);
      append(tr5, t37);
      append(tr5, td16);
      mount_component(numberinput6, td16, null);
      append(tr5, t38);
      append(tr5, td17);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[7]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[8]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[9]
          ),
          listen(
            input3,
            "change",
            /*input3_change_handler*/
            ctx[10]
          ),
          listen(
            input4,
            "change",
            /*input4_change_handler*/
            ctx[11]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler*/
            ctx[12]
          ),
          listen(
            input6,
            "change",
            /*input6_change_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const numberinput0_changes = {};
      if (dirty & /*persistent*/
      4)
        numberinput0_changes.isDisabled = /*persistent*/
        ctx2[2] ? "aa-disableOpacity" : "";
      numberinput0.$set(numberinput0_changes);
      const numberinput1_changes = {};
      if (dirty & /*persistent*/
      4)
        numberinput1_changes.isDisabled = /*persistent*/
        ctx2[2] ? "aa-disableOpacity" : "";
      numberinput1.$set(numberinput1_changes);
      if (dirty & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].target.options.persistent;
      }
      if (dirty & /*$animation*/
      1) {
        input1.checked = /*$animation*/
        ctx2[0].target.options.unbindVisibility;
      }
      if (!current || dirty & /*persistent*/
      4 && div1_class_value !== (div1_class_value = /*persistent*/
      ctx2[2] ? "" : "aa-disableOpacity")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input2.checked = /*$animation*/
        ctx2[0].target.options.unbindAlpha;
      }
      if (!current || dirty & /*persistent*/
      4 && div2_class_value !== (div2_class_value = /*persistent*/
      ctx2[2] ? "" : "aa-disableOpacity")) {
        attr(div2, "class", div2_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input3.checked = /*$animation*/
        ctx2[0].target.options.isMasked;
      }
      if (dirty & /*$animation*/
      1) {
        input4.checked = /*$animation*/
        ctx2[0].target.options.addTokenWidth;
      }
      if (!current || dirty & /*isRadius*/
      2 && div4_class_value !== (div4_class_value = /*isRadius*/
      ctx2[1] ? "" : "aa-disableOpacity")) {
        attr(div4, "class", div4_class_value);
      }
      if (dirty & /*$animation*/
      1 && input5.value !== /*$animation*/
      ctx2[0].target.options.anchor) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[0].target.options.anchor
        );
      }
      if (dirty & /*$animation*/
      1) {
        input6.checked = /*$animation*/
        ctx2[0].target.options.rotateSource;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(scaleradius.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(numberinput4.$$.fragment, local);
      transition_in(numberinput5.$$.fragment, local);
      transition_in(numberinput6.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(scaleradius.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(numberinput4.$$.fragment, local);
      transition_out(numberinput5.$$.fragment, local);
      transition_out(numberinput6.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(opacity);
      destroy_component(numberinput2);
      destroy_component(scaleradius);
      destroy_component(numberinput3);
      destroy_component(numberinput4);
      destroy_component(numberinput5);
      destroy_component(numberinput6);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$g(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[5]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[6]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$J(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[4]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$g],
        default: [create_default_slot$j]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, isRadius, persistent*/
      16391) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let persistent;
  let isRadius;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    },
    label: game.i18n.localize("autoanimations.menus.options")
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    },
    onClickPropagate: false
  };
  const click_handler = () => OptionsDialog.show("ontoken");
  function input0_change_handler() {
    $animation.target.options.persistent = this.checked;
    animation.set($animation);
  }
  function input1_change_handler() {
    $animation.target.options.unbindVisibility = this.checked;
    animation.set($animation);
  }
  function input2_change_handler() {
    $animation.target.options.unbindAlpha = this.checked;
    animation.set($animation);
  }
  function input3_change_handler() {
    $animation.target.options.isMasked = this.checked;
    animation.set($animation);
  }
  function input4_change_handler() {
    $animation.target.options.addTokenWidth = this.checked;
    animation.set($animation);
  }
  function input5_input_handler() {
    $animation.target.options.anchor = this.value;
    animation.set($animation);
  }
  function input6_change_handler() {
    $animation.target.options.rotateSource = this.checked;
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(2, persistent = $animation.target.options.persistent);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, isRadius = $animation.target.options.isRadius);
    }
  };
  return [
    $animation,
    isRadius,
    persistent,
    animation,
    folder,
    optionsInfo,
    click_handler,
    input0_change_handler,
    input1_change_handler,
    input2_change_handler,
    input3_change_handler,
    input4_change_handler,
    input5_input_handler,
    input6_change_handler
  ];
}
class TargetFXOptions extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$H, create_fragment$J, safe_not_equal, {});
  }
}
const ExtraTarget_svelte_svelte_type_style_lang = "";
function create_default_slot$i(ctx) {
  let div;
  let videoselect;
  let t0;
  let targetfxoptions;
  let t1;
  let switch_instance;
  let t2;
  let soundsettings;
  let div_class_value;
  let current;
  videoselect = new VideoSelect({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      section: "target",
      title: (
        /*title*/
        ctx[4]
      ),
      idx: (
        /*idx*/
        ctx[3]
      ),
      category: (
        /*category*/
        ctx[2]
      )
    }
  });
  targetfxoptions = new TargetFXOptions({
    props: { animation: (
      /*animation*/
      ctx[1]
    ) }
  });
  var switch_value = EffectColor;
  function switch_props(ctx2) {
    return { props: { section: "target" } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  soundsettings = new SoundSettings({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      category: (
        /*category*/
        ctx[2]
      ),
      idx: (
        /*idx*/
        ctx[3]
      ),
      section: "target"
    }
  });
  return {
    c() {
      div = element("div");
      create_component(videoselect.$$.fragment);
      t0 = space();
      create_component(targetfxoptions.$$.fragment);
      t1 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t2 = space();
      create_component(soundsettings.$$.fragment);
      attr(div, "class", div_class_value = null_to_empty(!/*$animation*/
      ctx[0].target?.enable ? "aa-isDisabled" : "") + " svelte-auto-1yddlio");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(videoselect, div, null);
      append(div, t0);
      mount_component(targetfxoptions, div, null);
      append(div, t1);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append(div, t2);
      mount_component(soundsettings, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = EffectColor)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t2);
        } else {
          switch_instance = null;
        }
      }
      if (!current || dirty & /*$animation*/
      1 && div_class_value !== (div_class_value = null_to_empty(!/*$animation*/
      ctx2[0].target?.enable ? "aa-isDisabled" : "") + " svelte-auto-1yddlio")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(videoselect.$$.fragment, local);
      transition_in(targetfxoptions.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(soundsettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(videoselect.$$.fragment, local);
      transition_out(targetfxoptions.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(soundsettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(videoselect);
      destroy_component(targetfxoptions);
      if (switch_instance)
        destroy_component(switch_instance);
      destroy_component(soundsettings);
    }
  };
}
function create_summary_end_slot$f(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Target FX On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[0].target.enable;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[7]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      1) {
        input.checked = /*$animation*/
        ctx2[0].target.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$I(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folderOptions*/
        ctx[5]
      ),
      label: localize("autoanimations.menus.target") + " " + localize("autoanimations.menus.animation"),
      $$slots: {
        "summary-end": [create_summary_end_slot$f],
        default: [create_default_slot$i]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-section-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation*/
      513) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$G($$self, $$props, $$invalidate) {
  let $animation;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  let title2 = "Target " + game.i18n.localize("autoanimations.menus.animation");
  const folderOptions = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  function checkMeta() {
    delete $animation.metaData;
  }
  function input_change_handler() {
    $animation.target.enable = this.checked;
    animation.set($animation);
  }
  const change_handler = () => checkMeta();
  return [
    $animation,
    animation,
    category,
    idx,
    title2,
    folderOptions,
    checkMeta,
    input_change_handler,
    change_handler
  ];
}
class ExtraTarget extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$G, create_fragment$I, safe_not_equal, {});
  }
}
const SectionButtons_svelte_svelte_type_style_lang = "";
function create_fragment$H(ctx) {
  let div4;
  let div0;
  let label0;
  let t0_value = localize("autoanimations.menus.preview") + "";
  let t0;
  let t1;
  let i0;
  let t2;
  let div1;
  let label1;
  let t3_value = localize("autoanimations.menus.3dcanvas") + "";
  let t3;
  let t4;
  let i1;
  let i1_class_value;
  let t5;
  let div2;
  let label2;
  let t6_value = localize("autoanimations.menus.sound") + "";
  let t6;
  let t7;
  let t8_value = localize("autoanimations.menus.only") + "";
  let t8;
  let t9;
  let i2;
  let i2_class_value;
  let t10;
  let input0;
  let t11;
  let div3;
  let label3;
  let t12_value = localize("autoanimations.menus.add") + "";
  let t12;
  let t13;
  let t14_value = localize("autoanimations.menus.macro") + "";
  let t14;
  let t15;
  let i3;
  let i3_class_value;
  let t16;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      label0 = element("label");
      t0 = text(t0_value);
      t1 = space();
      i0 = element("i");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      t3 = text(t3_value);
      t4 = space();
      i1 = element("i");
      t5 = space();
      div2 = element("div");
      label2 = element("label");
      t6 = text(t6_value);
      t7 = space();
      t8 = text(t8_value);
      t9 = space();
      i2 = element("i");
      t10 = space();
      input0 = element("input");
      t11 = space();
      div3 = element("div");
      label3 = element("label");
      t12 = text(t12_value);
      t13 = space();
      t14 = text(t14_value);
      t15 = space();
      i3 = element("i");
      t16 = space();
      input1 = element("input");
      attr(i0, "class", "fas fa-film fa-lg aa-zoom");
      attr(label0, "for", "");
      attr(label0, "role", "presentation");
      attr(label0, "class", "svelte-auto-18s2cti");
      set_style(div0, "grid-row", "1/2");
      set_style(div0, "grid-column", "1/2");
      attr(div0, "class", "sectionButton svelte-auto-18s2cti");
      attr(i1, "class", i1_class_value = "fas fa-cube fa-lg " + /*show3d*/
      (ctx[0] ? "aa-green" : ""));
      attr(label1, "for", "");
      attr(label1, "role", "presentation");
      attr(label1, "class", "svelte-auto-18s2cti");
      set_style(div1, "grid-row", "1/2");
      set_style(div1, "grid-column", "2/3");
      attr(div1, "class", "sectionButton " + /*canvas3dActive*/
      ctx[3] + " svelte-auto-18s2cti");
      attr(i2, "class", i2_class_value = "fas fa-music fa-lg " + /*$animation*/
      (ctx[1].soundOnly.sound.enable ? "aa-green" : ""));
      attr(label2, "for", "SoundOnly " + /*animation*/
      ctx[2]._data.id);
      attr(label2, "class", "svelte-auto-18s2cti");
      attr(input0, "type", "checkbox");
      input0.hidden = true;
      attr(input0, "id", "SoundOnly " + /*animation*/
      ctx[2]._data.id);
      set_style(div2, "grid-row", "1/2");
      set_style(div2, "grid-column", "3/4");
      attr(div2, "class", "sectionButton svelte-auto-18s2cti");
      attr(i3, "class", i3_class_value = "far fa-keyboard fa-lg " + /*$animation*/
      (ctx[1].macro.enable ? "aa-green" : ""));
      attr(label3, "for", "Macro " + /*animation*/
      ctx[2]._data.id);
      attr(label3, "class", "svelte-auto-18s2cti");
      attr(input1, "type", "checkbox");
      input1.hidden = true;
      attr(input1, "id", "Macro " + /*animation*/
      ctx[2]._data.id);
      set_style(div3, "grid-row", "1/2");
      set_style(div3, "grid-column", "4/5");
      attr(div3, "class", "sectionButton svelte-auto-18s2cti");
      attr(div4, "class", "aa-autorec-headerButton svelte-auto-18s2cti");
    },
    m(target2, anchor) {
      insert(target2, div4, anchor);
      append(div4, div0);
      append(div0, label0);
      append(label0, t0);
      append(label0, t1);
      append(label0, i0);
      append(div4, t2);
      append(div4, div1);
      append(div1, label1);
      append(label1, t3);
      append(label1, t4);
      append(label1, i1);
      append(div4, t5);
      append(div4, div2);
      append(div2, label2);
      append(label2, t6);
      append(label2, t7);
      append(label2, t8);
      append(label2, t9);
      append(label2, i2);
      append(div2, t10);
      append(div2, input0);
      input0.checked = /*$animation*/
      ctx[1].soundOnly.sound.enable;
      append(div4, t11);
      append(div4, div3);
      append(div3, label3);
      append(label3, t12);
      append(label3, t13);
      append(label3, t14);
      append(label3, t15);
      append(label3, i3);
      append(div3, t16);
      append(div3, input1);
      input1.checked = /*$animation*/
      ctx[1].macro.enable;
      if (!mounted) {
        dispose = [
          listen(
            label0,
            "click",
            /*click_handler*/
            ctx[7]
          ),
          listen(
            label1,
            "click",
            /*click_handler_1*/
            ctx[8]
          ),
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[9]
          ),
          listen(
            input0,
            "change",
            /*change_handler*/
            ctx[10]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[11]
          ),
          listen(
            input1,
            "change",
            /*change_handler_1*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*show3d*/
      1 && i1_class_value !== (i1_class_value = "fas fa-cube fa-lg " + /*show3d*/
      (ctx2[0] ? "aa-green" : ""))) {
        attr(i1, "class", i1_class_value);
      }
      if (dirty & /*$animation*/
      2 && i2_class_value !== (i2_class_value = "fas fa-music fa-lg " + /*$animation*/
      (ctx2[1].soundOnly.sound.enable ? "aa-green" : ""))) {
        attr(i2, "class", i2_class_value);
      }
      if (dirty & /*$animation*/
      2) {
        input0.checked = /*$animation*/
        ctx2[1].soundOnly.sound.enable;
      }
      if (dirty & /*$animation*/
      2 && i3_class_value !== (i3_class_value = "far fa-keyboard fa-lg " + /*$animation*/
      (ctx2[1].macro.enable ? "aa-green" : ""))) {
        attr(i3, "class", i3_class_value);
      }
      if (dirty & /*$animation*/
      2) {
        input1.checked = /*$animation*/
        ctx2[1].macro.enable;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$F($$self, $$props, $$invalidate) {
  let currentIDX;
  let $animation;
  let { type = "autorec" } = $$props;
  let { show3d = false } = $$props;
  let { animation, category } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(1, $animation = value));
  let canvas3dActive = game.modules.get("levels-3d-preview")?.active ? "" : "aa-disableOpacity";
  async function seePreview() {
    if (type === "item") {
      currentIDX.set("item");
    } else {
      const index = category._data.findIndex((x) => x.id === $animation.id);
      currentIDX.set(index);
    }
    currentStore.set(category);
    category.loadPreviews(category);
  }
  function removeMetaData() {
    delete $animation.metaData;
  }
  const click_handler = () => seePreview();
  const click_handler_1 = () => $$invalidate(0, show3d = !show3d);
  function input0_change_handler() {
    $animation.soundOnly.sound.enable = this.checked;
    animation.set($animation);
  }
  const change_handler = () => removeMetaData();
  function input1_change_handler() {
    $animation.macro.enable = this.checked;
    animation.set($animation);
  }
  const change_handler_1 = () => removeMetaData();
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(6, type = $$props2.type);
    if ("show3d" in $$props2)
      $$invalidate(0, show3d = $$props2.show3d);
  };
  currentIDX = category.stores.videoIDX;
  return [
    show3d,
    $animation,
    animation,
    canvas3dActive,
    seePreview,
    removeMetaData,
    type,
    click_handler,
    click_handler_1,
    input0_change_handler,
    change_handler,
    input1_change_handler,
    change_handler_1
  ];
}
class SectionButtons extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$F, create_fragment$H, safe_not_equal, { type: 6, show3d: 0 });
  }
}
function create_default_slot$h(ctx) {
  let div0;
  let videoselect;
  let div0_class_value;
  let t0;
  let div8;
  let div7;
  let table;
  let tr0;
  let td0;
  let div1;
  let label0;
  let t2;
  let div2;
  let select;
  let option0;
  let option1;
  let t5;
  let td1;
  let div5;
  let div3;
  let label1;
  let t7;
  let div4;
  let input0;
  let div5_class_value;
  let t8;
  let tr1;
  let td2;
  let div6;
  let label2;
  let t9_value = localize("autoanimations.menus.return") + "";
  let t9;
  let t10;
  let t11_value = localize("autoanimations.menus.animation") + "";
  let t11;
  let t12;
  let input1;
  let div6_class_value;
  let div8_class_value;
  let t13;
  let div9;
  let sound2;
  let div9_class_value;
  let current;
  let mounted;
  let dispose;
  videoselect = new VideoSelect({
    props: {
      animation: (
        /*animation*/
        ctx[5]
      ),
      section: "meleeSwitch",
      title: title$1,
      idx: (
        /*idx*/
        ctx[7]
      ),
      category: (
        /*category*/
        ctx[6]
      )
    }
  });
  sound2 = new SoundSettings({
    props: {
      animation: (
        /*animation*/
        ctx[5]
      ),
      category: (
        /*category*/
        ctx[6]
      ),
      idx: (
        /*idx*/
        ctx[7]
      ),
      section: "meleeSwitch"
    }
  });
  return {
    c() {
      div0 = element("div");
      create_component(videoselect.$$.fragment);
      t0 = space();
      div8 = element("div");
      div7 = element("div");
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div1 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.rangeDetect")}`;
      t2 = space();
      div2 = element("div");
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.menus.automatic")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.menus.manual")}`;
      t5 = space();
      td1 = element("td");
      div5 = element("div");
      div3 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.gridSquares")}`;
      t7 = space();
      div4 = element("div");
      input0 = element("input");
      t8 = space();
      tr1 = element("tr");
      td2 = element("td");
      div6 = element("div");
      label2 = element("label");
      t9 = text(t9_value);
      t10 = space();
      t11 = text(t11_value);
      t12 = space();
      input1 = element("input");
      t13 = space();
      div9 = element("div");
      create_component(sound2.$$.fragment);
      attr(div0, "class", div0_class_value = /*disableSection*/
      ctx[4] ? "aa-disableOpacity" : "");
      attr(label0, "for", "");
      option0.__value = "automatic";
      option0.value = option0.__value;
      option1.__value = "manual";
      option1.value = option1.__value;
      set_style(select, "margin", "auto");
      if (
        /*$animation*/
        ctx[1].meleeSwitch.options.detect === void 0
      )
        add_render_callback(() => (
          /*select_change_handler_1*/
          ctx[12].call(select)
        ));
      attr(div2, "class", "flexcol");
      attr(label1, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "2");
      attr(input0, "step", "1");
      attr(div5, "class", div5_class_value = /*detect*/
      ctx[3] === "automatic" ? "aa-disableOpacity" : "");
      attr(label2, "for", "OnlyX " + /*animation*/
      ctx[5]._data.id);
      attr(input1, "type", "checkbox");
      attr(input1, "id", "OnlyX " + /*animation*/
      ctx[5]._data.id);
      attr(div6, "class", div6_class_value = "form-group " + /*shouldShow*/
      (ctx[2] ? "" : "aa-disableOpacity"));
      attr(table, "class", "d");
      attr(div7, "class", "aa-options-border");
      attr(div8, "class", div8_class_value = /*switchType*/
      ctx[0] === "off" ? "aa-disableOpacity" : "");
      attr(div9, "class", div9_class_value = /*switchType*/
      ctx[0] === "off" ? "aa-disableOpacity" : "");
    },
    m(target2, anchor) {
      insert(target2, div0, anchor);
      mount_component(videoselect, div0, null);
      insert(target2, t0, anchor);
      insert(target2, div8, anchor);
      append(div8, div7);
      append(div7, table);
      append(table, tr0);
      append(tr0, td0);
      append(td0, div1);
      append(div1, label0);
      append(td0, t2);
      append(td0, div2);
      append(div2, select);
      append(select, option0);
      append(select, option1);
      select_option(
        select,
        /*$animation*/
        ctx[1].meleeSwitch.options.detect,
        true
      );
      append(tr0, t5);
      append(tr0, td1);
      append(td1, div5);
      append(div5, div3);
      append(div3, label1);
      append(div5, t7);
      append(div5, div4);
      append(div4, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[1].meleeSwitch.options.range
      );
      append(table, t8);
      append(table, tr1);
      append(tr1, td2);
      append(td2, div6);
      append(div6, label2);
      append(label2, t9);
      append(label2, t10);
      append(label2, t11);
      append(div6, t12);
      append(div6, input1);
      input1.checked = /*$animation*/
      ctx[1].meleeSwitch.options.isReturning;
      insert(target2, t13, anchor);
      insert(target2, div9, anchor);
      mount_component(sound2, div9, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler_1*/
            ctx[12]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[13]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*disableSection*/
      16 && div0_class_value !== (div0_class_value = /*disableSection*/
      ctx2[4] ? "aa-disableOpacity" : "")) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & /*$animation*/
      2) {
        select_option(
          select,
          /*$animation*/
          ctx2[1].meleeSwitch.options.detect
        );
      }
      if (dirty & /*$animation*/
      2 && to_number(input0.value) !== /*$animation*/
      ctx2[1].meleeSwitch.options.range) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[1].meleeSwitch.options.range
        );
      }
      if (!current || dirty & /*detect*/
      8 && div5_class_value !== (div5_class_value = /*detect*/
      ctx2[3] === "automatic" ? "aa-disableOpacity" : "")) {
        attr(div5, "class", div5_class_value);
      }
      if (dirty & /*$animation*/
      2) {
        input1.checked = /*$animation*/
        ctx2[1].meleeSwitch.options.isReturning;
      }
      if (!current || dirty & /*shouldShow*/
      4 && div6_class_value !== (div6_class_value = "form-group " + /*shouldShow*/
      (ctx2[2] ? "" : "aa-disableOpacity"))) {
        attr(div6, "class", div6_class_value);
      }
      if (!current || dirty & /*switchType*/
      1 && div8_class_value !== (div8_class_value = /*switchType*/
      ctx2[0] === "off" ? "aa-disableOpacity" : "")) {
        attr(div8, "class", div8_class_value);
      }
      if (!current || dirty & /*switchType*/
      1 && div9_class_value !== (div9_class_value = /*switchType*/
      ctx2[0] === "off" ? "aa-disableOpacity" : "")) {
        attr(div9, "class", div9_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(videoselect.$$.fragment, local);
      transition_in(sound2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(videoselect.$$.fragment, local);
      transition_out(sound2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(videoselect);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div8);
      if (detaching)
        detach(t13);
      if (detaching)
        detach(div9);
      destroy_component(sound2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$e(ctx) {
  let div;
  let select;
  let option0;
  let option1;
  let option2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.settings.ON")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.settings.OFF")}`;
      option2 = element("option");
      option2.textContent = `${localize("autoanimations.menus.custom")}`;
      option0.__value = "on";
      option0.value = option0.__value;
      option1.__value = "off";
      option1.value = option1.__value;
      option2.__value = "custom";
      option2.value = option2.__value;
      set_style(select, "width", "6em");
      if (
        /*$animation*/
        ctx[1].meleeSwitch.options.switchType === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[11].call(select)
        ));
      attr(div, "slot", "summary-end");
      set_style(div, "position", "relative");
      set_style(div, "left", "10px");
      attr(div, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      select_option(
        select,
        /*$animation*/
        ctx[1].meleeSwitch.options.switchType,
        true
      );
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*select_change_handler*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      2) {
        select_option(
          select,
          /*$animation*/
          ctx2[1].meleeSwitch.options.switchType
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$G(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folderOptions*/
        ctx[8]
      ),
      label: "Range Switch",
      $$slots: {
        "summary-end": [create_summary_end_slot$e],
        default: [create_default_slot$h]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-sound-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, switchType, shouldShow, detect, disableSection*/
      32799) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
const title$1 = "Switch Animation";
function instance$E($$self, $$props, $$invalidate) {
  let switchType;
  let disableSection;
  let detect;
  let anim;
  let switchAnim;
  let shouldShow;
  let $animation;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(1, $animation = value));
  const folderOptions = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  function select_change_handler() {
    $animation.meleeSwitch.options.switchType = select_value(this);
    animation.set($animation);
  }
  function select_change_handler_1() {
    $animation.meleeSwitch.options.detect = select_value(this);
    animation.set($animation);
  }
  function input0_input_handler() {
    $animation.meleeSwitch.options.range = to_number(this.value);
    animation.set($animation);
  }
  function input1_change_handler() {
    $animation.meleeSwitch.options.isReturning = this.checked;
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(0, switchType = $animation.meleeSwitch.options.switchType);
    }
    if ($$self.$$.dirty & /*switchType*/
    1) {
      $$invalidate(4, disableSection = switchType !== "custom");
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(3, detect = $animation.meleeSwitch.options.detect);
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(10, anim = $animation.primary.video.animation);
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(9, switchAnim = $animation.meleeSwitch.video.animation);
    }
    if ($$self.$$.dirty & /*switchType, anim, switchAnim*/
    1537) {
      $$invalidate(2, shouldShow = switchType === "on" ? aaReturnWeapons.includes(anim) : switchType === "custom" ? aaReturnWeapons.includes(switchAnim) : false);
    }
  };
  return [
    switchType,
    $animation,
    shouldShow,
    detect,
    disableSection,
    animation,
    category,
    idx,
    folderOptions,
    switchAnim,
    anim,
    select_change_handler,
    select_change_handler_1,
    input0_input_handler,
    input1_change_handler
  ];
}
class MeleeSwitch extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$E, create_fragment$G, safe_not_equal, {});
  }
}
function create_default_slot$g(ctx) {
  let div14;
  let div3;
  let div0;
  let i0;
  let i0_class_value;
  let t0;
  let div1;
  let input0;
  let t1;
  let div2;
  let i1;
  let t2;
  let table;
  let tr0;
  let td0;
  let div4;
  let label0;
  let t7;
  let div5;
  let input1;
  let t8;
  let td1;
  let div6;
  let label1;
  let t10;
  let div7;
  let input2;
  let t11;
  let td2;
  let div8;
  let label2;
  let t13;
  let div9;
  let input3;
  let t14;
  let tr1;
  let td3;
  let div10;
  let label3;
  let t16;
  let div11;
  let input4;
  let t17;
  let td4;
  let div12;
  let label4;
  let t21;
  let div13;
  let input5;
  let div14_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div14 = element("div");
      div3 = element("div");
      div0 = element("div");
      i0 = element("i");
      t0 = space();
      div1 = element("div");
      input0 = element("input");
      t1 = space();
      div2 = element("div");
      i1 = element("i");
      t2 = space();
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div4 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.start")} 
                                ${localize("autoanimations.menus.time")} (ms)`;
      t7 = space();
      div5 = element("div");
      input1 = element("input");
      t8 = space();
      td1 = element("td");
      div6 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.volume")}`;
      t10 = space();
      div7 = element("div");
      input2 = element("input");
      t11 = space();
      td2 = element("td");
      div8 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.delay")}`;
      t13 = space();
      div9 = element("div");
      input3 = element("input");
      t14 = space();
      tr1 = element("tr");
      td3 = element("td");
      div10 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.repeat")}`;
      t16 = space();
      div11 = element("div");
      input4 = element("input");
      t17 = space();
      td4 = element("td");
      div12 = element("div");
      label4 = element("label");
      label4.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t21 = space();
      div13 = element("div");
      input5 = element("input");
      attr(i0, "class", i0_class_value = "fas fa-music aa-blue " + /*isValid*/
      (ctx[3] ? "" : "aa-disableOpacity"));
      set_style(i0, "font-size", "1.5em");
      attr(i0, "title", "Play Sound");
      attr(i0, "role", "presentation");
      set_style(div0, "grid-row", "1/2");
      set_style(div0, "grid-column", "1/2");
      attr(input0, "type", "text");
      set_style(input0, "font-weight", "normal");
      set_style(input0, "font-size", "small");
      set_style(div1, "grid-row", "1/2");
      set_style(div1, "grid-column", "2/3");
      attr(i1, "class", "fas fa-file-import");
      attr(i1, "title", "File Picker");
      set_style(i1, "font-size", "1.5em");
      attr(i1, "role", "presentation");
      set_style(div2, "grid-row", "1/2");
      set_style(div2, "grid-column", "3/4");
      attr(div3, "class", "aa-Sound-container");
      attr(label0, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "0");
      attr(input1, "step", "0.01");
      attr(label1, "for", "");
      attr(input2, "type", "number");
      attr(input2, "placeholder", "0.5");
      attr(input2, "step", "0.01");
      attr(label2, "for", "");
      attr(input3, "type", "number");
      attr(input3, "placeholder", "0");
      attr(input3, "step", "0.01");
      attr(label3, "for", "");
      attr(input4, "type", "number");
      attr(input4, "placeholder", "1");
      attr(input4, "step", "1");
      attr(label4, "for", "");
      attr(input5, "type", "number");
      attr(input5, "placeholder", "250");
      attr(input5, "step", "1");
      attr(table, "class", "d");
      attr(div14, "class", div14_class_value = !/*$animation*/
      ctx[2][
        /*section*/
        ctx[0]
      ][
        /*section02*/
        ctx[1]
      ].sound.enable ? "aa-disableOpacity" : "");
    },
    m(target2, anchor) {
      insert(target2, div14, anchor);
      append(div14, div3);
      append(div3, div0);
      append(div0, i0);
      append(div3, t0);
      append(div3, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[2][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].sound.file
      );
      append(div3, t1);
      append(div3, div2);
      append(div2, i1);
      append(div14, t2);
      append(div14, table);
      append(table, tr0);
      append(tr0, td0);
      append(td0, div4);
      append(div4, label0);
      append(td0, t7);
      append(td0, div5);
      append(div5, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[2][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].sound.startTime
      );
      append(tr0, t8);
      append(tr0, td1);
      append(td1, div6);
      append(div6, label1);
      append(td1, t10);
      append(td1, div7);
      append(div7, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[2][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].sound.volume
      );
      append(tr0, t11);
      append(tr0, td2);
      append(td2, div8);
      append(div8, label2);
      append(td2, t13);
      append(td2, div9);
      append(div9, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[2][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].sound.delay
      );
      append(table, t14);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div10);
      append(div10, label3);
      append(td3, t16);
      append(td3, div11);
      append(div11, input4);
      set_input_value(
        input4,
        /*$animation*/
        ctx[2][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].sound.repeat
      );
      append(tr1, t17);
      append(tr1, td4);
      append(td4, div12);
      append(div12, label4);
      append(td4, t21);
      append(td4, div13);
      append(div13, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[2][
          /*section*/
          ctx[0]
        ][
          /*section02*/
          ctx[1]
        ].sound.repeatDelay
      );
      if (!mounted) {
        dispose = [
          listen(
            i0,
            "click",
            /*click_handler*/
            ctx[11]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[12]
          ),
          listen(i1, "click", prevent_default(
            /*click_handler_1*/
            ctx[13]
          )),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[14]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[15]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[16]
          ),
          listen(
            input4,
            "input",
            /*input4_input_handler*/
            ctx[17]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler*/
            ctx[18]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*isValid*/
      8 && i0_class_value !== (i0_class_value = "fas fa-music aa-blue " + /*isValid*/
      (ctx2[3] ? "" : "aa-disableOpacity"))) {
        attr(i0, "class", i0_class_value);
      }
      if (dirty & /*$animation, section, section02*/
      7 && input0.value !== /*$animation*/
      ctx2[2][
        /*section*/
        ctx2[0]
      ][
        /*section02*/
        ctx2[1]
      ].sound.file) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[2][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].sound.file
        );
      }
      if (dirty & /*$animation, section, section02*/
      7 && to_number(input1.value) !== /*$animation*/
      ctx2[2][
        /*section*/
        ctx2[0]
      ][
        /*section02*/
        ctx2[1]
      ].sound.startTime) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[2][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].sound.startTime
        );
      }
      if (dirty & /*$animation, section, section02*/
      7 && to_number(input2.value) !== /*$animation*/
      ctx2[2][
        /*section*/
        ctx2[0]
      ][
        /*section02*/
        ctx2[1]
      ].sound.volume) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[2][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].sound.volume
        );
      }
      if (dirty & /*$animation, section, section02*/
      7 && to_number(input3.value) !== /*$animation*/
      ctx2[2][
        /*section*/
        ctx2[0]
      ][
        /*section02*/
        ctx2[1]
      ].sound.delay) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[2][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].sound.delay
        );
      }
      if (dirty & /*$animation, section, section02*/
      7 && to_number(input4.value) !== /*$animation*/
      ctx2[2][
        /*section*/
        ctx2[0]
      ][
        /*section02*/
        ctx2[1]
      ].sound.repeat) {
        set_input_value(
          input4,
          /*$animation*/
          ctx2[2][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].sound.repeat
        );
      }
      if (dirty & /*$animation, section, section02*/
      7 && to_number(input5.value) !== /*$animation*/
      ctx2[2][
        /*section*/
        ctx2[0]
      ][
        /*section02*/
        ctx2[1]
      ].sound.repeatDelay) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[2][
            /*section*/
            ctx2[0]
          ][
            /*section02*/
            ctx2[1]
          ].sound.repeatDelay
        );
      }
      if (dirty & /*$animation, section, section02*/
      7 && div14_class_value !== (div14_class_value = !/*$animation*/
      ctx2[2][
        /*section*/
        ctx2[0]
      ][
        /*section02*/
        ctx2[1]
      ].sound.enable ? "aa-disableOpacity" : "")) {
        attr(div14, "class", div14_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div14);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$d(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Sound On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[2][
        /*section*/
        ctx[0]
      ][
        /*section02*/
        ctx[1]
      ].sound.enable;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[9]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation, section, section02*/
      7) {
        input.checked = /*$animation*/
        ctx2[2][
          /*section*/
          ctx2[0]
        ][
          /*section02*/
          ctx2[1]
        ].sound.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$F(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[7]
      ),
      label: localize("autoanimations.menus.sound"),
      $$slots: {
        "summary-end": [create_summary_end_slot$d],
        default: [create_default_slot$g]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-sound-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, section, section02, isValid*/
      524303) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$D($$self, $$props, $$invalidate) {
  let isValid;
  let $animation;
  let { section: section2 } = $$props;
  let { section02 } = $$props;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(2, $animation = value));
  if (!$animation[section2][section02].sound) {
    set_store_value(
      animation,
      $animation[section2][section02].sound = {
        enable: false,
        delay: 0,
        file: "",
        repeat: 1,
        repeatDelay: 250,
        startTime: 0,
        volume: 0.75
      },
      $animation
    );
  }
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  function checkMeta() {
    delete $animation.metaData;
  }
  function input_change_handler() {
    $animation[section2][section02].sound.enable = this.checked;
    animation.set($animation);
  }
  const change_handler = () => checkMeta();
  const click_handler = () => category.playSound(animation._data[section2][section02].sound);
  function input0_input_handler() {
    $animation[section2][section02].sound.file = this.value;
    animation.set($animation);
  }
  const click_handler_1 = () => category.selectSoundNested(section2, section02, idx);
  function input1_input_handler() {
    $animation[section2][section02].sound.startTime = to_number(this.value);
    animation.set($animation);
  }
  function input2_input_handler() {
    $animation[section2][section02].sound.volume = to_number(this.value);
    animation.set($animation);
  }
  function input3_input_handler() {
    $animation[section2][section02].sound.delay = to_number(this.value);
    animation.set($animation);
  }
  function input4_input_handler() {
    $animation[section2][section02].sound.repeat = to_number(this.value);
    animation.set($animation);
  }
  function input5_input_handler() {
    $animation[section2][section02].sound.repeatDelay = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
    if ("section02" in $$props2)
      $$invalidate(1, section02 = $$props2.section02);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation, section, section02*/
    7) {
      $$invalidate(3, isValid = $animation[section2][section02].sound.file && $animation[section2][section02].sound.enable);
    }
  };
  return [
    section2,
    section02,
    $animation,
    isValid,
    animation,
    category,
    idx,
    folder,
    checkMeta,
    input_change_handler,
    change_handler,
    click_handler,
    input0_input_handler,
    click_handler_1,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    input4_input_handler,
    input5_input_handler
  ];
}
class SoundSettingsNested extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$D, create_fragment$F, safe_not_equal, { section: 0, section02: 1 });
  }
}
const Canvas3dOptions_svelte_svelte_type_style_lang = "";
function get_each_context$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  return child_ctx;
}
function create_else_block$8(ctx) {
  let h1;
  let t3;
  let div10;
  let table;
  let tr0;
  let td0;
  let div0;
  let label0;
  let t5;
  let div1;
  let select0;
  let t6;
  let td1;
  let div2;
  let label1;
  let t8;
  let div3;
  let select1;
  let option0;
  let option1;
  let option2;
  let option3;
  let t13;
  let tr1;
  let td2;
  let div6;
  let div4;
  let label2;
  let t15;
  let div5;
  let input0;
  let t16;
  let td3;
  let div9;
  let div7;
  let label3;
  let t18;
  let div8;
  let input1;
  let mounted;
  let dispose;
  let each_value = Object.keys(
    /*tokenAnimations*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
  }
  return {
    c() {
      h1 = element("h1");
      h1.textContent = `${localize("autoanimations.menus.token")}  ${localize("autoanimations.menus.animation")}`;
      t3 = space();
      div10 = element("div");
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.type")}`;
      t5 = space();
      div1 = element("div");
      select0 = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t6 = space();
      td1 = element("td");
      div2 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.playOn")}`;
      t8 = space();
      div3 = element("div");
      select1 = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.menus.source")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.menus.target")}`;
      option2 = element("option");
      option2.textContent = `${localize("autoanimations.menus.targetDefault")}`;
      option3 = element("option");
      option3.textContent = `${localize("autoanimations.menus.both")}`;
      t13 = space();
      tr1 = element("tr");
      td2 = element("td");
      div6 = element("div");
      div4 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.repeat")}`;
      t15 = space();
      div5 = element("div");
      input0 = element("input");
      t16 = space();
      td3 = element("td");
      div9 = element("div");
      div7 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.resetTime")}`;
      t18 = space();
      div8 = element("div");
      input1 = element("input");
      attr(h1, "class", "svelte-auto-z8zyef");
      attr(label0, "for", "");
      if (
        /*$animation*/
        ctx[0].levels3d.data.animationType === void 0
      )
        add_render_callback(() => (
          /*select0_change_handler*/
          ctx[28].call(select0)
        ));
      attr(label1, "for", "");
      option0.__value = "source";
      option0.value = option0.__value;
      option1.__value = "target";
      option1.value = option1.__value;
      option2.__value = "default";
      option2.value = option2.__value;
      option3.__value = "both";
      option3.value = option3.__value;
      if (
        /*$animation*/
        ctx[0].levels3d.data.playOn === void 0
      )
        add_render_callback(() => (
          /*select1_change_handler*/
          ctx[29].call(select1)
        ));
      attr(label2, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "1");
      attr(input0, "step", ".01");
      attr(div6, "class", "flex-row");
      attr(label3, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "100");
      attr(input1, "step", "1");
      attr(div9, "class", "flex-row");
      attr(table, "class", "d");
      attr(div10, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, h1, anchor);
      insert(target2, t3, anchor);
      insert(target2, div10, anchor);
      append(div10, table);
      append(table, tr0);
      append(tr0, td0);
      append(td0, div0);
      append(div0, label0);
      append(td0, t5);
      append(td0, div1);
      append(div1, select0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select0, null);
        }
      }
      select_option(
        select0,
        /*$animation*/
        ctx[0].levels3d.data.animationType,
        true
      );
      append(tr0, t6);
      append(tr0, td1);
      append(td1, div2);
      append(div2, label1);
      append(td1, t8);
      append(td1, div3);
      append(div3, select1);
      append(select1, option0);
      append(select1, option1);
      append(select1, option2);
      append(select1, option3);
      select_option(
        select1,
        /*$animation*/
        ctx[0].levels3d.data.playOn,
        true
      );
      append(table, t13);
      append(table, tr1);
      append(tr1, td2);
      append(td2, div6);
      append(div6, div4);
      append(div4, label2);
      append(div6, t15);
      append(div6, div5);
      append(div5, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].levels3d.data.repeat
      );
      append(tr1, t16);
      append(tr1, td3);
      append(td3, div9);
      append(div9, div7);
      append(div7, label3);
      append(div9, t18);
      append(div9, div8);
      append(div8, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].levels3d.data.resetTime
      );
      if (!mounted) {
        dispose = [
          listen(
            select0,
            "change",
            /*select0_change_handler*/
            ctx[28]
          ),
          listen(
            select1,
            "change",
            /*select1_change_handler*/
            ctx[29]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler_4*/
            ctx[30]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler_4*/
            ctx[31]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*tokenAnimations*/
      4) {
        each_value = Object.keys(
          /*tokenAnimations*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5) {
        select_option(
          select0,
          /*$animation*/
          ctx2[0].levels3d.data.animationType
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5) {
        select_option(
          select1,
          /*$animation*/
          ctx2[0].levels3d.data.playOn
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input0.value) !== /*$animation*/
      ctx2[0].levels3d.data.repeat) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].levels3d.data.repeat
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input1.value) !== /*$animation*/
      ctx2[0].levels3d.data.resetTime) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].levels3d.data.resetTime
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(h1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div10);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$b(ctx) {
  let div2;
  let h1;
  let t1;
  let table;
  let tr;
  let td;
  let div0;
  let label;
  let t4;
  let input0;
  let t5;
  let div1;
  let input1;
  let t6;
  let t7;
  let div3;
  let tjssvgfolder;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*type*/
    ctx[1] !== "sprite" && create_if_block_2$4(ctx)
  );
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[4]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$c],
        default: [create_default_slot$f]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      h1 = element("h1");
      h1.textContent = "Colors";
      t1 = space();
      table = element("table");
      tr = element("tr");
      td = element("td");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.color")} 01`;
      t4 = space();
      input0 = element("input");
      t5 = space();
      div1 = element("div");
      input1 = element("input");
      t6 = space();
      if (if_block)
        if_block.c();
      t7 = space();
      div3 = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(h1, "class", "svelte-auto-z8zyef");
      attr(label, "for", "");
      attr(input0, "type", "Text");
      set_style(input0, "width", "10em");
      set_style(input0, "margin", "auto");
      attr(div0, "class", "flexcol");
      attr(input1, "type", "color");
      attr(input1, "data-edit", "color");
      attr(input1, "id", "tint");
      set_style(input1, "width", "10em");
      set_style(input1, "margin-left", "0");
      attr(div1, "class", "form-group");
      attr(table, "class", "d");
      set_style(table, "padding-right", "4em");
      set_style(table, "padding-left", "4em");
      attr(div2, "class", "aa-options-border");
      set_style(div2, "margin-top", ".5em");
      attr(div3, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div2, anchor);
      append(div2, h1);
      append(div2, t1);
      append(div2, table);
      append(table, tr);
      append(tr, td);
      append(td, div0);
      append(div0, label);
      append(div0, t4);
      append(div0, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].levels3d.data.color01
      );
      append(td, t5);
      append(td, div1);
      append(div1, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].levels3d.data.color01
      );
      append(tr, t6);
      if (if_block)
        if_block.m(tr, null);
      insert(target2, t7, anchor);
      insert(target2, div3, anchor);
      mount_component(tjssvgfolder, div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation, tokenAnimations*/
      5) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].levels3d.data.color01
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].levels3d.data.color01
        );
      }
      if (
        /*type*/
        ctx2[1] !== "sprite"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$4(ctx2);
          if_block.c();
          if_block.m(tr, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const tjssvgfolder_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block)
        if_block.d();
      if (detaching)
        detach(t7);
      if (detaching)
        detach(div3);
      destroy_component(tjssvgfolder);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block$7(ctx) {
  let option;
  let t_value = localize(`autoanimations.tokenAnimations.${/*tokenAnim*/
  ctx[32]}`) + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = /*tokenAnim*/
      ctx[32];
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_2$4(ctx) {
  let td;
  let div0;
  let label;
  let t2;
  let input0;
  let t3;
  let div1;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      td = element("td");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.color")} 02`;
      t2 = space();
      input0 = element("input");
      t3 = space();
      div1 = element("div");
      input1 = element("input");
      attr(label, "for", "");
      attr(input0, "type", "Text");
      set_style(input0, "width", "10em");
      set_style(input0, "margin", "auto");
      attr(div0, "class", "flexcol");
      attr(input1, "type", "color");
      attr(input1, "data-edit", "color");
      attr(input1, "id", "tint");
      set_style(input1, "width", "10em");
      set_style(input1, "margin-left", "0");
      attr(div1, "class", "form-group");
    },
    m(target2, anchor) {
      insert(target2, td, anchor);
      append(td, div0);
      append(div0, label);
      append(div0, t2);
      append(div0, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].levels3d.data.color02
      );
      append(td, t3);
      append(td, div1);
      append(div1, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].levels3d.data.color02
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler_1*/
            ctx[8]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler_1*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation, tokenAnimations*/
      5) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].levels3d.data.color02
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].levels3d.data.color02
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(td);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$5(ctx) {
  let tr;
  let td0;
  let div0;
  let label0;
  let t2;
  let div1;
  let input0;
  let t3;
  let td1;
  let div2;
  let label1;
  let t6;
  let div3;
  let input1;
  let t7;
  let td2;
  let div4;
  let label2;
  let t10;
  let div5;
  let input2;
  let mounted;
  let dispose;
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.rotation")} X`;
      t2 = space();
      div1 = element("div");
      input0 = element("input");
      t3 = space();
      td1 = element("td");
      div2 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.rotation")} Y`;
      t6 = space();
      div3 = element("div");
      input1 = element("input");
      t7 = space();
      td2 = element("td");
      div4 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.rotation")} Z`;
      t10 = space();
      div5 = element("div");
      input2 = element("input");
      attr(label0, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "0");
      attr(label1, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "0");
      attr(label2, "for", "");
      attr(input2, "type", "number");
      attr(input2, "placeholder", "0");
    },
    m(target2, anchor) {
      insert(target2, tr, anchor);
      append(tr, td0);
      append(td0, div0);
      append(div0, label0);
      append(td0, t2);
      append(td0, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].levels3d.data.rotationX
      );
      append(tr, t3);
      append(tr, td1);
      append(td1, div2);
      append(div2, label1);
      append(td1, t6);
      append(td1, div3);
      append(div3, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].levels3d.data.rotationY
      );
      append(tr, t7);
      append(tr, td2);
      append(td2, div4);
      append(div4, label2);
      append(td2, t10);
      append(td2, div5);
      append(div5, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].levels3d.data.rotationZ
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler_3*/
            ctx[25]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler_3*/
            ctx[26]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler_1*/
            ctx[27]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input0.value) !== /*$animation*/
      ctx2[0].levels3d.data.rotationX) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].levels3d.data.rotationX
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input1.value) !== /*$animation*/
      ctx2[0].levels3d.data.rotationY) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].levels3d.data.rotationY
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input2.value) !== /*$animation*/
      ctx2[0].levels3d.data.rotationZ) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].levels3d.data.rotationZ
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$f(ctx) {
  let table;
  let tr0;
  let td0;
  let div2;
  let div0;
  let label0;
  let t1;
  let div1;
  let input0;
  let t2;
  let td1;
  let div5;
  let div3;
  let label1;
  let t4;
  let div4;
  let input1;
  let t5;
  let td2;
  let div8;
  let div6;
  let label2;
  let t7;
  let div7;
  let input2;
  let t8;
  let tr1;
  let td3;
  let div11;
  let div9;
  let label3;
  let t10;
  let div10;
  let input3;
  let t11;
  let td4;
  let div14;
  let div12;
  let label4;
  let t13;
  let div13;
  let input4;
  let t14;
  let td5;
  let div17;
  let div15;
  let label5;
  let t16;
  let div16;
  let input5;
  let t17;
  let tr2;
  let td6;
  let div20;
  let div18;
  let label6;
  let t19;
  let div19;
  let input6;
  let t20;
  let td7;
  let div23;
  let div21;
  let label7;
  let t22;
  let div22;
  let input7;
  let t23;
  let td8;
  let div26;
  let div24;
  let label8;
  let t25;
  let div25;
  let input8;
  let t26;
  let tr3;
  let td9;
  let div29;
  let div27;
  let label9;
  let t28;
  let div28;
  let input9;
  let t29;
  let td10;
  let div32;
  let div30;
  let label10;
  let t31;
  let div31;
  let input10;
  let t32;
  let td11;
  let label11;
  let t33_value = localize("autoanimations.menus.rotateTowards") + "";
  let t33;
  let t34;
  let input11;
  let t35;
  let tr4;
  let td12;
  let label12;
  let t36_value = localize("autoanimations.menus.autoSize") + "";
  let t36;
  let t37;
  let input12;
  let t38;
  let td13;
  let label13;
  let t39_value = localize("autoanimations.menus.onCenter") + "";
  let t39;
  let t40;
  let input13;
  let t41;
  let mounted;
  let dispose;
  let if_block = (
    /*$animation*/
    ctx[0].levels3d.type === "sprite" && create_if_block_1$5(ctx)
  );
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.speed")}`;
      t1 = space();
      div1 = element("div");
      input0 = element("input");
      t2 = space();
      td1 = element("td");
      div5 = element("div");
      div3 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.repeat")}`;
      t4 = space();
      div4 = element("div");
      input1 = element("input");
      t5 = space();
      td2 = element("td");
      div8 = element("div");
      div6 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.delay")}`;
      t7 = space();
      div7 = element("div");
      input2 = element("input");
      t8 = space();
      tr1 = element("tr");
      td3 = element("td");
      div11 = element("div");
      div9 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.scale")}`;
      t10 = space();
      div10 = element("div");
      input3 = element("input");
      t11 = space();
      td4 = element("td");
      div14 = element("div");
      div12 = element("div");
      label4 = element("label");
      label4.textContent = `${localize("autoanimations.menus.arc")}`;
      t13 = space();
      div13 = element("div");
      input4 = element("input");
      t14 = space();
      td5 = element("td");
      div17 = element("div");
      div15 = element("div");
      label5 = element("label");
      label5.textContent = `${localize("autoanimations.menus.alpha")}`;
      t16 = space();
      div16 = element("div");
      input5 = element("input");
      t17 = space();
      tr2 = element("tr");
      td6 = element("td");
      div20 = element("div");
      div18 = element("div");
      label6 = element("label");
      label6.textContent = `${localize("autoanimations.menus.gravity")}`;
      t19 = space();
      div19 = element("div");
      input6 = element("input");
      t20 = space();
      td7 = element("td");
      div23 = element("div");
      div21 = element("div");
      label7 = element("label");
      label7.textContent = `${localize("autoanimations.menus.duration")}`;
      t22 = space();
      div22 = element("div");
      input7 = element("input");
      t23 = space();
      td8 = element("td");
      div26 = element("div");
      div24 = element("div");
      label8 = element("label");
      label8.textContent = `${localize("autoanimations.menus.life")}`;
      t25 = space();
      div25 = element("div");
      input8 = element("input");
      t26 = space();
      tr3 = element("tr");
      td9 = element("td");
      div29 = element("div");
      div27 = element("div");
      label9 = element("label");
      label9.textContent = `${localize("autoanimations.menus.emiterSize")}`;
      t28 = space();
      div28 = element("div");
      input9 = element("input");
      t29 = space();
      td10 = element("td");
      div32 = element("div");
      div30 = element("div");
      label10 = element("label");
      label10.textContent = `${localize("autoanimations.menus.rate")}`;
      t31 = space();
      div31 = element("div");
      input10 = element("input");
      t32 = space();
      td11 = element("td");
      label11 = element("label");
      t33 = text(t33_value);
      t34 = space();
      input11 = element("input");
      t35 = space();
      tr4 = element("tr");
      td12 = element("td");
      label12 = element("label");
      t36 = text(t36_value);
      t37 = space();
      input12 = element("input");
      t38 = space();
      td13 = element("td");
      label13 = element("label");
      t39 = text(t39_value);
      t40 = space();
      input13 = element("input");
      t41 = space();
      if (if_block)
        if_block.c();
      attr(label0, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "5");
      attr(input0, "step", ".01");
      attr(div2, "class", "flex-row");
      attr(label1, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "1");
      attr(input1, "step", ".01");
      attr(div5, "class", "flex-row");
      attr(label2, "for", "");
      attr(input2, "type", "number");
      attr(input2, "placeholder", "0");
      attr(input2, "step", ".01");
      attr(div8, "class", "flex-row");
      attr(label3, "for", "");
      attr(input3, "type", "number");
      attr(input3, "placeholder", "1");
      attr(input3, "step", ".01");
      attr(div11, "class", "flex-row");
      attr(label4, "for", "");
      attr(input4, "type", "number");
      attr(input4, "placeholder", "5");
      attr(input4, "step", ".01");
      attr(div14, "class", "flex-row");
      attr(label5, "for", "");
      attr(input5, "type", "number");
      attr(input5, "placeholder", "0.5");
      attr(input5, "step", ".01");
      attr(div17, "class", "flex-row");
      attr(label6, "for", "");
      attr(input6, "type", "number");
      attr(input6, "placeholder", "0");
      attr(input6, "step", ".01");
      attr(div20, "class", "flex-row");
      attr(label7, "for", "");
      attr(input7, "type", "number");
      attr(input7, "placeholder", "3000");
      attr(input7, "step", ".01");
      attr(div23, "class", "flex-row");
      attr(label8, "for", "");
      attr(input8, "type", "number");
      attr(input8, "placeholder", "500");
      attr(input8, "step", ".01");
      attr(div26, "class", "flex-row");
      attr(label9, "for", "");
      attr(input9, "type", "number");
      attr(input9, "placeholder", "0.0001");
      attr(input9, "step", ".0001");
      attr(div29, "class", "flex-row");
      attr(label10, "for", "");
      attr(input10, "type", "number");
      attr(input10, "placeholder", "10");
      attr(input10, "step", ".01");
      attr(div32, "class", "flex-row");
      attr(label11, "for", "3dRotateTowards " + /*animation*/
      ctx[3]._data.id);
      attr(input11, "type", "checkbox");
      attr(input11, "id", "3dRotateTowards " + /*animation*/
      ctx[3]._data.id);
      attr(label12, "for", "3dautoSize " + /*animation*/
      ctx[3]._data.id);
      attr(input12, "type", "checkbox");
      attr(input12, "id", "3dautoSize " + /*animation*/
      ctx[3]._data.id);
      attr(label13, "for", "3donCenter " + /*animation*/
      ctx[3]._data.id);
      attr(input13, "type", "checkbox");
      attr(input13, "id", "3donCenter " + /*animation*/
      ctx[3]._data.id);
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      append(td0, div2);
      append(div2, div0);
      append(div0, label0);
      append(div2, t1);
      append(div2, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].levels3d.data.speed
      );
      append(tr0, t2);
      append(tr0, td1);
      append(td1, div5);
      append(div5, div3);
      append(div3, label1);
      append(div5, t4);
      append(div5, div4);
      append(div4, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].levels3d.data.repeat
      );
      append(tr0, t5);
      append(tr0, td2);
      append(td2, div8);
      append(div8, div6);
      append(div6, label2);
      append(div8, t7);
      append(div8, div7);
      append(div7, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].levels3d.data.delay
      );
      append(table, t8);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div11);
      append(div11, div9);
      append(div9, label3);
      append(div11, t10);
      append(div11, div10);
      append(div10, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[0].levels3d.data.scale
      );
      append(tr1, t11);
      append(tr1, td4);
      append(td4, div14);
      append(div14, div12);
      append(div12, label4);
      append(div14, t13);
      append(div14, div13);
      append(div13, input4);
      set_input_value(
        input4,
        /*$animation*/
        ctx[0].levels3d.data.arc
      );
      append(tr1, t14);
      append(tr1, td5);
      append(td5, div17);
      append(div17, div15);
      append(div15, label5);
      append(div17, t16);
      append(div17, div16);
      append(div16, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[0].levels3d.data.alpha
      );
      append(table, t17);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div20);
      append(div20, div18);
      append(div18, label6);
      append(div20, t19);
      append(div20, div19);
      append(div19, input6);
      set_input_value(
        input6,
        /*$animation*/
        ctx[0].levels3d.data.gravity
      );
      append(tr2, t20);
      append(tr2, td7);
      append(td7, div23);
      append(div23, div21);
      append(div21, label7);
      append(div23, t22);
      append(div23, div22);
      append(div22, input7);
      set_input_value(
        input7,
        /*$animation*/
        ctx[0].levels3d.data.duration
      );
      append(tr2, t23);
      append(tr2, td8);
      append(td8, div26);
      append(div26, div24);
      append(div24, label8);
      append(div26, t25);
      append(div26, div25);
      append(div25, input8);
      set_input_value(
        input8,
        /*$animation*/
        ctx[0].levels3d.data.life
      );
      append(table, t26);
      append(table, tr3);
      append(tr3, td9);
      append(td9, div29);
      append(div29, div27);
      append(div27, label9);
      append(div29, t28);
      append(div29, div28);
      append(div28, input9);
      set_input_value(
        input9,
        /*$animation*/
        ctx[0].levels3d.data.emittersize
      );
      append(tr3, t29);
      append(tr3, td10);
      append(td10, div32);
      append(div32, div30);
      append(div30, label10);
      append(div32, t31);
      append(div32, div31);
      append(div31, input10);
      set_input_value(
        input10,
        /*$animation*/
        ctx[0].levels3d.data.rate
      );
      append(tr3, t32);
      append(tr3, td11);
      append(td11, label11);
      append(label11, t33);
      append(td11, t34);
      append(td11, input11);
      input11.checked = /*$animation*/
      ctx[0].levels3d.data.rotateTowards;
      append(table, t35);
      append(table, tr4);
      append(tr4, td12);
      append(td12, label12);
      append(label12, t36);
      append(td12, t37);
      append(td12, input12);
      input12.checked = /*$animation*/
      ctx[0].levels3d.data.autoSize;
      append(tr4, t38);
      append(tr4, td13);
      append(td13, label13);
      append(label13, t39);
      append(td13, t40);
      append(td13, input13);
      input13.checked = /*$animation*/
      ctx[0].levels3d.data.onCenter;
      append(table, t41);
      if (if_block)
        if_block.m(table, null);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler_2*/
            ctx[11]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler_2*/
            ctx[12]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[13]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[14]
          ),
          listen(
            input4,
            "input",
            /*input4_input_handler*/
            ctx[15]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler*/
            ctx[16]
          ),
          listen(
            input6,
            "input",
            /*input6_input_handler*/
            ctx[17]
          ),
          listen(
            input7,
            "input",
            /*input7_input_handler*/
            ctx[18]
          ),
          listen(
            input8,
            "input",
            /*input8_input_handler*/
            ctx[19]
          ),
          listen(
            input9,
            "input",
            /*input9_input_handler*/
            ctx[20]
          ),
          listen(
            input10,
            "input",
            /*input10_input_handler*/
            ctx[21]
          ),
          listen(
            input11,
            "change",
            /*input11_change_handler*/
            ctx[22]
          ),
          listen(
            input12,
            "change",
            /*input12_change_handler*/
            ctx[23]
          ),
          listen(
            input13,
            "change",
            /*input13_change_handler*/
            ctx[24]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input0.value) !== /*$animation*/
      ctx2[0].levels3d.data.speed) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].levels3d.data.speed
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input1.value) !== /*$animation*/
      ctx2[0].levels3d.data.repeat) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].levels3d.data.repeat
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input2.value) !== /*$animation*/
      ctx2[0].levels3d.data.delay) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].levels3d.data.delay
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input3.value) !== /*$animation*/
      ctx2[0].levels3d.data.scale) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[0].levels3d.data.scale
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input4.value) !== /*$animation*/
      ctx2[0].levels3d.data.arc) {
        set_input_value(
          input4,
          /*$animation*/
          ctx2[0].levels3d.data.arc
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input5.value) !== /*$animation*/
      ctx2[0].levels3d.data.alpha) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[0].levels3d.data.alpha
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input6.value) !== /*$animation*/
      ctx2[0].levels3d.data.gravity) {
        set_input_value(
          input6,
          /*$animation*/
          ctx2[0].levels3d.data.gravity
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input7.value) !== /*$animation*/
      ctx2[0].levels3d.data.duration) {
        set_input_value(
          input7,
          /*$animation*/
          ctx2[0].levels3d.data.duration
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input8.value) !== /*$animation*/
      ctx2[0].levels3d.data.life) {
        set_input_value(
          input8,
          /*$animation*/
          ctx2[0].levels3d.data.life
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input9.value) !== /*$animation*/
      ctx2[0].levels3d.data.emittersize) {
        set_input_value(
          input9,
          /*$animation*/
          ctx2[0].levels3d.data.emittersize
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5 && to_number(input10.value) !== /*$animation*/
      ctx2[0].levels3d.data.rate) {
        set_input_value(
          input10,
          /*$animation*/
          ctx2[0].levels3d.data.rate
        );
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5) {
        input11.checked = /*$animation*/
        ctx2[0].levels3d.data.rotateTowards;
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5) {
        input12.checked = /*$animation*/
        ctx2[0].levels3d.data.autoSize;
      }
      if (dirty[0] & /*$animation, tokenAnimations*/
      5) {
        input13.checked = /*$animation*/
        ctx2[0].levels3d.data.onCenter;
      }
      if (
        /*$animation*/
        ctx2[0].levels3d.type === "sprite"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$5(ctx2);
          if_block.c();
          if_block.m(table, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(table);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$c(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[5]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$E(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$b, create_else_block$8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[1] !== "token"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if_blocks[current_block_type_index].m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let type;
  let $animation;
  let tokenAnimations = game.Levels3DPreview?.CONFIG?.tokenAnimations || {
    bow: {},
    breath: {},
    buff: {},
    charge: {},
    debuff: {},
    knockback: {},
    shake: {},
    slash: {},
    swipe: {},
    twirl: {}
  };
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  if (typeof $animation.levels3d.data.autoSize !== "boolean") {
    set_store_value(animation, $animation.levels3d.data.autoSize = true, $animation);
  }
  const folder = {
    label: game.i18n.localize("autoanimations.menus.options"),
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    },
    onClickPropagate: false
  };
  function input0_input_handler() {
    $animation.levels3d.data.color01 = this.value;
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input1_input_handler() {
    $animation.levels3d.data.color01 = this.value;
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input0_input_handler_1() {
    $animation.levels3d.data.color02 = this.value;
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input1_input_handler_1() {
    $animation.levels3d.data.color02 = this.value;
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  const click_handler = () => OptionsDialog.show("canvas3d");
  function input0_input_handler_2() {
    $animation.levels3d.data.speed = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input1_input_handler_2() {
    $animation.levels3d.data.repeat = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input2_input_handler() {
    $animation.levels3d.data.delay = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input3_input_handler() {
    $animation.levels3d.data.scale = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input4_input_handler() {
    $animation.levels3d.data.arc = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input5_input_handler() {
    $animation.levels3d.data.alpha = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input6_input_handler() {
    $animation.levels3d.data.gravity = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input7_input_handler() {
    $animation.levels3d.data.duration = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input8_input_handler() {
    $animation.levels3d.data.life = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input9_input_handler() {
    $animation.levels3d.data.emittersize = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input10_input_handler() {
    $animation.levels3d.data.rate = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input11_change_handler() {
    $animation.levels3d.data.rotateTowards = this.checked;
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input12_change_handler() {
    $animation.levels3d.data.autoSize = this.checked;
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input13_change_handler() {
    $animation.levels3d.data.onCenter = this.checked;
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input0_input_handler_3() {
    $animation.levels3d.data.rotationX = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input1_input_handler_3() {
    $animation.levels3d.data.rotationY = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input2_input_handler_1() {
    $animation.levels3d.data.rotationZ = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function select0_change_handler() {
    $animation.levels3d.data.animationType = select_value(this);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function select1_change_handler() {
    $animation.levels3d.data.playOn = select_value(this);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input0_input_handler_4() {
    $animation.levels3d.data.repeat = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  function input1_input_handler_4() {
    $animation.levels3d.data.resetTime = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, tokenAnimations);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$animation*/
    1) {
      $$invalidate(1, type = $animation.levels3d.type);
    }
  };
  return [
    $animation,
    type,
    tokenAnimations,
    animation,
    folder,
    optionsInfo,
    input0_input_handler,
    input1_input_handler,
    input0_input_handler_1,
    input1_input_handler_1,
    click_handler,
    input0_input_handler_2,
    input1_input_handler_2,
    input2_input_handler,
    input3_input_handler,
    input4_input_handler,
    input5_input_handler,
    input6_input_handler,
    input7_input_handler,
    input8_input_handler,
    input9_input_handler,
    input10_input_handler,
    input11_change_handler,
    input12_change_handler,
    input13_change_handler,
    input0_input_handler_3,
    input1_input_handler_3,
    input2_input_handler_1,
    select0_change_handler,
    select1_change_handler,
    input0_input_handler_4,
    input1_input_handler_4
  ];
}
class Canvas3dOptions extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$C, create_fragment$E, safe_not_equal, {}, null, [-1, -1]);
  }
}
const Canvas3DSecondary_svelte_svelte_type_style_lang = "";
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  return child_ctx;
}
function create_each_block$6(ctx) {
  let option;
  let t_value = localize(`levels3dpreview.particleSystems.${/*effect*/
  ctx[27]}`) + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = /*effect*/
      ctx[27];
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_default_slot_1$3(ctx) {
  let table;
  let tr0;
  let td0;
  let div2;
  let div0;
  let label0;
  let t1;
  let div1;
  let input0;
  let t2;
  let td1;
  let div5;
  let div3;
  let label1;
  let t4;
  let div4;
  let input1;
  let t5;
  let td2;
  let div8;
  let div6;
  let label2;
  let t7;
  let div7;
  let input2;
  let t8;
  let tr1;
  let td3;
  let div11;
  let div9;
  let label3;
  let t10;
  let div10;
  let input3;
  let t11;
  let td4;
  let div14;
  let div12;
  let label4;
  let t13;
  let div13;
  let input4;
  let t14;
  let td5;
  let div17;
  let div15;
  let label5;
  let t16;
  let div16;
  let input5;
  let t17;
  let tr2;
  let td6;
  let div20;
  let div18;
  let label6;
  let t19;
  let div19;
  let input6;
  let t20;
  let td7;
  let div23;
  let div21;
  let label7;
  let t22;
  let div22;
  let input7;
  let t23;
  let td8;
  let label8;
  let t24_value = localize("autoanimations.menus.autoSize") + "";
  let t24;
  let t25;
  let input8;
  let t26;
  let tr3;
  let td9;
  let label9;
  let t27_value = localize("autoanimations.menus.onCenter") + "";
  let t27;
  let t28;
  let input9;
  let t29;
  let td10;
  let t30;
  let td11;
  let mounted;
  let dispose;
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.speed")}`;
      t1 = space();
      div1 = element("div");
      input0 = element("input");
      t2 = space();
      td1 = element("td");
      div5 = element("div");
      div3 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.scale")}`;
      t4 = space();
      div4 = element("div");
      input1 = element("input");
      t5 = space();
      td2 = element("td");
      div8 = element("div");
      div6 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.alpha")}`;
      t7 = space();
      div7 = element("div");
      input2 = element("input");
      t8 = space();
      tr1 = element("tr");
      td3 = element("td");
      div11 = element("div");
      div9 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.gravity")}`;
      t10 = space();
      div10 = element("div");
      input3 = element("input");
      t11 = space();
      td4 = element("td");
      div14 = element("div");
      div12 = element("div");
      label4 = element("label");
      label4.textContent = `${localize("autoanimations.menus.duration")}`;
      t13 = space();
      div13 = element("div");
      input4 = element("input");
      t14 = space();
      td5 = element("td");
      div17 = element("div");
      div15 = element("div");
      label5 = element("label");
      label5.textContent = `${localize("autoanimations.menus.life")}`;
      t16 = space();
      div16 = element("div");
      input5 = element("input");
      t17 = space();
      tr2 = element("tr");
      td6 = element("td");
      div20 = element("div");
      div18 = element("div");
      label6 = element("label");
      label6.textContent = `${localize("autoanimations.menus.emiterSize")}`;
      t19 = space();
      div19 = element("div");
      input6 = element("input");
      t20 = space();
      td7 = element("td");
      div23 = element("div");
      div21 = element("div");
      label7 = element("label");
      label7.textContent = `${localize("autoanimations.menus.rate")}`;
      t22 = space();
      div22 = element("div");
      input7 = element("input");
      t23 = space();
      td8 = element("td");
      label8 = element("label");
      t24 = text(t24_value);
      t25 = space();
      input8 = element("input");
      t26 = space();
      tr3 = element("tr");
      td9 = element("td");
      label9 = element("label");
      t27 = text(t27_value);
      t28 = space();
      input9 = element("input");
      t29 = space();
      td10 = element("td");
      t30 = space();
      td11 = element("td");
      attr(label0, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "5");
      attr(input0, "step", ".01");
      attr(div2, "class", "flex-row");
      attr(label1, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "0.7");
      attr(input1, "step", ".01");
      attr(div5, "class", "flex-row");
      attr(label2, "for", "");
      attr(input2, "type", "number");
      attr(input2, "placeholder", "0.5");
      attr(input2, "step", ".01");
      attr(div8, "class", "flex-row");
      attr(label3, "for", "");
      attr(input3, "type", "number");
      attr(input3, "placeholder", "0");
      attr(input3, "step", ".01");
      attr(div11, "class", "flex-row");
      attr(label4, "for", "");
      attr(input4, "type", "number");
      attr(input4, "placeholder", "3000");
      attr(input4, "step", ".01");
      attr(div14, "class", "flex-row");
      attr(label5, "for", "");
      attr(input5, "type", "number");
      attr(input5, "placeholder", "500");
      attr(input5, "step", ".01");
      attr(div17, "class", "flex-row");
      attr(label6, "for", "");
      attr(input6, "type", "number");
      attr(input6, "placeholder", "0.0001");
      attr(input6, "step", ".0001");
      attr(div20, "class", "flex-row");
      attr(label7, "for", "");
      attr(input7, "type", "number");
      attr(input7, "placeholder", "10");
      attr(input7, "step", ".01");
      attr(div23, "class", "flex-row");
      attr(label8, "for", "3dautoSize " + /*animation*/
      ctx[2]._data.id);
      attr(input8, "type", "checkbox");
      attr(input8, "id", "3dautoSize " + /*animation*/
      ctx[2]._data.id);
      attr(label9, "for", "3donCenter " + /*animation*/
      ctx[2]._data.id);
      attr(input9, "type", "checkbox");
      attr(input9, "id", "3donCenter " + /*animation*/
      ctx[2]._data.id);
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      append(td0, div2);
      append(div2, div0);
      append(div0, label0);
      append(div2, t1);
      append(div2, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].levels3d.secondary.data.speed
      );
      append(tr0, t2);
      append(tr0, td1);
      append(td1, div5);
      append(div5, div3);
      append(div3, label1);
      append(div5, t4);
      append(div5, div4);
      append(div4, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].levels3d.secondary.data.scale
      );
      append(tr0, t5);
      append(tr0, td2);
      append(td2, div8);
      append(div8, div6);
      append(div6, label2);
      append(div8, t7);
      append(div8, div7);
      append(div7, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].levels3d.secondary.data.alpha
      );
      append(table, t8);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div11);
      append(div11, div9);
      append(div9, label3);
      append(div11, t10);
      append(div11, div10);
      append(div10, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[0].levels3d.secondary.data.gravity
      );
      append(tr1, t11);
      append(tr1, td4);
      append(td4, div14);
      append(div14, div12);
      append(div12, label4);
      append(div14, t13);
      append(div14, div13);
      append(div13, input4);
      set_input_value(
        input4,
        /*$animation*/
        ctx[0].levels3d.secondary.data.duration
      );
      append(tr1, t14);
      append(tr1, td5);
      append(td5, div17);
      append(div17, div15);
      append(div15, label5);
      append(div17, t16);
      append(div17, div16);
      append(div16, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[0].levels3d.secondary.data.life
      );
      append(table, t17);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div20);
      append(div20, div18);
      append(div18, label6);
      append(div20, t19);
      append(div20, div19);
      append(div19, input6);
      set_input_value(
        input6,
        /*$animation*/
        ctx[0].levels3d.secondary.data.emittersize
      );
      append(tr2, t20);
      append(tr2, td7);
      append(td7, div23);
      append(div23, div21);
      append(div21, label7);
      append(div23, t22);
      append(div23, div22);
      append(div22, input7);
      set_input_value(
        input7,
        /*$animation*/
        ctx[0].levels3d.secondary.data.rate
      );
      append(td7, t23);
      append(tr2, td8);
      append(td8, label8);
      append(label8, t24);
      append(td8, t25);
      append(td8, input8);
      input8.checked = /*$animation*/
      ctx[0].levels3d.secondary.data.autoSize;
      append(table, t26);
      append(table, tr3);
      append(tr3, td9);
      append(td9, label9);
      append(label9, t27);
      append(td9, t28);
      append(td9, input9);
      input9.checked = /*$animation*/
      ctx[0].levels3d.secondary.data.onCenter;
      append(tr3, t29);
      append(tr3, td10);
      append(tr3, t30);
      append(tr3, td11);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler_1*/
            ctx[17]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler_1*/
            ctx[18]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler_1*/
            ctx[19]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler_1*/
            ctx[20]
          ),
          listen(
            input4,
            "input",
            /*input4_input_handler_1*/
            ctx[21]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler*/
            ctx[22]
          ),
          listen(
            input6,
            "input",
            /*input6_input_handler*/
            ctx[23]
          ),
          listen(
            input7,
            "input",
            /*input7_input_handler*/
            ctx[24]
          ),
          listen(
            input8,
            "change",
            /*input8_change_handler*/
            ctx[25]
          ),
          listen(
            input9,
            "change",
            /*input9_change_handler*/
            ctx[26]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation, Object, pEffects*/
      9 && to_number(input0.value) !== /*$animation*/
      ctx2[0].levels3d.secondary.data.speed) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.speed
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9 && to_number(input1.value) !== /*$animation*/
      ctx2[0].levels3d.secondary.data.scale) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.scale
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9 && to_number(input2.value) !== /*$animation*/
      ctx2[0].levels3d.secondary.data.alpha) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.alpha
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9 && to_number(input3.value) !== /*$animation*/
      ctx2[0].levels3d.secondary.data.gravity) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.gravity
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9 && to_number(input4.value) !== /*$animation*/
      ctx2[0].levels3d.secondary.data.duration) {
        set_input_value(
          input4,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.duration
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9 && to_number(input5.value) !== /*$animation*/
      ctx2[0].levels3d.secondary.data.life) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.life
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9 && to_number(input6.value) !== /*$animation*/
      ctx2[0].levels3d.secondary.data.emittersize) {
        set_input_value(
          input6,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.emittersize
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9 && to_number(input7.value) !== /*$animation*/
      ctx2[0].levels3d.secondary.data.rate) {
        set_input_value(
          input7,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.rate
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9) {
        input8.checked = /*$animation*/
        ctx2[0].levels3d.secondary.data.autoSize;
      }
      if (dirty & /*$animation, Object, pEffects*/
      9) {
        input9.checked = /*$animation*/
        ctx2[0].levels3d.secondary.data.onCenter;
      }
    },
    d(detaching) {
      if (detaching)
        detach(table);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot_1$2(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[5]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler_1*/
    ctx[16]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_default_slot$e(ctx) {
  let div0;
  let label0;
  let t1;
  let select;
  let t2;
  let table0;
  let tr0;
  let td0;
  let div1;
  let label1;
  let t4;
  let td1;
  let input0;
  let t5;
  let td2;
  let i;
  let t6;
  let div8;
  let div6;
  let h1;
  let t8;
  let table1;
  let tr1;
  let td3;
  let div2;
  let label2;
  let t11;
  let input1;
  let t12;
  let div3;
  let input2;
  let t13;
  let td4;
  let div4;
  let label3;
  let t16;
  let input3;
  let t17;
  let div5;
  let input4;
  let t18;
  let div7;
  let tjssvgfolder;
  let div8_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = Object.keys(
    /*pEffects*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$6(get_each_context$6(ctx, each_value, i2));
  }
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[4]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot_1$2],
        default: [create_default_slot_1$3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.type")}`;
      t1 = space();
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      table0 = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div1 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.sprite")}`;
      t4 = space();
      td1 = element("td");
      input0 = element("input");
      t5 = space();
      td2 = element("td");
      i = element("i");
      t6 = space();
      div8 = element("div");
      div6 = element("div");
      h1 = element("h1");
      h1.textContent = "Colors";
      t8 = space();
      table1 = element("table");
      tr1 = element("tr");
      td3 = element("td");
      div2 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.color")} 01`;
      t11 = space();
      input1 = element("input");
      t12 = space();
      div3 = element("div");
      input2 = element("input");
      t13 = space();
      td4 = element("td");
      div4 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.color")} 02`;
      t16 = space();
      input3 = element("input");
      t17 = space();
      div5 = element("div");
      input4 = element("input");
      t18 = space();
      div7 = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(label0, "for", "");
      if (
        /*$animation*/
        ctx[0].levels3d.secondary.data.type === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[9].call(select)
        ));
      attr(div0, "class", "flexcol");
      set_style(div0, "align-items", "center");
      attr(label1, "for", "");
      attr(label1, "class", "aa-customFont");
      attr(div1, "class", "flexrow");
      set_style(td0, "width", "6em");
      set_style(td0, "border", "none");
      attr(input0, "type", "text");
      set_style(input0, "font-weight", "normal");
      set_style(input0, "font-size", "small");
      set_style(input0, "border-radius", "5px");
      set_style(input0, "text-align", "left");
      set_style(input0, "width", "100%");
      set_style(td1, "border", "none");
      attr(i, "class", "fas fa-file-import");
      attr(i, "title", "File Picker");
      set_style(i, "font-size", "1.5em");
      attr(i, "role", "presentation");
      set_style(td2, "width", "4em");
      set_style(td2, "border", "none");
      attr(table0, "class", "c");
      attr(h1, "class", "svelte-auto-z8zyef");
      attr(label2, "for", "");
      attr(input1, "type", "Text");
      set_style(input1, "width", "10em");
      set_style(input1, "margin", "auto");
      attr(div2, "class", "flexcol");
      attr(input2, "type", "color");
      attr(input2, "data-edit", "color");
      attr(input2, "id", "tint");
      set_style(input2, "width", "10em");
      set_style(input2, "margin-left", "0");
      attr(div3, "class", "form-group");
      attr(label3, "for", "");
      attr(input3, "type", "Text");
      set_style(input3, "width", "10em");
      set_style(input3, "margin", "auto");
      attr(div4, "class", "flexcol");
      attr(input4, "type", "color");
      attr(input4, "data-edit", "color");
      attr(input4, "id", "tint");
      set_style(input4, "width", "10em");
      set_style(input4, "margin-left", "0");
      attr(div5, "class", "form-group");
      attr(table1, "class", "d");
      set_style(table1, "padding-right", "4em");
      set_style(table1, "padding-left", "4em");
      attr(div6, "class", "aa-options-border");
      set_style(div6, "margin-top", ".5em");
      attr(div7, "class", "aa-options-border");
      attr(div8, "class", div8_class_value = /*isEnabled*/
      ctx[1] ? "" : "aa-disableOpacity");
    },
    m(target2, anchor) {
      insert(target2, div0, anchor);
      append(div0, label0);
      append(div0, t1);
      append(div0, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(
        select,
        /*$animation*/
        ctx[0].levels3d.secondary.data.type,
        true
      );
      insert(target2, t2, anchor);
      insert(target2, table0, anchor);
      append(table0, tr0);
      append(tr0, td0);
      append(td0, div1);
      append(div1, label1);
      append(tr0, t4);
      append(tr0, td1);
      append(td1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].levels3d.secondary.data.spritePath
      );
      append(tr0, t5);
      append(tr0, td2);
      append(td2, i);
      insert(target2, t6, anchor);
      insert(target2, div8, anchor);
      append(div8, div6);
      append(div6, h1);
      append(div6, t8);
      append(div6, table1);
      append(table1, tr1);
      append(tr1, td3);
      append(td3, div2);
      append(div2, label2);
      append(div2, t11);
      append(div2, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].levels3d.secondary.data.color01
      );
      append(td3, t12);
      append(td3, div3);
      append(div3, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].levels3d.secondary.data.color01
      );
      append(tr1, t13);
      append(tr1, td4);
      append(td4, div4);
      append(div4, label3);
      append(div4, t16);
      append(div4, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[0].levels3d.secondary.data.color02
      );
      append(td4, t17);
      append(td4, div5);
      append(div5, input4);
      set_input_value(
        input4,
        /*$animation*/
        ctx[0].levels3d.secondary.data.color02
      );
      append(div8, t18);
      append(div8, div7);
      mount_component(tjssvgfolder, div7, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[9]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[10]
          ),
          listen(i, "click", prevent_default(
            /*click_handler*/
            ctx[11]
          )),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[12]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[13]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[14]
          ),
          listen(
            input4,
            "input",
            /*input4_input_handler*/
            ctx[15]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, pEffects, localize*/
      8) {
        each_value = Object.keys(
          /*pEffects*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$6(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$animation, Object, pEffects*/
      9) {
        select_option(
          select,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.type
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9 && input0.value !== /*$animation*/
      ctx2[0].levels3d.secondary.data.spritePath) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.spritePath
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.color01
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.color01
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.color02
        );
      }
      if (dirty & /*$animation, Object, pEffects*/
      9) {
        set_input_value(
          input4,
          /*$animation*/
          ctx2[0].levels3d.secondary.data.color02
        );
      }
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation*/
      1073741825) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
      if (!current || dirty & /*isEnabled*/
      2 && div8_class_value !== (div8_class_value = /*isEnabled*/
      ctx2[1] ? "" : "aa-disableOpacity")) {
        attr(div8, "class", div8_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(table0);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(div8);
      destroy_component(tjssvgfolder);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$b(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Secondary On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[0].levels3d.secondary.enable;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation, Object, pEffects*/
      9) {
        input.checked = /*$animation*/
        ctx2[0].levels3d.secondary.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$D(ctx) {
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folderOptions*/
        ctx[6]
      ),
      label: localize("autoanimations.animations.explosion"),
      $$slots: {
        "summary-end": [create_summary_end_slot$b],
        default: [create_default_slot$e]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tjssvgfolder.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjssvgfolder, target2, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, isEnabled*/
      1073741827) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjssvgfolder, detaching);
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let isEnabled;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  if (typeof $animation.levels3d.secondary.data.autoSize !== "boolean") {
    set_store_value(animation, $animation.levels3d.secondary.data.autoSize = true, $animation);
  }
  if (!$animation.levels3d.secondary.data.spritePath) {
    set_store_value(animation, $animation.levels3d.secondary.data.spritePath = "modules/levels-3d-preview/assets/particles/dust.png", $animation);
  }
  let pEffects = game.Levels3DPreview?.CONFIG.PARTICLE_SYSTEMS?.TARGET_ONLY_PARTICLE_SYSTEMS || {};
  const folder = {
    label: game.i18n.localize("autoanimations.menus.options"),
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    },
    onClickPropagate: false
  };
  const folderOptions = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  async function selectCustom() {
    const current = animation._data.levels3d.secondary.data.spritePath;
    const picker = new FilePicker({
      type: "any",
      current,
      callback: (path) => {
        set_store_value(animation, $animation.levels3d.secondary.data.spritePath = path, $animation);
      }
    });
    setTimeout(
      () => {
        picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
      },
      100
    );
    await picker.browse(current);
  }
  function input_change_handler() {
    $animation.levels3d.secondary.enable = this.checked;
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function select_change_handler() {
    $animation.levels3d.secondary.data.type = select_value(this);
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input0_input_handler() {
    $animation.levels3d.secondary.data.spritePath = this.value;
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  const click_handler = () => selectCustom();
  function input1_input_handler() {
    $animation.levels3d.secondary.data.color01 = this.value;
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input2_input_handler() {
    $animation.levels3d.secondary.data.color01 = this.value;
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input3_input_handler() {
    $animation.levels3d.secondary.data.color02 = this.value;
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input4_input_handler() {
    $animation.levels3d.secondary.data.color02 = this.value;
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  const click_handler_1 = () => OptionsDialog.show("canvas3d");
  function input0_input_handler_1() {
    $animation.levels3d.secondary.data.speed = to_number(this.value);
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input1_input_handler_1() {
    $animation.levels3d.secondary.data.scale = to_number(this.value);
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input2_input_handler_1() {
    $animation.levels3d.secondary.data.alpha = to_number(this.value);
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input3_input_handler_1() {
    $animation.levels3d.secondary.data.gravity = to_number(this.value);
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input4_input_handler_1() {
    $animation.levels3d.secondary.data.duration = to_number(this.value);
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input5_input_handler() {
    $animation.levels3d.secondary.data.life = to_number(this.value);
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input6_input_handler() {
    $animation.levels3d.secondary.data.emittersize = to_number(this.value);
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input7_input_handler() {
    $animation.levels3d.secondary.data.rate = to_number(this.value);
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input8_change_handler() {
    $animation.levels3d.secondary.data.autoSize = this.checked;
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  function input9_change_handler() {
    $animation.levels3d.secondary.data.onCenter = this.checked;
    animation.set($animation);
    $$invalidate(3, pEffects);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, isEnabled = $animation.levels3d.secondary.enable);
    }
  };
  return [
    $animation,
    isEnabled,
    animation,
    pEffects,
    folder,
    optionsInfo,
    folderOptions,
    selectCustom,
    input_change_handler,
    select_change_handler,
    input0_input_handler,
    click_handler,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    input4_input_handler,
    click_handler_1,
    input0_input_handler_1,
    input1_input_handler_1,
    input2_input_handler_1,
    input3_input_handler_1,
    input4_input_handler_1,
    input5_input_handler,
    input6_input_handler,
    input7_input_handler,
    input8_change_handler,
    input9_change_handler
  ];
}
class Canvas3DSecondary extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$B, create_fragment$D, safe_not_equal, {});
  }
}
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let option;
  let t_value = localize(`autoanimations.tokenAnimations.${/*sourceAnim*/
  ctx[17]}`) + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = /*sourceAnim*/
      ctx[17];
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block$5(ctx) {
  let option;
  let t_value = localize(`autoanimations.tokenAnimations.${/*targetAnim*/
  ctx[14]}`) + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = /*targetAnim*/
      ctx[14];
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_default_slot$d(ctx) {
  let div13;
  let table;
  let tr0;
  let td0;
  let div0;
  let label0;
  let t0_value = localize("autoanimations.menus.source") + "";
  let t0;
  let t1;
  let t2_value = localize("autoanimations.menus.token") + "";
  let t2;
  let t3;
  let input0;
  let t4;
  let td1;
  let div3;
  let div1;
  let label1;
  let t6;
  let div2;
  let select0;
  let div3_class_value;
  let t7;
  let td2;
  let div6;
  let div4;
  let label2;
  let t9;
  let div5;
  let select1;
  let option0;
  let option1;
  let option2;
  let div6_class_value;
  let t13;
  let tr1;
  let td3;
  let label3;
  let t14_value = localize("autoanimations.menus.target") + "";
  let t14;
  let t15;
  let t16_value = localize("autoanimations.menus.token") + "";
  let t16;
  let t17;
  let input1;
  let t18;
  let td4;
  let div9;
  let div7;
  let label4;
  let t20;
  let div8;
  let select2;
  let div9_class_value;
  let t21;
  let td5;
  let div12;
  let div10;
  let label5;
  let t23;
  let div11;
  let select3;
  let option3;
  let option4;
  let option5;
  let div12_class_value;
  let div13_class_value;
  let mounted;
  let dispose;
  let each_value_1 = Object.keys(
    /*tokenAnimations*/
    ctx[4]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = Object.keys(
    /*tokenAnimations*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  }
  return {
    c() {
      div13 = element("div");
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div0 = element("div");
      label0 = element("label");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      input0 = element("input");
      t4 = space();
      td1 = element("td");
      div3 = element("div");
      div1 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.type")}`;
      t6 = space();
      div2 = element("div");
      select0 = element("select");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t7 = space();
      td2 = element("td");
      div6 = element("div");
      div4 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.playOn")}`;
      t9 = space();
      div5 = element("div");
      select1 = element("select");
      option0 = element("option");
      option0.textContent = `${localize(`autoanimations.menus.start`)}`;
      option1 = element("option");
      option1.textContent = `${localize(`autoanimations.menus.end`)}`;
      option2 = element("option");
      option2.textContent = `${localize(`autoanimations.menus.both`)}`;
      t13 = space();
      tr1 = element("tr");
      td3 = element("td");
      label3 = element("label");
      t14 = text(t14_value);
      t15 = space();
      t16 = text(t16_value);
      t17 = space();
      input1 = element("input");
      t18 = space();
      td4 = element("td");
      div9 = element("div");
      div7 = element("div");
      label4 = element("label");
      label4.textContent = `${localize("autoanimations.menus.type")}`;
      t20 = space();
      div8 = element("div");
      select2 = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t21 = space();
      td5 = element("td");
      div12 = element("div");
      div10 = element("div");
      label5 = element("label");
      label5.textContent = `${localize("autoanimations.menus.playOn")}`;
      t23 = space();
      div11 = element("div");
      select3 = element("select");
      option3 = element("option");
      option3.textContent = `${localize(`autoanimations.menus.start`)}`;
      option4 = element("option");
      option4.textContent = `${localize(`autoanimations.menus.end`)}`;
      option5 = element("option");
      option5.textContent = `${localize(`autoanimations.menus.both`)}`;
      attr(label0, "for", "3DSourceAnim " + /*animation*/
      ctx[2]._data.id);
      attr(input0, "type", "checkbox");
      set_style(input0, "margin", "auto");
      attr(input0, "id", "3DSourceAnim " + /*animation*/
      ctx[2]._data.id);
      attr(label1, "for", "");
      if (
        /*$animation*/
        ctx[0].levels3d.tokens.sourceType === void 0
      )
        add_render_callback(() => (
          /*select0_change_handler*/
          ctx[7].call(select0)
        ));
      attr(div3, "class", div3_class_value = /*$animation*/
      ctx[0].levels3d?.tokens?.source ? "" : "aa-disableOpacity");
      attr(label2, "for", "");
      option0.__value = "start";
      option0.value = option0.__value;
      option1.__value = "end";
      option1.value = option1.__value;
      option2.__value = "both";
      option2.value = option2.__value;
      if (
        /*$animation*/
        ctx[0].levels3d.tokens.sourcePlay === void 0
      )
        add_render_callback(() => (
          /*select1_change_handler*/
          ctx[8].call(select1)
        ));
      attr(div6, "class", div6_class_value = /*$animation*/
      ctx[0].levels3d?.tokens?.source ? "" : "aa-disableOpacity");
      attr(label3, "for", "3DTargetAnim " + /*animation*/
      ctx[2]._data.id);
      attr(input1, "type", "checkbox");
      set_style(input1, "margin", "auto");
      attr(input1, "id", "3DTargetAnim " + /*animation*/
      ctx[2]._data.id);
      attr(label4, "for", "");
      if (
        /*$animation*/
        ctx[0].levels3d.tokens.targetType === void 0
      )
        add_render_callback(() => (
          /*select2_change_handler*/
          ctx[10].call(select2)
        ));
      attr(div9, "class", div9_class_value = /*$animation*/
      ctx[0].levels3d?.tokens?.target ? "" : "aa-disableOpacity");
      attr(label5, "for", "");
      option3.__value = "start";
      option3.value = option3.__value;
      option4.__value = "end";
      option4.value = option4.__value;
      option5.__value = "both";
      option5.value = option5.__value;
      if (
        /*$animation*/
        ctx[0].levels3d.tokens.targetPlay === void 0
      )
        add_render_callback(() => (
          /*select3_change_handler*/
          ctx[11].call(select3)
        ));
      attr(div12, "class", div12_class_value = /*$animation*/
      ctx[0].levels3d?.tokens?.target ? "" : "aa-disableOpacity");
      attr(table, "class", "c");
      attr(div13, "class", div13_class_value = "aa-options-border " + /*isEnabled*/
      (ctx[1] ? "" : "aa-disableOpacity"));
    },
    m(target2, anchor) {
      insert(target2, div13, anchor);
      append(div13, table);
      append(table, tr0);
      append(tr0, td0);
      append(td0, div0);
      append(div0, label0);
      append(label0, t0);
      append(label0, t1);
      append(label0, t2);
      append(div0, t3);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[0].levels3d.tokens.source;
      append(tr0, t4);
      append(tr0, td1);
      append(td1, div3);
      append(div3, div1);
      append(div1, label1);
      append(div3, t6);
      append(div3, div2);
      append(div2, select0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(select0, null);
        }
      }
      select_option(
        select0,
        /*$animation*/
        ctx[0].levels3d.tokens.sourceType,
        true
      );
      append(tr0, t7);
      append(tr0, td2);
      append(td2, div6);
      append(div6, div4);
      append(div4, label2);
      append(div6, t9);
      append(div6, div5);
      append(div5, select1);
      append(select1, option0);
      append(select1, option1);
      append(select1, option2);
      select_option(
        select1,
        /*$animation*/
        ctx[0].levels3d.tokens.sourcePlay,
        true
      );
      append(table, t13);
      append(table, tr1);
      append(tr1, td3);
      append(td3, label3);
      append(label3, t14);
      append(label3, t15);
      append(label3, t16);
      append(td3, t17);
      append(td3, input1);
      input1.checked = /*$animation*/
      ctx[0].levels3d.tokens.target;
      append(tr1, t18);
      append(tr1, td4);
      append(td4, div9);
      append(div9, div7);
      append(div7, label4);
      append(div9, t20);
      append(div9, div8);
      append(div8, select2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select2, null);
        }
      }
      select_option(
        select2,
        /*$animation*/
        ctx[0].levels3d.tokens.targetType,
        true
      );
      append(tr1, t21);
      append(tr1, td5);
      append(td5, div12);
      append(div12, div10);
      append(div10, label5);
      append(div12, t23);
      append(div12, div11);
      append(div11, select3);
      append(select3, option3);
      append(select3, option4);
      append(select3, option5);
      select_option(
        select3,
        /*$animation*/
        ctx[0].levels3d.tokens.targetPlay,
        true
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[6]
          ),
          listen(
            select0,
            "change",
            /*select0_change_handler*/
            ctx[7]
          ),
          listen(
            select1,
            "change",
            /*select1_change_handler*/
            ctx[8]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[9]
          ),
          listen(
            select2,
            "change",
            /*select2_change_handler*/
            ctx[10]
          ),
          listen(
            select3,
            "change",
            /*select3_change_handler*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation, Object, tokenAnimations*/
      17) {
        input0.checked = /*$animation*/
        ctx2[0].levels3d.tokens.source;
      }
      if (dirty & /*Object, tokenAnimations, localize*/
      16) {
        each_value_1 = Object.keys(
          /*tokenAnimations*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(select0, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*$animation, Object, tokenAnimations*/
      17) {
        select_option(
          select0,
          /*$animation*/
          ctx2[0].levels3d.tokens.sourceType
        );
      }
      if (dirty & /*$animation, Object, tokenAnimations*/
      17 && div3_class_value !== (div3_class_value = /*$animation*/
      ctx2[0].levels3d?.tokens?.source ? "" : "aa-disableOpacity")) {
        attr(div3, "class", div3_class_value);
      }
      if (dirty & /*$animation, Object, tokenAnimations*/
      17) {
        select_option(
          select1,
          /*$animation*/
          ctx2[0].levels3d.tokens.sourcePlay
        );
      }
      if (dirty & /*$animation, Object, tokenAnimations*/
      17 && div6_class_value !== (div6_class_value = /*$animation*/
      ctx2[0].levels3d?.tokens?.source ? "" : "aa-disableOpacity")) {
        attr(div6, "class", div6_class_value);
      }
      if (dirty & /*$animation, Object, tokenAnimations*/
      17) {
        input1.checked = /*$animation*/
        ctx2[0].levels3d.tokens.target;
      }
      if (dirty & /*Object, tokenAnimations, localize*/
      16) {
        each_value = Object.keys(
          /*tokenAnimations*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select2, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$animation, Object, tokenAnimations*/
      17) {
        select_option(
          select2,
          /*$animation*/
          ctx2[0].levels3d.tokens.targetType
        );
      }
      if (dirty & /*$animation, Object, tokenAnimations*/
      17 && div9_class_value !== (div9_class_value = /*$animation*/
      ctx2[0].levels3d?.tokens?.target ? "" : "aa-disableOpacity")) {
        attr(div9, "class", div9_class_value);
      }
      if (dirty & /*$animation, Object, tokenAnimations*/
      17) {
        select_option(
          select3,
          /*$animation*/
          ctx2[0].levels3d.tokens.targetPlay
        );
      }
      if (dirty & /*$animation, Object, tokenAnimations*/
      17 && div12_class_value !== (div12_class_value = /*$animation*/
      ctx2[0].levels3d?.tokens?.target ? "" : "aa-disableOpacity")) {
        attr(div12, "class", div12_class_value);
      }
      if (dirty & /*isEnabled*/
      2 && div13_class_value !== (div13_class_value = "aa-options-border " + /*isEnabled*/
      (ctx2[1] ? "" : "aa-disableOpacity"))) {
        attr(div13, "class", div13_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div13);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$a(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Secondary On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[0].levels3d.tokens.enable;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation, Object, tokenAnimations*/
      17) {
        input.checked = /*$animation*/
        ctx2[0].levels3d.tokens.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$C(ctx) {
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folderOptions*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.token") + " " + localize("autoanimations.menus.animation"),
      $$slots: {
        "summary-end": [create_summary_end_slot$a],
        default: [create_default_slot$d]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tjssvgfolder.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjssvgfolder, target2, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, isEnabled*/
      1048579) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjssvgfolder, detaching);
    }
  };
}
function instance$A($$self, $$props, $$invalidate) {
  let isEnabled;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  ({
    label: game.i18n.localize("autoanimations.menus.options"),
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  });
  const folderOptions = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  let tokenAnimations = game.Levels3DPreview?.CONFIG?.tokenAnimations || {
    bow: {},
    breath: {},
    buff: {},
    charge: {},
    debuff: {},
    knockback: {},
    shake: {},
    slash: {},
    swipe: {},
    twirl: {}
  };
  if (!$animation.levels3d.tokens) {
    set_store_value(
      animation,
      $animation.levels3d.tokens = {
        enable: false,
        source: false,
        target: false,
        sourceType: "twirl",
        sourcePlay: "start",
        targetType: "shake",
        targetPlay: "end"
      },
      $animation
    );
  }
  function input_change_handler() {
    $animation.levels3d.tokens.enable = this.checked;
    animation.set($animation);
    $$invalidate(4, tokenAnimations);
  }
  function input0_change_handler() {
    $animation.levels3d.tokens.source = this.checked;
    animation.set($animation);
    $$invalidate(4, tokenAnimations);
  }
  function select0_change_handler() {
    $animation.levels3d.tokens.sourceType = select_value(this);
    animation.set($animation);
    $$invalidate(4, tokenAnimations);
  }
  function select1_change_handler() {
    $animation.levels3d.tokens.sourcePlay = select_value(this);
    animation.set($animation);
    $$invalidate(4, tokenAnimations);
  }
  function input1_change_handler() {
    $animation.levels3d.tokens.target = this.checked;
    animation.set($animation);
    $$invalidate(4, tokenAnimations);
  }
  function select2_change_handler() {
    $animation.levels3d.tokens.targetType = select_value(this);
    animation.set($animation);
    $$invalidate(4, tokenAnimations);
  }
  function select3_change_handler() {
    $animation.levels3d.tokens.targetPlay = select_value(this);
    animation.set($animation);
    $$invalidate(4, tokenAnimations);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, isEnabled = $animation.levels3d.tokens.enable);
    }
  };
  return [
    $animation,
    isEnabled,
    animation,
    folderOptions,
    tokenAnimations,
    input_change_handler,
    input0_change_handler,
    select0_change_handler,
    select1_change_handler,
    input1_change_handler,
    select2_change_handler,
    select3_change_handler
  ];
}
class Canvas3DAnimation extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$A, create_fragment$C, safe_not_equal, {});
  }
}
const Canvas3D_svelte_svelte_type_style_lang = "";
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function create_else_block$7(ctx) {
  let option;
  let t_value = localize(`levels3dpreview.particleSystems.${/*effect*/
  ctx[14]}`) + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = /*effect*/
      ctx[14];
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_2$3(ctx) {
  let optgroup;
  return {
    c() {
      optgroup = element("optgroup");
      attr(optgroup, "label", localize(`levels3dpreview.particleSystems.${/*effect*/
      ctx[14]}`));
    },
    m(target2, anchor) {
      insert(target2, optgroup, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(optgroup);
    }
  };
}
function create_each_block$4(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*effect*/
      ctx2[14].includes("optgroup")
    )
      return create_if_block_2$3;
    return create_else_block$7;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if_block.m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$4(ctx) {
  let table;
  let tr;
  let td0;
  let div;
  let label;
  let t1;
  let td1;
  let input;
  let t2;
  let td2;
  let i;
  let mounted;
  let dispose;
  return {
    c() {
      table = element("table");
      tr = element("tr");
      td0 = element("td");
      div = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.sprite")}`;
      t1 = space();
      td1 = element("td");
      input = element("input");
      t2 = space();
      td2 = element("td");
      i = element("i");
      attr(label, "for", "");
      attr(label, "class", "aa-customFont svelte-auto-bvaskx");
      attr(div, "class", "flexrow");
      set_style(td0, "width", "6em");
      set_style(td0, "border", "none");
      attr(input, "type", "text");
      set_style(input, "font-weight", "normal");
      set_style(input, "font-size", "small");
      set_style(input, "border-radius", "5px");
      set_style(input, "text-align", "left");
      set_style(input, "width", "100%");
      set_style(td1, "border", "none");
      attr(i, "class", "fas fa-file-import");
      attr(i, "title", "File Picker");
      set_style(i, "font-size", "1.5em");
      attr(i, "role", "presentation");
      set_style(td2, "width", "4em");
      set_style(td2, "border", "none");
      attr(table, "class", "c svelte-auto-bvaskx");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr);
      append(tr, td0);
      append(td0, div);
      append(div, label);
      append(tr, t1);
      append(tr, td1);
      append(td1, input);
      set_input_value(
        input,
        /*$animation*/
        ctx[0].levels3d.data.spritePath
      );
      append(tr, t2);
      append(tr, td2);
      append(td2, i);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[12]
          ),
          listen(i, "click", prevent_default(
            /*click_handler*/
            ctx[13]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation, Object, pEffects*/
      65 && input.value !== /*$animation*/
      ctx2[0].levels3d.data.spritePath) {
        set_input_value(
          input,
          /*$animation*/
          ctx2[0].levels3d.data.spritePath
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(table);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$a(ctx) {
  let div0;
  let canvas3dsecondary;
  let div0_class_value;
  let t;
  let div1;
  let canvas3dtokenanimation;
  let div1_class_value;
  let current;
  canvas3dsecondary = new Canvas3DSecondary({
    props: { animation: (
      /*animation*/
      ctx[3]
    ) }
  });
  canvas3dtokenanimation = new Canvas3DAnimation({
    props: { animation: (
      /*animation*/
      ctx[3]
    ) }
  });
  return {
    c() {
      div0 = element("div");
      create_component(canvas3dsecondary.$$.fragment);
      t = space();
      div1 = element("div");
      create_component(canvas3dtokenanimation.$$.fragment);
      attr(div0, "class", div0_class_value = "aa-section-border " + /*isEnabled*/
      (ctx[1] ? "" : "aa-disableOpacity"));
      attr(div1, "class", div1_class_value = "aa-section-border " + /*isEnabled*/
      (ctx[1] ? "" : "aa-disableOpacity"));
    },
    m(target2, anchor) {
      insert(target2, div0, anchor);
      mount_component(canvas3dsecondary, div0, null);
      insert(target2, t, anchor);
      insert(target2, div1, anchor);
      mount_component(canvas3dtokenanimation, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*isEnabled*/
      2 && div0_class_value !== (div0_class_value = "aa-section-border " + /*isEnabled*/
      (ctx2[1] ? "" : "aa-disableOpacity"))) {
        attr(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*isEnabled*/
      2 && div1_class_value !== (div1_class_value = "aa-section-border " + /*isEnabled*/
      (ctx2[1] ? "" : "aa-disableOpacity"))) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(canvas3dsecondary.$$.fragment, local);
      transition_in(canvas3dtokenanimation.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(canvas3dsecondary.$$.fragment, local);
      transition_out(canvas3dtokenanimation.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(canvas3dsecondary);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div1);
      destroy_component(canvas3dtokenanimation);
    }
  };
}
function create_fragment$B(ctx) {
  let h1;
  let t1;
  let h3;
  let t3;
  let table;
  let td0;
  let div0;
  let label0;
  let t4;
  let t5;
  let input;
  let t6;
  let td1;
  let div1;
  let label1;
  let t8;
  let select;
  let option;
  let td1_class_value;
  let t12;
  let td2;
  let t13;
  let div2;
  let t14;
  let canvas3doptions;
  let t15;
  let soundsettings;
  let div2_class_value;
  let t16;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value = Object.keys(
    /*pEffects*/
    ctx[6]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  let if_block0 = (
    /*type*/
    ctx[2] !== "token" && create_if_block_1$4(ctx)
  );
  canvas3doptions = new Canvas3dOptions({
    props: { animation: (
      /*animation*/
      ctx[3]
    ) }
  });
  soundsettings = new SoundSettings({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      category: (
        /*category*/
        ctx[4]
      ),
      idx: (
        /*idx*/
        ctx[5]
      ),
      section: "levels3d"
    }
  });
  let if_block1 = (
    /*type*/
    ctx[2] !== "token" && create_if_block$a(ctx)
  );
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "3D Canvas Particle Animations";
      t1 = space();
      h3 = element("h3");
      h3.textContent = "Requires the 3D Canvas Module by Ripper";
      t3 = space();
      table = element("table");
      td0 = element("td");
      div0 = element("div");
      label0 = element("label");
      t4 = text("Enable");
      t5 = space();
      input = element("input");
      t6 = space();
      td1 = element("td");
      div1 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.type")}`;
      t8 = space();
      select = element("select");
      option = element("option");
      option.textContent = `${localize(`autoanimations.menus.token`)}  ${localize(`autoanimations.menus.animation`)}`;
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t12 = space();
      td2 = element("td");
      t13 = space();
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t14 = space();
      create_component(canvas3doptions.$$.fragment);
      t15 = space();
      create_component(soundsettings.$$.fragment);
      t16 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(h1, "class", "svelte-auto-bvaskx");
      attr(h3, "class", "svelte-auto-bvaskx");
      attr(label0, "for", "Canvas3D " + /*animation*/
      ctx[3]._data.id);
      attr(label0, "class", "svelte-auto-bvaskx");
      attr(input, "type", "checkbox");
      set_style(input, "position", "relative");
      set_style(input, "left", "-10px");
      attr(input, "id", "Canvas3D " + /*animation*/
      ctx[3]._data.id);
      attr(div0, "class", "flexrow");
      set_style(td0, "width", "20%");
      set_style(td0, "vertical-align", "bottom");
      set_style(td0, "border", "none");
      attr(label1, "for", "");
      attr(label1, "class", "svelte-auto-bvaskx");
      option.__value = "token";
      option.value = option.__value;
      if (
        /*$animation*/
        ctx[0].levels3d.type === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[10].call(select)
        ));
      attr(div1, "class", "flexcol");
      set_style(div1, "align-items", "center");
      set_style(td1, "width", "60%");
      set_style(td1, "border", "none");
      attr(td1, "class", td1_class_value = /*isEnabled*/
      ctx[1] ? "" : "aa-disableOpacity");
      set_style(td2, "width", "20%");
      set_style(td2, "border", "none");
      attr(table, "class", "c svelte-auto-bvaskx");
      attr(div2, "class", div2_class_value = "aa-section-border " + /*isEnabled*/
      (ctx[1] ? "" : "aa-disableOpacity"));
    },
    m(target2, anchor) {
      insert(target2, h1, anchor);
      insert(target2, t1, anchor);
      insert(target2, h3, anchor);
      insert(target2, t3, anchor);
      insert(target2, table, anchor);
      append(table, td0);
      append(td0, div0);
      append(div0, label0);
      append(label0, t4);
      append(div0, t5);
      append(div0, input);
      input.checked = /*$animation*/
      ctx[0].levels3d.enable;
      append(table, t6);
      append(table, td1);
      append(td1, div1);
      append(div1, label1);
      append(div1, t8);
      append(div1, select);
      append(select, option);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*$animation*/
        ctx[0].levels3d.type,
        true
      );
      append(table, t12);
      append(table, td2);
      insert(target2, t13, anchor);
      insert(target2, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t14);
      mount_component(canvas3doptions, div2, null);
      append(div2, t15);
      mount_component(soundsettings, div2, null);
      insert(target2, t16, anchor);
      if (if_block1)
        if_block1.m(target2, anchor);
      insert(target2, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[9]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[10]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$animation, Object, pEffects*/
      65) {
        input.checked = /*$animation*/
        ctx2[0].levels3d.enable;
      }
      if (dirty & /*localize, Object, pEffects*/
      64) {
        each_value = Object.keys(
          /*pEffects*/
          ctx2[6]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$animation, Object, pEffects*/
      65) {
        select_option(
          select,
          /*$animation*/
          ctx2[0].levels3d.type
        );
      }
      if (!current || dirty & /*isEnabled*/
      2 && td1_class_value !== (td1_class_value = /*isEnabled*/
      ctx2[1] ? "" : "aa-disableOpacity")) {
        attr(td1, "class", td1_class_value);
      }
      if (
        /*type*/
        ctx2[2] !== "token"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$4(ctx2);
          if_block0.c();
          if_block0.m(div2, t14);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & /*isEnabled*/
      2 && div2_class_value !== (div2_class_value = "aa-section-border " + /*isEnabled*/
      (ctx2[1] ? "" : "aa-disableOpacity"))) {
        attr(div2, "class", div2_class_value);
      }
      if (
        /*type*/
        ctx2[2] !== "token"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*type*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$a(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(canvas3doptions.$$.fragment, local);
      transition_in(soundsettings.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(canvas3doptions.$$.fragment, local);
      transition_out(soundsettings.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(table);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t13);
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      destroy_component(canvas3doptions);
      destroy_component(soundsettings);
      if (detaching)
        detach(t16);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$z($$self, $$props, $$invalidate) {
  let type;
  let isEnabled;
  let $animation;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  let pEffects = game.Levels3DPreview?.CONFIG.PARTICLE_SYSTEMS?.ALL_PARTICLE_SYSTEMS_WITHOPTS || {};
  function setSprite(type2) {
    let spritePath;
    switch (type2) {
      case "explosion":
        spritePath = "modules/levels-3d-preview/assets/particles/dust.png";
        break;
      case "sprite":
        spritePath = "modules/canvas3dcompendium/assets/Tiles/RPG%20Items/Arrow_Golden.glb";
        break;
      default:
        spritePath = "modules/levels-3d-preview/assets/particles/emberssmall.png";
    }
    set_store_value(animation, $animation.levels3d.data.spritePath = spritePath, $animation);
  }
  async function selectCustom() {
    const current = animation._data.levels3d.data.spritePath;
    const picker = new FilePicker({
      type: "any",
      current,
      callback: (path) => {
        set_store_value(animation, $animation.levels3d.data.spritePath = path, $animation);
      }
    });
    setTimeout(
      () => {
        picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
      },
      100
    );
    await picker.browse(current);
  }
  function input_change_handler() {
    $animation.levels3d.enable = this.checked;
    animation.set($animation);
    $$invalidate(6, pEffects);
  }
  function select_change_handler() {
    $animation.levels3d.type = select_value(this);
    animation.set($animation);
    $$invalidate(6, pEffects);
  }
  const change_handler = () => setSprite(animation._data.levels3d.type);
  function input_input_handler() {
    $animation.levels3d.data.spritePath = this.value;
    animation.set($animation);
    $$invalidate(6, pEffects);
  }
  const click_handler = () => selectCustom();
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(2, type = $animation.levels3d.type);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, isEnabled = $animation.levels3d.enable);
    }
  };
  return [
    $animation,
    isEnabled,
    type,
    animation,
    category,
    idx,
    pEffects,
    setSprite,
    selectCustom,
    input_change_handler,
    select_change_handler,
    change_handler,
    input_input_handler,
    click_handler
  ];
}
class Canvas3D extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$z, create_fragment$B, safe_not_equal, {});
  }
}
function create_default_slot$c(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let numberinput0;
  let t1;
  let td2;
  let numberinput1;
  let t2;
  let tr1;
  let td3;
  let opacity;
  let t3;
  let td4;
  let numberinput2;
  let t4;
  let td5;
  let numberinput3;
  let t5;
  let tr2;
  let td6;
  let numberinput4;
  let t6;
  let td7;
  let waitdelay;
  let t7;
  let td8;
  let current;
  elevation = new Elevation$1({
    props: {
      animation: (
        /*animation*/
        ctx[0]
      ),
      section: "primary"
    }
  });
  numberinput0 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[0]
      ),
      label: localize("autoanimations.menus.repeat"),
      section: "primary",
      field: "repeat"
    }
  });
  numberinput1 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[0]
      ),
      label: localize("autoanimations.menus.repeat") + " " + localize("autoanimations.menus.delay"),
      section: "primary",
      field: "repeatDelay",
      placeholder: "250"
    }
  });
  opacity = new Opacity$1({
    props: { animation: (
      /*animation*/
      ctx[0]
    ) }
  });
  numberinput2 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[0]
      ),
      label: localize("autoanimations.menus.z-index"),
      section: "primary",
      field: "zIndex"
    }
  });
  numberinput3 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[0]
      ),
      label: localize("autoanimations.menus.scale"),
      section: "primary",
      field: "size",
      step: "0.01"
    }
  });
  numberinput4 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[0]
      ),
      label: localize("autoanimations.menus.playbackRate"),
      section: "primary",
      field: "playbackRate"
    }
  });
  waitdelay = new WaitDelay({
    props: { animation: (
      /*animation*/
      ctx[0]
    ) }
  });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      create_component(numberinput0.$$.fragment);
      t1 = space();
      td2 = element("td");
      create_component(numberinput1.$$.fragment);
      t2 = space();
      tr1 = element("tr");
      td3 = element("td");
      create_component(opacity.$$.fragment);
      t3 = space();
      td4 = element("td");
      create_component(numberinput2.$$.fragment);
      t4 = space();
      td5 = element("td");
      create_component(numberinput3.$$.fragment);
      t5 = space();
      tr2 = element("tr");
      td6 = element("td");
      create_component(numberinput4.$$.fragment);
      t6 = space();
      td7 = element("td");
      create_component(waitdelay.$$.fragment);
      t7 = space();
      td8 = element("td");
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      mount_component(numberinput0, td1, null);
      append(tr0, t1);
      append(tr0, td2);
      mount_component(numberinput1, td2, null);
      append(table, t2);
      append(table, tr1);
      append(tr1, td3);
      mount_component(opacity, td3, null);
      append(tr1, t3);
      append(tr1, td4);
      mount_component(numberinput2, td4, null);
      append(tr1, t4);
      append(tr1, td5);
      mount_component(numberinput3, td5, null);
      append(table, t5);
      append(table, tr2);
      append(tr2, td6);
      mount_component(numberinput4, td6, null);
      append(tr2, t6);
      append(tr2, td7);
      mount_component(waitdelay, td7, null);
      append(tr2, t7);
      append(tr2, td8);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(numberinput4.$$.fragment, local);
      transition_in(waitdelay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(numberinput4.$$.fragment, local);
      transition_out(waitdelay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(opacity);
      destroy_component(numberinput2);
      destroy_component(numberinput3);
      destroy_component(numberinput4);
      destroy_component(waitdelay);
    }
  };
}
function create_summary_end_slot$9(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[2]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[3]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$A(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[1]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$9],
        default: [create_default_slot$c]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope*/
      16) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$y($$self) {
  let { animation } = getContext("animation-data");
  const folder = {
    label: game.i18n.localize("autoanimations.menus.options"),
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    },
    onClickPropagate: false
  };
  const click_handler = () => OptionsDialog.show("melee");
  return [animation, folder, optionsInfo, click_handler];
}
class MeleeOptions extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$y, create_fragment$A, safe_not_equal, {});
  }
}
function create_else_block$6(ctx) {
  let td;
  return {
    c() {
      td = element("td");
    },
    m(target2, anchor) {
      insert(target2, td, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_if_block$9(ctx) {
  let td;
  let div;
  let label;
  let t0_value = localize("autoanimations.menus.animation") + "";
  let t0;
  let t1;
  let t2_value = localize("autoanimations.menus.source") + "";
  let t2;
  let t3;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      td = element("td");
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      input = element("input");
      attr(label, "for", "TempSource " + /*animation*/
      ctx[3]._data.id);
      attr(input, "type", "checkbox");
      attr(input, "id", "TempSource " + /*animation*/
      ctx[3]._data.id);
    },
    m(target2, anchor) {
      insert(target2, td, anchor);
      append(td, div);
      append(div, label);
      append(label, t0);
      append(label, t1);
      append(label, t2);
      append(div, t3);
      append(div, input);
      input.checked = /*$animation*/
      ctx[0].primary.options.animationSource;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[14]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      1) {
        input.checked = /*$animation*/
        ctx2[0].primary.options.animationSource;
      }
    },
    d(detaching) {
      if (detaching)
        detach(td);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$b(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let numberinput0;
  let t1;
  let td2;
  let numberinput1;
  let t2;
  let tr1;
  let td3;
  let div0;
  let label0;
  let t3_value = localize("autoanimations.menus.only") + "";
  let t3;
  let t4;
  let t5;
  let input0;
  let div0_class_value;
  let t6;
  let td4;
  let opacity;
  let t7;
  let td5;
  let numberinput2;
  let t8;
  let tr2;
  let td6;
  let div1;
  let label1;
  let t9_value = localize("autoanimations.menus.return") + "";
  let t9;
  let t10;
  let t11_value = localize("autoanimations.menus.animation") + "";
  let t11;
  let t12;
  let input1;
  let div1_class_value;
  let t13;
  let td7;
  let div2;
  let label2;
  let t14_value = localize("autoanimations.menus.randomOffset") + "";
  let t14;
  let t15;
  let input2;
  let t16;
  let td8;
  let numberinput3;
  let t17;
  let tr3;
  let td9;
  let div3;
  let label3;
  let t18_value = localize("autoanimations.animations.reverse") + "";
  let t18;
  let t19;
  let t20_value = localize("autoanimations.menus.animation") + "";
  let t20;
  let t21;
  let input3;
  let t22;
  let td10;
  let waitdelay;
  let t23;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation$1({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      section: "primary"
    }
  });
  numberinput0 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.repeat"),
      section: "primary",
      field: "repeat"
    }
  });
  numberinput1 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.repeat") + " " + localize("autoanimations.menus.delay"),
      section: "primary",
      field: "repeatDelay",
      placeholder: "250"
    }
  });
  opacity = new Opacity$1({
    props: { animation: (
      /*animation*/
      ctx[3]
    ) }
  });
  numberinput2 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.z-index"),
      section: "primary",
      field: "zIndex"
    }
  });
  numberinput3 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.playbackRate"),
      section: "primary",
      field: "playbackRate"
    }
  });
  waitdelay = new WaitDelay({
    props: { animation: (
      /*animation*/
      ctx[3]
    ) }
  });
  function select_block_type(ctx2, dirty) {
    if (
      /*category*/
      ctx2[4].stores.animationSourceOption
    )
      return create_if_block$9;
    return create_else_block$6;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      create_component(numberinput0.$$.fragment);
      t1 = space();
      td2 = element("td");
      create_component(numberinput1.$$.fragment);
      t2 = space();
      tr1 = element("tr");
      td3 = element("td");
      div0 = element("div");
      label0 = element("label");
      t3 = text(t3_value);
      t4 = text(" X");
      t5 = space();
      input0 = element("input");
      t6 = space();
      td4 = element("td");
      create_component(opacity.$$.fragment);
      t7 = space();
      td5 = element("td");
      create_component(numberinput2.$$.fragment);
      t8 = space();
      tr2 = element("tr");
      td6 = element("td");
      div1 = element("div");
      label1 = element("label");
      t9 = text(t9_value);
      t10 = space();
      t11 = text(t11_value);
      t12 = space();
      input1 = element("input");
      t13 = space();
      td7 = element("td");
      div2 = element("div");
      label2 = element("label");
      t14 = text(t14_value);
      t15 = space();
      input2 = element("input");
      t16 = space();
      td8 = element("td");
      create_component(numberinput3.$$.fragment);
      t17 = space();
      tr3 = element("tr");
      td9 = element("td");
      div3 = element("div");
      label3 = element("label");
      t18 = text(t18_value);
      t19 = space();
      t20 = text(t20_value);
      t21 = space();
      input3 = element("input");
      t22 = space();
      td10 = element("td");
      create_component(waitdelay.$$.fragment);
      t23 = space();
      if_block.c();
      attr(label0, "for", "OnlyX " + /*animation*/
      ctx[3]._data.id);
      attr(input0, "type", "checkbox");
      attr(input0, "id", "OnlyX " + /*animation*/
      ctx[3]._data.id);
      attr(div0, "class", div0_class_value = /*isCustom*/
      ctx[1] ? "" : "aa-disableOpacity");
      attr(label1, "for", "OnlyX " + /*animation*/
      ctx[3]._data.id);
      attr(input1, "type", "checkbox");
      attr(input1, "id", "OnlyX " + /*animation*/
      ctx[3]._data.id);
      attr(div1, "class", div1_class_value = /*shouldShow*/
      ctx[2] ? "" : "aa-disableOpacity");
      attr(label2, "for", "RandomOffset " + /*animation*/
      ctx[3]._data.id);
      attr(input2, "type", "checkbox");
      attr(input2, "id", "RandomOffset " + /*animation*/
      ctx[3]._data.id);
      attr(label3, "for", "TempSource " + /*animation*/
      ctx[3]._data.id);
      attr(input3, "type", "checkbox");
      attr(input3, "id", "TempSource " + /*animation*/
      ctx[3]._data.id);
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      mount_component(numberinput0, td1, null);
      append(tr0, t1);
      append(tr0, td2);
      mount_component(numberinput1, td2, null);
      append(table, t2);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div0);
      append(div0, label0);
      append(label0, t3);
      append(label0, t4);
      append(div0, t5);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[0].primary.options.onlyX;
      append(tr1, t6);
      append(tr1, td4);
      mount_component(opacity, td4, null);
      append(tr1, t7);
      append(tr1, td5);
      mount_component(numberinput2, td5, null);
      append(table, t8);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div1);
      append(div1, label1);
      append(label1, t9);
      append(label1, t10);
      append(label1, t11);
      append(div1, t12);
      append(div1, input1);
      input1.checked = /*$animation*/
      ctx[0].primary.options.isReturning;
      append(tr2, t13);
      append(tr2, td7);
      append(td7, div2);
      append(div2, label2);
      append(label2, t14);
      append(div2, t15);
      append(div2, input2);
      input2.checked = /*$animation*/
      ctx[0].primary.options.randomOffset;
      append(tr2, t16);
      append(tr2, td8);
      mount_component(numberinput3, td8, null);
      append(table, t17);
      append(table, tr3);
      append(tr3, td9);
      append(td9, div3);
      append(div3, label3);
      append(label3, t18);
      append(label3, t19);
      append(label3, t20);
      append(div3, t21);
      append(div3, input3);
      input3.checked = /*$animation*/
      ctx[0].primary.options.reverse;
      append(tr3, t22);
      append(tr3, td10);
      mount_component(waitdelay, td10, null);
      append(tr3, t23);
      if_block.m(tr3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[10]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[11]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[12]
          ),
          listen(
            input3,
            "change",
            /*input3_change_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].primary.options.onlyX;
      }
      if (!current || dirty & /*isCustom*/
      2 && div0_class_value !== (div0_class_value = /*isCustom*/
      ctx2[1] ? "" : "aa-disableOpacity")) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input1.checked = /*$animation*/
        ctx2[0].primary.options.isReturning;
      }
      if (!current || dirty & /*shouldShow*/
      4 && div1_class_value !== (div1_class_value = /*shouldShow*/
      ctx2[2] ? "" : "aa-disableOpacity")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input2.checked = /*$animation*/
        ctx2[0].primary.options.randomOffset;
      }
      if (dirty & /*$animation*/
      1) {
        input3.checked = /*$animation*/
        ctx2[0].primary.options.reverse;
      }
      if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(waitdelay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(waitdelay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(opacity);
      destroy_component(numberinput2);
      destroy_component(numberinput3);
      destroy_component(waitdelay);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$8(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[6]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[9]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$z(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[5]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$8],
        default: [create_default_slot$b]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, shouldShow, isCustom*/
      32775) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let menuType;
  let anim;
  let shouldShow;
  let isCustom;
  let $animation;
  let { animation, category } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    label: game.i18n.localize("autoanimations.menus.options"),
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    }
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    },
    onClickPropagate: false
  };
  const click_handler = () => OptionsDialog.show("range");
  function input0_change_handler() {
    $animation.primary.options.onlyX = this.checked;
    animation.set($animation);
  }
  function input1_change_handler() {
    $animation.primary.options.isReturning = this.checked;
    animation.set($animation);
  }
  function input2_change_handler() {
    $animation.primary.options.randomOffset = this.checked;
    animation.set($animation);
  }
  function input3_change_handler() {
    $animation.primary.options.reverse = this.checked;
    animation.set($animation);
  }
  function input_change_handler() {
    $animation.primary.options.animationSource = this.checked;
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(8, menuType = $animation.primary.video.menuType);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(7, anim = $animation.primary.video.animation);
    }
    if ($$self.$$.dirty & /*menuType, anim*/
    384) {
      $$invalidate(2, shouldShow = menuType === "weapon" && aaReturnWeapons.includes(anim) ? true : false);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, isCustom = $animation.primary.video.enableCustom);
    }
  };
  return [
    $animation,
    isCustom,
    shouldShow,
    animation,
    category,
    folder,
    optionsInfo,
    anim,
    menuType,
    click_handler,
    input0_change_handler,
    input1_change_handler,
    input2_change_handler,
    input3_change_handler,
    input_change_handler
  ];
}
class RangeOptions extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$x, create_fragment$z, safe_not_equal, {});
  }
}
function create_default_slot$a(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let numberinput0;
  let t1;
  let td2;
  let numberinput1;
  let t2;
  let tr1;
  let td3;
  let label0;
  let t3_value = localize("autoanimations.menus.persistant") + "";
  let t3;
  let t4;
  let input0;
  let t5;
  let td4;
  let div0;
  let label1;
  let t6_value = localize("autoanimations.menus.bind") + "";
  let t6;
  let t7;
  let t8_value = localize("autoanimations.menus.visibility") + "";
  let t8;
  let t9;
  let input1;
  let div0_class_value;
  let t10;
  let td5;
  let div1;
  let label2;
  let t11_value = localize("autoanimations.menus.bind") + "";
  let t11;
  let t12;
  let t13_value = localize("autoanimations.menus.alpha") + "";
  let t13;
  let t14;
  let input2;
  let div1_class_value;
  let t15;
  let tr2;
  let td6;
  let div2;
  let label3;
  let t16_value = localize("autoanimations.menus.mask") + "";
  let t16;
  let t17;
  let input3;
  let t18;
  let td7;
  let opacity;
  let t19;
  let td8;
  let numberinput2;
  let t20;
  let tr3;
  let td9;
  let scaleradius;
  let t21;
  let td10;
  let div3;
  let label4;
  let t22_value = localize("autoanimations.menus.add") + "";
  let t22;
  let t23;
  let t24_value = localize("autoanimations.menus.token") + "";
  let t24;
  let t25;
  let t26_value = localize("autoanimations.menus.width") + "";
  let t26;
  let t27;
  let input4;
  let div3_class_value;
  let t28;
  let td11;
  let numberinput3;
  let t29;
  let tr4;
  let td12;
  let numberinput4;
  let t30;
  let td13;
  let div4;
  let label5;
  let t32;
  let div5;
  let input5;
  let t33;
  let td14;
  let div8;
  let div6;
  let label6;
  let t35;
  let div7;
  let select;
  let option0;
  let option1;
  let option2;
  let option3;
  let t40;
  let tr5;
  let td15;
  let numberinput5;
  let t41;
  let td16;
  let waitdelay;
  let t42;
  let td17;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation$1({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      section: "primary"
    }
  });
  numberinput0 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.repeat"),
      section: "primary",
      field: "repeat",
      isDisabled: (
        /*persistent*/
        ctx[2] ? "aa-disableOpacity" : ""
      )
    }
  });
  numberinput1 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.repeat") + " " + localize("autoanimations.menus.delay"),
      section: "primary",
      field: "repeatDelay",
      isDisabled: (
        /*persistent*/
        ctx[2] ? "aa-disableOpacity" : ""
      )
    }
  });
  opacity = new Opacity$1({
    props: { animation: (
      /*animation*/
      ctx[3]
    ) }
  });
  numberinput2 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.z-index"),
      section: "primary",
      field: "zIndex"
    }
  });
  scaleradius = new ScaleRadius$1({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      section: "primary",
      field: "size",
      step: "0.01"
    }
  });
  numberinput3 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.fadeIn"),
      section: "primary",
      field: "fadeIn",
      placeholder: "250",
      step: "0.01"
    }
  });
  numberinput4 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.fadeOut"),
      section: "primary",
      field: "fadeOut",
      placeholder: "500",
      step: "0.01"
    }
  });
  numberinput5 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[3]
      ),
      label: localize("autoanimations.menus.playbackRate"),
      section: "primary",
      field: "playbackRate"
    }
  });
  waitdelay = new WaitDelay({
    props: { animation: (
      /*animation*/
      ctx[3]
    ) }
  });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      create_component(numberinput0.$$.fragment);
      t1 = space();
      td2 = element("td");
      create_component(numberinput1.$$.fragment);
      t2 = space();
      tr1 = element("tr");
      td3 = element("td");
      label0 = element("label");
      t3 = text(t3_value);
      t4 = space();
      input0 = element("input");
      t5 = space();
      td4 = element("td");
      div0 = element("div");
      label1 = element("label");
      t6 = text(t6_value);
      t7 = space();
      t8 = text(t8_value);
      t9 = space();
      input1 = element("input");
      t10 = space();
      td5 = element("td");
      div1 = element("div");
      label2 = element("label");
      t11 = text(t11_value);
      t12 = space();
      t13 = text(t13_value);
      t14 = space();
      input2 = element("input");
      t15 = space();
      tr2 = element("tr");
      td6 = element("td");
      div2 = element("div");
      label3 = element("label");
      t16 = text(t16_value);
      t17 = space();
      input3 = element("input");
      t18 = space();
      td7 = element("td");
      create_component(opacity.$$.fragment);
      t19 = space();
      td8 = element("td");
      create_component(numberinput2.$$.fragment);
      t20 = space();
      tr3 = element("tr");
      td9 = element("td");
      create_component(scaleradius.$$.fragment);
      t21 = space();
      td10 = element("td");
      div3 = element("div");
      label4 = element("label");
      t22 = text(t22_value);
      t23 = space();
      t24 = text(t24_value);
      t25 = space();
      t26 = text(t26_value);
      t27 = space();
      input4 = element("input");
      t28 = space();
      td11 = element("td");
      create_component(numberinput3.$$.fragment);
      t29 = space();
      tr4 = element("tr");
      td12 = element("td");
      create_component(numberinput4.$$.fragment);
      t30 = space();
      td13 = element("td");
      div4 = element("div");
      label5 = element("label");
      label5.textContent = `${localize("autoanimations.menus.anchor")}`;
      t32 = space();
      div5 = element("div");
      input5 = element("input");
      t33 = space();
      td14 = element("td");
      div8 = element("div");
      div6 = element("div");
      label6 = element("label");
      label6.textContent = `${localize("autoanimations.menus.playOn")}`;
      t35 = space();
      div7 = element("div");
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.menus.source")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.menus.target")}`;
      option2 = element("option");
      option2.textContent = `${localize("autoanimations.menus.targetDefault")}`;
      option3 = element("option");
      option3.textContent = `${localize("autoanimations.menus.both")}`;
      t40 = space();
      tr5 = element("tr");
      td15 = element("td");
      create_component(numberinput5.$$.fragment);
      t41 = space();
      td16 = element("td");
      create_component(waitdelay.$$.fragment);
      t42 = space();
      td17 = element("td");
      attr(label0, "for", "Persist " + /*animation*/
      ctx[3]._data.id);
      attr(input0, "type", "checkbox");
      attr(input0, "id", "Persist " + /*animation*/
      ctx[3]._data.id);
      attr(label1, "for", "Vis " + /*animation*/
      ctx[3]._data.id);
      attr(input1, "type", "checkbox");
      attr(input1, "id", "Vis " + /*animation*/
      ctx[3]._data.id);
      attr(div0, "class", div0_class_value = /*persistent*/
      ctx[2] ? "" : "aa-disableOpacity");
      attr(label2, "for", "Alpha " + /*animation*/
      ctx[3]._data.id);
      attr(input2, "type", "checkbox");
      attr(input2, "id", "Alpha " + /*animation*/
      ctx[3]._data.id);
      attr(div1, "class", div1_class_value = /*persistent*/
      ctx[2] ? "" : "aa-disableOpacity");
      attr(label3, "for", "Masked " + /*animation*/
      ctx[3]._data.id);
      attr(input3, "type", "checkbox");
      attr(input3, "id", "Masked " + /*animation*/
      ctx[3]._data.id);
      attr(label4, "for", "Width " + /*animation*/
      ctx[3]._data.id);
      attr(input4, "type", "checkbox");
      attr(input4, "id", "Width " + /*animation*/
      ctx[3]._data.id);
      attr(div3, "class", div3_class_value = /*isRadius*/
      ctx[1] ? "" : "aa-disableOpacity");
      attr(label5, "for", "");
      attr(input5, "type", "text");
      attr(input5, "placeholder", "0.5");
      attr(label6, "for", "");
      option0.__value = "source";
      option0.value = option0.__value;
      option1.__value = "target";
      option1.value = option1.__value;
      option2.__value = "default";
      option2.value = option2.__value;
      option3.__value = "both";
      option3.value = option3.__value;
      set_style(select, "width", "90%");
      set_style(select, "height", "1em");
      if (
        /*$animation*/
        ctx[0].primary.options.playOn === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[13].call(select)
        ));
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      mount_component(numberinput0, td1, null);
      append(tr0, t1);
      append(tr0, td2);
      mount_component(numberinput1, td2, null);
      append(table, t2);
      append(table, tr1);
      append(tr1, td3);
      append(td3, label0);
      append(label0, t3);
      append(td3, t4);
      append(td3, input0);
      input0.checked = /*$animation*/
      ctx[0].primary.options.persistent;
      append(tr1, t5);
      append(tr1, td4);
      append(td4, div0);
      append(div0, label1);
      append(label1, t6);
      append(label1, t7);
      append(label1, t8);
      append(div0, t9);
      append(div0, input1);
      input1.checked = /*$animation*/
      ctx[0].primary.options.unbindVisibility;
      append(tr1, t10);
      append(tr1, td5);
      append(td5, div1);
      append(div1, label2);
      append(label2, t11);
      append(label2, t12);
      append(label2, t13);
      append(div1, t14);
      append(div1, input2);
      input2.checked = /*$animation*/
      ctx[0].primary.options.unbindAlpha;
      append(table, t15);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div2);
      append(div2, label3);
      append(label3, t16);
      append(div2, t17);
      append(div2, input3);
      input3.checked = /*$animation*/
      ctx[0].primary.options.isMasked;
      append(tr2, t18);
      append(tr2, td7);
      mount_component(opacity, td7, null);
      append(tr2, t19);
      append(tr2, td8);
      mount_component(numberinput2, td8, null);
      append(table, t20);
      append(table, tr3);
      append(tr3, td9);
      mount_component(scaleradius, td9, null);
      append(tr3, t21);
      append(tr3, td10);
      append(td10, div3);
      append(div3, label4);
      append(label4, t22);
      append(label4, t23);
      append(label4, t24);
      append(label4, t25);
      append(label4, t26);
      append(div3, t27);
      append(div3, input4);
      input4.checked = /*$animation*/
      ctx[0].primary.options.addTokenWidth;
      append(tr3, t28);
      append(tr3, td11);
      mount_component(numberinput3, td11, null);
      append(table, t29);
      append(table, tr4);
      append(tr4, td12);
      mount_component(numberinput4, td12, null);
      append(tr4, t30);
      append(tr4, td13);
      append(td13, div4);
      append(div4, label5);
      append(td13, t32);
      append(td13, div5);
      append(div5, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[0].primary.options.anchor
      );
      append(tr4, t33);
      append(tr4, td14);
      append(td14, div8);
      append(div8, div6);
      append(div6, label6);
      append(div8, t35);
      append(div8, div7);
      append(div7, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      append(select, option3);
      select_option(
        select,
        /*$animation*/
        ctx[0].primary.options.playOn,
        true
      );
      append(table, t40);
      append(table, tr5);
      append(tr5, td15);
      mount_component(numberinput5, td15, null);
      append(tr5, t41);
      append(tr5, td16);
      mount_component(waitdelay, td16, null);
      append(tr5, t42);
      append(tr5, td17);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[7]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[8]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[9]
          ),
          listen(
            input3,
            "change",
            /*input3_change_handler*/
            ctx[10]
          ),
          listen(
            input4,
            "change",
            /*input4_change_handler*/
            ctx[11]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler*/
            ctx[12]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const numberinput0_changes = {};
      if (dirty & /*persistent*/
      4)
        numberinput0_changes.isDisabled = /*persistent*/
        ctx2[2] ? "aa-disableOpacity" : "";
      numberinput0.$set(numberinput0_changes);
      const numberinput1_changes = {};
      if (dirty & /*persistent*/
      4)
        numberinput1_changes.isDisabled = /*persistent*/
        ctx2[2] ? "aa-disableOpacity" : "";
      numberinput1.$set(numberinput1_changes);
      if (dirty & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].primary.options.persistent;
      }
      if (dirty & /*$animation*/
      1) {
        input1.checked = /*$animation*/
        ctx2[0].primary.options.unbindVisibility;
      }
      if (!current || dirty & /*persistent*/
      4 && div0_class_value !== (div0_class_value = /*persistent*/
      ctx2[2] ? "" : "aa-disableOpacity")) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input2.checked = /*$animation*/
        ctx2[0].primary.options.unbindAlpha;
      }
      if (!current || dirty & /*persistent*/
      4 && div1_class_value !== (div1_class_value = /*persistent*/
      ctx2[2] ? "" : "aa-disableOpacity")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*$animation*/
      1) {
        input3.checked = /*$animation*/
        ctx2[0].primary.options.isMasked;
      }
      if (dirty & /*$animation*/
      1) {
        input4.checked = /*$animation*/
        ctx2[0].primary.options.addTokenWidth;
      }
      if (!current || dirty & /*isRadius*/
      2 && div3_class_value !== (div3_class_value = /*isRadius*/
      ctx2[1] ? "" : "aa-disableOpacity")) {
        attr(div3, "class", div3_class_value);
      }
      if (dirty & /*$animation*/
      1 && input5.value !== /*$animation*/
      ctx2[0].primary.options.anchor) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[0].primary.options.anchor
        );
      }
      if (dirty & /*$animation*/
      1) {
        select_option(
          select,
          /*$animation*/
          ctx2[0].primary.options.playOn
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(scaleradius.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(numberinput4.$$.fragment, local);
      transition_in(numberinput5.$$.fragment, local);
      transition_in(waitdelay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(scaleradius.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(numberinput4.$$.fragment, local);
      transition_out(numberinput5.$$.fragment, local);
      transition_out(waitdelay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(opacity);
      destroy_component(numberinput2);
      destroy_component(scaleradius);
      destroy_component(numberinput3);
      destroy_component(numberinput4);
      destroy_component(numberinput5);
      destroy_component(waitdelay);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$7(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[5]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[6]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$y(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[4]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$7],
        default: [create_default_slot$a]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, isRadius, persistent*/
      16391) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  let persistent;
  let isRadius;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    },
    label: game.i18n.localize("autoanimations.menus.options")
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    },
    onClickPropagate: false
  };
  const click_handler = () => OptionsDialog.show("ontoken");
  function input0_change_handler() {
    $animation.primary.options.persistent = this.checked;
    animation.set($animation);
  }
  function input1_change_handler() {
    $animation.primary.options.unbindVisibility = this.checked;
    animation.set($animation);
  }
  function input2_change_handler() {
    $animation.primary.options.unbindAlpha = this.checked;
    animation.set($animation);
  }
  function input3_change_handler() {
    $animation.primary.options.isMasked = this.checked;
    animation.set($animation);
  }
  function input4_change_handler() {
    $animation.primary.options.addTokenWidth = this.checked;
    animation.set($animation);
  }
  function input5_input_handler() {
    $animation.primary.options.anchor = this.value;
    animation.set($animation);
  }
  function select_change_handler() {
    $animation.primary.options.playOn = select_value(this);
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(2, persistent = $animation.primary.options.persistent);
    }
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, isRadius = $animation.primary.options.isRadius);
    }
  };
  return [
    $animation,
    isRadius,
    persistent,
    animation,
    folder,
    optionsInfo,
    click_handler,
    input0_change_handler,
    input1_change_handler,
    input2_change_handler,
    input3_change_handler,
    input4_change_handler,
    input5_input_handler,
    select_change_handler
  ];
}
class OnTokenOptions extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$w, create_fragment$y, safe_not_equal, {});
  }
}
function create_if_block_1$3(ctx) {
  let option0;
  let option1;
  return {
    c() {
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.menus.overheadtile")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.menus.groundtile")}`;
      option0.__value = "overheadtile";
      option0.value = option0.__value;
      option1.__value = "groundtile";
      option1.value = option1.__value;
    },
    m(target2, anchor) {
      insert(target2, option0, anchor);
      insert(target2, option1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option0);
      if (detaching)
        detach(option1);
    }
  };
}
function create_if_block$8(ctx) {
  let tr;
  let td0;
  let div0;
  let label0;
  let t1;
  let select;
  let option0;
  let option1;
  let option2;
  let option3;
  let t6;
  let td1;
  let div2;
  let label1;
  let t8;
  let div1;
  let input0;
  let t9;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.occlusionMode")}`;
      t1 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.menus.occlusion03")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.menus.occlusion01")}`;
      option2 = element("option");
      option2.textContent = `${localize("autoanimations.menus.occlusion02")}`;
      option3 = element("option");
      option3.textContent = `${localize("autoanimations.menus.occlusion00")}`;
      t6 = space();
      td1 = element("td");
      div2 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.occlusionAlpha")}`;
      t8 = space();
      div1 = element("div");
      input0 = element("input");
      t9 = space();
      input1 = element("input");
      attr(label0, "for", "");
      option0.__value = "3";
      option0.value = option0.__value;
      option1.__value = "1";
      option1.value = option1.__value;
      option2.__value = "2";
      option2.value = option2.__value;
      option3.__value = "0";
      option3.value = option3.__value;
      set_style(select, "text-align", "center");
      set_style(select, "align-self", "center");
      set_style(select, "width", "13em");
      if (
        /*$animation*/
        ctx[2].primary.options.occlusionMode === void 0
      )
        add_render_callback(() => (
          /*select_change_handler_1*/
          ctx[18].call(select)
        ));
      attr(div0, "class", "flexcol");
      attr(label1, "for", "aaOpacity");
      attr(input0, "type", "number");
      attr(input0, "id", "aaOpacity");
      attr(input0, "placeholder", "1");
      attr(input0, "min", "0");
      attr(input0, "max", "1");
      attr(input0, "step", "0.01");
      set_style(input1, "border", "none");
      set_style(input1, "background", "none");
      set_style(input1, "margin-left", "3px");
      attr(input1, "type", "range");
      attr(input1, "min", "0");
      attr(input1, "max", "1");
      attr(input1, "step", "0.01");
      set_style(div1, "display", "flex");
      set_style(div1, "margin-right", "2em");
      set_style(div1, "margin-left", "2em");
      attr(div2, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, tr, anchor);
      append(tr, td0);
      append(td0, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      append(select, option3);
      select_option(
        select,
        /*$animation*/
        ctx[2].primary.options.occlusionMode,
        true
      );
      append(tr, t6);
      append(tr, td1);
      append(td1, div2);
      append(div2, label1);
      append(div2, t8);
      append(div2, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[2].primary.options.occlusionAlpha
      );
      append(div1, t9);
      append(div1, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[2].primary.options.occlusionAlpha
      );
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler_1*/
            ctx[18]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[19]
          ),
          listen(
            input1,
            "change",
            /*input1_change_input_handler*/
            ctx[20]
          ),
          listen(
            input1,
            "input",
            /*input1_change_input_handler*/
            ctx[20]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      4) {
        select_option(
          select,
          /*$animation*/
          ctx2[2].primary.options.occlusionMode
        );
      }
      if (dirty & /*$animation*/
      4 && to_number(input0.value) !== /*$animation*/
      ctx2[2].primary.options.occlusionAlpha) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[2].primary.options.occlusionAlpha
        );
      }
      if (dirty & /*$animation*/
      4) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[2].primary.options.occlusionAlpha
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$9(ctx) {
  let table0;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let numberinput0;
  let t1;
  let td2;
  let numberinput1;
  let t2;
  let tr1;
  let td3;
  let div0;
  let label0;
  let t3_value = localize("autoanimations.menus.mask") + "";
  let t3;
  let t4;
  let input0;
  let t5;
  let td4;
  let div1;
  let label1;
  let t7;
  let div2;
  let input1;
  let t8;
  let td5;
  let div3;
  let label2;
  let t9_value = localize("autoanimations.menus.remove") + "";
  let t9;
  let t10;
  let input2;
  let td5_class_value;
  let t11;
  let tr2;
  let td6;
  let opacity;
  let t12;
  let td7;
  let numberinput2;
  let t13;
  let td8;
  let numberinput3;
  let t14;
  let tr3;
  let td9;
  let numberinput4;
  let t15;
  let td10;
  let div4;
  let label3;
  let t16_value = localize("autoanimations.variants.above") + "";
  let t16;
  let t17;
  let t18_value = localize("autoanimations.animTypes.templatefx") + "";
  let t18;
  let t19;
  let input3;
  let t20;
  let td11;
  let div5;
  let label4;
  let t22;
  let div6;
  let input4;
  let t23;
  let tr4;
  let td12;
  let t24;
  let td13;
  let waitdelay;
  let t25;
  let td14;
  let t26;
  let table1;
  let tr5;
  let td15;
  let div7;
  let label5;
  let t27_value = localize("autoanimations.menus.persistant") + "";
  let t27;
  let t28;
  let input5;
  let t29;
  let td16;
  let div10;
  let div8;
  let label6;
  let t33;
  let div9;
  let select;
  let option0;
  let option1;
  let div10_class_value;
  let t36;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation$1({
    props: {
      animation: (
        /*animation*/
        ctx[6]
      ),
      section: "primary"
    }
  });
  numberinput0 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[6]
      ),
      label: localize("autoanimations.menus.repeat"),
      section: "primary",
      field: "repeat",
      isDisabled: (
        /*persistent*/
        ctx[1] ? "aa-disableOpacity" : ""
      )
    }
  });
  numberinput1 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[6]
      ),
      label: localize("autoanimations.menus.repeat") + " " + localize("autoanimations.menus.delay"),
      section: "primary",
      field: "repeatDelay",
      isDisabled: (
        /*persistent*/
        ctx[1] ? "aa-disableOpacity" : ""
      )
    }
  });
  opacity = new Opacity$1({
    props: { animation: (
      /*animation*/
      ctx[6]
    ) }
  });
  numberinput2 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[6]
      ),
      label: localize("autoanimations.menus.z-index"),
      section: "primary",
      field: "zIndex"
    }
  });
  numberinput3 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[6]
      ),
      label: "Adjust Rotation",
      section: "primary",
      field: "rotate",
      placeholder: "0"
    }
  });
  numberinput4 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[6]
      ),
      label: localize("autoanimations.menus.playbackRate"),
      section: "primary",
      field: "playbackRate"
    }
  });
  waitdelay = new WaitDelay({
    props: { animation: (
      /*animation*/
      ctx[6]
    ) }
  });
  let if_block0 = (
    /*currentType*/
    (ctx[5] === "circle" || /*currentType*/
    ctx[5] === "square") && create_if_block_1$3()
  );
  let if_block1 = (
    /*persistType*/
    ctx[0] === "overheadtile" && /*persistent*/
    ctx[1] && create_if_block$8(ctx)
  );
  return {
    c() {
      table0 = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      create_component(numberinput0.$$.fragment);
      t1 = space();
      td2 = element("td");
      create_component(numberinput1.$$.fragment);
      t2 = space();
      tr1 = element("tr");
      td3 = element("td");
      div0 = element("div");
      label0 = element("label");
      t3 = text(t3_value);
      t4 = space();
      input0 = element("input");
      t5 = space();
      td4 = element("td");
      div1 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.scale")}`;
      t7 = space();
      div2 = element("div");
      input1 = element("input");
      t8 = space();
      td5 = element("td");
      div3 = element("div");
      label2 = element("label");
      t9 = text(t9_value);
      t10 = space();
      input2 = element("input");
      t11 = space();
      tr2 = element("tr");
      td6 = element("td");
      create_component(opacity.$$.fragment);
      t12 = space();
      td7 = element("td");
      create_component(numberinput2.$$.fragment);
      t13 = space();
      td8 = element("td");
      create_component(numberinput3.$$.fragment);
      t14 = space();
      tr3 = element("tr");
      td9 = element("td");
      create_component(numberinput4.$$.fragment);
      t15 = space();
      td10 = element("td");
      div4 = element("div");
      label3 = element("label");
      t16 = text(t16_value);
      t17 = space();
      t18 = text(t18_value);
      t19 = space();
      input3 = element("input");
      t20 = space();
      td11 = element("td");
      div5 = element("div");
      label4 = element("label");
      label4.textContent = `${localize("autoanimations.menus.anchor")}`;
      t22 = space();
      div6 = element("div");
      input4 = element("input");
      t23 = space();
      tr4 = element("tr");
      td12 = element("td");
      t24 = space();
      td13 = element("td");
      create_component(waitdelay.$$.fragment);
      t25 = space();
      td14 = element("td");
      t26 = space();
      table1 = element("table");
      tr5 = element("tr");
      td15 = element("td");
      div7 = element("div");
      label5 = element("label");
      t27 = text(t27_value);
      t28 = space();
      input5 = element("input");
      t29 = space();
      td16 = element("td");
      div10 = element("div");
      div8 = element("div");
      label6 = element("label");
      label6.textContent = `${localize("autoanimations.menus.persistant")} 
                            ${localize("autoanimations.menus.type")}`;
      t33 = space();
      div9 = element("div");
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.menus.sequencereffect")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.menus.attachtotemplate")}`;
      if (if_block0)
        if_block0.c();
      t36 = space();
      if (if_block1)
        if_block1.c();
      attr(label0, "for", "Masked " + /*animation*/
      ctx[6]._data.id);
      attr(input0, "type", "checkbox");
      attr(input0, "id", "Masked " + /*animation*/
      ctx[6]._data.id);
      attr(label1, "for", "");
      attr(input1, "type", "text");
      attr(input1, "placeholder", "1");
      attr(label2, "for", "Remove " + /*animation*/
      ctx[6]._data.id);
      attr(input2, "type", "checkbox");
      attr(input2, "id", "Remove " + /*animation*/
      ctx[6]._data.id);
      attr(td5, "class", td5_class_value = /*isAttached*/
      ctx[4] ? "aa-disableOpacity" : "");
      attr(label3, "for", "aboveTemplate " + /*animation*/
      ctx[6]._data.id);
      attr(input3, "type", "checkbox");
      attr(input3, "id", "aboveTemplate " + /*animation*/
      ctx[6]._data.id);
      attr(label4, "for", "");
      attr(input4, "type", "text");
      attr(
        input4,
        "placeholder",
        /*defaultAnchor*/
        ctx[3]
      );
      attr(table0, "class", "d");
      attr(label5, "for", "Persist " + /*animation*/
      ctx[6]._data.id);
      attr(input5, "type", "checkbox");
      attr(input5, "id", "Persist " + /*animation*/
      ctx[6]._data.id);
      attr(label6, "for", "");
      option0.__value = "sequencerground";
      option0.value = option0.__value;
      option1.__value = "attachtemplate";
      option1.value = option1.__value;
      set_style(select, "width", "11em");
      set_style(select, "height", "1em");
      if (
        /*$animation*/
        ctx[2].primary.options.persistType === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[17].call(select)
        ));
      attr(div10, "class", div10_class_value = !/*persistent*/
      ctx[1] ? "aa-disableOpacity" : "");
      attr(table1, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table0, anchor);
      append(table0, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      mount_component(numberinput0, td1, null);
      append(tr0, t1);
      append(tr0, td2);
      mount_component(numberinput1, td2, null);
      append(table0, t2);
      append(table0, tr1);
      append(tr1, td3);
      append(td3, div0);
      append(div0, label0);
      append(label0, t3);
      append(div0, t4);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[2].primary.options.isMasked;
      append(tr1, t5);
      append(tr1, td4);
      append(td4, div1);
      append(div1, label1);
      append(td4, t7);
      append(td4, div2);
      append(div2, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[2].primary.options.scale
      );
      append(tr1, t8);
      append(tr1, td5);
      append(td5, div3);
      append(div3, label2);
      append(label2, t9);
      append(div3, t10);
      append(div3, input2);
      input2.checked = /*$animation*/
      ctx[2].primary.options.removeTemplate;
      append(table0, t11);
      append(table0, tr2);
      append(tr2, td6);
      mount_component(opacity, td6, null);
      append(tr2, t12);
      append(tr2, td7);
      mount_component(numberinput2, td7, null);
      append(tr2, t13);
      append(tr2, td8);
      mount_component(numberinput3, td8, null);
      append(table0, t14);
      append(table0, tr3);
      append(tr3, td9);
      mount_component(numberinput4, td9, null);
      append(tr3, t15);
      append(tr3, td10);
      append(td10, div4);
      append(div4, label3);
      append(label3, t16);
      append(label3, t17);
      append(label3, t18);
      append(div4, t19);
      append(div4, input3);
      input3.checked = /*$animation*/
      ctx[2].primary.options.aboveTemplate;
      append(tr3, t20);
      append(tr3, td11);
      append(td11, div5);
      append(div5, label4);
      append(td11, t22);
      append(td11, div6);
      append(div6, input4);
      set_input_value(
        input4,
        /*$animation*/
        ctx[2].primary.options.anchor
      );
      append(table0, t23);
      append(table0, tr4);
      append(tr4, td12);
      append(tr4, t24);
      append(tr4, td13);
      mount_component(waitdelay, td13, null);
      append(tr4, t25);
      append(tr4, td14);
      insert(target2, t26, anchor);
      insert(target2, table1, anchor);
      append(table1, tr5);
      append(tr5, td15);
      append(td15, div7);
      append(div7, label5);
      append(label5, t27);
      append(div7, t28);
      append(div7, input5);
      input5.checked = /*$animation*/
      ctx[2].primary.options.persistent;
      append(tr5, t29);
      append(tr5, td16);
      append(td16, div10);
      append(div10, div8);
      append(div8, label6);
      append(div10, t33);
      append(div10, div9);
      append(div9, select);
      append(select, option0);
      append(select, option1);
      if (if_block0)
        if_block0.m(select, null);
      select_option(
        select,
        /*$animation*/
        ctx[2].primary.options.persistType,
        true
      );
      append(table1, t36);
      if (if_block1)
        if_block1.m(table1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[11]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[12]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[13]
          ),
          listen(
            input3,
            "change",
            /*input3_change_handler*/
            ctx[14]
          ),
          listen(
            input4,
            "input",
            /*input4_input_handler*/
            ctx[15]
          ),
          listen(
            input5,
            "change",
            /*input5_change_handler*/
            ctx[16]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[17]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const numberinput0_changes = {};
      if (dirty & /*persistent*/
      2)
        numberinput0_changes.isDisabled = /*persistent*/
        ctx2[1] ? "aa-disableOpacity" : "";
      numberinput0.$set(numberinput0_changes);
      const numberinput1_changes = {};
      if (dirty & /*persistent*/
      2)
        numberinput1_changes.isDisabled = /*persistent*/
        ctx2[1] ? "aa-disableOpacity" : "";
      numberinput1.$set(numberinput1_changes);
      if (dirty & /*$animation*/
      4) {
        input0.checked = /*$animation*/
        ctx2[2].primary.options.isMasked;
      }
      if (dirty & /*$animation*/
      4 && input1.value !== /*$animation*/
      ctx2[2].primary.options.scale) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[2].primary.options.scale
        );
      }
      if (dirty & /*$animation*/
      4) {
        input2.checked = /*$animation*/
        ctx2[2].primary.options.removeTemplate;
      }
      if (!current || dirty & /*isAttached*/
      16 && td5_class_value !== (td5_class_value = /*isAttached*/
      ctx2[4] ? "aa-disableOpacity" : "")) {
        attr(td5, "class", td5_class_value);
      }
      if (dirty & /*$animation*/
      4) {
        input3.checked = /*$animation*/
        ctx2[2].primary.options.aboveTemplate;
      }
      if (!current || dirty & /*defaultAnchor*/
      8) {
        attr(
          input4,
          "placeholder",
          /*defaultAnchor*/
          ctx2[3]
        );
      }
      if (dirty & /*$animation*/
      4 && input4.value !== /*$animation*/
      ctx2[2].primary.options.anchor) {
        set_input_value(
          input4,
          /*$animation*/
          ctx2[2].primary.options.anchor
        );
      }
      if (dirty & /*$animation*/
      4) {
        input5.checked = /*$animation*/
        ctx2[2].primary.options.persistent;
      }
      if (
        /*currentType*/
        ctx2[5] === "circle" || /*currentType*/
        ctx2[5] === "square"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$3();
          if_block0.c();
          if_block0.m(select, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*$animation*/
      4) {
        select_option(
          select,
          /*$animation*/
          ctx2[2].primary.options.persistType
        );
      }
      if (!current || dirty & /*persistent*/
      2 && div10_class_value !== (div10_class_value = !/*persistent*/
      ctx2[1] ? "aa-disableOpacity" : "")) {
        attr(div10, "class", div10_class_value);
      }
      if (
        /*persistType*/
        ctx2[0] === "overheadtile" && /*persistent*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$8(ctx2);
          if_block1.c();
          if_block1.m(table1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(numberinput4.$$.fragment, local);
      transition_in(waitdelay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(numberinput4.$$.fragment, local);
      transition_out(waitdelay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table0);
      destroy_component(elevation);
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(opacity);
      destroy_component(numberinput2);
      destroy_component(numberinput3);
      destroy_component(numberinput4);
      destroy_component(waitdelay);
      if (detaching)
        detach(t26);
      if (detaching)
        detach(table1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$6(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[8]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$x(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[7]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$6],
        default: [create_default_slot$9]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation, persistType, persistent, currentType, defaultAnchor, isAttached*/
      2097215) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let persistent;
  let currentType;
  let persistType;
  let isAttached;
  let menuType;
  let defaultAnchor;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(2, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    },
    label: game.i18n.localize("autoanimations.menus.options")
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    },
    onClickPropagate: false
  };
  const click_handler = () => OptionsDialog.show("templatefx");
  function input0_change_handler() {
    $animation.primary.options.isMasked = this.checked;
    animation.set($animation);
  }
  function input1_input_handler() {
    $animation.primary.options.scale = this.value;
    animation.set($animation);
  }
  function input2_change_handler() {
    $animation.primary.options.removeTemplate = this.checked;
    animation.set($animation);
  }
  function input3_change_handler() {
    $animation.primary.options.aboveTemplate = this.checked;
    animation.set($animation);
  }
  function input4_input_handler() {
    $animation.primary.options.anchor = this.value;
    animation.set($animation);
  }
  function input5_change_handler() {
    $animation.primary.options.persistent = this.checked;
    animation.set($animation);
  }
  function select_change_handler() {
    $animation.primary.options.persistType = select_value(this);
    animation.set($animation);
  }
  function select_change_handler_1() {
    $animation.primary.options.occlusionMode = select_value(this);
    animation.set($animation);
  }
  function input0_input_handler() {
    $animation.primary.options.occlusionAlpha = to_number(this.value);
    animation.set($animation);
  }
  function input1_change_input_handler() {
    $animation.primary.options.occlusionAlpha = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(1, persistent = $animation.primary.options.persistent);
    }
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(5, currentType = $animation.primary.video.menuType);
    }
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(0, persistType = $animation.primary.options.persistType);
    }
    if ($$self.$$.dirty & /*persistent, persistType*/
    3) {
      $$invalidate(4, isAttached = persistent && persistType === "attachtemplate");
    }
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(9, menuType = $animation.primary.video.menuType);
    }
    if ($$self.$$.dirty & /*menuType*/
    512) {
      $$invalidate(3, defaultAnchor = menuType === "cone" || menuType === "ray" ? "0, 0.5" : "0.5, 0.5");
    }
  };
  return [
    persistType,
    persistent,
    $animation,
    defaultAnchor,
    isAttached,
    currentType,
    animation,
    folder,
    optionsInfo,
    menuType,
    click_handler,
    input0_change_handler,
    input1_input_handler,
    input2_change_handler,
    input3_change_handler,
    input4_input_handler,
    input5_change_handler,
    select_change_handler,
    select_change_handler_1,
    input0_input_handler,
    input1_change_input_handler
  ];
}
class TemplateOptions extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$v, create_fragment$x, safe_not_equal, {});
  }
}
function create_default_slot$8(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let div0;
  let label0;
  let t1_value = localize("autoanimations.menus.bind") + "";
  let t1;
  let t2;
  let t3_value = localize("autoanimations.menus.visibility") + "";
  let t3;
  let t4;
  let input0;
  let t5;
  let td2;
  let div1;
  let label1;
  let t6_value = localize("autoanimations.menus.bind") + "";
  let t6;
  let t7;
  let t8_value = localize("autoanimations.menus.alpha") + "";
  let t8;
  let t9;
  let input1;
  let t10;
  let tr1;
  let td3;
  let opacity;
  let t11;
  let td4;
  let numberinput0;
  let t12;
  let td5;
  let div4;
  let div2;
  let label2;
  let t14;
  let div3;
  let select;
  let option0;
  let option1;
  let option2;
  let option3;
  let t19;
  let tr2;
  let td6;
  let numberinput1;
  let t20;
  let td7;
  let div5;
  let label3;
  let t21_value = localize("autoanimations.menus.add") + "";
  let t21;
  let t22;
  let t23_value = localize("autoanimations.menus.token") + "";
  let t23;
  let t24;
  let t25_value = localize("autoanimations.menus.width") + "";
  let t25;
  let t26;
  let input2;
  let t27;
  let td8;
  let numberinput2;
  let t28;
  let tr3;
  let td9;
  let numberinput3;
  let t29;
  let td10;
  let waitdelay;
  let t30;
  let td11;
  let numberinput4;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation$1({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      section: "primary"
    }
  });
  opacity = new Opacity$1({
    props: { animation: (
      /*animation*/
      ctx[1]
    ) }
  });
  numberinput0 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      label: localize("autoanimations.menus.z-index"),
      section: "primary",
      field: "zIndex",
      step: "1"
    }
  });
  numberinput1 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      label: localize("autoanimations.menus.radius"),
      section: "primary",
      field: "size",
      step: "0.01"
    }
  });
  numberinput2 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      label: localize("autoanimations.menus.fadeIn"),
      section: "primary",
      field: "fadeIn",
      step: "1"
    }
  });
  numberinput3 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      label: localize("autoanimations.menus.fadeOut"),
      section: "primary",
      field: "fadeOut",
      step: "1"
    }
  });
  waitdelay = new WaitDelay({
    props: { animation: (
      /*animation*/
      ctx[1]
    ) }
  });
  numberinput4 = new NumberInput({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      label: localize("autoanimations.menus.playbackRate"),
      section: "primary",
      field: "playbackRate"
    }
  });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      div0 = element("div");
      label0 = element("label");
      t1 = text(t1_value);
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      input0 = element("input");
      t5 = space();
      td2 = element("td");
      div1 = element("div");
      label1 = element("label");
      t6 = text(t6_value);
      t7 = space();
      t8 = text(t8_value);
      t9 = space();
      input1 = element("input");
      t10 = space();
      tr1 = element("tr");
      td3 = element("td");
      create_component(opacity.$$.fragment);
      t11 = space();
      td4 = element("td");
      create_component(numberinput0.$$.fragment);
      t12 = space();
      td5 = element("td");
      div4 = element("div");
      div2 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.playOn")}`;
      t14 = space();
      div3 = element("div");
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.menus.source")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.menus.target")}`;
      option2 = element("option");
      option2.textContent = `${localize("autoanimations.menus.targetDefault")}`;
      option3 = element("option");
      option3.textContent = `${localize("autoanimations.menus.both")}`;
      t19 = space();
      tr2 = element("tr");
      td6 = element("td");
      create_component(numberinput1.$$.fragment);
      t20 = space();
      td7 = element("td");
      div5 = element("div");
      label3 = element("label");
      t21 = text(t21_value);
      t22 = space();
      t23 = text(t23_value);
      t24 = space();
      t25 = text(t25_value);
      t26 = space();
      input2 = element("input");
      t27 = space();
      td8 = element("td");
      create_component(numberinput2.$$.fragment);
      t28 = space();
      tr3 = element("tr");
      td9 = element("td");
      create_component(numberinput3.$$.fragment);
      t29 = space();
      td10 = element("td");
      create_component(waitdelay.$$.fragment);
      t30 = space();
      td11 = element("td");
      create_component(numberinput4.$$.fragment);
      attr(label0, "for", "Vis " + /*animation*/
      ctx[1]._data.id);
      attr(input0, "type", "checkbox");
      attr(input0, "id", "Vis " + /*animation*/
      ctx[1]._data.id);
      attr(label1, "for", "Alpha " + /*animation*/
      ctx[1]._data.id);
      attr(input1, "type", "checkbox");
      attr(input1, "id", "Alpha " + /*animation*/
      ctx[1]._data.id);
      attr(label2, "for", "");
      option0.__value = "source";
      option0.value = option0.__value;
      option1.__value = "target";
      option1.value = option1.__value;
      option2.__value = "default";
      option2.value = option2.__value;
      option3.__value = "both";
      option3.value = option3.__value;
      set_style(select, "width", "90%");
      set_style(select, "height", "1em");
      if (
        /*$animation*/
        ctx[0].primary.options.playOn === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[7].call(select)
        ));
      attr(label3, "for", "Width " + /*animation*/
      ctx[1]._data.id);
      attr(input2, "type", "checkbox");
      attr(input2, "id", "Width " + /*animation*/
      ctx[1]._data.id);
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      append(td1, div0);
      append(div0, label0);
      append(label0, t1);
      append(label0, t2);
      append(label0, t3);
      append(div0, t4);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[0].primary.options.unbindVisibility;
      append(tr0, t5);
      append(tr0, td2);
      append(td2, div1);
      append(div1, label1);
      append(label1, t6);
      append(label1, t7);
      append(label1, t8);
      append(div1, t9);
      append(div1, input1);
      input1.checked = /*$animation*/
      ctx[0].primary.options.unbindAlpha;
      append(table, t10);
      append(table, tr1);
      append(tr1, td3);
      mount_component(opacity, td3, null);
      append(tr1, t11);
      append(tr1, td4);
      mount_component(numberinput0, td4, null);
      append(tr1, t12);
      append(tr1, td5);
      append(td5, div4);
      append(div4, div2);
      append(div2, label2);
      append(div4, t14);
      append(div4, div3);
      append(div3, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      append(select, option3);
      select_option(
        select,
        /*$animation*/
        ctx[0].primary.options.playOn,
        true
      );
      append(table, t19);
      append(table, tr2);
      append(tr2, td6);
      mount_component(numberinput1, td6, null);
      append(tr2, t20);
      append(tr2, td7);
      append(td7, div5);
      append(div5, label3);
      append(label3, t21);
      append(label3, t22);
      append(label3, t23);
      append(label3, t24);
      append(label3, t25);
      append(div5, t26);
      append(div5, input2);
      input2.checked = /*$animation*/
      ctx[0].primary.options.addTokenWidth;
      append(tr2, t27);
      append(tr2, td8);
      mount_component(numberinput2, td8, null);
      append(table, t28);
      append(table, tr3);
      append(tr3, td9);
      mount_component(numberinput3, td9, null);
      append(tr3, t29);
      append(tr3, td10);
      mount_component(waitdelay, td10, null);
      append(tr3, t30);
      append(tr3, td11);
      mount_component(numberinput4, td11, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[5]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[6]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[7]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].primary.options.unbindVisibility;
      }
      if (dirty & /*$animation*/
      1) {
        input1.checked = /*$animation*/
        ctx2[0].primary.options.unbindAlpha;
      }
      if (dirty & /*$animation*/
      1) {
        select_option(
          select,
          /*$animation*/
          ctx2[0].primary.options.playOn
        );
      }
      if (dirty & /*$animation*/
      1) {
        input2.checked = /*$animation*/
        ctx2[0].primary.options.addTokenWidth;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(waitdelay.$$.fragment, local);
      transition_in(numberinput4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(waitdelay.$$.fragment, local);
      transition_out(numberinput4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(opacity);
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(numberinput2);
      destroy_component(numberinput3);
      destroy_component(waitdelay);
      destroy_component(numberinput4);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$5(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[3]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[4]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$w(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[2]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$5],
        default: [create_default_slot$8]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "aa-options-border");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation*/
      513) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    },
    label: game.i18n.localize("autoanimations.menus.options")
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    },
    onClickPropagate: false
  };
  const click_handler = () => OptionsDialog.show("aura");
  function input0_change_handler() {
    $animation.primary.options.unbindVisibility = this.checked;
    animation.set($animation);
  }
  function input1_change_handler() {
    $animation.primary.options.unbindAlpha = this.checked;
    animation.set($animation);
  }
  function select_change_handler() {
    $animation.primary.options.playOn = select_value(this);
    animation.set($animation);
  }
  function input2_change_handler() {
    $animation.primary.options.addTokenWidth = this.checked;
    animation.set($animation);
  }
  return [
    $animation,
    animation,
    folder,
    optionsInfo,
    click_handler,
    input0_change_handler,
    input1_change_handler,
    select_change_handler,
    input2_change_handler
  ];
}
class AuraOptions extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$u, create_fragment$w, safe_not_equal, {});
  }
}
function create_else_block$5(ctx) {
  let div0;
  let switch_instance0;
  let div0_hidden_value;
  let t0;
  let div1;
  let switch_instance1;
  let div1_hidden_value;
  let t1;
  let div3;
  let switch_instance2;
  let t2;
  let div2;
  let switch_instance3;
  let t3;
  let switch_instance4;
  let t4;
  let switch_instance5;
  let t5;
  let switch_instance6;
  let t6;
  let switch_instance7;
  let t7;
  let switch_instance8;
  let t8;
  let switch_instance9;
  let div3_hidden_value;
  let current;
  var switch_value = SoundOnly;
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props());
  }
  var switch_value_1 = Macro$1;
  function switch_props_1(ctx2) {
    return {};
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
  }
  var switch_value_2 = ExtraSource;
  function switch_props_2(ctx2) {
    return {};
  }
  if (switch_value_2) {
    switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2());
  }
  var switch_value_3 = VideoSelect;
  function switch_props_3(ctx2) {
    return {
      props: {
        title: (
          /*title*/
          ctx2[6]
        ),
        section: "primary"
      }
    };
  }
  if (switch_value_3) {
    switch_instance3 = construct_svelte_component(switch_value_3, switch_props_3(ctx));
  }
  var switch_value_4 = MeleeOptions;
  function switch_props_4(ctx2) {
    return {};
  }
  if (switch_value_4) {
    switch_instance4 = construct_svelte_component(switch_value_4, switch_props_4());
  }
  var switch_value_5 = EffectColor;
  function switch_props_5(ctx2) {
    return {};
  }
  if (switch_value_5) {
    switch_instance5 = construct_svelte_component(switch_value_5, switch_props_5());
  }
  var switch_value_6 = SoundSettings;
  function switch_props_6(ctx2) {
    return { props: { section: "primary" } };
  }
  if (switch_value_6) {
    switch_instance6 = construct_svelte_component(switch_value_6, switch_props_6());
  }
  var switch_value_7 = MeleeSwitch;
  function switch_props_7(ctx2) {
    return {};
  }
  if (switch_value_7) {
    switch_instance7 = construct_svelte_component(switch_value_7, switch_props_7());
  }
  var switch_value_8 = Secondary;
  function switch_props_8(ctx2) {
    return {};
  }
  if (switch_value_8) {
    switch_instance8 = construct_svelte_component(switch_value_8, switch_props_8());
  }
  var switch_value_9 = ExtraTarget;
  function switch_props_9(ctx2) {
    return {};
  }
  if (switch_value_9) {
    switch_instance9 = construct_svelte_component(switch_value_9, switch_props_9());
  }
  return {
    c() {
      div0 = element("div");
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t0 = space();
      div1 = element("div");
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      t1 = space();
      div3 = element("div");
      if (switch_instance2)
        create_component(switch_instance2.$$.fragment);
      t2 = space();
      div2 = element("div");
      if (switch_instance3)
        create_component(switch_instance3.$$.fragment);
      t3 = space();
      if (switch_instance4)
        create_component(switch_instance4.$$.fragment);
      t4 = space();
      if (switch_instance5)
        create_component(switch_instance5.$$.fragment);
      t5 = space();
      if (switch_instance6)
        create_component(switch_instance6.$$.fragment);
      t6 = space();
      if (switch_instance7)
        create_component(switch_instance7.$$.fragment);
      t7 = space();
      if (switch_instance8)
        create_component(switch_instance8.$$.fragment);
      t8 = space();
      if (switch_instance9)
        create_component(switch_instance9.$$.fragment);
      div0.hidden = div0_hidden_value = !/*soundOnly*/
      ctx[3];
      div1.hidden = div1_hidden_value = !/*macroEnabled*/
      ctx[2];
      attr(div2, "class", "aa-primary-border");
      div3.hidden = div3_hidden_value = /*soundOnly*/
      ctx[3] || /*macroEnabled*/
      ctx[2] && /*macroPlay*/
      ctx[1] === "2";
    },
    m(target2, anchor) {
      insert(target2, div0, anchor);
      if (switch_instance0)
        mount_component(switch_instance0, div0, null);
      insert(target2, t0, anchor);
      insert(target2, div1, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, div1, null);
      insert(target2, t1, anchor);
      insert(target2, div3, anchor);
      if (switch_instance2)
        mount_component(switch_instance2, div3, null);
      append(div3, t2);
      append(div3, div2);
      if (switch_instance3)
        mount_component(switch_instance3, div2, null);
      append(div2, t3);
      if (switch_instance4)
        mount_component(switch_instance4, div2, null);
      append(div2, t4);
      if (switch_instance5)
        mount_component(switch_instance5, div2, null);
      append(div2, t5);
      if (switch_instance6)
        mount_component(switch_instance6, div2, null);
      append(div2, t6);
      if (switch_instance7)
        mount_component(switch_instance7, div2, null);
      append(div3, t7);
      if (switch_instance8)
        mount_component(switch_instance8, div3, null);
      append(div3, t8);
      if (switch_instance9)
        mount_component(switch_instance9, div3, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = SoundOnly)) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, div0, null);
        } else {
          switch_instance0 = null;
        }
      }
      if (!current || dirty & /*soundOnly*/
      8 && div0_hidden_value !== (div0_hidden_value = !/*soundOnly*/
      ctx2[3])) {
        div0.hidden = div0_hidden_value;
      }
      if (switch_value_1 !== (switch_value_1 = Macro$1)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, div1, null);
        } else {
          switch_instance1 = null;
        }
      }
      if (!current || dirty & /*macroEnabled*/
      4 && div1_hidden_value !== (div1_hidden_value = !/*macroEnabled*/
      ctx2[2])) {
        div1.hidden = div1_hidden_value;
      }
      if (switch_value_2 !== (switch_value_2 = ExtraSource)) {
        if (switch_instance2) {
          group_outros();
          const old_component = switch_instance2;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_2) {
          switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2());
          create_component(switch_instance2.$$.fragment);
          transition_in(switch_instance2.$$.fragment, 1);
          mount_component(switch_instance2, div3, t2);
        } else {
          switch_instance2 = null;
        }
      }
      if (switch_value_3 !== (switch_value_3 = VideoSelect)) {
        if (switch_instance3) {
          group_outros();
          const old_component = switch_instance3;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_3) {
          switch_instance3 = construct_svelte_component(switch_value_3, switch_props_3(ctx2));
          create_component(switch_instance3.$$.fragment);
          transition_in(switch_instance3.$$.fragment, 1);
          mount_component(switch_instance3, div2, t3);
        } else {
          switch_instance3 = null;
        }
      }
      if (switch_value_4 !== (switch_value_4 = MeleeOptions)) {
        if (switch_instance4) {
          group_outros();
          const old_component = switch_instance4;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_4) {
          switch_instance4 = construct_svelte_component(switch_value_4, switch_props_4());
          create_component(switch_instance4.$$.fragment);
          transition_in(switch_instance4.$$.fragment, 1);
          mount_component(switch_instance4, div2, t4);
        } else {
          switch_instance4 = null;
        }
      }
      if (switch_value_5 !== (switch_value_5 = EffectColor)) {
        if (switch_instance5) {
          group_outros();
          const old_component = switch_instance5;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_5) {
          switch_instance5 = construct_svelte_component(switch_value_5, switch_props_5());
          create_component(switch_instance5.$$.fragment);
          transition_in(switch_instance5.$$.fragment, 1);
          mount_component(switch_instance5, div2, t5);
        } else {
          switch_instance5 = null;
        }
      }
      if (switch_value_6 !== (switch_value_6 = SoundSettings)) {
        if (switch_instance6) {
          group_outros();
          const old_component = switch_instance6;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_6) {
          switch_instance6 = construct_svelte_component(switch_value_6, switch_props_6());
          create_component(switch_instance6.$$.fragment);
          transition_in(switch_instance6.$$.fragment, 1);
          mount_component(switch_instance6, div2, t6);
        } else {
          switch_instance6 = null;
        }
      }
      if (switch_value_7 !== (switch_value_7 = MeleeSwitch)) {
        if (switch_instance7) {
          group_outros();
          const old_component = switch_instance7;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_7) {
          switch_instance7 = construct_svelte_component(switch_value_7, switch_props_7());
          create_component(switch_instance7.$$.fragment);
          transition_in(switch_instance7.$$.fragment, 1);
          mount_component(switch_instance7, div2, null);
        } else {
          switch_instance7 = null;
        }
      }
      if (switch_value_8 !== (switch_value_8 = Secondary)) {
        if (switch_instance8) {
          group_outros();
          const old_component = switch_instance8;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_8) {
          switch_instance8 = construct_svelte_component(switch_value_8, switch_props_8());
          create_component(switch_instance8.$$.fragment);
          transition_in(switch_instance8.$$.fragment, 1);
          mount_component(switch_instance8, div3, t8);
        } else {
          switch_instance8 = null;
        }
      }
      if (switch_value_9 !== (switch_value_9 = ExtraTarget)) {
        if (switch_instance9) {
          group_outros();
          const old_component = switch_instance9;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_9) {
          switch_instance9 = construct_svelte_component(switch_value_9, switch_props_9());
          create_component(switch_instance9.$$.fragment);
          transition_in(switch_instance9.$$.fragment, 1);
          mount_component(switch_instance9, div3, null);
        } else {
          switch_instance9 = null;
        }
      }
      if (!current || dirty & /*soundOnly, macroEnabled, macroPlay*/
      14 && div3_hidden_value !== (div3_hidden_value = /*soundOnly*/
      ctx2[3] || /*macroEnabled*/
      ctx2[2] && /*macroPlay*/
      ctx2[1] === "2")) {
        div3.hidden = div3_hidden_value;
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_in(switch_instance2.$$.fragment, local);
      if (switch_instance3)
        transition_in(switch_instance3.$$.fragment, local);
      if (switch_instance4)
        transition_in(switch_instance4.$$.fragment, local);
      if (switch_instance5)
        transition_in(switch_instance5.$$.fragment, local);
      if (switch_instance6)
        transition_in(switch_instance6.$$.fragment, local);
      if (switch_instance7)
        transition_in(switch_instance7.$$.fragment, local);
      if (switch_instance8)
        transition_in(switch_instance8.$$.fragment, local);
      if (switch_instance9)
        transition_in(switch_instance9.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_out(switch_instance2.$$.fragment, local);
      if (switch_instance3)
        transition_out(switch_instance3.$$.fragment, local);
      if (switch_instance4)
        transition_out(switch_instance4.$$.fragment, local);
      if (switch_instance5)
        transition_out(switch_instance5.$$.fragment, local);
      if (switch_instance6)
        transition_out(switch_instance6.$$.fragment, local);
      if (switch_instance7)
        transition_out(switch_instance7.$$.fragment, local);
      if (switch_instance8)
        transition_out(switch_instance8.$$.fragment, local);
      if (switch_instance9)
        transition_out(switch_instance9.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (switch_instance0)
        destroy_component(switch_instance0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if (switch_instance1)
        destroy_component(switch_instance1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div3);
      if (switch_instance2)
        destroy_component(switch_instance2);
      if (switch_instance3)
        destroy_component(switch_instance3);
      if (switch_instance4)
        destroy_component(switch_instance4);
      if (switch_instance5)
        destroy_component(switch_instance5);
      if (switch_instance6)
        destroy_component(switch_instance6);
      if (switch_instance7)
        destroy_component(switch_instance7);
      if (switch_instance8)
        destroy_component(switch_instance8);
      if (switch_instance9)
        destroy_component(switch_instance9);
    }
  };
}
function create_if_block$7(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = Canvas3D;
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = Canvas3D)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$v(ctx) {
  let switch_instance;
  let updating_show3d;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  function switch_instance_show3d_binding(value) {
    ctx[8](value);
  }
  var switch_value = SectionButtons;
  function switch_props(ctx2) {
    let switch_instance_props = { type: (
      /*fromMenu*/
      ctx2[0]
    ) };
    if (
      /*show3d*/
      ctx2[4] !== void 0
    ) {
      switch_instance_props.show3d = /*show3d*/
      ctx2[4];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "show3d", switch_instance_show3d_binding));
  }
  const if_block_creators = [create_if_block$7, create_else_block$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*show3d*/
      ctx2[4] && !/*soundOnly*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, t, anchor);
      if_blocks[current_block_type_index].m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & /*fromMenu*/
      1)
        switch_instance_changes.type = /*fromMenu*/
        ctx2[0];
      if (!updating_show3d && dirty & /*show3d*/
      16) {
        updating_show3d = true;
        switch_instance_changes.show3d = /*show3d*/
        ctx2[4];
        add_flush_callback(() => updating_show3d = false);
      }
      if (switch_value !== (switch_value = SectionButtons)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          binding_callbacks.push(() => bind(switch_instance, "show3d", switch_instance_show3d_binding));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let show3d;
  let soundOnly;
  let macroEnabled;
  let macroPlay;
  let $animation;
  let { fromMenu = "autorec" } = $$props;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(7, $animation = value));
  let title2 = game.i18n.localize("autoanimations.menus.primary") + " " + game.i18n.localize("autoanimations.menus.animation");
  function switch_instance_show3d_binding(value) {
    show3d = value;
    $$invalidate(4, show3d);
  }
  $$self.$$set = ($$props2) => {
    if ("fromMenu" in $$props2)
      $$invalidate(0, fromMenu = $$props2.fromMenu);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    128) {
      $$invalidate(3, soundOnly = $animation.soundOnly.sound.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    128) {
      $$invalidate(2, macroEnabled = $animation.macro.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    128) {
      $$invalidate(1, macroPlay = $animation.macro.playWhen);
    }
  };
  $$invalidate(4, show3d = false);
  return [
    fromMenu,
    macroPlay,
    macroEnabled,
    soundOnly,
    show3d,
    animation,
    title2,
    $animation,
    switch_instance_show3d_binding
  ];
}
class BuildMelee extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$t, create_fragment$v, safe_not_equal, { fromMenu: 0 });
  }
}
function create_else_block$4(ctx) {
  let div0;
  let switch_instance0;
  let div0_hidden_value;
  let t0;
  let div1;
  let switch_instance1;
  let div1_hidden_value;
  let t1;
  let div3;
  let switch_instance2;
  let t2;
  let div2;
  let switch_instance3;
  let t3;
  let switch_instance4;
  let t4;
  let switch_instance5;
  let t5;
  let switch_instance6;
  let t6;
  let switch_instance7;
  let t7;
  let switch_instance8;
  let div3_hidden_value;
  let current;
  var switch_value = SoundOnly;
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props());
  }
  var switch_value_1 = Macro$1;
  function switch_props_1(ctx2) {
    return {};
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
  }
  var switch_value_2 = ExtraSource;
  function switch_props_2(ctx2) {
    return {};
  }
  if (switch_value_2) {
    switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2());
  }
  var switch_value_3 = VideoSelect;
  function switch_props_3(ctx2) {
    return {
      props: {
        title: (
          /*title*/
          ctx2[6]
        ),
        section: "primary"
      }
    };
  }
  if (switch_value_3) {
    switch_instance3 = construct_svelte_component(switch_value_3, switch_props_3(ctx));
  }
  var switch_value_4 = RangeOptions;
  function switch_props_4(ctx2) {
    return {};
  }
  if (switch_value_4) {
    switch_instance4 = construct_svelte_component(switch_value_4, switch_props_4());
  }
  var switch_value_5 = EffectColor;
  function switch_props_5(ctx2) {
    return {};
  }
  if (switch_value_5) {
    switch_instance5 = construct_svelte_component(switch_value_5, switch_props_5());
  }
  var switch_value_6 = SoundSettings;
  function switch_props_6(ctx2) {
    return { props: { section: "primary" } };
  }
  if (switch_value_6) {
    switch_instance6 = construct_svelte_component(switch_value_6, switch_props_6());
  }
  var switch_value_7 = Secondary;
  function switch_props_7(ctx2) {
    return {};
  }
  if (switch_value_7) {
    switch_instance7 = construct_svelte_component(switch_value_7, switch_props_7());
  }
  var switch_value_8 = ExtraTarget;
  function switch_props_8(ctx2) {
    return {};
  }
  if (switch_value_8) {
    switch_instance8 = construct_svelte_component(switch_value_8, switch_props_8());
  }
  return {
    c() {
      div0 = element("div");
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t0 = space();
      div1 = element("div");
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      t1 = space();
      div3 = element("div");
      if (switch_instance2)
        create_component(switch_instance2.$$.fragment);
      t2 = space();
      div2 = element("div");
      if (switch_instance3)
        create_component(switch_instance3.$$.fragment);
      t3 = space();
      if (switch_instance4)
        create_component(switch_instance4.$$.fragment);
      t4 = space();
      if (switch_instance5)
        create_component(switch_instance5.$$.fragment);
      t5 = space();
      if (switch_instance6)
        create_component(switch_instance6.$$.fragment);
      t6 = space();
      if (switch_instance7)
        create_component(switch_instance7.$$.fragment);
      t7 = space();
      if (switch_instance8)
        create_component(switch_instance8.$$.fragment);
      div0.hidden = div0_hidden_value = !/*soundOnly*/
      ctx[3];
      div1.hidden = div1_hidden_value = !/*macroEnabled*/
      ctx[2];
      attr(div2, "class", "aa-primary-border");
      div3.hidden = div3_hidden_value = /*soundOnly*/
      ctx[3] || /*macroEnabled*/
      ctx[2] && /*macroPlay*/
      ctx[1] === "2";
    },
    m(target2, anchor) {
      insert(target2, div0, anchor);
      if (switch_instance0)
        mount_component(switch_instance0, div0, null);
      insert(target2, t0, anchor);
      insert(target2, div1, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, div1, null);
      insert(target2, t1, anchor);
      insert(target2, div3, anchor);
      if (switch_instance2)
        mount_component(switch_instance2, div3, null);
      append(div3, t2);
      append(div3, div2);
      if (switch_instance3)
        mount_component(switch_instance3, div2, null);
      append(div2, t3);
      if (switch_instance4)
        mount_component(switch_instance4, div2, null);
      append(div2, t4);
      if (switch_instance5)
        mount_component(switch_instance5, div2, null);
      append(div2, t5);
      if (switch_instance6)
        mount_component(switch_instance6, div2, null);
      append(div3, t6);
      if (switch_instance7)
        mount_component(switch_instance7, div3, null);
      append(div3, t7);
      if (switch_instance8)
        mount_component(switch_instance8, div3, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = SoundOnly)) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, div0, null);
        } else {
          switch_instance0 = null;
        }
      }
      if (!current || dirty & /*soundOnly*/
      8 && div0_hidden_value !== (div0_hidden_value = !/*soundOnly*/
      ctx2[3])) {
        div0.hidden = div0_hidden_value;
      }
      if (switch_value_1 !== (switch_value_1 = Macro$1)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, div1, null);
        } else {
          switch_instance1 = null;
        }
      }
      if (!current || dirty & /*macroEnabled*/
      4 && div1_hidden_value !== (div1_hidden_value = !/*macroEnabled*/
      ctx2[2])) {
        div1.hidden = div1_hidden_value;
      }
      if (switch_value_2 !== (switch_value_2 = ExtraSource)) {
        if (switch_instance2) {
          group_outros();
          const old_component = switch_instance2;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_2) {
          switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2());
          create_component(switch_instance2.$$.fragment);
          transition_in(switch_instance2.$$.fragment, 1);
          mount_component(switch_instance2, div3, t2);
        } else {
          switch_instance2 = null;
        }
      }
      if (switch_value_3 !== (switch_value_3 = VideoSelect)) {
        if (switch_instance3) {
          group_outros();
          const old_component = switch_instance3;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_3) {
          switch_instance3 = construct_svelte_component(switch_value_3, switch_props_3(ctx2));
          create_component(switch_instance3.$$.fragment);
          transition_in(switch_instance3.$$.fragment, 1);
          mount_component(switch_instance3, div2, t3);
        } else {
          switch_instance3 = null;
        }
      }
      if (switch_value_4 !== (switch_value_4 = RangeOptions)) {
        if (switch_instance4) {
          group_outros();
          const old_component = switch_instance4;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_4) {
          switch_instance4 = construct_svelte_component(switch_value_4, switch_props_4());
          create_component(switch_instance4.$$.fragment);
          transition_in(switch_instance4.$$.fragment, 1);
          mount_component(switch_instance4, div2, t4);
        } else {
          switch_instance4 = null;
        }
      }
      if (switch_value_5 !== (switch_value_5 = EffectColor)) {
        if (switch_instance5) {
          group_outros();
          const old_component = switch_instance5;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_5) {
          switch_instance5 = construct_svelte_component(switch_value_5, switch_props_5());
          create_component(switch_instance5.$$.fragment);
          transition_in(switch_instance5.$$.fragment, 1);
          mount_component(switch_instance5, div2, t5);
        } else {
          switch_instance5 = null;
        }
      }
      if (switch_value_6 !== (switch_value_6 = SoundSettings)) {
        if (switch_instance6) {
          group_outros();
          const old_component = switch_instance6;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_6) {
          switch_instance6 = construct_svelte_component(switch_value_6, switch_props_6());
          create_component(switch_instance6.$$.fragment);
          transition_in(switch_instance6.$$.fragment, 1);
          mount_component(switch_instance6, div2, null);
        } else {
          switch_instance6 = null;
        }
      }
      if (switch_value_7 !== (switch_value_7 = Secondary)) {
        if (switch_instance7) {
          group_outros();
          const old_component = switch_instance7;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_7) {
          switch_instance7 = construct_svelte_component(switch_value_7, switch_props_7());
          create_component(switch_instance7.$$.fragment);
          transition_in(switch_instance7.$$.fragment, 1);
          mount_component(switch_instance7, div3, t7);
        } else {
          switch_instance7 = null;
        }
      }
      if (switch_value_8 !== (switch_value_8 = ExtraTarget)) {
        if (switch_instance8) {
          group_outros();
          const old_component = switch_instance8;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_8) {
          switch_instance8 = construct_svelte_component(switch_value_8, switch_props_8());
          create_component(switch_instance8.$$.fragment);
          transition_in(switch_instance8.$$.fragment, 1);
          mount_component(switch_instance8, div3, null);
        } else {
          switch_instance8 = null;
        }
      }
      if (!current || dirty & /*soundOnly, macroEnabled, macroPlay*/
      14 && div3_hidden_value !== (div3_hidden_value = /*soundOnly*/
      ctx2[3] || /*macroEnabled*/
      ctx2[2] && /*macroPlay*/
      ctx2[1] === "2")) {
        div3.hidden = div3_hidden_value;
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_in(switch_instance2.$$.fragment, local);
      if (switch_instance3)
        transition_in(switch_instance3.$$.fragment, local);
      if (switch_instance4)
        transition_in(switch_instance4.$$.fragment, local);
      if (switch_instance5)
        transition_in(switch_instance5.$$.fragment, local);
      if (switch_instance6)
        transition_in(switch_instance6.$$.fragment, local);
      if (switch_instance7)
        transition_in(switch_instance7.$$.fragment, local);
      if (switch_instance8)
        transition_in(switch_instance8.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_out(switch_instance2.$$.fragment, local);
      if (switch_instance3)
        transition_out(switch_instance3.$$.fragment, local);
      if (switch_instance4)
        transition_out(switch_instance4.$$.fragment, local);
      if (switch_instance5)
        transition_out(switch_instance5.$$.fragment, local);
      if (switch_instance6)
        transition_out(switch_instance6.$$.fragment, local);
      if (switch_instance7)
        transition_out(switch_instance7.$$.fragment, local);
      if (switch_instance8)
        transition_out(switch_instance8.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (switch_instance0)
        destroy_component(switch_instance0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if (switch_instance1)
        destroy_component(switch_instance1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div3);
      if (switch_instance2)
        destroy_component(switch_instance2);
      if (switch_instance3)
        destroy_component(switch_instance3);
      if (switch_instance4)
        destroy_component(switch_instance4);
      if (switch_instance5)
        destroy_component(switch_instance5);
      if (switch_instance6)
        destroy_component(switch_instance6);
      if (switch_instance7)
        destroy_component(switch_instance7);
      if (switch_instance8)
        destroy_component(switch_instance8);
    }
  };
}
function create_if_block$6(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = Canvas3D;
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = Canvas3D)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$u(ctx) {
  let switch_instance;
  let updating_show3d;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  function switch_instance_show3d_binding(value) {
    ctx[8](value);
  }
  var switch_value = SectionButtons;
  function switch_props(ctx2) {
    let switch_instance_props = { type: (
      /*fromMenu*/
      ctx2[0]
    ) };
    if (
      /*show3d*/
      ctx2[4] !== void 0
    ) {
      switch_instance_props.show3d = /*show3d*/
      ctx2[4];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "show3d", switch_instance_show3d_binding));
  }
  const if_block_creators = [create_if_block$6, create_else_block$4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*show3d*/
      ctx2[4] && !/*soundOnly*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, t, anchor);
      if_blocks[current_block_type_index].m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & /*fromMenu*/
      1)
        switch_instance_changes.type = /*fromMenu*/
        ctx2[0];
      if (!updating_show3d && dirty & /*show3d*/
      16) {
        updating_show3d = true;
        switch_instance_changes.show3d = /*show3d*/
        ctx2[4];
        add_flush_callback(() => updating_show3d = false);
      }
      if (switch_value !== (switch_value = SectionButtons)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          binding_callbacks.push(() => bind(switch_instance, "show3d", switch_instance_show3d_binding));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  let show3d;
  let soundOnly;
  let macroEnabled;
  let macroPlay;
  let $animation;
  let { fromMenu = "autorec" } = $$props;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(7, $animation = value));
  let title2 = game.i18n.localize("autoanimations.menus.primary") + " " + game.i18n.localize("autoanimations.menus.animation");
  function switch_instance_show3d_binding(value) {
    show3d = value;
    $$invalidate(4, show3d);
  }
  $$self.$$set = ($$props2) => {
    if ("fromMenu" in $$props2)
      $$invalidate(0, fromMenu = $$props2.fromMenu);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    128) {
      $$invalidate(3, soundOnly = $animation.soundOnly.sound.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    128) {
      $$invalidate(2, macroEnabled = $animation.macro.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    128) {
      $$invalidate(1, macroPlay = $animation.macro.playWhen);
    }
  };
  $$invalidate(4, show3d = false);
  return [
    fromMenu,
    macroPlay,
    macroEnabled,
    soundOnly,
    show3d,
    animation,
    title2,
    $animation,
    switch_instance_show3d_binding
  ];
}
class BuildRange extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$s, create_fragment$u, safe_not_equal, { fromMenu: 0 });
  }
}
function create_else_block$3(ctx) {
  let div0;
  let switch_instance0;
  let div0_hidden_value;
  let t0;
  let div1;
  let switch_instance1;
  let div1_hidden_value;
  let t1;
  let div4;
  let switch_instance2;
  let t2;
  let div2;
  let switch_instance3;
  let t3;
  let switch_instance4;
  let t4;
  let switch_instance5;
  let t5;
  let switch_instance6;
  let t6;
  let switch_instance7;
  let t7;
  let div3;
  let switch_instance8;
  let div3_class_value;
  let div4_hidden_value;
  let current;
  var switch_value = SoundOnly;
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props());
  }
  var switch_value_1 = Macro$1;
  function switch_props_1(ctx2) {
    return {};
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
  }
  var switch_value_2 = ExtraSource;
  function switch_props_2(ctx2) {
    return {};
  }
  if (switch_value_2) {
    switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2());
  }
  var switch_value_3 = VideoSelect;
  function switch_props_3(ctx2) {
    return {
      props: {
        title: (
          /*title*/
          ctx2[7]
        ),
        section: "primary"
      }
    };
  }
  if (switch_value_3) {
    switch_instance3 = construct_svelte_component(switch_value_3, switch_props_3(ctx));
  }
  var switch_value_4 = OnTokenOptions;
  function switch_props_4(ctx2) {
    return {};
  }
  if (switch_value_4) {
    switch_instance4 = construct_svelte_component(switch_value_4, switch_props_4());
  }
  var switch_value_5 = EffectColor;
  function switch_props_5(ctx2) {
    return {};
  }
  if (switch_value_5) {
    switch_instance5 = construct_svelte_component(switch_value_5, switch_props_5());
  }
  var switch_value_6 = SoundSettings;
  function switch_props_6(ctx2) {
    return { props: { section: "primary" } };
  }
  if (switch_value_6) {
    switch_instance6 = construct_svelte_component(switch_value_6, switch_props_6());
  }
  var switch_value_7 = Secondary;
  function switch_props_7(ctx2) {
    return {};
  }
  if (switch_value_7) {
    switch_instance7 = construct_svelte_component(switch_value_7, switch_props_7());
  }
  var switch_value_8 = ExtraTarget;
  function switch_props_8(ctx2) {
    return {};
  }
  if (switch_value_8) {
    switch_instance8 = construct_svelte_component(switch_value_8, switch_props_8());
  }
  return {
    c() {
      div0 = element("div");
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t0 = space();
      div1 = element("div");
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      t1 = space();
      div4 = element("div");
      if (switch_instance2)
        create_component(switch_instance2.$$.fragment);
      t2 = space();
      div2 = element("div");
      if (switch_instance3)
        create_component(switch_instance3.$$.fragment);
      t3 = space();
      if (switch_instance4)
        create_component(switch_instance4.$$.fragment);
      t4 = space();
      if (switch_instance5)
        create_component(switch_instance5.$$.fragment);
      t5 = space();
      if (switch_instance6)
        create_component(switch_instance6.$$.fragment);
      t6 = space();
      if (switch_instance7)
        create_component(switch_instance7.$$.fragment);
      t7 = space();
      div3 = element("div");
      if (switch_instance8)
        create_component(switch_instance8.$$.fragment);
      div0.hidden = div0_hidden_value = !/*soundOnly*/
      ctx[4];
      div1.hidden = div1_hidden_value = !/*macroEnabled*/
      ctx[3];
      attr(div2, "class", "aa-primary-border");
      attr(div3, "class", div3_class_value = /*$animation*/
      ctx[1].primary.options.playOn === "source" ? "aa-disableOpacity" : "");
      div4.hidden = div4_hidden_value = /*soundOnly*/
      ctx[4] || /*macroEnabled*/
      ctx[3] && /*macroPlay*/
      ctx[2] === "2";
    },
    m(target2, anchor) {
      insert(target2, div0, anchor);
      if (switch_instance0)
        mount_component(switch_instance0, div0, null);
      insert(target2, t0, anchor);
      insert(target2, div1, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, div1, null);
      insert(target2, t1, anchor);
      insert(target2, div4, anchor);
      if (switch_instance2)
        mount_component(switch_instance2, div4, null);
      append(div4, t2);
      append(div4, div2);
      if (switch_instance3)
        mount_component(switch_instance3, div2, null);
      append(div2, t3);
      if (switch_instance4)
        mount_component(switch_instance4, div2, null);
      append(div2, t4);
      if (switch_instance5)
        mount_component(switch_instance5, div2, null);
      append(div2, t5);
      if (switch_instance6)
        mount_component(switch_instance6, div2, null);
      append(div4, t6);
      if (switch_instance7)
        mount_component(switch_instance7, div4, null);
      append(div4, t7);
      append(div4, div3);
      if (switch_instance8)
        mount_component(switch_instance8, div3, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = SoundOnly)) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, div0, null);
        } else {
          switch_instance0 = null;
        }
      }
      if (!current || dirty & /*soundOnly*/
      16 && div0_hidden_value !== (div0_hidden_value = !/*soundOnly*/
      ctx2[4])) {
        div0.hidden = div0_hidden_value;
      }
      if (switch_value_1 !== (switch_value_1 = Macro$1)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, div1, null);
        } else {
          switch_instance1 = null;
        }
      }
      if (!current || dirty & /*macroEnabled*/
      8 && div1_hidden_value !== (div1_hidden_value = !/*macroEnabled*/
      ctx2[3])) {
        div1.hidden = div1_hidden_value;
      }
      if (switch_value_2 !== (switch_value_2 = ExtraSource)) {
        if (switch_instance2) {
          group_outros();
          const old_component = switch_instance2;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_2) {
          switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2());
          create_component(switch_instance2.$$.fragment);
          transition_in(switch_instance2.$$.fragment, 1);
          mount_component(switch_instance2, div4, t2);
        } else {
          switch_instance2 = null;
        }
      }
      if (switch_value_3 !== (switch_value_3 = VideoSelect)) {
        if (switch_instance3) {
          group_outros();
          const old_component = switch_instance3;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_3) {
          switch_instance3 = construct_svelte_component(switch_value_3, switch_props_3(ctx2));
          create_component(switch_instance3.$$.fragment);
          transition_in(switch_instance3.$$.fragment, 1);
          mount_component(switch_instance3, div2, t3);
        } else {
          switch_instance3 = null;
        }
      }
      if (switch_value_4 !== (switch_value_4 = OnTokenOptions)) {
        if (switch_instance4) {
          group_outros();
          const old_component = switch_instance4;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_4) {
          switch_instance4 = construct_svelte_component(switch_value_4, switch_props_4());
          create_component(switch_instance4.$$.fragment);
          transition_in(switch_instance4.$$.fragment, 1);
          mount_component(switch_instance4, div2, t4);
        } else {
          switch_instance4 = null;
        }
      }
      if (switch_value_5 !== (switch_value_5 = EffectColor)) {
        if (switch_instance5) {
          group_outros();
          const old_component = switch_instance5;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_5) {
          switch_instance5 = construct_svelte_component(switch_value_5, switch_props_5());
          create_component(switch_instance5.$$.fragment);
          transition_in(switch_instance5.$$.fragment, 1);
          mount_component(switch_instance5, div2, t5);
        } else {
          switch_instance5 = null;
        }
      }
      if (switch_value_6 !== (switch_value_6 = SoundSettings)) {
        if (switch_instance6) {
          group_outros();
          const old_component = switch_instance6;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_6) {
          switch_instance6 = construct_svelte_component(switch_value_6, switch_props_6());
          create_component(switch_instance6.$$.fragment);
          transition_in(switch_instance6.$$.fragment, 1);
          mount_component(switch_instance6, div2, null);
        } else {
          switch_instance6 = null;
        }
      }
      if (switch_value_7 !== (switch_value_7 = Secondary)) {
        if (switch_instance7) {
          group_outros();
          const old_component = switch_instance7;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_7) {
          switch_instance7 = construct_svelte_component(switch_value_7, switch_props_7());
          create_component(switch_instance7.$$.fragment);
          transition_in(switch_instance7.$$.fragment, 1);
          mount_component(switch_instance7, div4, t7);
        } else {
          switch_instance7 = null;
        }
      }
      if (switch_value_8 !== (switch_value_8 = ExtraTarget)) {
        if (switch_instance8) {
          group_outros();
          const old_component = switch_instance8;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_8) {
          switch_instance8 = construct_svelte_component(switch_value_8, switch_props_8());
          create_component(switch_instance8.$$.fragment);
          transition_in(switch_instance8.$$.fragment, 1);
          mount_component(switch_instance8, div3, null);
        } else {
          switch_instance8 = null;
        }
      }
      if (!current || dirty & /*$animation*/
      2 && div3_class_value !== (div3_class_value = /*$animation*/
      ctx2[1].primary.options.playOn === "source" ? "aa-disableOpacity" : "")) {
        attr(div3, "class", div3_class_value);
      }
      if (!current || dirty & /*soundOnly, macroEnabled, macroPlay*/
      28 && div4_hidden_value !== (div4_hidden_value = /*soundOnly*/
      ctx2[4] || /*macroEnabled*/
      ctx2[3] && /*macroPlay*/
      ctx2[2] === "2")) {
        div4.hidden = div4_hidden_value;
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_in(switch_instance2.$$.fragment, local);
      if (switch_instance3)
        transition_in(switch_instance3.$$.fragment, local);
      if (switch_instance4)
        transition_in(switch_instance4.$$.fragment, local);
      if (switch_instance5)
        transition_in(switch_instance5.$$.fragment, local);
      if (switch_instance6)
        transition_in(switch_instance6.$$.fragment, local);
      if (switch_instance7)
        transition_in(switch_instance7.$$.fragment, local);
      if (switch_instance8)
        transition_in(switch_instance8.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_out(switch_instance2.$$.fragment, local);
      if (switch_instance3)
        transition_out(switch_instance3.$$.fragment, local);
      if (switch_instance4)
        transition_out(switch_instance4.$$.fragment, local);
      if (switch_instance5)
        transition_out(switch_instance5.$$.fragment, local);
      if (switch_instance6)
        transition_out(switch_instance6.$$.fragment, local);
      if (switch_instance7)
        transition_out(switch_instance7.$$.fragment, local);
      if (switch_instance8)
        transition_out(switch_instance8.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (switch_instance0)
        destroy_component(switch_instance0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if (switch_instance1)
        destroy_component(switch_instance1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div4);
      if (switch_instance2)
        destroy_component(switch_instance2);
      if (switch_instance3)
        destroy_component(switch_instance3);
      if (switch_instance4)
        destroy_component(switch_instance4);
      if (switch_instance5)
        destroy_component(switch_instance5);
      if (switch_instance6)
        destroy_component(switch_instance6);
      if (switch_instance7)
        destroy_component(switch_instance7);
      if (switch_instance8)
        destroy_component(switch_instance8);
    }
  };
}
function create_if_block$5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = Canvas3D;
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = Canvas3D)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$t(ctx) {
  let switch_instance;
  let updating_show3d;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  function switch_instance_show3d_binding(value) {
    ctx[8](value);
  }
  var switch_value = SectionButtons;
  function switch_props(ctx2) {
    let switch_instance_props = { type: (
      /*fromMenu*/
      ctx2[0]
    ) };
    if (
      /*show3d*/
      ctx2[5] !== void 0
    ) {
      switch_instance_props.show3d = /*show3d*/
      ctx2[5];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "show3d", switch_instance_show3d_binding));
  }
  const if_block_creators = [create_if_block$5, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*show3d*/
      ctx2[5] && !/*soundOnly*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, t, anchor);
      if_blocks[current_block_type_index].m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & /*fromMenu*/
      1)
        switch_instance_changes.type = /*fromMenu*/
        ctx2[0];
      if (!updating_show3d && dirty & /*show3d*/
      32) {
        updating_show3d = true;
        switch_instance_changes.show3d = /*show3d*/
        ctx2[5];
        add_flush_callback(() => updating_show3d = false);
      }
      if (switch_value !== (switch_value = SectionButtons)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          binding_callbacks.push(() => bind(switch_instance, "show3d", switch_instance_show3d_binding));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let show3d;
  let soundOnly;
  let macroEnabled;
  let macroPlay;
  let $animation;
  let { fromMenu = "autorec" } = $$props;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(1, $animation = value));
  let title2 = game.i18n.localize("autoanimations.menus.primary") + " " + game.i18n.localize("autoanimations.menus.animation");
  function switch_instance_show3d_binding(value) {
    show3d = value;
    $$invalidate(5, show3d);
  }
  $$self.$$set = ($$props2) => {
    if ("fromMenu" in $$props2)
      $$invalidate(0, fromMenu = $$props2.fromMenu);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(4, soundOnly = $animation.soundOnly.sound.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(3, macroEnabled = $animation.macro.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(2, macroPlay = $animation.macro.playWhen);
    }
  };
  $$invalidate(5, show3d = false);
  return [
    fromMenu,
    $animation,
    macroPlay,
    macroEnabled,
    soundOnly,
    show3d,
    animation,
    title2,
    switch_instance_show3d_binding
  ];
}
class BuildOnToken extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$r, create_fragment$t, safe_not_equal, { fromMenu: 0 });
  }
}
function create_fragment$s(ctx) {
  let switch_instance0;
  let t0;
  let div0;
  let switch_instance1;
  let div0_hidden_value;
  let t1;
  let div1;
  let switch_instance2;
  let div1_hidden_value;
  let t2;
  let div3;
  let switch_instance3;
  let t3;
  let div2;
  let switch_instance4;
  let t4;
  let switch_instance5;
  let t5;
  let switch_instance6;
  let t6;
  let switch_instance7;
  let t7;
  let switch_instance8;
  let t8;
  let switch_instance9;
  let div3_hidden_value;
  let current;
  var switch_value = SectionButtons02;
  function switch_props(ctx2) {
    return { props: { type: (
      /*fromMenu*/
      ctx2[0]
    ) } };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
  }
  var switch_value_1 = SoundOnly;
  function switch_props_1(ctx2) {
    return {};
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
  }
  var switch_value_2 = Macro$1;
  function switch_props_2(ctx2) {
    return {};
  }
  if (switch_value_2) {
    switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2());
  }
  var switch_value_3 = ExtraSource;
  function switch_props_3(ctx2) {
    return {};
  }
  if (switch_value_3) {
    switch_instance3 = construct_svelte_component(switch_value_3, switch_props_3());
  }
  var switch_value_4 = VideoSelect;
  function switch_props_4(ctx2) {
    return {
      props: {
        title: (
          /*title*/
          ctx2[5]
        ),
        section: "primary"
      }
    };
  }
  if (switch_value_4) {
    switch_instance4 = construct_svelte_component(switch_value_4, switch_props_4(ctx));
  }
  var switch_value_5 = TemplateOptions;
  function switch_props_5(ctx2) {
    return {};
  }
  if (switch_value_5) {
    switch_instance5 = construct_svelte_component(switch_value_5, switch_props_5());
  }
  var switch_value_6 = EffectColor;
  function switch_props_6(ctx2) {
    return {};
  }
  if (switch_value_6) {
    switch_instance6 = construct_svelte_component(switch_value_6, switch_props_6());
  }
  var switch_value_7 = SoundSettings;
  function switch_props_7(ctx2) {
    return { props: { section: "primary" } };
  }
  if (switch_value_7) {
    switch_instance7 = construct_svelte_component(switch_value_7, switch_props_7());
  }
  var switch_value_8 = Secondary;
  function switch_props_8(ctx2) {
    return {};
  }
  if (switch_value_8) {
    switch_instance8 = construct_svelte_component(switch_value_8, switch_props_8());
  }
  var switch_value_9 = ExtraTarget;
  function switch_props_9(ctx2) {
    return {};
  }
  if (switch_value_9) {
    switch_instance9 = construct_svelte_component(switch_value_9, switch_props_9());
  }
  return {
    c() {
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t0 = space();
      div0 = element("div");
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      t1 = space();
      div1 = element("div");
      if (switch_instance2)
        create_component(switch_instance2.$$.fragment);
      t2 = space();
      div3 = element("div");
      if (switch_instance3)
        create_component(switch_instance3.$$.fragment);
      t3 = space();
      div2 = element("div");
      if (switch_instance4)
        create_component(switch_instance4.$$.fragment);
      t4 = space();
      if (switch_instance5)
        create_component(switch_instance5.$$.fragment);
      t5 = space();
      if (switch_instance6)
        create_component(switch_instance6.$$.fragment);
      t6 = space();
      if (switch_instance7)
        create_component(switch_instance7.$$.fragment);
      t7 = space();
      if (switch_instance8)
        create_component(switch_instance8.$$.fragment);
      t8 = space();
      if (switch_instance9)
        create_component(switch_instance9.$$.fragment);
      div0.hidden = div0_hidden_value = !/*soundOnly*/
      ctx[3];
      div1.hidden = div1_hidden_value = !/*macroEnabled*/
      ctx[2];
      attr(div2, "class", "aa-primary-border");
      div3.hidden = div3_hidden_value = /*soundOnly*/
      ctx[3] || /*macroEnabled*/
      ctx[2] && /*macroPlay*/
      ctx[1] === "2";
    },
    m(target2, anchor) {
      if (switch_instance0)
        mount_component(switch_instance0, target2, anchor);
      insert(target2, t0, anchor);
      insert(target2, div0, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, div0, null);
      insert(target2, t1, anchor);
      insert(target2, div1, anchor);
      if (switch_instance2)
        mount_component(switch_instance2, div1, null);
      insert(target2, t2, anchor);
      insert(target2, div3, anchor);
      if (switch_instance3)
        mount_component(switch_instance3, div3, null);
      append(div3, t3);
      append(div3, div2);
      if (switch_instance4)
        mount_component(switch_instance4, div2, null);
      append(div2, t4);
      if (switch_instance5)
        mount_component(switch_instance5, div2, null);
      append(div2, t5);
      if (switch_instance6)
        mount_component(switch_instance6, div2, null);
      append(div2, t6);
      if (switch_instance7)
        mount_component(switch_instance7, div2, null);
      append(div3, t7);
      if (switch_instance8)
        mount_component(switch_instance8, div3, null);
      append(div3, t8);
      if (switch_instance9)
        mount_component(switch_instance9, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance0_changes = {};
      if (dirty & /*fromMenu*/
      1)
        switch_instance0_changes.type = /*fromMenu*/
        ctx2[0];
      if (switch_value !== (switch_value = SectionButtons02)) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, t0.parentNode, t0);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
        switch_instance0.$set(switch_instance0_changes);
      }
      if (switch_value_1 !== (switch_value_1 = SoundOnly)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, div0, null);
        } else {
          switch_instance1 = null;
        }
      }
      if (!current || dirty & /*soundOnly*/
      8 && div0_hidden_value !== (div0_hidden_value = !/*soundOnly*/
      ctx2[3])) {
        div0.hidden = div0_hidden_value;
      }
      if (switch_value_2 !== (switch_value_2 = Macro$1)) {
        if (switch_instance2) {
          group_outros();
          const old_component = switch_instance2;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_2) {
          switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2());
          create_component(switch_instance2.$$.fragment);
          transition_in(switch_instance2.$$.fragment, 1);
          mount_component(switch_instance2, div1, null);
        } else {
          switch_instance2 = null;
        }
      }
      if (!current || dirty & /*macroEnabled*/
      4 && div1_hidden_value !== (div1_hidden_value = !/*macroEnabled*/
      ctx2[2])) {
        div1.hidden = div1_hidden_value;
      }
      if (switch_value_3 !== (switch_value_3 = ExtraSource)) {
        if (switch_instance3) {
          group_outros();
          const old_component = switch_instance3;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_3) {
          switch_instance3 = construct_svelte_component(switch_value_3, switch_props_3());
          create_component(switch_instance3.$$.fragment);
          transition_in(switch_instance3.$$.fragment, 1);
          mount_component(switch_instance3, div3, t3);
        } else {
          switch_instance3 = null;
        }
      }
      if (switch_value_4 !== (switch_value_4 = VideoSelect)) {
        if (switch_instance4) {
          group_outros();
          const old_component = switch_instance4;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_4) {
          switch_instance4 = construct_svelte_component(switch_value_4, switch_props_4(ctx2));
          create_component(switch_instance4.$$.fragment);
          transition_in(switch_instance4.$$.fragment, 1);
          mount_component(switch_instance4, div2, t4);
        } else {
          switch_instance4 = null;
        }
      }
      if (switch_value_5 !== (switch_value_5 = TemplateOptions)) {
        if (switch_instance5) {
          group_outros();
          const old_component = switch_instance5;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_5) {
          switch_instance5 = construct_svelte_component(switch_value_5, switch_props_5());
          create_component(switch_instance5.$$.fragment);
          transition_in(switch_instance5.$$.fragment, 1);
          mount_component(switch_instance5, div2, t5);
        } else {
          switch_instance5 = null;
        }
      }
      if (switch_value_6 !== (switch_value_6 = EffectColor)) {
        if (switch_instance6) {
          group_outros();
          const old_component = switch_instance6;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_6) {
          switch_instance6 = construct_svelte_component(switch_value_6, switch_props_6());
          create_component(switch_instance6.$$.fragment);
          transition_in(switch_instance6.$$.fragment, 1);
          mount_component(switch_instance6, div2, t6);
        } else {
          switch_instance6 = null;
        }
      }
      if (switch_value_7 !== (switch_value_7 = SoundSettings)) {
        if (switch_instance7) {
          group_outros();
          const old_component = switch_instance7;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_7) {
          switch_instance7 = construct_svelte_component(switch_value_7, switch_props_7());
          create_component(switch_instance7.$$.fragment);
          transition_in(switch_instance7.$$.fragment, 1);
          mount_component(switch_instance7, div2, null);
        } else {
          switch_instance7 = null;
        }
      }
      if (switch_value_8 !== (switch_value_8 = Secondary)) {
        if (switch_instance8) {
          group_outros();
          const old_component = switch_instance8;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_8) {
          switch_instance8 = construct_svelte_component(switch_value_8, switch_props_8());
          create_component(switch_instance8.$$.fragment);
          transition_in(switch_instance8.$$.fragment, 1);
          mount_component(switch_instance8, div3, t8);
        } else {
          switch_instance8 = null;
        }
      }
      if (switch_value_9 !== (switch_value_9 = ExtraTarget)) {
        if (switch_instance9) {
          group_outros();
          const old_component = switch_instance9;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_9) {
          switch_instance9 = construct_svelte_component(switch_value_9, switch_props_9());
          create_component(switch_instance9.$$.fragment);
          transition_in(switch_instance9.$$.fragment, 1);
          mount_component(switch_instance9, div3, null);
        } else {
          switch_instance9 = null;
        }
      }
      if (!current || dirty & /*soundOnly, macroEnabled, macroPlay*/
      14 && div3_hidden_value !== (div3_hidden_value = /*soundOnly*/
      ctx2[3] || /*macroEnabled*/
      ctx2[2] && /*macroPlay*/
      ctx2[1] === "2")) {
        div3.hidden = div3_hidden_value;
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_in(switch_instance2.$$.fragment, local);
      if (switch_instance3)
        transition_in(switch_instance3.$$.fragment, local);
      if (switch_instance4)
        transition_in(switch_instance4.$$.fragment, local);
      if (switch_instance5)
        transition_in(switch_instance5.$$.fragment, local);
      if (switch_instance6)
        transition_in(switch_instance6.$$.fragment, local);
      if (switch_instance7)
        transition_in(switch_instance7.$$.fragment, local);
      if (switch_instance8)
        transition_in(switch_instance8.$$.fragment, local);
      if (switch_instance9)
        transition_in(switch_instance9.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_out(switch_instance2.$$.fragment, local);
      if (switch_instance3)
        transition_out(switch_instance3.$$.fragment, local);
      if (switch_instance4)
        transition_out(switch_instance4.$$.fragment, local);
      if (switch_instance5)
        transition_out(switch_instance5.$$.fragment, local);
      if (switch_instance6)
        transition_out(switch_instance6.$$.fragment, local);
      if (switch_instance7)
        transition_out(switch_instance7.$$.fragment, local);
      if (switch_instance8)
        transition_out(switch_instance8.$$.fragment, local);
      if (switch_instance9)
        transition_out(switch_instance9.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (switch_instance0)
        destroy_component(switch_instance0, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div0);
      if (switch_instance1)
        destroy_component(switch_instance1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      if (switch_instance2)
        destroy_component(switch_instance2);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div3);
      if (switch_instance3)
        destroy_component(switch_instance3);
      if (switch_instance4)
        destroy_component(switch_instance4);
      if (switch_instance5)
        destroy_component(switch_instance5);
      if (switch_instance6)
        destroy_component(switch_instance6);
      if (switch_instance7)
        destroy_component(switch_instance7);
      if (switch_instance8)
        destroy_component(switch_instance8);
      if (switch_instance9)
        destroy_component(switch_instance9);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let soundOnly;
  let macroEnabled;
  let macroPlay;
  let $animation;
  let { fromMenu = "autorec" } = $$props;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(6, $animation = value));
  let title2 = game.i18n.localize("autoanimations.menus.primary") + " " + game.i18n.localize("autoanimations.menus.animation");
  $$self.$$set = ($$props2) => {
    if ("fromMenu" in $$props2)
      $$invalidate(0, fromMenu = $$props2.fromMenu);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    64) {
      $$invalidate(3, soundOnly = $animation.soundOnly.sound.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    64) {
      $$invalidate(2, macroEnabled = $animation.macro.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    64) {
      $$invalidate(1, macroPlay = $animation.macro.playWhen);
    }
  };
  return [fromMenu, macroPlay, macroEnabled, soundOnly, animation, title2, $animation];
}
class BuildTemplateFX extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$q, create_fragment$s, safe_not_equal, { fromMenu: 0 });
  }
}
function create_fragment$r(ctx) {
  let switch_instance0;
  let t0;
  let div0;
  let switch_instance1;
  let div0_hidden_value;
  let t1;
  let div1;
  let switch_instance2;
  let div1_hidden_value;
  let t2;
  let div3;
  let switch_instance3;
  let t3;
  let div2;
  let switch_instance4;
  let t4;
  let switch_instance5;
  let t5;
  let switch_instance6;
  let t6;
  let switch_instance7;
  let t7;
  let switch_instance8;
  let t8;
  let switch_instance9;
  let div3_hidden_value;
  let current;
  var switch_value = SectionButtons02;
  function switch_props(ctx2) {
    return { props: { type: (
      /*fromMenu*/
      ctx2[0]
    ) } };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
  }
  var switch_value_1 = SoundOnly;
  function switch_props_1(ctx2) {
    return {};
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
  }
  var switch_value_2 = Macro$1;
  function switch_props_2(ctx2) {
    return {};
  }
  if (switch_value_2) {
    switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2());
  }
  var switch_value_3 = ExtraSource;
  function switch_props_3(ctx2) {
    return {};
  }
  if (switch_value_3) {
    switch_instance3 = construct_svelte_component(switch_value_3, switch_props_3());
  }
  var switch_value_4 = VideoSelect;
  function switch_props_4(ctx2) {
    return {
      props: {
        title: (
          /*title*/
          ctx2[5]
        ),
        section: "primary"
      }
    };
  }
  if (switch_value_4) {
    switch_instance4 = construct_svelte_component(switch_value_4, switch_props_4(ctx));
  }
  var switch_value_5 = AuraOptions;
  function switch_props_5(ctx2) {
    return {};
  }
  if (switch_value_5) {
    switch_instance5 = construct_svelte_component(switch_value_5, switch_props_5());
  }
  var switch_value_6 = AuraEffects;
  function switch_props_6(ctx2) {
    return {};
  }
  if (switch_value_6) {
    switch_instance6 = construct_svelte_component(switch_value_6, switch_props_6());
  }
  var switch_value_7 = SoundSettings;
  function switch_props_7(ctx2) {
    return { props: { section: "primary" } };
  }
  if (switch_value_7) {
    switch_instance7 = construct_svelte_component(switch_value_7, switch_props_7());
  }
  var switch_value_8 = Secondary;
  function switch_props_8(ctx2) {
    return {};
  }
  if (switch_value_8) {
    switch_instance8 = construct_svelte_component(switch_value_8, switch_props_8());
  }
  var switch_value_9 = ExtraTarget;
  function switch_props_9(ctx2) {
    return {};
  }
  if (switch_value_9) {
    switch_instance9 = construct_svelte_component(switch_value_9, switch_props_9());
  }
  return {
    c() {
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t0 = space();
      div0 = element("div");
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      t1 = space();
      div1 = element("div");
      if (switch_instance2)
        create_component(switch_instance2.$$.fragment);
      t2 = space();
      div3 = element("div");
      if (switch_instance3)
        create_component(switch_instance3.$$.fragment);
      t3 = space();
      div2 = element("div");
      if (switch_instance4)
        create_component(switch_instance4.$$.fragment);
      t4 = space();
      if (switch_instance5)
        create_component(switch_instance5.$$.fragment);
      t5 = space();
      if (switch_instance6)
        create_component(switch_instance6.$$.fragment);
      t6 = space();
      if (switch_instance7)
        create_component(switch_instance7.$$.fragment);
      t7 = space();
      if (switch_instance8)
        create_component(switch_instance8.$$.fragment);
      t8 = space();
      if (switch_instance9)
        create_component(switch_instance9.$$.fragment);
      div0.hidden = div0_hidden_value = !/*soundOnly*/
      ctx[3];
      div1.hidden = div1_hidden_value = !/*macroEnabled*/
      ctx[2];
      attr(div2, "class", "aa-primary-border");
      div3.hidden = div3_hidden_value = /*soundOnly*/
      ctx[3] || /*macroEnabled*/
      ctx[2] && /*macroPlay*/
      ctx[1] === "2";
    },
    m(target2, anchor) {
      if (switch_instance0)
        mount_component(switch_instance0, target2, anchor);
      insert(target2, t0, anchor);
      insert(target2, div0, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, div0, null);
      insert(target2, t1, anchor);
      insert(target2, div1, anchor);
      if (switch_instance2)
        mount_component(switch_instance2, div1, null);
      insert(target2, t2, anchor);
      insert(target2, div3, anchor);
      if (switch_instance3)
        mount_component(switch_instance3, div3, null);
      append(div3, t3);
      append(div3, div2);
      if (switch_instance4)
        mount_component(switch_instance4, div2, null);
      append(div2, t4);
      if (switch_instance5)
        mount_component(switch_instance5, div2, null);
      append(div2, t5);
      if (switch_instance6)
        mount_component(switch_instance6, div2, null);
      append(div2, t6);
      if (switch_instance7)
        mount_component(switch_instance7, div2, null);
      append(div3, t7);
      if (switch_instance8)
        mount_component(switch_instance8, div3, null);
      append(div3, t8);
      if (switch_instance9)
        mount_component(switch_instance9, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance0_changes = {};
      if (dirty & /*fromMenu*/
      1)
        switch_instance0_changes.type = /*fromMenu*/
        ctx2[0];
      if (switch_value !== (switch_value = SectionButtons02)) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, t0.parentNode, t0);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
        switch_instance0.$set(switch_instance0_changes);
      }
      if (switch_value_1 !== (switch_value_1 = SoundOnly)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, div0, null);
        } else {
          switch_instance1 = null;
        }
      }
      if (!current || dirty & /*soundOnly*/
      8 && div0_hidden_value !== (div0_hidden_value = !/*soundOnly*/
      ctx2[3])) {
        div0.hidden = div0_hidden_value;
      }
      if (switch_value_2 !== (switch_value_2 = Macro$1)) {
        if (switch_instance2) {
          group_outros();
          const old_component = switch_instance2;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_2) {
          switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2());
          create_component(switch_instance2.$$.fragment);
          transition_in(switch_instance2.$$.fragment, 1);
          mount_component(switch_instance2, div1, null);
        } else {
          switch_instance2 = null;
        }
      }
      if (!current || dirty & /*macroEnabled*/
      4 && div1_hidden_value !== (div1_hidden_value = !/*macroEnabled*/
      ctx2[2])) {
        div1.hidden = div1_hidden_value;
      }
      if (switch_value_3 !== (switch_value_3 = ExtraSource)) {
        if (switch_instance3) {
          group_outros();
          const old_component = switch_instance3;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_3) {
          switch_instance3 = construct_svelte_component(switch_value_3, switch_props_3());
          create_component(switch_instance3.$$.fragment);
          transition_in(switch_instance3.$$.fragment, 1);
          mount_component(switch_instance3, div3, t3);
        } else {
          switch_instance3 = null;
        }
      }
      if (switch_value_4 !== (switch_value_4 = VideoSelect)) {
        if (switch_instance4) {
          group_outros();
          const old_component = switch_instance4;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_4) {
          switch_instance4 = construct_svelte_component(switch_value_4, switch_props_4(ctx2));
          create_component(switch_instance4.$$.fragment);
          transition_in(switch_instance4.$$.fragment, 1);
          mount_component(switch_instance4, div2, t4);
        } else {
          switch_instance4 = null;
        }
      }
      if (switch_value_5 !== (switch_value_5 = AuraOptions)) {
        if (switch_instance5) {
          group_outros();
          const old_component = switch_instance5;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_5) {
          switch_instance5 = construct_svelte_component(switch_value_5, switch_props_5());
          create_component(switch_instance5.$$.fragment);
          transition_in(switch_instance5.$$.fragment, 1);
          mount_component(switch_instance5, div2, t5);
        } else {
          switch_instance5 = null;
        }
      }
      if (switch_value_6 !== (switch_value_6 = AuraEffects)) {
        if (switch_instance6) {
          group_outros();
          const old_component = switch_instance6;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_6) {
          switch_instance6 = construct_svelte_component(switch_value_6, switch_props_6());
          create_component(switch_instance6.$$.fragment);
          transition_in(switch_instance6.$$.fragment, 1);
          mount_component(switch_instance6, div2, t6);
        } else {
          switch_instance6 = null;
        }
      }
      if (switch_value_7 !== (switch_value_7 = SoundSettings)) {
        if (switch_instance7) {
          group_outros();
          const old_component = switch_instance7;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_7) {
          switch_instance7 = construct_svelte_component(switch_value_7, switch_props_7());
          create_component(switch_instance7.$$.fragment);
          transition_in(switch_instance7.$$.fragment, 1);
          mount_component(switch_instance7, div2, null);
        } else {
          switch_instance7 = null;
        }
      }
      if (switch_value_8 !== (switch_value_8 = Secondary)) {
        if (switch_instance8) {
          group_outros();
          const old_component = switch_instance8;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_8) {
          switch_instance8 = construct_svelte_component(switch_value_8, switch_props_8());
          create_component(switch_instance8.$$.fragment);
          transition_in(switch_instance8.$$.fragment, 1);
          mount_component(switch_instance8, div3, t8);
        } else {
          switch_instance8 = null;
        }
      }
      if (switch_value_9 !== (switch_value_9 = ExtraTarget)) {
        if (switch_instance9) {
          group_outros();
          const old_component = switch_instance9;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_9) {
          switch_instance9 = construct_svelte_component(switch_value_9, switch_props_9());
          create_component(switch_instance9.$$.fragment);
          transition_in(switch_instance9.$$.fragment, 1);
          mount_component(switch_instance9, div3, null);
        } else {
          switch_instance9 = null;
        }
      }
      if (!current || dirty & /*soundOnly, macroEnabled, macroPlay*/
      14 && div3_hidden_value !== (div3_hidden_value = /*soundOnly*/
      ctx2[3] || /*macroEnabled*/
      ctx2[2] && /*macroPlay*/
      ctx2[1] === "2")) {
        div3.hidden = div3_hidden_value;
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_in(switch_instance2.$$.fragment, local);
      if (switch_instance3)
        transition_in(switch_instance3.$$.fragment, local);
      if (switch_instance4)
        transition_in(switch_instance4.$$.fragment, local);
      if (switch_instance5)
        transition_in(switch_instance5.$$.fragment, local);
      if (switch_instance6)
        transition_in(switch_instance6.$$.fragment, local);
      if (switch_instance7)
        transition_in(switch_instance7.$$.fragment, local);
      if (switch_instance8)
        transition_in(switch_instance8.$$.fragment, local);
      if (switch_instance9)
        transition_in(switch_instance9.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_out(switch_instance2.$$.fragment, local);
      if (switch_instance3)
        transition_out(switch_instance3.$$.fragment, local);
      if (switch_instance4)
        transition_out(switch_instance4.$$.fragment, local);
      if (switch_instance5)
        transition_out(switch_instance5.$$.fragment, local);
      if (switch_instance6)
        transition_out(switch_instance6.$$.fragment, local);
      if (switch_instance7)
        transition_out(switch_instance7.$$.fragment, local);
      if (switch_instance8)
        transition_out(switch_instance8.$$.fragment, local);
      if (switch_instance9)
        transition_out(switch_instance9.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (switch_instance0)
        destroy_component(switch_instance0, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div0);
      if (switch_instance1)
        destroy_component(switch_instance1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      if (switch_instance2)
        destroy_component(switch_instance2);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div3);
      if (switch_instance3)
        destroy_component(switch_instance3);
      if (switch_instance4)
        destroy_component(switch_instance4);
      if (switch_instance5)
        destroy_component(switch_instance5);
      if (switch_instance6)
        destroy_component(switch_instance6);
      if (switch_instance7)
        destroy_component(switch_instance7);
      if (switch_instance8)
        destroy_component(switch_instance8);
      if (switch_instance9)
        destroy_component(switch_instance9);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let soundOnly;
  let macroEnabled;
  let macroPlay;
  let $animation;
  let { fromMenu = "autorec" } = $$props;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(6, $animation = value));
  let title2 = game.i18n.localize("autoanimations.menus.primary") + " " + game.i18n.localize("autoanimations.menus.animation");
  $$self.$$set = ($$props2) => {
    if ("fromMenu" in $$props2)
      $$invalidate(0, fromMenu = $$props2.fromMenu);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    64) {
      $$invalidate(3, soundOnly = $animation.soundOnly.sound.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    64) {
      $$invalidate(2, macroEnabled = $animation.macro.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    64) {
      $$invalidate(1, macroPlay = $animation.macro.playWhen);
    }
  };
  return [fromMenu, macroPlay, macroEnabled, soundOnly, animation, title2, $animation];
}
class BuildAura extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$p, create_fragment$r, safe_not_equal, { fromMenu: 0 });
  }
}
function create_fragment$q(ctx) {
  let div1;
  let label_1;
  let t1;
  let div0;
  let input0;
  let t2;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      label_1 = element("label");
      label_1.textContent = `${/*label*/
      ctx[2]}`;
      t1 = space();
      div0 = element("div");
      input0 = element("input");
      t2 = space();
      input1 = element("input");
      attr(label_1, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "1");
      attr(input0, "min", "0");
      attr(input0, "max", "1");
      attr(input0, "step", "0.01");
      set_style(input1, "border", "none");
      set_style(input1, "background", "none");
      set_style(input1, "margin-left", "3px");
      attr(input1, "type", "range");
      attr(input1, "min", "0");
      attr(input1, "max", "1");
      attr(input1, "step", "0.01");
      set_style(div0, "display", "flex");
      set_style(div0, "margin-right", "1.5em");
      set_style(div0, "margin-left", "1.5em");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label_1);
      append(div1, t1);
      append(div1, div0);
      append(div0, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].data.options.opacity
      );
      append(div0, t2);
      append(div0, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].data.options.opacity
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[3]
          ),
          listen(
            input1,
            "change",
            /*input1_change_input_handler*/
            ctx[4]
          ),
          listen(
            input1,
            "input",
            /*input1_change_input_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$animation*/
      1 && to_number(input0.value) !== /*$animation*/
      ctx2[0].data.options.opacity) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].data.options.opacity
        );
      }
      if (dirty & /*$animation*/
      1) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].data.options.opacity
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const label = game.i18n.localize("autoanimations.menus.effect") + " " + game.i18n.localize("autoanimations.menus.opacity");
  function input0_input_handler() {
    $animation.data.options.opacity = to_number(this.value);
    animation.set($animation);
  }
  function input1_change_input_handler() {
    $animation.data.options.opacity = to_number(this.value);
    animation.set($animation);
  }
  return [
    $animation,
    animation,
    label,
    input0_input_handler,
    input1_change_input_handler
  ];
}
class Opacity02 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$o, create_fragment$q, safe_not_equal, {});
  }
}
function create_default_slot$7(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let opacity;
  let t1;
  let td2;
  let div0;
  let label0;
  let t3;
  let div1;
  let input0;
  let t4;
  let tr1;
  let td3;
  let t5;
  let td4;
  let div2;
  let label1;
  let t6_value = localize("autoanimations.menus.only") + "";
  let t6;
  let t7;
  let t8;
  let input1;
  let div2_class_value;
  let t9;
  let td5;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation$1({
    props: {
      animation: (
        /*animation*/
        ctx[2]
      ),
      section: "data"
    }
  });
  opacity = new Opacity02({
    props: { animation: (
      /*animation*/
      ctx[2]
    ) }
  });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      create_component(opacity.$$.fragment);
      t1 = space();
      td2 = element("td");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t3 = space();
      div1 = element("div");
      input0 = element("input");
      t4 = space();
      tr1 = element("tr");
      td3 = element("td");
      t5 = space();
      td4 = element("td");
      div2 = element("div");
      label1 = element("label");
      t6 = text(t6_value);
      t7 = text(" X");
      t8 = space();
      input1 = element("input");
      t9 = space();
      td5 = element("td");
      attr(label0, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "1");
      attr(input0, "step", ".01");
      attr(label1, "for", "Remove " + /*animation*/
      ctx[2]._data.id);
      attr(input1, "type", "checkbox");
      attr(input1, "id", "Remove " + /*animation*/
      ctx[2]._data.id);
      attr(div2, "class", div2_class_value = !/*isCustom*/
      ctx[1] ? "aa-disableOpacity" : "");
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      mount_component(opacity, td1, null);
      append(tr0, t1);
      append(tr0, td2);
      append(td2, div0);
      append(div0, label0);
      append(td2, t3);
      append(td2, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].data.options.playbackRate
      );
      append(table, t4);
      append(table, tr1);
      append(tr1, td3);
      append(tr1, t5);
      append(tr1, td4);
      append(td4, div2);
      append(div2, label1);
      append(label1, t6);
      append(label1, t7);
      append(div2, t8);
      append(div2, input1);
      input1.checked = /*$animation*/
      ctx[0].data.options.onlyX;
      append(tr1, t9);
      append(tr1, td5);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation*/
      1 && to_number(input0.value) !== /*$animation*/
      ctx2[0].data.options.playbackRate) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].data.options.playbackRate
        );
      }
      if (dirty & /*$animation*/
      1) {
        input1.checked = /*$animation*/
        ctx2[0].data.options.onlyX;
      }
      if (!current || dirty & /*isCustom*/
      2 && div2_class_value !== (div2_class_value = !/*isCustom*/
      ctx2[1] ? "aa-disableOpacity" : "")) {
        attr(div2, "class", div2_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(opacity);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$4(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[4]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[5]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$p(ctx) {
  let div1;
  let videoselect;
  let t0;
  let div0;
  let tjssvgfolder;
  let t1;
  let soundsettings;
  let current;
  videoselect = new VideoSelect({
    props: { title: "Dual Attach", section: "data" }
  });
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[3]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$4],
        default: [create_default_slot$7]
      },
      $$scope: { ctx }
    }
  });
  soundsettings = new SoundSettings({ props: { section: "data" } });
  return {
    c() {
      div1 = element("div");
      create_component(videoselect.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(tjssvgfolder.$$.fragment);
      t1 = space();
      create_component(soundsettings.$$.fragment);
      attr(div0, "class", "aa-options-border");
      attr(div1, "class", "aa-section-border");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      mount_component(videoselect, div1, null);
      append(div1, t0);
      append(div1, div0);
      mount_component(tjssvgfolder, div0, null);
      append(div1, t1);
      mount_component(soundsettings, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, isCustom, $animation*/
      259) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(videoselect.$$.fragment, local);
      transition_in(tjssvgfolder.$$.fragment, local);
      transition_in(soundsettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(videoselect.$$.fragment, local);
      transition_out(tjssvgfolder.$$.fragment, local);
      transition_out(soundsettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(videoselect);
      destroy_component(tjssvgfolder);
      destroy_component(soundsettings);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let isCustom;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    },
    label: game.i18n.localize("autoanimations.menus.options")
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    }
  };
  const click_handler = () => OptionsDialog.show("preset", "dualattach");
  function input0_input_handler() {
    $animation.data.options.playbackRate = to_number(this.value);
    animation.set($animation);
  }
  function input1_change_handler() {
    $animation.data.options.onlyX = this.checked;
    animation.set($animation);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    1) {
      $$invalidate(1, isCustom = $animation.data.video.enableCustom);
    }
  };
  return [
    $animation,
    isCustom,
    animation,
    folder,
    optionsInfo,
    click_handler,
    input0_input_handler,
    input1_change_handler
  ];
}
class DualAttach extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$n, create_fragment$p, safe_not_equal, {});
  }
}
function create_fragment$o(ctx) {
  let div1;
  let label_1;
  let t0;
  let t1;
  let div0;
  let input0;
  let t2;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[2]
      );
      t1 = space();
      div0 = element("div");
      input0 = element("input");
      t2 = space();
      input1 = element("input");
      attr(label_1, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "1");
      attr(input0, "min", "0");
      attr(input0, "max", "1");
      attr(input0, "step", "0.01");
      set_style(input1, "border", "none");
      set_style(input1, "background", "none");
      set_style(input1, "margin-left", "3px");
      attr(input1, "type", "range");
      attr(input1, "min", "0");
      attr(input1, "max", "1");
      attr(input1, "step", "0.01");
      set_style(div0, "display", "flex");
      set_style(div0, "margin-right", "1.5em");
      set_style(div0, "margin-left", "1.5em");
      attr(div1, "class", "flexcol");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, label_1);
      append(label_1, t0);
      append(div1, t1);
      append(div1, div0);
      append(div0, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[3].data[
          /*section*/
          ctx[0]
        ].options[
          /*field*/
          ctx[1]
        ]
      );
      append(div0, t2);
      append(div0, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[3].data[
          /*section*/
          ctx[0]
        ].options[
          /*field*/
          ctx[1]
        ]
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[5]
          ),
          listen(
            input1,
            "change",
            /*input1_change_input_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "input",
            /*input1_change_input_handler*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*label*/
      4)
        set_data(
          t0,
          /*label*/
          ctx2[2]
        );
      if (dirty & /*$animation, section, field*/
      11 && to_number(input0.value) !== /*$animation*/
      ctx2[3].data[
        /*section*/
        ctx2[0]
      ].options[
        /*field*/
        ctx2[1]
      ]) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[3].data[
            /*section*/
            ctx2[0]
          ].options[
            /*field*/
            ctx2[1]
          ]
        );
      }
      if (dirty & /*$animation, section, field*/
      11) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[3].data[
            /*section*/
            ctx2[0]
          ].options[
            /*field*/
            ctx2[1]
          ]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let $animation;
  let { section: section2 } = $$props;
  let { field = "opacity" } = $$props;
  let { label = game.i18n.localize("autoanimations.menus.effect") + " " + game.i18n.localize("autoanimations.menus.opacity") } = $$props;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(3, $animation = value));
  function input0_input_handler() {
    $animation.data[section2].options[field] = to_number(this.value);
    animation.set($animation);
  }
  function input1_change_input_handler() {
    $animation.data[section2].options[field] = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
  };
  return [
    section2,
    field,
    label,
    $animation,
    animation,
    input0_input_handler,
    input1_change_input_handler
  ];
}
class Opacity extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$m, create_fragment$o, safe_not_equal, { section: 0, field: 1, label: 2 });
  }
}
const Elevation_svelte_svelte_type_style_lang = "";
function create_fragment$n(ctx) {
  let div2;
  let div0;
  let label0;
  let t0;
  let label0_for_value;
  let label0_class_value;
  let t1;
  let input0;
  let input0_id_value;
  let t2;
  let label1;
  let t4;
  let div1;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      t0 = text("ABS");
      t1 = space();
      input0 = element("input");
      t2 = space();
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.elevation")}`;
      t4 = space();
      div1 = element("div");
      input1 = element("input");
      attr(label0, "for", label0_for_value = "Relative " + /*section*/
      ctx[0] + " " + /*animation*/
      ctx[3]._data.id);
      set_style(label0, "font-size", "10px");
      attr(label0, "class", label0_class_value = "aaLabelBorder " + /*isAbsolute*/
      (ctx[2] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv");
      attr(input0, "id", input0_id_value = "Relative " + /*section*/
      ctx[0] + " " + /*animation*/
      ctx[3]._data.id);
      attr(input0, "type", "checkbox");
      set_style(input0, "display", "none");
      attr(label1, "for", "");
      set_style(label1, "font-size", "13px");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "1000");
      attr(input1, "step", "1");
    },
    m(target2, anchor) {
      insert(target2, div2, anchor);
      append(div2, div0);
      append(div0, label0);
      append(label0, t0);
      append(div0, t1);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[1].data[
        /*section*/
        ctx[0]
      ].options.isAbsolute;
      append(div0, t2);
      append(div0, label1);
      append(div2, t4);
      append(div2, div1);
      append(div1, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[1].data[
          /*section*/
          ctx[0]
        ].options.elevation
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[4]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*section*/
      1 && label0_for_value !== (label0_for_value = "Relative " + /*section*/
      ctx2[0] + " " + /*animation*/
      ctx2[3]._data.id)) {
        attr(label0, "for", label0_for_value);
      }
      if (dirty & /*isAbsolute*/
      4 && label0_class_value !== (label0_class_value = "aaLabelBorder " + /*isAbsolute*/
      (ctx2[2] ? "aaIsSelected" : "") + " svelte-auto-bsgjrv")) {
        attr(label0, "class", label0_class_value);
      }
      if (dirty & /*section*/
      1 && input0_id_value !== (input0_id_value = "Relative " + /*section*/
      ctx2[0] + " " + /*animation*/
      ctx2[3]._data.id)) {
        attr(input0, "id", input0_id_value);
      }
      if (dirty & /*$animation, section*/
      3) {
        input0.checked = /*$animation*/
        ctx2[1].data[
          /*section*/
          ctx2[0]
        ].options.isAbsolute;
      }
      if (dirty & /*$animation, section*/
      3 && to_number(input1.value) !== /*$animation*/
      ctx2[1].data[
        /*section*/
        ctx2[0]
      ].options.elevation) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[1].data[
            /*section*/
            ctx2[0]
          ].options.elevation
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let isAbsolute;
  let $animation;
  let { section: section2 = "primary" } = $$props;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(1, $animation = value));
  function input0_change_handler() {
    $animation.data[section2].options.isAbsolute = this.checked;
    animation.set($animation);
  }
  function input1_input_handler() {
    $animation.data[section2].options.elevation = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation, section*/
    3) {
      $$invalidate(2, isAbsolute = $animation.data[section2].options.isAbsolute);
    }
  };
  return [
    section2,
    $animation,
    isAbsolute,
    animation,
    input0_change_handler,
    input1_input_handler
  ];
}
class Elevation extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$l, create_fragment$n, safe_not_equal, { section: 0 });
  }
}
const ProjectileToTemplate_svelte_svelte_type_style_lang = "";
function create_default_slot_4$1(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let div0;
  let label0;
  let t2;
  let div1;
  let input0;
  let t3;
  let td2;
  let div2;
  let label1;
  let t7;
  let div3;
  let input1;
  let t8;
  let tr1;
  let td3;
  let div4;
  let label2;
  let t9_value = localize("autoanimations.menus.remove") + "";
  let t9;
  let t10;
  let input2;
  let t11;
  let td4;
  let div5;
  let label3;
  let t13;
  let div6;
  let input3;
  let t14;
  let td5;
  let opacity;
  let t15;
  let tr2;
  let td6;
  let div7;
  let label4;
  let t16_value = localize("autoanimations.menus.randomOffset") + "";
  let t16;
  let t17;
  let input4;
  let t18;
  let td7;
  let div8;
  let label5;
  let t20;
  let div9;
  let input5;
  let t21;
  let td8;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation({ props: { section: "projectile" } });
  opacity = new Opacity({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      section: "projectile"
    }
  });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.repeat")}`;
      t2 = space();
      div1 = element("div");
      input0 = element("input");
      t3 = space();
      td2 = element("td");
      div2 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t7 = space();
      div3 = element("div");
      input1 = element("input");
      t8 = space();
      tr1 = element("tr");
      td3 = element("td");
      div4 = element("div");
      label2 = element("label");
      t9 = text(t9_value);
      t10 = space();
      input2 = element("input");
      t11 = space();
      td4 = element("td");
      div5 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.wait")}`;
      t13 = space();
      div6 = element("div");
      input3 = element("input");
      t14 = space();
      td5 = element("td");
      create_component(opacity.$$.fragment);
      t15 = space();
      tr2 = element("tr");
      td6 = element("td");
      div7 = element("div");
      label4 = element("label");
      t16 = text(t16_value);
      t17 = space();
      input4 = element("input");
      t18 = space();
      td7 = element("td");
      div8 = element("div");
      label5 = element("label");
      label5.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t20 = space();
      div9 = element("div");
      input5 = element("input");
      t21 = space();
      td8 = element("td");
      attr(label0, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "1");
      attr(input0, "step", "1");
      attr(label1, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "1");
      attr(input1, "step", "1");
      attr(label2, "for", "Remove " + /*animation*/
      ctx[1]._data.id);
      attr(input2, "type", "checkbox");
      attr(input2, "id", "Remove " + /*animation*/
      ctx[1]._data.id);
      attr(label3, "for", "");
      attr(input3, "type", "number");
      attr(input3, "placeholder", "1");
      attr(input3, "step", "1");
      attr(label4, "for", "RandomOffset " + /*animation*/
      ctx[1]._data.id);
      attr(input4, "type", "checkbox");
      attr(input4, "id", "RandomOffset " + /*animation*/
      ctx[1]._data.id);
      attr(label5, "for", "");
      attr(input5, "type", "number");
      attr(input5, "placeholder", "1");
      attr(input5, "step", ".01");
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      append(td1, div0);
      append(div0, label0);
      append(td1, t2);
      append(td1, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].data.projectile.options.repeat
      );
      append(tr0, t3);
      append(tr0, td2);
      append(td2, div2);
      append(div2, label1);
      append(td2, t7);
      append(td2, div3);
      append(div3, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].data.projectile.options.repeatDelay
      );
      append(table, t8);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div4);
      append(div4, label2);
      append(label2, t9);
      append(div4, t10);
      append(div4, input2);
      input2.checked = /*$animation*/
      ctx[0].data.projectile.options.removeTemplate;
      append(tr1, t11);
      append(tr1, td4);
      append(td4, div5);
      append(div5, label3);
      append(td4, t13);
      append(td4, div6);
      append(div6, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[0].data.projectile.options.wait
      );
      append(tr1, t14);
      append(tr1, td5);
      mount_component(opacity, td5, null);
      append(table, t15);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div7);
      append(div7, label4);
      append(label4, t16);
      append(div7, t17);
      append(div7, input4);
      input4.checked = /*$animation*/
      ctx[0].data.projectile.options.randomOffset;
      append(tr2, t18);
      append(tr2, td7);
      append(td7, div8);
      append(div8, label5);
      append(td7, t20);
      append(td7, div9);
      append(div9, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[0].data.projectile.options.playbackRate
      );
      append(tr2, t21);
      append(tr2, td8);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[9]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[10]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[11]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[12]
          ),
          listen(
            input4,
            "change",
            /*input4_change_handler*/
            ctx[13]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1 && to_number(input0.value) !== /*$animation*/
      ctx2[0].data.projectile.options.repeat) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].data.projectile.options.repeat
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input1.value) !== /*$animation*/
      ctx2[0].data.projectile.options.repeatDelay) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].data.projectile.options.repeatDelay
        );
      }
      if (dirty[0] & /*$animation*/
      1) {
        input2.checked = /*$animation*/
        ctx2[0].data.projectile.options.removeTemplate;
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input3.value) !== /*$animation*/
      ctx2[0].data.projectile.options.wait) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[0].data.projectile.options.wait
        );
      }
      if (dirty[0] & /*$animation*/
      1) {
        input4.checked = /*$animation*/
        ctx2[0].data.projectile.options.randomOffset;
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input5.value) !== /*$animation*/
      ctx2[0].data.projectile.options.playbackRate) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[0].data.projectile.options.playbackRate
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(opacity);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot_2$1(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[4]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[8]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_default_slot_3$1(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let div0;
  let label0;
  let t2;
  let div1;
  let input0;
  let t3;
  let td2;
  let div2;
  let label1;
  let t7;
  let div3;
  let input1;
  let t8;
  let tr1;
  let td3;
  let div4;
  let label2;
  let t10;
  let div5;
  let input2;
  let t11;
  let td4;
  let div6;
  let label3;
  let t13;
  let div7;
  let input3;
  let t14;
  let td5;
  let opacity;
  let t15;
  let tr2;
  let td6;
  let div8;
  let label4;
  let t16_value = localize("autoanimations.variants.above") + "";
  let t16;
  let t17;
  let t18_value = localize("autoanimations.animTypes.templatefx") + "";
  let t18;
  let t19;
  let input4;
  let t20;
  let td7;
  let div9;
  let label5;
  let t22;
  let div10;
  let input5;
  let t23;
  let td8;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation({ props: { section: "preExplosion" } });
  opacity = new Opacity({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      section: "preExplosion"
    }
  });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.repeat")}`;
      t2 = space();
      div1 = element("div");
      input0 = element("input");
      t3 = space();
      td2 = element("td");
      div2 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t7 = space();
      div3 = element("div");
      input1 = element("input");
      t8 = space();
      tr1 = element("tr");
      td3 = element("td");
      div4 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.scale")}`;
      t10 = space();
      div5 = element("div");
      input2 = element("input");
      t11 = space();
      td4 = element("td");
      div6 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.wait")}`;
      t13 = space();
      div7 = element("div");
      input3 = element("input");
      t14 = space();
      td5 = element("td");
      create_component(opacity.$$.fragment);
      t15 = space();
      tr2 = element("tr");
      td6 = element("td");
      div8 = element("div");
      label4 = element("label");
      t16 = text(t16_value);
      t17 = space();
      t18 = text(t18_value);
      t19 = space();
      input4 = element("input");
      t20 = space();
      td7 = element("td");
      div9 = element("div");
      label5 = element("label");
      label5.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t22 = space();
      div10 = element("div");
      input5 = element("input");
      t23 = space();
      td8 = element("td");
      attr(label0, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "1");
      attr(input0, "step", "1");
      attr(label1, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "1");
      attr(input1, "step", "1");
      attr(label2, "for", "");
      attr(input2, "type", "number");
      attr(input2, "placeholder", "1");
      attr(input2, "step", ".01");
      attr(label3, "for", "");
      attr(input3, "type", "number");
      attr(input3, "placeholder", "1");
      attr(input3, "step", "1");
      attr(label4, "for", "aboveTemplatePre " + /*animation*/
      ctx[1]._data.id);
      attr(input4, "type", "checkbox");
      attr(input4, "id", "aboveTemplatePre " + /*animation*/
      ctx[1]._data.id);
      attr(label5, "for", "");
      attr(input5, "type", "number");
      attr(input5, "placeholder", "1");
      attr(input5, "step", ".01");
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      append(td1, div0);
      append(div0, label0);
      append(td1, t2);
      append(td1, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].data.preExplosion.options.repeat
      );
      append(tr0, t3);
      append(tr0, td2);
      append(td2, div2);
      append(div2, label1);
      append(td2, t7);
      append(td2, div3);
      append(div3, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].data.preExplosion.options.repeatDelay
      );
      append(table, t8);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div4);
      append(div4, label2);
      append(td3, t10);
      append(td3, div5);
      append(div5, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].data.preExplosion.options.scale
      );
      append(tr1, t11);
      append(tr1, td4);
      append(td4, div6);
      append(div6, label3);
      append(td4, t13);
      append(td4, div7);
      append(div7, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[0].data.preExplosion.options.wait
      );
      append(tr1, t14);
      append(tr1, td5);
      mount_component(opacity, td5, null);
      append(table, t15);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div8);
      append(div8, label4);
      append(label4, t16);
      append(label4, t17);
      append(label4, t18);
      append(div8, t19);
      append(div8, input4);
      input4.checked = /*$animation*/
      ctx[0].data.preExplosion.options.aboveTemplate;
      append(tr2, t20);
      append(tr2, td7);
      append(td7, div9);
      append(div9, label5);
      append(td7, t22);
      append(td7, div10);
      append(div10, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[0].data.preExplosion.options.playbackRate
      );
      append(tr2, t23);
      append(tr2, td8);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler_1*/
            ctx[16]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler_1*/
            ctx[17]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[18]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler_1*/
            ctx[19]
          ),
          listen(
            input4,
            "change",
            /*input4_change_handler_1*/
            ctx[20]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler_1*/
            ctx[21]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1 && to_number(input0.value) !== /*$animation*/
      ctx2[0].data.preExplosion.options.repeat) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].data.preExplosion.options.repeat
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input1.value) !== /*$animation*/
      ctx2[0].data.preExplosion.options.repeatDelay) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].data.preExplosion.options.repeatDelay
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input2.value) !== /*$animation*/
      ctx2[0].data.preExplosion.options.scale) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].data.preExplosion.options.scale
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input3.value) !== /*$animation*/
      ctx2[0].data.preExplosion.options.wait) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[0].data.preExplosion.options.wait
        );
      }
      if (dirty[0] & /*$animation*/
      1) {
        input4.checked = /*$animation*/
        ctx2[0].data.preExplosion.options.aboveTemplate;
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input5.value) !== /*$animation*/
      ctx2[0].data.preExplosion.options.playbackRate) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[0].data.preExplosion.options.playbackRate
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(opacity);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let div1;
  let videoselect;
  let t0;
  let div0;
  let tjssvgfolder;
  let t1;
  let soundsettings;
  let div1_class_value;
  let current;
  videoselect = new VideoSelect({
    props: {
      section: "data",
      section02: "preExplosion",
      title: "Pre Explosion"
    }
  });
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  soundsettings = new SoundSettingsNested({
    props: {
      section: "data",
      section02: "preExplosion"
    }
  });
  return {
    c() {
      div1 = element("div");
      create_component(videoselect.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(tjssvgfolder.$$.fragment);
      t1 = space();
      create_component(soundsettings.$$.fragment);
      attr(div0, "class", "aa-options-border");
      attr(div1, "class", div1_class_value = /*$animation*/
      ctx[0].data.preExplosion.enable ? "" : "aa-disableOpacity");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      mount_component(videoselect, div1, null);
      append(div1, t0);
      append(div1, div0);
      mount_component(tjssvgfolder, div0, null);
      append(div1, t1);
      mount_component(soundsettings, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tjssvgfolder_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
      if (!current || dirty[0] & /*$animation*/
      1 && div1_class_value !== (div1_class_value = /*$animation*/
      ctx2[0].data.preExplosion.enable ? "" : "aa-disableOpacity")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(videoselect.$$.fragment, local);
      transition_in(tjssvgfolder.$$.fragment, local);
      transition_in(soundsettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(videoselect.$$.fragment, local);
      transition_out(tjssvgfolder.$$.fragment, local);
      transition_out(soundsettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(videoselect);
      destroy_component(tjssvgfolder);
      destroy_component(soundsettings);
    }
  };
}
function create_summary_end_slot_1$1(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Source FX On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[0].data.preExplosion.enable;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[15]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1) {
        input.checked = /*$animation*/
        ctx2[0].data.preExplosion.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$2(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let div0;
  let label0;
  let t2;
  let div1;
  let input0;
  let t3;
  let td2;
  let div2;
  let label1;
  let t7;
  let div3;
  let input1;
  let t8;
  let tr1;
  let td3;
  let div4;
  let label2;
  let t10;
  let div5;
  let input2;
  let t11;
  let td4;
  let div6;
  let label3;
  let t13;
  let div7;
  let input3;
  let t14;
  let td5;
  let opacity;
  let t15;
  let tr2;
  let td6;
  let div8;
  let label4;
  let t16_value = localize("autoanimations.variants.above") + "";
  let t16;
  let t17;
  let t18_value = localize("autoanimations.animTypes.templatefx") + "";
  let t18;
  let t19;
  let input4;
  let t20;
  let td7;
  let div9;
  let label5;
  let t22;
  let div10;
  let input5;
  let t23;
  let td8;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation({ props: { section: "explosion" } });
  opacity = new Opacity({
    props: {
      animation: (
        /*animation*/
        ctx[1]
      ),
      section: "explosion"
    }
  });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.repeat")}`;
      t2 = space();
      div1 = element("div");
      input0 = element("input");
      t3 = space();
      td2 = element("td");
      div2 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.repeat")}  ${localize("autoanimations.menus.delay")}`;
      t7 = space();
      div3 = element("div");
      input1 = element("input");
      t8 = space();
      tr1 = element("tr");
      td3 = element("td");
      div4 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.scale")}`;
      t10 = space();
      div5 = element("div");
      input2 = element("input");
      t11 = space();
      td4 = element("td");
      div6 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.wait")}`;
      t13 = space();
      div7 = element("div");
      input3 = element("input");
      t14 = space();
      td5 = element("td");
      create_component(opacity.$$.fragment);
      t15 = space();
      tr2 = element("tr");
      td6 = element("td");
      div8 = element("div");
      label4 = element("label");
      t16 = text(t16_value);
      t17 = space();
      t18 = text(t18_value);
      t19 = space();
      input4 = element("input");
      t20 = space();
      td7 = element("td");
      div9 = element("div");
      label5 = element("label");
      label5.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t22 = space();
      div10 = element("div");
      input5 = element("input");
      t23 = space();
      td8 = element("td");
      attr(label0, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "1");
      attr(input0, "step", "1");
      attr(label1, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "1");
      attr(input1, "step", "1");
      attr(label2, "for", "");
      attr(input2, "type", "number");
      attr(input2, "placeholder", "1");
      attr(input2, "step", ".01");
      attr(label3, "for", "");
      attr(input3, "type", "number");
      attr(input3, "placeholder", "1");
      attr(input3, "step", "1");
      attr(label4, "for", "aboveTemplateExp " + /*animation*/
      ctx[1]._data.id);
      attr(input4, "type", "checkbox");
      attr(input4, "id", "aboveTemplateExp " + /*animation*/
      ctx[1]._data.id);
      attr(label5, "for", "");
      attr(input5, "type", "number");
      attr(input5, "placeholder", "1");
      attr(input5, "step", ".01");
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      append(td1, div0);
      append(div0, label0);
      append(td1, t2);
      append(td1, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].data.explosion.options.repeat
      );
      append(tr0, t3);
      append(tr0, td2);
      append(td2, div2);
      append(div2, label1);
      append(td2, t7);
      append(td2, div3);
      append(div3, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].data.explosion.options.repeatDelay
      );
      append(table, t8);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div4);
      append(div4, label2);
      append(td3, t10);
      append(td3, div5);
      append(div5, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].data.explosion.options.scale
      );
      append(tr1, t11);
      append(tr1, td4);
      append(td4, div6);
      append(div6, label3);
      append(td4, t13);
      append(td4, div7);
      append(div7, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[0].data.explosion.options.wait
      );
      append(tr1, t14);
      append(tr1, td5);
      mount_component(opacity, td5, null);
      append(table, t15);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div8);
      append(div8, label4);
      append(label4, t16);
      append(label4, t17);
      append(label4, t18);
      append(div8, t19);
      append(div8, input4);
      input4.checked = /*$animation*/
      ctx[0].data.explosion.options.aboveTemplate;
      append(tr2, t20);
      append(tr2, td7);
      append(td7, div9);
      append(div9, label5);
      append(td7, t22);
      append(td7, div10);
      append(div10, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[0].data.explosion.options.playbackRate
      );
      append(tr2, t23);
      append(tr2, td8);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler_2*/
            ctx[22]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler_2*/
            ctx[23]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler_1*/
            ctx[24]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler_2*/
            ctx[25]
          ),
          listen(
            input4,
            "change",
            /*input4_change_handler_2*/
            ctx[26]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler_2*/
            ctx[27]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1 && to_number(input0.value) !== /*$animation*/
      ctx2[0].data.explosion.options.repeat) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].data.explosion.options.repeat
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input1.value) !== /*$animation*/
      ctx2[0].data.explosion.options.repeatDelay) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].data.explosion.options.repeatDelay
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input2.value) !== /*$animation*/
      ctx2[0].data.explosion.options.scale) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].data.explosion.options.scale
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input3.value) !== /*$animation*/
      ctx2[0].data.explosion.options.wait) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[0].data.explosion.options.wait
        );
      }
      if (dirty[0] & /*$animation*/
      1) {
        input4.checked = /*$animation*/
        ctx2[0].data.explosion.options.aboveTemplate;
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input5.value) !== /*$animation*/
      ctx2[0].data.explosion.options.playbackRate) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[0].data.explosion.options.playbackRate
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(opacity);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$6(ctx) {
  let sectionheader;
  let t0;
  let div7;
  let div2;
  let div0;
  let input0;
  let t1;
  let div1;
  let i0;
  let t2;
  let i1;
  let t3;
  let div6;
  let table;
  let tr;
  let td0;
  let elevation;
  let t4;
  let td1;
  let div3;
  let label0;
  let t5_value = localize("autoanimations.menus.persistant") + "";
  let t5;
  let t6;
  let input1;
  let t7;
  let td2;
  let div4;
  let label1;
  let t9;
  let div5;
  let input2;
  let div7_class_value;
  let current;
  let mounted;
  let dispose;
  sectionheader = new SectionHeader({ props: { title: "After Image" } });
  elevation = new Elevation({ props: { section: "afterImage" } });
  return {
    c() {
      create_component(sectionheader.$$.fragment);
      t0 = space();
      div7 = element("div");
      div2 = element("div");
      div0 = element("div");
      input0 = element("input");
      t1 = space();
      div1 = element("div");
      i0 = element("i");
      t2 = space();
      i1 = element("i");
      t3 = space();
      div6 = element("div");
      table = element("table");
      tr = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t4 = space();
      td1 = element("td");
      div3 = element("div");
      label0 = element("label");
      t5 = text(t5_value);
      t6 = space();
      input1 = element("input");
      t7 = space();
      td2 = element("td");
      div4 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.scale")}`;
      t9 = space();
      div5 = element("div");
      input2 = element("input");
      attr(input0, "type", "text");
      set_style(input0, "font-weight", "normal");
      set_style(input0, "font-size", "small");
      set_style(input0, "border-radius", "5px");
      set_style(input0, "border", "1px solid grey");
      attr(div0, "class", "aa-custom");
      set_style(div0, "grid-row", "1/2");
      set_style(div0, "grid-column", "1/4");
      set_style(div0, "padding-top", "5px");
      attr(i0, "class", "fas fa-file-import");
      attr(i0, "title", "File Picker");
      set_style(i0, "font-size", "1.5em");
      attr(i0, "role", "presentation");
      attr(i1, "class", "fas fa-database");
      attr(i1, "title", "Sequencer Database Viewer");
      set_style(i1, "font-size", "1.5em");
      set_style(i1, "margin-left", "10px");
      attr(i1, "role", "presentation");
      attr(div1, "class", "aa-custom");
      set_style(div1, "grid-row", "1/2");
      set_style(div1, "grid-column", "4/5");
      attr(div2, "class", "aa-customAnim-container svelte-auto-1imdkug");
      attr(label0, "for", "Persist " + /*animation*/
      ctx[1]._data.id);
      attr(input1, "type", "checkbox");
      attr(input1, "id", "Persist " + /*animation*/
      ctx[1]._data.id);
      attr(label1, "for", "");
      attr(input2, "type", "number");
      attr(input2, "placeholder", "1");
      attr(input2, "step", ".01");
      attr(table, "class", "d");
      attr(div6, "class", "aa-options-border");
      attr(div7, "class", div7_class_value = /*$animation*/
      ctx[0].data.afterImage.enable ? "" : "aa-disableOpacity");
    },
    m(target2, anchor) {
      mount_component(sectionheader, target2, anchor);
      insert(target2, t0, anchor);
      insert(target2, div7, anchor);
      append(div7, div2);
      append(div2, div0);
      append(div0, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].data.afterImage.customPath
      );
      append(div2, t1);
      append(div2, div1);
      append(div1, i0);
      append(div1, t2);
      append(div1, i1);
      append(div7, t3);
      append(div7, div6);
      append(div6, table);
      append(table, tr);
      append(tr, td0);
      mount_component(elevation, td0, null);
      append(tr, t4);
      append(tr, td1);
      append(td1, div3);
      append(div3, label0);
      append(label0, t5);
      append(div3, t6);
      append(div3, input1);
      input1.checked = /*$animation*/
      ctx[0].data.afterImage.options.persistent;
      append(tr, t7);
      append(tr, td2);
      append(td2, div4);
      append(div4, label1);
      append(td2, t9);
      append(td2, div5);
      append(div5, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].data.afterImage.options.scale
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler_3*/
            ctx[29]
          ),
          listen(i0, "click", prevent_default(
            /*click_handler_1*/
            ctx[30]
          )),
          listen(i1, "click", prevent_default(
            /*click_handler_2*/
            ctx[31]
          )),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[32]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler_2*/
            ctx[33]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1 && input0.value !== /*$animation*/
      ctx2[0].data.afterImage.customPath) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].data.afterImage.customPath
        );
      }
      if (dirty[0] & /*$animation*/
      1) {
        input1.checked = /*$animation*/
        ctx2[0].data.afterImage.options.persistent;
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input2.value) !== /*$animation*/
      ctx2[0].data.afterImage.options.scale) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].data.afterImage.options.scale
        );
      }
      if (!current || dirty[0] & /*$animation*/
      1 && div7_class_value !== (div7_class_value = /*$animation*/
      ctx2[0].data.afterImage.enable ? "" : "aa-disableOpacity")) {
        attr(div7, "class", div7_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sectionheader.$$.fragment, local);
      transition_in(elevation.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sectionheader.$$.fragment, local);
      transition_out(elevation.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sectionheader, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div7);
      destroy_component(elevation);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$3(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Source FX On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[0].data.afterImage.enable;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_1*/
          ctx[28]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1) {
        input.checked = /*$animation*/
        ctx2[0].data.afterImage.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$m(ctx) {
  let div1;
  let videoselect0;
  let t0;
  let div0;
  let tjssvgfolder0;
  let t1;
  let soundsettings0;
  let t2;
  let div2;
  let tjssvgfolder1;
  let t3;
  let div4;
  let videoselect1;
  let t4;
  let div3;
  let tjssvgfolder2;
  let t5;
  let soundsettings1;
  let t6;
  let div5;
  let tjssvgfolder3;
  let t7;
  let switch_instance0;
  let t8;
  let switch_instance1;
  let switch_instance1_anchor;
  let current;
  videoselect0 = new VideoSelect({
    props: {
      section: "data",
      section02: "projectile",
      title: "Projectile"
    }
  });
  tjssvgfolder0 = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[5]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot_2$1],
        default: [create_default_slot_4$1]
      },
      $$scope: { ctx }
    }
  });
  soundsettings0 = new SoundSettingsNested({
    props: { section: "data", section02: "projectile" }
  });
  tjssvgfolder1 = new TJSSvgFolder({
    props: {
      folder: (
        /*preExplode*/
        ctx[7]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot_1$1],
        default: [create_default_slot_2$1]
      },
      $$scope: { ctx }
    }
  });
  videoselect1 = new VideoSelect({
    props: {
      section: "data",
      section02: "explosion",
      title: "Primary Explosion"
    }
  });
  tjssvgfolder2 = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  soundsettings1 = new SoundSettingsNested({
    props: { section: "data", section02: "explosion" }
  });
  tjssvgfolder3 = new TJSSvgFolder({
    props: {
      folder: (
        /*afterImage*/
        ctx[6]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$3],
        default: [create_default_slot$6]
      },
      $$scope: { ctx }
    }
  });
  var switch_value = Secondary;
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props());
  }
  var switch_value_1 = ExtraTarget;
  function switch_props_1(ctx2) {
    return {};
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
  }
  return {
    c() {
      div1 = element("div");
      create_component(videoselect0.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(tjssvgfolder0.$$.fragment);
      t1 = space();
      create_component(soundsettings0.$$.fragment);
      t2 = space();
      div2 = element("div");
      create_component(tjssvgfolder1.$$.fragment);
      t3 = space();
      div4 = element("div");
      create_component(videoselect1.$$.fragment);
      t4 = space();
      div3 = element("div");
      create_component(tjssvgfolder2.$$.fragment);
      t5 = space();
      create_component(soundsettings1.$$.fragment);
      t6 = space();
      div5 = element("div");
      create_component(tjssvgfolder3.$$.fragment);
      t7 = space();
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t8 = space();
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      switch_instance1_anchor = empty();
      attr(div0, "class", "aa-options-border");
      attr(div1, "class", "aa-section-border");
      attr(div2, "class", "aa-section-border");
      attr(div3, "class", "aa-options-border");
      attr(div4, "class", "aa-section-border");
      attr(div5, "class", "aa-section-border");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      mount_component(videoselect0, div1, null);
      append(div1, t0);
      append(div1, div0);
      mount_component(tjssvgfolder0, div0, null);
      append(div1, t1);
      mount_component(soundsettings0, div1, null);
      insert(target2, t2, anchor);
      insert(target2, div2, anchor);
      mount_component(tjssvgfolder1, div2, null);
      insert(target2, t3, anchor);
      insert(target2, div4, anchor);
      mount_component(videoselect1, div4, null);
      append(div4, t4);
      append(div4, div3);
      mount_component(tjssvgfolder2, div3, null);
      append(div4, t5);
      mount_component(soundsettings1, div4, null);
      insert(target2, t6, anchor);
      insert(target2, div5, anchor);
      mount_component(tjssvgfolder3, div5, null);
      insert(target2, t7, anchor);
      if (switch_instance0)
        mount_component(switch_instance0, target2, anchor);
      insert(target2, t8, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, target2, anchor);
      insert(target2, switch_instance1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjssvgfolder0_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder0.$set(tjssvgfolder0_changes);
      const tjssvgfolder1_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder1.$set(tjssvgfolder1_changes);
      const tjssvgfolder2_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder2.$set(tjssvgfolder2_changes);
      const tjssvgfolder3_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder3.$set(tjssvgfolder3_changes);
      if (switch_value !== (switch_value = Secondary)) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, t8.parentNode, t8);
        } else {
          switch_instance0 = null;
        }
      }
      if (switch_value_1 !== (switch_value_1 = ExtraTarget)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1());
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, switch_instance1_anchor.parentNode, switch_instance1_anchor);
        } else {
          switch_instance1 = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(videoselect0.$$.fragment, local);
      transition_in(tjssvgfolder0.$$.fragment, local);
      transition_in(soundsettings0.$$.fragment, local);
      transition_in(tjssvgfolder1.$$.fragment, local);
      transition_in(videoselect1.$$.fragment, local);
      transition_in(tjssvgfolder2.$$.fragment, local);
      transition_in(soundsettings1.$$.fragment, local);
      transition_in(tjssvgfolder3.$$.fragment, local);
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(videoselect0.$$.fragment, local);
      transition_out(tjssvgfolder0.$$.fragment, local);
      transition_out(soundsettings0.$$.fragment, local);
      transition_out(tjssvgfolder1.$$.fragment, local);
      transition_out(videoselect1.$$.fragment, local);
      transition_out(tjssvgfolder2.$$.fragment, local);
      transition_out(soundsettings1.$$.fragment, local);
      transition_out(tjssvgfolder3.$$.fragment, local);
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(videoselect0);
      destroy_component(tjssvgfolder0);
      destroy_component(soundsettings0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div2);
      destroy_component(tjssvgfolder1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div4);
      destroy_component(videoselect1);
      destroy_component(tjssvgfolder2);
      destroy_component(soundsettings1);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(div5);
      destroy_component(tjssvgfolder3);
      if (detaching)
        detach(t7);
      if (switch_instance0)
        destroy_component(switch_instance0, detaching);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(switch_instance1_anchor);
      if (switch_instance1)
        destroy_component(switch_instance1, detaching);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let $animation;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const styling = {
    "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
    "--tjs-summary-font-size": "1.1em",
    "--tjs-summary-chevron-size": "0.7em"
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    }
  };
  const folder = {
    styles: styling,
    label: game.i18n.localize("autoanimations.menus.options")
  };
  const afterImage = {
    styles: styling,
    label: "After Image/Video"
  };
  const preExplode = { styles: styling, label: "Pre Explosion" };
  const click_handler = () => OptionsDialog.show("preset", "proToTemp");
  function input0_input_handler() {
    $animation.data.projectile.options.repeat = to_number(this.value);
    animation.set($animation);
  }
  function input1_input_handler() {
    $animation.data.projectile.options.repeatDelay = to_number(this.value);
    animation.set($animation);
  }
  function input2_change_handler() {
    $animation.data.projectile.options.removeTemplate = this.checked;
    animation.set($animation);
  }
  function input3_input_handler() {
    $animation.data.projectile.options.wait = to_number(this.value);
    animation.set($animation);
  }
  function input4_change_handler() {
    $animation.data.projectile.options.randomOffset = this.checked;
    animation.set($animation);
  }
  function input5_input_handler() {
    $animation.data.projectile.options.playbackRate = to_number(this.value);
    animation.set($animation);
  }
  function input_change_handler() {
    $animation.data.preExplosion.enable = this.checked;
    animation.set($animation);
  }
  function input0_input_handler_1() {
    $animation.data.preExplosion.options.repeat = to_number(this.value);
    animation.set($animation);
  }
  function input1_input_handler_1() {
    $animation.data.preExplosion.options.repeatDelay = to_number(this.value);
    animation.set($animation);
  }
  function input2_input_handler() {
    $animation.data.preExplosion.options.scale = to_number(this.value);
    animation.set($animation);
  }
  function input3_input_handler_1() {
    $animation.data.preExplosion.options.wait = to_number(this.value);
    animation.set($animation);
  }
  function input4_change_handler_1() {
    $animation.data.preExplosion.options.aboveTemplate = this.checked;
    animation.set($animation);
  }
  function input5_input_handler_1() {
    $animation.data.preExplosion.options.playbackRate = to_number(this.value);
    animation.set($animation);
  }
  function input0_input_handler_2() {
    $animation.data.explosion.options.repeat = to_number(this.value);
    animation.set($animation);
  }
  function input1_input_handler_2() {
    $animation.data.explosion.options.repeatDelay = to_number(this.value);
    animation.set($animation);
  }
  function input2_input_handler_1() {
    $animation.data.explosion.options.scale = to_number(this.value);
    animation.set($animation);
  }
  function input3_input_handler_2() {
    $animation.data.explosion.options.wait = to_number(this.value);
    animation.set($animation);
  }
  function input4_change_handler_2() {
    $animation.data.explosion.options.aboveTemplate = this.checked;
    animation.set($animation);
  }
  function input5_input_handler_2() {
    $animation.data.explosion.options.playbackRate = to_number(this.value);
    animation.set($animation);
  }
  function input_change_handler_1() {
    $animation.data.afterImage.enable = this.checked;
    animation.set($animation);
  }
  function input0_input_handler_3() {
    $animation.data.afterImage.customPath = this.value;
    animation.set($animation);
  }
  const click_handler_1 = () => category.selectCustom("data", "afterImage", idx);
  const click_handler_2 = () => category.openSequencerViewer();
  function input1_change_handler() {
    $animation.data.afterImage.options.persistent = this.checked;
    animation.set($animation);
  }
  function input2_input_handler_2() {
    $animation.data.afterImage.options.scale = to_number(this.value);
    animation.set($animation);
  }
  return [
    $animation,
    animation,
    category,
    idx,
    optionsInfo,
    folder,
    afterImage,
    preExplode,
    click_handler,
    input0_input_handler,
    input1_input_handler,
    input2_change_handler,
    input3_input_handler,
    input4_change_handler,
    input5_input_handler,
    input_change_handler,
    input0_input_handler_1,
    input1_input_handler_1,
    input2_input_handler,
    input3_input_handler_1,
    input4_change_handler_1,
    input5_input_handler_1,
    input0_input_handler_2,
    input1_input_handler_2,
    input2_input_handler_1,
    input3_input_handler_2,
    input4_change_handler_2,
    input5_input_handler_2,
    input_change_handler_1,
    input0_input_handler_3,
    click_handler_1,
    click_handler_2,
    input1_change_handler,
    input2_input_handler_2
  ];
}
class ProjectileToTemplate extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$k, create_fragment$m, safe_not_equal, {}, null, [-1, -1]);
  }
}
const ScaleRadius_svelte_svelte_type_style_lang = "";
function create_fragment$l(ctx) {
  let div2;
  let div0;
  let label0;
  let t0;
  let label0_class_value;
  let t1;
  let label1;
  let t3;
  let label2;
  let t4;
  let label2_class_value;
  let t5;
  let div1;
  let input;
  let div2_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      t0 = text(
        /*scaleLabel*/
        ctx[8]
      );
      t1 = space();
      label1 = element("label");
      label1.textContent = "|";
      t3 = space();
      label2 = element("label");
      t4 = text(
        /*radiusLabel*/
        ctx[9]
      );
      t5 = space();
      div1 = element("div");
      input = element("input");
      attr(label0, "for", "");
      attr(label0, "class", label0_class_value = "aaLabelBorder " + (!/*isRadius*/
      ctx[6] ? "aaIsSelected" : "aaNotSelected") + " svelte-auto-136pjjz");
      attr(label0, "role", "presentation");
      attr(label1, "for", "");
      attr(label2, "for", "");
      attr(label2, "class", label2_class_value = "aaLabelBorder " + /*isRadius*/
      (ctx[6] ? "aaIsSelected" : "aaNotSelected") + " svelte-auto-136pjjz");
      attr(label2, "role", "presentation");
      attr(input, "type", "number");
      attr(
        input,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      attr(
        input,
        "step",
        /*step*/
        ctx[4]
      );
      attr(div2, "class", div2_class_value = null_to_empty(
        /*isDisabled*/
        ctx[2]
      ) + " svelte-auto-136pjjz");
    },
    m(target2, anchor) {
      insert(target2, div2, anchor);
      append(div2, div0);
      append(div0, label0);
      append(label0, t0);
      append(div0, t1);
      append(div0, label1);
      append(div0, t3);
      append(div0, label2);
      append(label2, t4);
      append(div2, t5);
      append(div2, div1);
      append(div1, input);
      set_input_value(
        input,
        /*$animation*/
        ctx[5].data[
          /*section*/
          ctx[0]
        ].options[
          /*field*/
          ctx[1]
        ]
      );
      if (!mounted) {
        dispose = [
          listen(
            label0,
            "click",
            /*click_handler*/
            ctx[12]
          ),
          listen(
            label2,
            "click",
            /*click_handler_1*/
            ctx[13]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isRadius*/
      64 && label0_class_value !== (label0_class_value = "aaLabelBorder " + (!/*isRadius*/
      ctx2[6] ? "aaIsSelected" : "aaNotSelected") + " svelte-auto-136pjjz")) {
        attr(label0, "class", label0_class_value);
      }
      if (dirty & /*isRadius*/
      64 && label2_class_value !== (label2_class_value = "aaLabelBorder " + /*isRadius*/
      (ctx2[6] ? "aaIsSelected" : "aaNotSelected") + " svelte-auto-136pjjz")) {
        attr(label2, "class", label2_class_value);
      }
      if (dirty & /*placeholder*/
      8) {
        attr(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (dirty & /*step*/
      16) {
        attr(
          input,
          "step",
          /*step*/
          ctx2[4]
        );
      }
      if (dirty & /*$animation, section, field*/
      35 && to_number(input.value) !== /*$animation*/
      ctx2[5].data[
        /*section*/
        ctx2[0]
      ].options[
        /*field*/
        ctx2[1]
      ]) {
        set_input_value(
          input,
          /*$animation*/
          ctx2[5].data[
            /*section*/
            ctx2[0]
          ].options[
            /*field*/
            ctx2[1]
          ]
        );
      }
      if (dirty & /*isDisabled*/
      4 && div2_class_value !== (div2_class_value = null_to_empty(
        /*isDisabled*/
        ctx2[2]
      ) + " svelte-auto-136pjjz")) {
        attr(div2, "class", div2_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let isRadius;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(5, $animation = value));
  let { section: section2 } = $$props;
  let { field } = $$props;
  let { isDisabled = "" } = $$props;
  let { placeholder = 1 } = $$props;
  let { step = 1 } = $$props;
  const scaleLabel = game.i18n.localize("autoanimations.menus.scale");
  const radiusLabel = game.i18n.localize("autoanimations.menus.radius");
  function switchScale() {
    if (!animation._data.data[section2].options.isRadius) {
      return;
    }
    set_store_value(animation, $animation.data[section2].options.isRadius = false, $animation);
  }
  function switchRadius() {
    if (animation._data.data[section2].options.isRadius) {
      return;
    }
    set_store_value(animation, $animation.data[section2].options.isRadius = true, $animation);
  }
  const click_handler = () => switchScale();
  const click_handler_1 = () => switchRadius();
  function input_input_handler() {
    $animation.data[section2].options[field] = to_number(this.value);
    animation.set($animation);
  }
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(0, section2 = $$props2.section);
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
    if ("isDisabled" in $$props2)
      $$invalidate(2, isDisabled = $$props2.isDisabled);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("step" in $$props2)
      $$invalidate(4, step = $$props2.step);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation, section*/
    33) {
      $$invalidate(6, isRadius = $animation.data[section2].options.isRadius);
    }
  };
  return [
    section2,
    field,
    isDisabled,
    placeholder,
    step,
    $animation,
    isRadius,
    animation,
    scaleLabel,
    radiusLabel,
    switchScale,
    switchRadius,
    click_handler,
    click_handler_1,
    input_input_handler
  ];
}
class ScaleRadius extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$j, create_fragment$l, safe_not_equal, {
      section: 0,
      field: 1,
      isDisabled: 2,
      placeholder: 3,
      step: 4
    });
  }
}
const Teleportation_svelte_svelte_type_style_lang = "";
function create_default_slot_5(ctx) {
  let table;
  let tr0;
  let td0;
  let div0;
  let label0;
  let t0_value = localize("autoanimations.menus.mask") + "";
  let t0;
  let t1;
  let input0;
  let t2;
  let td1;
  let elevation;
  let t3;
  let td2;
  let scaleradius;
  let t4;
  let tr1;
  let td3;
  let opacity;
  let t5;
  let td4;
  let div1;
  let label1;
  let t7;
  let div2;
  let input1;
  let t8;
  let td5;
  let div3;
  let label2;
  let t10;
  let div4;
  let input2;
  let t11;
  let tr2;
  let td6;
  let div5;
  let label3;
  let t13;
  let div6;
  let input3;
  let t14;
  let td7;
  let div7;
  let label4;
  let t16;
  let div8;
  let input4;
  let t17;
  let td8;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation({ props: { section: "start" } });
  scaleradius = new ScaleRadius({
    props: {
      section: "start",
      field: "size",
      step: "0.01"
    }
  });
  opacity = new Opacity({ props: { section: "start" } });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div0 = element("div");
      label0 = element("label");
      t0 = text(t0_value);
      t1 = space();
      input0 = element("input");
      t2 = space();
      td1 = element("td");
      create_component(elevation.$$.fragment);
      t3 = space();
      td2 = element("td");
      create_component(scaleradius.$$.fragment);
      t4 = space();
      tr1 = element("tr");
      td3 = element("td");
      create_component(opacity.$$.fragment);
      t5 = space();
      td4 = element("td");
      div1 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.fadeIn")}`;
      t7 = space();
      div2 = element("div");
      input1 = element("input");
      t8 = space();
      td5 = element("td");
      div3 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.fadeOut")}`;
      t10 = space();
      div4 = element("div");
      input2 = element("input");
      t11 = space();
      tr2 = element("tr");
      td6 = element("td");
      div5 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t13 = space();
      div6 = element("div");
      input3 = element("input");
      t14 = space();
      td7 = element("td");
      div7 = element("div");
      label4 = element("label");
      label4.textContent = `${localize("autoanimations.menus.delay")}`;
      t16 = space();
      div8 = element("div");
      input4 = element("input");
      t17 = space();
      td8 = element("td");
      attr(label0, "for", "Masked " + /*animation*/
      ctx[1]._data.id);
      attr(input0, "type", "checkbox");
      attr(input0, "id", "Masked " + /*animation*/
      ctx[1]._data.id);
      attr(label1, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "1");
      attr(input1, "step", "1");
      attr(label2, "for", "");
      attr(input2, "type", "number");
      attr(input2, "placeholder", "1");
      attr(input2, "step", "1");
      attr(label3, "for", "");
      attr(input3, "type", "number");
      attr(input3, "placeholder", "1");
      attr(input3, "step", ".1");
      attr(label4, "for", "");
      attr(input4, "type", "number");
      attr(input4, "placeholder", "250");
      attr(input4, "step", "1");
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      append(td0, div0);
      append(div0, label0);
      append(label0, t0);
      append(div0, t1);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[0].data.start.options.isMasked;
      append(tr0, t2);
      append(tr0, td1);
      mount_component(elevation, td1, null);
      append(tr0, t3);
      append(tr0, td2);
      mount_component(scaleradius, td2, null);
      append(table, t4);
      append(table, tr1);
      append(tr1, td3);
      mount_component(opacity, td3, null);
      append(tr1, t5);
      append(tr1, td4);
      append(td4, div1);
      append(div1, label1);
      append(td4, t7);
      append(td4, div2);
      append(div2, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].data.start.options.fadeIn
      );
      append(tr1, t8);
      append(tr1, td5);
      append(td5, div3);
      append(div3, label2);
      append(td5, t10);
      append(td5, div4);
      append(div4, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].data.start.options.fadeOut
      );
      append(table, t11);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div5);
      append(div5, label3);
      append(td6, t13);
      append(td6, div6);
      append(div6, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[0].data.start.options.playbackRate
      );
      append(tr2, t14);
      append(tr2, td7);
      append(td7, div7);
      append(div7, label4);
      append(td7, t16);
      append(td7, div8);
      append(div8, input4);
      set_input_value(
        input4,
        /*$animation*/
        ctx[0].data.start.options.delay
      );
      append(tr2, t17);
      append(tr2, td8);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler_1*/
            ctx[20]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler_1*/
            ctx[21]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[22]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler_1*/
            ctx[23]
          ),
          listen(
            input4,
            "input",
            /*input4_input_handler_1*/
            ctx[24]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].data.start.options.isMasked;
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input1.value) !== /*$animation*/
      ctx2[0].data.start.options.fadeIn) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].data.start.options.fadeIn
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input2.value) !== /*$animation*/
      ctx2[0].data.start.options.fadeOut) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].data.start.options.fadeOut
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input3.value) !== /*$animation*/
      ctx2[0].data.start.options.playbackRate) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[0].data.start.options.playbackRate
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input4.value) !== /*$animation*/
      ctx2[0].data.start.options.delay) {
        set_input_value(
          input4,
          /*$animation*/
          ctx2[0].data.start.options.delay
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(scaleradius.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(scaleradius.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(scaleradius);
      destroy_component(opacity);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_4(ctx) {
  let div1;
  let videoselect;
  let t;
  let div0;
  let tjssvgfolder;
  let div1_class_value;
  let current;
  videoselect = new VideoSelect({
    props: {
      title: "Start Animation",
      section: "data",
      section02: "start"
    }
  });
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      create_component(videoselect.$$.fragment);
      t = space();
      div0 = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div0, "class", "aa-options-border");
      attr(div1, "class", div1_class_value = /*$animation*/
      ctx[0].data.start.enable ? "" : "aa-disableOpacity");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      mount_component(videoselect, div1, null);
      append(div1, t);
      append(div1, div0);
      mount_component(tjssvgfolder, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tjssvgfolder_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
      if (!current || dirty[0] & /*$animation*/
      1 && div1_class_value !== (div1_class_value = /*$animation*/
      ctx2[0].data.start.enable ? "" : "aa-disableOpacity")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(videoselect.$$.fragment, local);
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(videoselect.$$.fragment, local);
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(videoselect);
      destroy_component(tjssvgfolder);
    }
  };
}
function create_summary_end_slot_2(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Source FX On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[0].data.start.enable;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[19]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1) {
        input.checked = /*$animation*/
        ctx2[0].data.start.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let div0;
  let label0;
  let t2;
  let div1;
  let input0;
  let t3;
  let td2;
  let opacity;
  let t4;
  let tr1;
  let td3;
  let t5;
  let td4;
  let div2;
  let label1;
  let t7;
  let div3;
  let input1;
  let t8;
  let td5;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation({ props: { section: "between" } });
  opacity = new Opacity({ props: { section: "between" } });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t2 = space();
      div1 = element("div");
      input0 = element("input");
      t3 = space();
      td2 = element("td");
      create_component(opacity.$$.fragment);
      t4 = space();
      tr1 = element("tr");
      td3 = element("td");
      t5 = space();
      td4 = element("td");
      div2 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.delay")}`;
      t7 = space();
      div3 = element("div");
      input1 = element("input");
      t8 = space();
      td5 = element("td");
      attr(label0, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "1");
      attr(input0, "step", ".01");
      attr(label1, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "250");
      attr(input1, "step", "1");
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      append(td1, div0);
      append(div0, label0);
      append(td1, t2);
      append(td1, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].data.between.options.playbackRate
      );
      append(tr0, t3);
      append(tr0, td2);
      mount_component(opacity, td2, null);
      append(table, t4);
      append(table, tr1);
      append(tr1, td3);
      append(tr1, t5);
      append(tr1, td4);
      append(td4, div2);
      append(div2, label1);
      append(td4, t7);
      append(td4, div3);
      append(div3, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].data.between.options.delay
      );
      append(tr1, t8);
      append(tr1, td5);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[26]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler_2*/
            ctx[27]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1 && to_number(input0.value) !== /*$animation*/
      ctx2[0].data.between.options.playbackRate) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].data.between.options.playbackRate
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input1.value) !== /*$animation*/
      ctx2[0].data.between.options.delay) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].data.between.options.delay
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(opacity);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_2(ctx) {
  let div1;
  let videoselect;
  let t;
  let div0;
  let tjssvgfolder;
  let div1_class_value;
  let current;
  videoselect = new VideoSelect({
    props: {
      title: localize("autoanimations.menus.between") + " " + localize("autoanimations.menus.animation"),
      section: "data",
      section02: "between"
    }
  });
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      create_component(videoselect.$$.fragment);
      t = space();
      div0 = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div0, "class", "aa-options-border");
      attr(div1, "class", div1_class_value = /*$animation*/
      ctx[0].data.between.enable ? "" : "aa-disableOpacity");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      mount_component(videoselect, div1, null);
      append(div1, t);
      append(div1, div0);
      mount_component(tjssvgfolder, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tjssvgfolder_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
      if (!current || dirty[0] & /*$animation*/
      1 && div1_class_value !== (div1_class_value = /*$animation*/
      ctx2[0].data.between.enable ? "" : "aa-disableOpacity")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(videoselect.$$.fragment, local);
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(videoselect.$$.fragment, local);
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(videoselect);
      destroy_component(tjssvgfolder);
    }
  };
}
function create_summary_end_slot_1(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Source FX On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[0].data.between.enable;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_1*/
          ctx[25]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1) {
        input.checked = /*$animation*/
        ctx2[0].data.between.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$1(ctx) {
  let table;
  let tr0;
  let td0;
  let div0;
  let label0;
  let t0_value = localize("autoanimations.menus.mask") + "";
  let t0;
  let t1;
  let input0;
  let t2;
  let td1;
  let elevation;
  let t3;
  let td2;
  let scaleradius;
  let t4;
  let tr1;
  let td3;
  let opacity;
  let t5;
  let td4;
  let div1;
  let label1;
  let t7;
  let div2;
  let input1;
  let t8;
  let td5;
  let div3;
  let label2;
  let t10;
  let div4;
  let input2;
  let t11;
  let tr2;
  let td6;
  let div5;
  let label3;
  let t13;
  let div6;
  let input3;
  let t14;
  let td7;
  let div7;
  let label4;
  let t16;
  let div8;
  let input4;
  let t17;
  let td8;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation({ props: { section: "end" } });
  scaleradius = new ScaleRadius({
    props: {
      section: "end",
      field: "size",
      step: "0.01"
    }
  });
  opacity = new Opacity({ props: { section: "end" } });
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div0 = element("div");
      label0 = element("label");
      t0 = text(t0_value);
      t1 = space();
      input0 = element("input");
      t2 = space();
      td1 = element("td");
      create_component(elevation.$$.fragment);
      t3 = space();
      td2 = element("td");
      create_component(scaleradius.$$.fragment);
      t4 = space();
      tr1 = element("tr");
      td3 = element("td");
      create_component(opacity.$$.fragment);
      t5 = space();
      td4 = element("td");
      div1 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.fadeIn")}`;
      t7 = space();
      div2 = element("div");
      input1 = element("input");
      t8 = space();
      td5 = element("td");
      div3 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.menus.fadeOut")}`;
      t10 = space();
      div4 = element("div");
      input2 = element("input");
      t11 = space();
      tr2 = element("tr");
      td6 = element("td");
      div5 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.playbackRate")}`;
      t13 = space();
      div6 = element("div");
      input3 = element("input");
      t14 = space();
      td7 = element("td");
      div7 = element("div");
      label4 = element("label");
      label4.textContent = `${localize("autoanimations.menus.delay")}`;
      t16 = space();
      div8 = element("div");
      input4 = element("input");
      t17 = space();
      td8 = element("td");
      attr(label0, "for", "Masked " + /*animation*/
      ctx[1]._data.id);
      attr(input0, "type", "checkbox");
      attr(input0, "id", "Masked " + /*animation*/
      ctx[1]._data.id);
      attr(label1, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "1");
      attr(input1, "step", "1");
      attr(label2, "for", "");
      attr(input2, "type", "number");
      attr(input2, "placeholder", "1");
      attr(input2, "step", "1");
      attr(label3, "for", "");
      attr(input3, "type", "number");
      attr(input3, "placeholder", "1");
      attr(input3, "step", ".1");
      attr(label4, "for", "");
      attr(input4, "type", "number");
      attr(input4, "placeholder", "250");
      attr(input4, "step", "1");
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      append(td0, div0);
      append(div0, label0);
      append(label0, t0);
      append(div0, t1);
      append(div0, input0);
      input0.checked = /*$animation*/
      ctx[0].data.end.options.isMasked;
      append(tr0, t2);
      append(tr0, td1);
      mount_component(elevation, td1, null);
      append(tr0, t3);
      append(tr0, td2);
      mount_component(scaleradius, td2, null);
      append(table, t4);
      append(table, tr1);
      append(tr1, td3);
      mount_component(opacity, td3, null);
      append(tr1, t5);
      append(tr1, td4);
      append(td4, div1);
      append(div1, label1);
      append(td4, t7);
      append(td4, div2);
      append(div2, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].data.end.options.fadeIn
      );
      append(tr1, t8);
      append(tr1, td5);
      append(td5, div3);
      append(div3, label2);
      append(td5, t10);
      append(td5, div4);
      append(div4, input2);
      set_input_value(
        input2,
        /*$animation*/
        ctx[0].data.end.options.fadeOut
      );
      append(table, t11);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div5);
      append(div5, label3);
      append(td6, t13);
      append(td6, div6);
      append(div6, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[0].data.end.options.playbackRate
      );
      append(tr2, t14);
      append(tr2, td7);
      append(td7, div7);
      append(div7, label4);
      append(td7, t16);
      append(td7, div8);
      append(div8, input4);
      set_input_value(
        input4,
        /*$animation*/
        ctx[0].data.end.options.delay
      );
      append(tr2, t17);
      append(tr2, td8);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler_2*/
            ctx[29]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler_3*/
            ctx[30]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler_1*/
            ctx[31]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler_2*/
            ctx[32]
          ),
          listen(
            input4,
            "input",
            /*input4_input_handler_2*/
            ctx[33]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].data.end.options.isMasked;
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input1.value) !== /*$animation*/
      ctx2[0].data.end.options.fadeIn) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].data.end.options.fadeIn
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input2.value) !== /*$animation*/
      ctx2[0].data.end.options.fadeOut) {
        set_input_value(
          input2,
          /*$animation*/
          ctx2[0].data.end.options.fadeOut
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input3.value) !== /*$animation*/
      ctx2[0].data.end.options.playbackRate) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[0].data.end.options.playbackRate
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input4.value) !== /*$animation*/
      ctx2[0].data.end.options.delay) {
        set_input_value(
          input4,
          /*$animation*/
          ctx2[0].data.end.options.delay
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(scaleradius.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(scaleradius.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(scaleradius);
      destroy_component(opacity);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$5(ctx) {
  let div1;
  let videoselect;
  let t;
  let div0;
  let tjssvgfolder;
  let div1_class_value;
  let current;
  videoselect = new VideoSelect({
    props: {
      title: "End Animation",
      section: "data",
      section02: "end"
    }
  });
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      create_component(videoselect.$$.fragment);
      t = space();
      div0 = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div0, "class", "aa-options-border");
      attr(div1, "class", div1_class_value = /*$animation*/
      ctx[0].data.end.enable ? "" : "aa-disableOpacity");
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      mount_component(videoselect, div1, null);
      append(div1, t);
      append(div1, div0);
      mount_component(tjssvgfolder, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tjssvgfolder_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
      if (!current || dirty[0] & /*$animation*/
      1 && div1_class_value !== (div1_class_value = /*$animation*/
      ctx2[0].data.end.enable ? "" : "aa-disableOpacity")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(videoselect.$$.fragment, local);
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(videoselect.$$.fragment, local);
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(videoselect);
      destroy_component(tjssvgfolder);
    }
  };
}
function create_summary_end_slot$2(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      set_style(input, "align-self", "center");
      attr(input, "title", "Toggle Source FX On/Off");
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, input);
      input.checked = /*$animation*/
      ctx[0].data.end.enable;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler_2*/
          ctx[28]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1) {
        input.checked = /*$animation*/
        ctx2[0].data.end.enable;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$k(ctx) {
  let div22;
  let div1;
  let div0;
  let label0;
  let t1;
  let i;
  let t2;
  let table;
  let tr0;
  let td0;
  let div2;
  let t4;
  let div3;
  let select;
  let option0;
  let option1;
  let t7;
  let td1;
  let div4;
  let label2;
  let t8_value = localize("autoanimations.menus.hideBorder") + "";
  let t8;
  let t9;
  let div5;
  let input0;
  let t10;
  let td2;
  let div6;
  let label3;
  let t12;
  let div7;
  let input1;
  let t13;
  let tr1;
  let td3;
  let div8;
  let label4;
  let t14_value = localize("autoanimations.menus.teleport") + "";
  let t14;
  let t15;
  let t16_value = localize("autoanimations.menus.token") + "";
  let t16;
  let t17;
  let div9;
  let input2;
  let t18;
  let td4;
  let div10;
  let t20;
  let div11;
  let input3;
  let t21;
  let td5;
  let div12;
  let label6;
  let t23;
  let div13;
  let input4;
  let td5_class_value;
  let t24;
  let tr2;
  let td6;
  let div15;
  let label7;
  let t26;
  let div14;
  let input5;
  let t27;
  let input6;
  let t28;
  let td7;
  let div16;
  let label8;
  let t32;
  let div17;
  let input7;
  let t33;
  let td8;
  let div18;
  let label9;
  let t37;
  let div19;
  let input8;
  let t38;
  let tr3;
  let td9;
  let t39;
  let td10;
  let div20;
  let label10;
  let t40_value = localize("autoanimations.menus.checkCollision") + "";
  let t40;
  let t41;
  let div21;
  let input9;
  let t42;
  let td11;
  let t43;
  let soundsettings;
  let t44;
  let div23;
  let tjssvgfolder0;
  let t45;
  let div24;
  let tjssvgfolder1;
  let t46;
  let div25;
  let tjssvgfolder2;
  let current;
  let mounted;
  let dispose;
  soundsettings = new SoundSettings({ props: { section: "data" } });
  tjssvgfolder0 = new TJSSvgFolder({
    props: {
      folder: (
        /*startFolder*/
        ctx[4]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot_2],
        default: [create_default_slot_4]
      },
      $$scope: { ctx }
    }
  });
  tjssvgfolder1 = new TJSSvgFolder({
    props: {
      folder: (
        /*betweenFolder*/
        ctx[3]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot_1],
        default: [create_default_slot_2]
      },
      $$scope: { ctx }
    }
  });
  tjssvgfolder2 = new TJSSvgFolder({
    props: {
      folder: (
        /*endFolder*/
        ctx[5]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$2],
        default: [create_default_slot$5]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div22 = element("div");
      div1 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.movement") + " " + localize("autoanimations.menus.options")}`;
      t1 = space();
      i = element("i");
      t2 = space();
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      div2 = element("div");
      div2.innerHTML = `<label for="">Range Marker</label>`;
      t4 = space();
      div3 = element("div");
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.menuTypes.circle")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.menuTypes.square")}`;
      t7 = space();
      td1 = element("td");
      div4 = element("div");
      label2 = element("label");
      t8 = text(t8_value);
      t9 = space();
      div5 = element("div");
      input0 = element("input");
      t10 = space();
      td2 = element("td");
      div6 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.menus.ranged")}`;
      t12 = space();
      div7 = element("div");
      input1 = element("input");
      t13 = space();
      tr1 = element("tr");
      td3 = element("td");
      div8 = element("div");
      label4 = element("label");
      t14 = text(t14_value);
      t15 = space();
      t16 = text(t16_value);
      t17 = space();
      div9 = element("div");
      input2 = element("input");
      t18 = space();
      td4 = element("td");
      div10 = element("div");
      div10.innerHTML = `<label for="">Delay Movement</label>`;
      t20 = space();
      div11 = element("div");
      input3 = element("input");
      t21 = space();
      td5 = element("td");
      div12 = element("div");
      label6 = element("label");
      label6.textContent = `${localize("autoanimations.menus.speed")}`;
      t23 = space();
      div13 = element("div");
      input4 = element("input");
      t24 = space();
      tr2 = element("tr");
      td6 = element("td");
      div15 = element("div");
      label7 = element("label");
      label7.textContent = `${localize("autoanimations.menus.token") + " " + localize("autoanimations.menus.alpha")}`;
      t26 = space();
      div14 = element("div");
      input5 = element("input");
      t27 = space();
      input6 = element("input");
      t28 = space();
      td7 = element("td");
      div16 = element("div");
      label8 = element("label");
      label8.textContent = `${localize("autoanimations.menus.delay")} 
                        ${localize("autoanimations.menus.fadeOut")}`;
      t32 = space();
      div17 = element("div");
      input7 = element("input");
      t33 = space();
      td8 = element("td");
      div18 = element("div");
      label9 = element("label");
      label9.textContent = `${localize("autoanimations.menus.delay")} 
                        ${localize("autoanimations.menus.fadeIn")}`;
      t37 = space();
      div19 = element("div");
      input8 = element("input");
      t38 = space();
      tr3 = element("tr");
      td9 = element("td");
      t39 = space();
      td10 = element("td");
      div20 = element("div");
      label10 = element("label");
      t40 = text(t40_value);
      t41 = space();
      div21 = element("div");
      input9 = element("input");
      t42 = space();
      td11 = element("td");
      t43 = space();
      create_component(soundsettings.$$.fragment);
      t44 = space();
      div23 = element("div");
      create_component(tjssvgfolder0.$$.fragment);
      t45 = space();
      div24 = element("div");
      create_component(tjssvgfolder1.$$.fragment);
      t46 = space();
      div25 = element("div");
      create_component(tjssvgfolder2.$$.fragment);
      attr(label0, "for", "");
      attr(label0, "class", "svelte-auto-kmbw2l");
      attr(i, "class", "fas fa-info-circle aa-blue");
      set_style(i, "font-size", "1.2em");
      attr(i, "title", "Quick Reference");
      attr(i, "role", "presentation");
      attr(div1, "class", "aa-SectionHeader svelte-auto-kmbw2l");
      set_style(div1, "text-align", "center");
      option0.__value = "alternating";
      option0.value = option0.__value;
      option1.__value = "equidistant";
      option1.value = option1.__value;
      set_style(select, "width", "95%");
      set_style(select, "align-self", "center");
      if (
        /*$animation*/
        ctx[0].data.options.measureType === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[8].call(select)
        ));
      attr(div3, "class", "flexcol");
      attr(label2, "for", "Hide " + /*animation*/
      ctx[1]._data.id);
      attr(input0, "type", "checkbox");
      attr(input0, "id", "Hide " + /*animation*/
      ctx[1]._data.id);
      attr(
        td1,
        "class",
        /*isGM*/
        ctx[6] ? "" : "aa-disableOpacity"
      );
      attr(label3, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "30");
      attr(input1, "step", ".01");
      attr(label4, "for", "Hide " + /*animation*/
      ctx[1]._data.id);
      attr(input2, "type", "checkbox");
      attr(input2, "id", "Hide " + /*animation*/
      ctx[1]._data.id);
      attr(input3, "type", "number");
      attr(input3, "placeholder", "30");
      attr(input3, "step", ".01");
      attr(label6, "for", "");
      attr(input4, "type", "number");
      attr(input4, "placeholder", "30");
      attr(input4, "step", ".01");
      attr(td5, "class", td5_class_value = /*$animation*/
      ctx[0].data.options.teleport ? "aa-disableOpacity" : "");
      attr(label7, "for", "");
      attr(input5, "type", "number");
      attr(input5, "placeholder", "1");
      attr(input5, "min", "0");
      attr(input5, "max", "1");
      attr(input5, "step", "0.01");
      set_style(input6, "border", "none");
      set_style(input6, "background", "none");
      set_style(input6, "margin-left", "3px");
      attr(input6, "type", "range");
      attr(input6, "min", "0");
      attr(input6, "max", "1");
      attr(input6, "step", "0.01");
      set_style(div14, "display", "flex");
      set_style(div14, "margin-right", "1.5em");
      set_style(div14, "margin-left", "1.5em");
      attr(div15, "class", "flexcol");
      attr(label8, "for", "");
      attr(input7, "type", "number");
      attr(input7, "placeholder", "1");
      attr(input7, "step", "1");
      attr(label9, "for", "");
      attr(input8, "type", "number");
      attr(input8, "placeholder", "1");
      attr(input8, "step", "1");
      attr(label10, "for", "Collision " + /*animation*/
      ctx[1]._data.id);
      attr(input9, "type", "checkbox");
      attr(input9, "id", "Collision " + /*animation*/
      ctx[1]._data.id);
      attr(table, "class", "d");
      attr(div22, "class", "aa-options-border");
      set_style(div22, "padding-left", "1em");
      set_style(div22, "padding-right", "1em");
      attr(div23, "class", "aa-section-border");
      attr(div24, "class", "aa-section-border");
      attr(div25, "class", "aa-section-border");
    },
    m(target2, anchor) {
      insert(target2, div22, anchor);
      append(div22, div1);
      append(div1, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, i);
      append(div22, t2);
      append(div22, table);
      append(table, tr0);
      append(tr0, td0);
      append(td0, div2);
      append(td0, t4);
      append(td0, div3);
      append(div3, select);
      append(select, option0);
      append(select, option1);
      select_option(
        select,
        /*$animation*/
        ctx[0].data.options.measureType,
        true
      );
      append(tr0, t7);
      append(tr0, td1);
      append(td1, div4);
      append(div4, label2);
      append(label2, t8);
      append(td1, t9);
      append(td1, div5);
      append(div5, input0);
      input0.checked = /*$animation*/
      ctx[0].data.options.hideFromPlayers;
      append(tr0, t10);
      append(tr0, td2);
      append(td2, div6);
      append(div6, label3);
      append(td2, t12);
      append(td2, div7);
      append(div7, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].data.options.range
      );
      append(table, t13);
      append(table, tr1);
      append(tr1, td3);
      append(td3, div8);
      append(div8, label4);
      append(label4, t14);
      append(label4, t15);
      append(label4, t16);
      append(td3, t17);
      append(td3, div9);
      append(div9, input2);
      input2.checked = /*$animation*/
      ctx[0].data.options.teleport;
      append(tr1, t18);
      append(tr1, td4);
      append(td4, div10);
      append(td4, t20);
      append(td4, div11);
      append(div11, input3);
      set_input_value(
        input3,
        /*$animation*/
        ctx[0].data.options.delayMove
      );
      append(tr1, t21);
      append(tr1, td5);
      append(td5, div12);
      append(div12, label6);
      append(td5, t23);
      append(td5, div13);
      append(div13, input4);
      set_input_value(
        input4,
        /*$animation*/
        ctx[0].data.options.speed
      );
      append(table, t24);
      append(table, tr2);
      append(tr2, td6);
      append(td6, div15);
      append(div15, label7);
      append(div15, t26);
      append(div15, div14);
      append(div14, input5);
      set_input_value(
        input5,
        /*$animation*/
        ctx[0].data.options.alpha
      );
      append(div14, t27);
      append(div14, input6);
      set_input_value(
        input6,
        /*$animation*/
        ctx[0].data.options.alpha
      );
      append(tr2, t28);
      append(tr2, td7);
      append(td7, div16);
      append(div16, label8);
      append(td7, t32);
      append(td7, div17);
      append(div17, input7);
      set_input_value(
        input7,
        /*$animation*/
        ctx[0].data.options.delayFade
      );
      append(tr2, t33);
      append(tr2, td8);
      append(td8, div18);
      append(div18, label9);
      append(td8, t37);
      append(td8, div19);
      append(div19, input8);
      set_input_value(
        input8,
        /*$animation*/
        ctx[0].data.options.delayReturn
      );
      append(table, t38);
      append(table, tr3);
      append(tr3, td9);
      append(tr3, t39);
      append(tr3, td10);
      append(td10, div20);
      append(div20, label10);
      append(label10, t40);
      append(td10, t41);
      append(td10, div21);
      append(div21, input9);
      input9.checked = /*$animation*/
      ctx[0].data.options.checkCollision;
      append(tr3, t42);
      append(tr3, td11);
      insert(target2, t43, anchor);
      mount_component(soundsettings, target2, anchor);
      insert(target2, t44, anchor);
      insert(target2, div23, anchor);
      mount_component(tjssvgfolder0, div23, null);
      insert(target2, t45, anchor);
      insert(target2, div24, anchor);
      mount_component(tjssvgfolder1, div24, null);
      insert(target2, t46, anchor);
      insert(target2, div25, anchor);
      mount_component(tjssvgfolder2, div25, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            i,
            "click",
            /*click_handler*/
            ctx[7]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[8]
          ),
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[9]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[10]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[11]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[12]
          ),
          listen(
            input4,
            "input",
            /*input4_input_handler*/
            ctx[13]
          ),
          listen(
            input5,
            "input",
            /*input5_input_handler*/
            ctx[14]
          ),
          listen(
            input6,
            "change",
            /*input6_change_input_handler*/
            ctx[15]
          ),
          listen(
            input6,
            "input",
            /*input6_change_input_handler*/
            ctx[15]
          ),
          listen(
            input7,
            "input",
            /*input7_input_handler*/
            ctx[16]
          ),
          listen(
            input8,
            "input",
            /*input8_input_handler*/
            ctx[17]
          ),
          listen(
            input9,
            "change",
            /*input9_change_handler*/
            ctx[18]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$animation*/
      1) {
        select_option(
          select,
          /*$animation*/
          ctx2[0].data.options.measureType
        );
      }
      if (dirty[0] & /*$animation*/
      1) {
        input0.checked = /*$animation*/
        ctx2[0].data.options.hideFromPlayers;
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input1.value) !== /*$animation*/
      ctx2[0].data.options.range) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].data.options.range
        );
      }
      if (dirty[0] & /*$animation*/
      1) {
        input2.checked = /*$animation*/
        ctx2[0].data.options.teleport;
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input3.value) !== /*$animation*/
      ctx2[0].data.options.delayMove) {
        set_input_value(
          input3,
          /*$animation*/
          ctx2[0].data.options.delayMove
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input4.value) !== /*$animation*/
      ctx2[0].data.options.speed) {
        set_input_value(
          input4,
          /*$animation*/
          ctx2[0].data.options.speed
        );
      }
      if (!current || dirty[0] & /*$animation*/
      1 && td5_class_value !== (td5_class_value = /*$animation*/
      ctx2[0].data.options.teleport ? "aa-disableOpacity" : "")) {
        attr(td5, "class", td5_class_value);
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input5.value) !== /*$animation*/
      ctx2[0].data.options.alpha) {
        set_input_value(
          input5,
          /*$animation*/
          ctx2[0].data.options.alpha
        );
      }
      if (dirty[0] & /*$animation*/
      1) {
        set_input_value(
          input6,
          /*$animation*/
          ctx2[0].data.options.alpha
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input7.value) !== /*$animation*/
      ctx2[0].data.options.delayFade) {
        set_input_value(
          input7,
          /*$animation*/
          ctx2[0].data.options.delayFade
        );
      }
      if (dirty[0] & /*$animation*/
      1 && to_number(input8.value) !== /*$animation*/
      ctx2[0].data.options.delayReturn) {
        set_input_value(
          input8,
          /*$animation*/
          ctx2[0].data.options.delayReturn
        );
      }
      if (dirty[0] & /*$animation*/
      1) {
        input9.checked = /*$animation*/
        ctx2[0].data.options.checkCollision;
      }
      const tjssvgfolder0_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder0.$set(tjssvgfolder0_changes);
      const tjssvgfolder1_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder1.$set(tjssvgfolder1_changes);
      const tjssvgfolder2_changes = {};
      if (dirty[0] & /*$animation*/
      1 | dirty[1] & /*$$scope*/
      16) {
        tjssvgfolder2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder2.$set(tjssvgfolder2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(soundsettings.$$.fragment, local);
      transition_in(tjssvgfolder0.$$.fragment, local);
      transition_in(tjssvgfolder1.$$.fragment, local);
      transition_in(tjssvgfolder2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(soundsettings.$$.fragment, local);
      transition_out(tjssvgfolder0.$$.fragment, local);
      transition_out(tjssvgfolder1.$$.fragment, local);
      transition_out(tjssvgfolder2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div22);
      if (detaching)
        detach(t43);
      destroy_component(soundsettings, detaching);
      if (detaching)
        detach(t44);
      if (detaching)
        detach(div23);
      destroy_component(tjssvgfolder0);
      if (detaching)
        detach(t45);
      if (detaching)
        detach(div24);
      destroy_component(tjssvgfolder1);
      if (detaching)
        detach(t46);
      if (detaching)
        detach(div25);
      destroy_component(tjssvgfolder2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    },
    label: game.i18n.localize("autoanimations.menus.options")
  };
  const styling = {
    "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
    "--tjs-summary-font-size": "1.1em",
    "--tjs-summary-chevron-size": "0.7em"
  };
  const betweenFolder = {
    styles: styling,
    label: game.i18n.localize("autoanimations.menus.between") + " " + game.i18n.localize("autoanimations.menus.animation")
  };
  const startFolder = {
    styles: styling,
    label: game.i18n.localize("autoanimations.menus.start") + " " + game.i18n.localize("autoanimations.menus.animation")
  };
  const endFolder = {
    styles: styling,
    label: game.i18n.localize("autoanimations.menus.end") + " " + game.i18n.localize("autoanimations.menus.animation")
  };
  const isGM = game.user.isGM;
  const click_handler = () => OptionsDialog.show("preset", "teleportation");
  function select_change_handler() {
    $animation.data.options.measureType = select_value(this);
    animation.set($animation);
  }
  function input0_change_handler() {
    $animation.data.options.hideFromPlayers = this.checked;
    animation.set($animation);
  }
  function input1_input_handler() {
    $animation.data.options.range = to_number(this.value);
    animation.set($animation);
  }
  function input2_change_handler() {
    $animation.data.options.teleport = this.checked;
    animation.set($animation);
  }
  function input3_input_handler() {
    $animation.data.options.delayMove = to_number(this.value);
    animation.set($animation);
  }
  function input4_input_handler() {
    $animation.data.options.speed = to_number(this.value);
    animation.set($animation);
  }
  function input5_input_handler() {
    $animation.data.options.alpha = to_number(this.value);
    animation.set($animation);
  }
  function input6_change_input_handler() {
    $animation.data.options.alpha = to_number(this.value);
    animation.set($animation);
  }
  function input7_input_handler() {
    $animation.data.options.delayFade = to_number(this.value);
    animation.set($animation);
  }
  function input8_input_handler() {
    $animation.data.options.delayReturn = to_number(this.value);
    animation.set($animation);
  }
  function input9_change_handler() {
    $animation.data.options.checkCollision = this.checked;
    animation.set($animation);
  }
  function input_change_handler() {
    $animation.data.start.enable = this.checked;
    animation.set($animation);
  }
  function input0_change_handler_1() {
    $animation.data.start.options.isMasked = this.checked;
    animation.set($animation);
  }
  function input1_input_handler_1() {
    $animation.data.start.options.fadeIn = to_number(this.value);
    animation.set($animation);
  }
  function input2_input_handler() {
    $animation.data.start.options.fadeOut = to_number(this.value);
    animation.set($animation);
  }
  function input3_input_handler_1() {
    $animation.data.start.options.playbackRate = to_number(this.value);
    animation.set($animation);
  }
  function input4_input_handler_1() {
    $animation.data.start.options.delay = to_number(this.value);
    animation.set($animation);
  }
  function input_change_handler_1() {
    $animation.data.between.enable = this.checked;
    animation.set($animation);
  }
  function input0_input_handler() {
    $animation.data.between.options.playbackRate = to_number(this.value);
    animation.set($animation);
  }
  function input1_input_handler_2() {
    $animation.data.between.options.delay = to_number(this.value);
    animation.set($animation);
  }
  function input_change_handler_2() {
    $animation.data.end.enable = this.checked;
    animation.set($animation);
  }
  function input0_change_handler_2() {
    $animation.data.end.options.isMasked = this.checked;
    animation.set($animation);
  }
  function input1_input_handler_3() {
    $animation.data.end.options.fadeIn = to_number(this.value);
    animation.set($animation);
  }
  function input2_input_handler_1() {
    $animation.data.end.options.fadeOut = to_number(this.value);
    animation.set($animation);
  }
  function input3_input_handler_2() {
    $animation.data.end.options.playbackRate = to_number(this.value);
    animation.set($animation);
  }
  function input4_input_handler_2() {
    $animation.data.end.options.delay = to_number(this.value);
    animation.set($animation);
  }
  return [
    $animation,
    animation,
    folder,
    betweenFolder,
    startFolder,
    endFolder,
    isGM,
    click_handler,
    select_change_handler,
    input0_change_handler,
    input1_input_handler,
    input2_change_handler,
    input3_input_handler,
    input4_input_handler,
    input5_input_handler,
    input6_change_input_handler,
    input7_input_handler,
    input8_input_handler,
    input9_change_handler,
    input_change_handler,
    input0_change_handler_1,
    input1_input_handler_1,
    input2_input_handler,
    input3_input_handler_1,
    input4_input_handler_1,
    input_change_handler_1,
    input0_input_handler,
    input1_input_handler_2,
    input_change_handler_2,
    input0_change_handler_2,
    input1_input_handler_3,
    input2_input_handler_1,
    input3_input_handler_2,
    input4_input_handler_2
  ];
}
class Teleportation extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$i, create_fragment$k, safe_not_equal, {}, null, [-1, -1]);
  }
}
const Thunderwave_svelte_svelte_type_style_lang = "";
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i][0];
  child_ctx[12] = list[i][1];
  return child_ctx;
}
function create_each_block$3(ctx) {
  let option;
  let t_value = (
    /*name*/
    ctx[12] + ""
  );
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = /*key*/
      ctx[11];
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_default_slot$4(ctx) {
  let table;
  let tr0;
  let td0;
  let elevation;
  let t0;
  let td1;
  let div0;
  let label0;
  let t2;
  let div1;
  let input0;
  let t3;
  let td2;
  let div2;
  let label1;
  let t5;
  let div3;
  let input1;
  let t6;
  let tr1;
  let td3;
  let opacity;
  let t7;
  let td4;
  let div4;
  let label2;
  let t8_value = localize("autoanimations.menus.remove") + "";
  let t8;
  let t9;
  let input2;
  let t10;
  let td5;
  let current;
  let mounted;
  let dispose;
  elevation = new Elevation$1({ props: { section: "data" } });
  opacity = new Opacity02({});
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      td0 = element("td");
      create_component(elevation.$$.fragment);
      t0 = space();
      td1 = element("td");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.menus.repeat")}`;
      t2 = space();
      div1 = element("div");
      input0 = element("input");
      t3 = space();
      td2 = element("td");
      div2 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.menus.delay")}`;
      t5 = space();
      div3 = element("div");
      input1 = element("input");
      t6 = space();
      tr1 = element("tr");
      td3 = element("td");
      create_component(opacity.$$.fragment);
      t7 = space();
      td4 = element("td");
      div4 = element("div");
      label2 = element("label");
      t8 = text(t8_value);
      t9 = space();
      input2 = element("input");
      t10 = space();
      td5 = element("td");
      attr(label0, "for", "");
      attr(input0, "type", "number");
      attr(input0, "placeholder", "1");
      attr(input0, "step", "1");
      attr(label1, "for", "");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "1");
      attr(input1, "step", "1");
      attr(label2, "for", "Remove " + /*animation*/
      ctx[1]._data.id);
      attr(input2, "type", "checkbox");
      attr(input2, "id", "Remove " + /*animation*/
      ctx[1]._data.id);
      attr(table, "class", "d");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, td0);
      mount_component(elevation, td0, null);
      append(tr0, t0);
      append(tr0, td1);
      append(td1, div0);
      append(div0, label0);
      append(td1, t2);
      append(td1, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*$animation*/
        ctx[0].data.options.repeat
      );
      append(tr0, t3);
      append(tr0, td2);
      append(td2, div2);
      append(div2, label1);
      append(td2, t5);
      append(td2, div3);
      append(div3, input1);
      set_input_value(
        input1,
        /*$animation*/
        ctx[0].data.options.repeatDelay
      );
      append(table, t6);
      append(table, tr1);
      append(tr1, td3);
      mount_component(opacity, td3, null);
      append(tr1, t7);
      append(tr1, td4);
      append(td4, div4);
      append(div4, label2);
      append(label2, t8);
      append(div4, t9);
      append(div4, input2);
      input2.checked = /*$animation*/
      ctx[0].data.options.removeTemplate;
      append(tr1, t10);
      append(tr1, td5);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[7]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[8]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$animation, category*/
      5 && to_number(input0.value) !== /*$animation*/
      ctx2[0].data.options.repeat) {
        set_input_value(
          input0,
          /*$animation*/
          ctx2[0].data.options.repeat
        );
      }
      if (dirty & /*$animation, category*/
      5 && to_number(input1.value) !== /*$animation*/
      ctx2[0].data.options.repeatDelay) {
        set_input_value(
          input1,
          /*$animation*/
          ctx2[0].data.options.repeatDelay
        );
      }
      if (dirty & /*$animation, category*/
      5) {
        input2.checked = /*$animation*/
        ctx2[0].data.options.removeTemplate;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(elevation.$$.fragment, local);
      transition_in(opacity.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elevation.$$.fragment, local);
      transition_out(opacity.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(elevation);
      destroy_component(opacity);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_summary_end_slot$1(ctx) {
  let div;
  let tjsiconbutton;
  let current;
  tjsiconbutton = new TJSIconButton({
    props: { button: (
      /*optionsInfo*/
      ctx[4]
    ) }
  });
  tjsiconbutton.$on(
    "click",
    /*click_handler*/
    ctx[6]
  );
  return {
    c() {
      div = element("div");
      create_component(tjsiconbutton.$$.fragment);
      attr(div, "slot", "summary-end");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjsiconbutton, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsiconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsiconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsiconbutton);
    }
  };
}
function create_fragment$j(ctx) {
  let div3;
  let sectionheader;
  let t0;
  let div1;
  let div0;
  let label;
  let t2;
  let select;
  let t3;
  let div2;
  let tjssvgfolder;
  let t4;
  let soundsettings;
  let current;
  let mounted;
  let dispose;
  sectionheader = new SectionHeader({ props: { title } });
  let each_value = (
    /*category*/
    ctx[2].colorMenu.templatefx.square.thunderwave.mid
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  }
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[3]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot$1],
        default: [create_default_slot$4]
      },
      $$scope: { ctx }
    }
  });
  soundsettings = new SoundSettings({ props: { section: "data" } });
  return {
    c() {
      div3 = element("div");
      create_component(sectionheader.$$.fragment);
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.color")}`;
      t2 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      div2 = element("div");
      create_component(tjssvgfolder.$$.fragment);
      t4 = space();
      create_component(soundsettings.$$.fragment);
      attr(label, "for", "");
      set_style(label, "align-self", "center");
      set_style(label, "font-size", "1.2em");
      if (
        /*$animation*/
        ctx[0].data.video.color === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[5].call(select)
        ));
      attr(div0, "class", "flexcol");
      set_style(div0, "grid-row", "1/2");
      set_style(div0, "grid-column", "2/3");
      set_style(div0, "margin-bottom", "1em");
      attr(div1, "class", "aa-3wide aa-select-label svelte-auto-1kbp5kz");
      attr(div2, "class", "aa-options-border");
      attr(div3, "class", "aa-section-border");
    },
    m(target2, anchor) {
      insert(target2, div3, anchor);
      mount_component(sectionheader, div3, null);
      append(div3, t0);
      append(div3, div1);
      append(div1, div0);
      append(div0, label);
      append(div0, t2);
      append(div0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*$animation*/
        ctx[0].data.video.color,
        true
      );
      append(div3, t3);
      append(div3, div2);
      mount_component(tjssvgfolder, div2, null);
      append(div3, t4);
      mount_component(soundsettings, div3, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*select_change_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*category*/
      4) {
        each_value = /*category*/
        ctx2[2].colorMenu.templatefx.square.thunderwave.mid;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$animation, category*/
      5) {
        select_option(
          select,
          /*$animation*/
          ctx2[0].data.video.color
        );
      }
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, $animation*/
      32769) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sectionheader.$$.fragment, local);
      transition_in(tjssvgfolder.$$.fragment, local);
      transition_in(soundsettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sectionheader.$$.fragment, local);
      transition_out(tjssvgfolder.$$.fragment, local);
      transition_out(soundsettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(sectionheader);
      destroy_each(each_blocks, detaching);
      destroy_component(tjssvgfolder);
      destroy_component(soundsettings);
      mounted = false;
      dispose();
    }
  };
}
const title = "Thunderwave 5e";
function instance$h($$self, $$props, $$invalidate) {
  let $animation;
  let { animation, category, idx } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(0, $animation = value));
  const folder = {
    styles: {
      "--tjs-summary-font-family": '"Modesto Condensed", "Palatino Linotype", serif',
      "--tjs-summary-font-size": "1.1em",
      "--tjs-summary-chevron-size": "0.7em"
    },
    label: game.i18n.localize("autoanimations.menus.options")
  };
  const optionsInfo = {
    icon: "fas fa-info-circle",
    title: "autoanimations.menus.quickReference",
    styles: {
      "--tjs-icon-button-diameter": "1.em",
      position: "relative",
      left: "10px",
      bottom: "-2px",
      color: "rgba(50, 79, 245, 0.5)"
    }
  };
  function select_change_handler() {
    $animation.data.video.color = select_value(this);
    animation.set($animation);
    $$invalidate(2, category);
  }
  const click_handler = () => OptionsDialog.show("preset", "thunderwave");
  function input0_input_handler() {
    $animation.data.options.repeat = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, category);
  }
  function input1_input_handler() {
    $animation.data.options.repeatDelay = to_number(this.value);
    animation.set($animation);
    $$invalidate(2, category);
  }
  function input2_change_handler() {
    $animation.data.options.removeTemplate = this.checked;
    animation.set($animation);
    $$invalidate(2, category);
  }
  return [
    $animation,
    animation,
    category,
    folder,
    optionsInfo,
    select_change_handler,
    click_handler,
    input0_input_handler,
    input1_input_handler,
    input2_change_handler
  ];
}
class Thunderwave extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$h, create_fragment$j, safe_not_equal, {});
  }
}
const BuildPreset_svelte_svelte_type_style_lang = "";
function create_fragment$i(ctx) {
  let sectionbuttons;
  let t0;
  let div0;
  let soundonly;
  let div0_hidden_value;
  let t1;
  let div1;
  let macro2;
  let div1_hidden_value;
  let t2;
  let div4;
  let div3;
  let div2;
  let label;
  let t6;
  let select;
  let option0;
  let option1;
  let option2;
  let option3;
  let t12;
  let switch_instance;
  let div4_hidden_value;
  let current;
  let mounted;
  let dispose;
  sectionbuttons = new SectionButtons02({ props: { type: (
    /*fromMenu*/
    ctx[0]
  ) } });
  soundonly = new SoundOnly({});
  macro2 = new Macro$1({});
  var switch_value = (
    /*presetRoute*/
    ctx[1]
  );
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      create_component(sectionbuttons.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(soundonly.$$.fragment);
      t1 = space();
      div1 = element("div");
      create_component(macro2.$$.fragment);
      t2 = space();
      div4 = element("div");
      div3 = element("div");
      div2 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.preset")} 
                    ${localize("autoanimations.menus.type")}`;
      t6 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.presetTypes.dualattach")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.presetTypes.proToTemp")}`;
      option2 = element("option");
      option2.textContent = `${localize("autoanimations.presetTypes.animTeleportation")}`;
      option3 = element("option");
      option3.textContent = `${localize("autoanimations.presetTypes.thunderwave")} D&D
                        5e`;
      t12 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      div0.hidden = div0_hidden_value = !/*soundOnly*/
      ctx[5];
      div1.hidden = div1_hidden_value = !/*macroEnabled*/
      ctx[4];
      attr(label, "for", "1");
      attr(label, "class", "svelte-auto-1rxi4rw");
      option0.__value = "dualattach";
      option0.value = option0.__value;
      option1.__value = "proToTemp";
      option1.value = option1.__value;
      option2.__value = "teleportation";
      option2.value = option2.__value;
      option3.__value = "thunderwave";
      option3.value = option3.__value;
      set_style(select, "background-color", "rgba(21, 154, 169, 0.4)");
      set_style(select, "width", "95%");
      attr(select, "class", "svelte-auto-1rxi4rw");
      if (
        /*$animation*/
        ctx[2].presetType === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[8].call(select)
        ));
      attr(div2, "class", "flexcol");
      set_style(div2, "grid-row", "2 / 3");
      set_style(div2, "grid-column", "2 / 3");
      set_style(div2, "margin-bottom", "0.75em");
      attr(div3, "class", "aa-pickAnim svelte-auto-1rxi4rw");
      div4.hidden = div4_hidden_value = /*soundOnly*/
      ctx[5] || /*macroEnabled*/
      ctx[4] && /*macroPlay*/
      ctx[3] === "2";
    },
    m(target2, anchor) {
      mount_component(sectionbuttons, target2, anchor);
      insert(target2, t0, anchor);
      insert(target2, div0, anchor);
      mount_component(soundonly, div0, null);
      insert(target2, t1, anchor);
      insert(target2, div1, anchor);
      mount_component(macro2, div1, null);
      insert(target2, t2, anchor);
      insert(target2, div4, anchor);
      append(div4, div3);
      append(div3, div2);
      append(div2, label);
      append(div2, t6);
      append(div2, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      append(select, option3);
      select_option(
        select,
        /*$animation*/
        ctx[2].presetType,
        true
      );
      append(div4, t12);
      if (switch_instance)
        mount_component(switch_instance, div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[8]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const sectionbuttons_changes = {};
      if (dirty & /*fromMenu*/
      1)
        sectionbuttons_changes.type = /*fromMenu*/
        ctx2[0];
      sectionbuttons.$set(sectionbuttons_changes);
      if (!current || dirty & /*soundOnly*/
      32 && div0_hidden_value !== (div0_hidden_value = !/*soundOnly*/
      ctx2[5])) {
        div0.hidden = div0_hidden_value;
      }
      if (!current || dirty & /*macroEnabled*/
      16 && div1_hidden_value !== (div1_hidden_value = !/*macroEnabled*/
      ctx2[4])) {
        div1.hidden = div1_hidden_value;
      }
      if (dirty & /*$animation*/
      4) {
        select_option(
          select,
          /*$animation*/
          ctx2[2].presetType
        );
      }
      if (dirty & /*presetRoute*/
      2 && switch_value !== (switch_value = /*presetRoute*/
      ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div4, null);
        } else {
          switch_instance = null;
        }
      }
      if (!current || dirty & /*soundOnly, macroEnabled, macroPlay*/
      56 && div4_hidden_value !== (div4_hidden_value = /*soundOnly*/
      ctx2[5] || /*macroEnabled*/
      ctx2[4] && /*macroPlay*/
      ctx2[3] === "2")) {
        div4.hidden = div4_hidden_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sectionbuttons.$$.fragment, local);
      transition_in(soundonly.$$.fragment, local);
      transition_in(macro2.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sectionbuttons.$$.fragment, local);
      transition_out(soundonly.$$.fragment, local);
      transition_out(macro2.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sectionbuttons, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div0);
      destroy_component(soundonly);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      destroy_component(macro2);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div4);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let soundOnly;
  let macroEnabled;
  let macroPlay;
  let $animation;
  let { fromMenu = "autorec" } = $$props;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(2, $animation = value));
  let presetType = $animation.presetType || "proToTemp";
  let presetContent = {
    dualattach: { component: DualAttach },
    proToTemp: { component: ProjectileToTemplate },
    teleportation: { component: Teleportation },
    thunderwave: { component: Thunderwave },
    "": {}
  };
  let presetRoute = presetContent[presetType].component;
  function changePreset() {
    let newData = preset({}, $animation.presetType);
    switch (animation._data.presetType) {
      case "dualattach":
        set_store_value(animation, $animation.data = newData.data, $animation);
        delete $animation.secondary;
        delete $animation.target;
        $$invalidate(1, presetRoute = presetContent.dualattach.component);
        break;
      case "teleportation":
        set_store_value(animation, $animation.data = newData.data, $animation);
        delete $animation.secondary;
        delete $animation.target;
        $$invalidate(1, presetRoute = presetContent.teleportation.component);
        break;
      case "thunderwave":
        set_store_value(animation, $animation.data = newData.data, $animation);
        delete $animation.secondary;
        delete $animation.target;
        $$invalidate(1, presetRoute = presetContent.thunderwave.component);
        break;
      case "proToTemp":
        set_store_value(animation, $animation.data = newData.data, $animation);
        set_store_value(animation, $animation.secondary = newData.secondary, $animation);
        set_store_value(animation, $animation.target = newData.target, $animation);
        $$invalidate(1, presetRoute = presetContent.proToTemp.component);
        break;
    }
  }
  function select_change_handler() {
    $animation.presetType = select_value(this);
    animation.set($animation);
  }
  const change_handler = () => changePreset();
  $$self.$$set = ($$props2) => {
    if ("fromMenu" in $$props2)
      $$invalidate(0, fromMenu = $$props2.fromMenu);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*presetRoute*/
    2)
      ;
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(5, soundOnly = $animation.soundOnly.sound.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(4, macroEnabled = $animation.macro.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(3, macroPlay = $animation.macro.playWhen);
    }
  };
  return [
    fromMenu,
    presetRoute,
    $animation,
    macroPlay,
    macroEnabled,
    soundOnly,
    animation,
    changePreset,
    select_change_handler,
    change_handler
  ];
}
class BuildPreset extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$g, create_fragment$i, safe_not_equal, { fromMenu: 0 });
  }
}
const BuildActiveEffects_svelte_svelte_type_style_lang = "";
function create_fragment$h(ctx) {
  let sectionbuttons;
  let t0;
  let div0;
  let soundonly;
  let div0_hidden_value;
  let t1;
  let div1;
  let macro2;
  let div1_hidden_value;
  let t2;
  let div5;
  let div4;
  let div3;
  let div2;
  let label;
  let t6;
  let select;
  let option0;
  let option1;
  let t9;
  let switch_instance;
  let div4_hidden_value;
  let current;
  let mounted;
  let dispose;
  sectionbuttons = new SectionButtons02({ props: { type: (
    /*fromMenu*/
    ctx[0]
  ) } });
  soundonly = new SoundOnly({});
  macro2 = new Macro$1({});
  var switch_value = (
    /*activeEffectRoute*/
    ctx[4]
  );
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      create_component(sectionbuttons.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(soundonly.$$.fragment);
      t1 = space();
      div1 = element("div");
      create_component(macro2.$$.fragment);
      t2 = space();
      div5 = element("div");
      div4 = element("div");
      div3 = element("div");
      div2 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.animation")} 
                    ${localize("autoanimations.menus.type")}`;
      t6 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.animTypes.ontoken")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.animTypes.aura")}`;
      t9 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      div0.hidden = div0_hidden_value = !/*soundOnly*/
      ctx[3];
      div1.hidden = div1_hidden_value = !/*macroEnabled*/
      ctx[2];
      attr(label, "for", "");
      attr(label, "class", "svelte-auto-11wacwj");
      option0.__value = "ontoken";
      option0.value = option0.__value;
      option1.__value = "aura";
      option1.value = option1.__value;
      set_style(select, "background-color", "rgba(21, 154, 169, 0.4)");
      set_style(select, "width", "12em");
      attr(select, "class", "svelte-auto-11wacwj");
      if (
        /*$animation*/
        ctx[1].activeEffectType === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[8].call(select)
        ));
      attr(div2, "class", "flexcol");
      set_style(div2, "grid-row", "2 / 3");
      set_style(div2, "grid-column", "2 / 3");
      set_style(div2, "margin-bottom", "1em");
      attr(div3, "class", "aa-pickAnim svelte-auto-11wacwj");
      div4.hidden = div4_hidden_value = /*$animation*/
      ctx[1].macro.enable && /*$animation*/
      ctx[1].macro.playWhen === "2";
      div5.hidden = /*soundOnly*/
      ctx[3];
    },
    m(target2, anchor) {
      mount_component(sectionbuttons, target2, anchor);
      insert(target2, t0, anchor);
      insert(target2, div0, anchor);
      mount_component(soundonly, div0, null);
      insert(target2, t1, anchor);
      insert(target2, div1, anchor);
      mount_component(macro2, div1, null);
      insert(target2, t2, anchor);
      insert(target2, div5, anchor);
      append(div5, div4);
      append(div4, div3);
      append(div3, div2);
      append(div2, label);
      append(div2, t6);
      append(div2, select);
      append(select, option0);
      append(select, option1);
      select_option(
        select,
        /*$animation*/
        ctx[1].activeEffectType,
        true
      );
      append(div4, t9);
      if (switch_instance)
        mount_component(switch_instance, div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[8]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const sectionbuttons_changes = {};
      if (dirty & /*fromMenu*/
      1)
        sectionbuttons_changes.type = /*fromMenu*/
        ctx2[0];
      sectionbuttons.$set(sectionbuttons_changes);
      if (!current || dirty & /*soundOnly*/
      8 && div0_hidden_value !== (div0_hidden_value = !/*soundOnly*/
      ctx2[3])) {
        div0.hidden = div0_hidden_value;
      }
      if (!current || dirty & /*macroEnabled*/
      4 && div1_hidden_value !== (div1_hidden_value = !/*macroEnabled*/
      ctx2[2])) {
        div1.hidden = div1_hidden_value;
      }
      if (dirty & /*$animation*/
      2) {
        select_option(
          select,
          /*$animation*/
          ctx2[1].activeEffectType
        );
      }
      if (dirty & /*activeEffectRoute*/
      16 && switch_value !== (switch_value = /*activeEffectRoute*/
      ctx2[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div4, null);
        } else {
          switch_instance = null;
        }
      }
      if (!current || dirty & /*$animation*/
      2 && div4_hidden_value !== (div4_hidden_value = /*$animation*/
      ctx2[1].macro.enable && /*$animation*/
      ctx2[1].macro.playWhen === "2")) {
        div4.hidden = div4_hidden_value;
      }
      if (!current || dirty & /*soundOnly*/
      8) {
        div5.hidden = /*soundOnly*/
        ctx2[3];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sectionbuttons.$$.fragment, local);
      transition_in(soundonly.$$.fragment, local);
      transition_in(macro2.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sectionbuttons.$$.fragment, local);
      transition_out(soundonly.$$.fragment, local);
      transition_out(macro2.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sectionbuttons, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div0);
      destroy_component(soundonly);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      destroy_component(macro2);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div5);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let activeEffectType;
  let activeEffectRoute;
  let soundOnly;
  let macroEnabled;
  let $animation;
  let { fromMenu = "autorec" } = $$props;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(1, $animation = value));
  let aeContent = {
    ontoken: { component: BuildAEOnToken },
    aura: { component: BuildAEAura },
    "": {}
  };
  function changeAE() {
    let newData = aefx({}, animation._data.activeEffectType);
    switch (animation._data.activeEffectType) {
      case "ontoken":
        set_store_value(animation, $animation.primary = newData.primary, $animation);
        break;
      case "aura":
        set_store_value(animation, $animation.primary = newData.primary, $animation);
        break;
    }
  }
  function select_change_handler() {
    $animation.activeEffectType = select_value(this);
    animation.set($animation);
  }
  const change_handler = () => changeAE();
  $$self.$$set = ($$props2) => {
    if ("fromMenu" in $$props2)
      $$invalidate(0, fromMenu = $$props2.fromMenu);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(7, activeEffectType = $animation.activeEffectType);
    }
    if ($$self.$$.dirty & /*activeEffectType*/
    128) {
      $$invalidate(4, activeEffectRoute = aeContent[activeEffectType].component);
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(3, soundOnly = $animation.soundOnly.sound.enable);
    }
    if ($$self.$$.dirty & /*$animation*/
    2) {
      $$invalidate(2, macroEnabled = $animation.macro.enable);
    }
  };
  return [
    fromMenu,
    $animation,
    macroEnabled,
    soundOnly,
    activeEffectRoute,
    animation,
    changeAE,
    activeEffectType,
    select_change_handler,
    change_handler
  ];
}
class BuildActiveEffects extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$f, create_fragment$h, safe_not_equal, { fromMenu: 0 });
  }
}
function selectBuildMenu(categoryKey) {
  let component;
  switch (categoryKey) {
    case "aaAutorec-melee":
      component = BuildMelee;
      break;
    case "aaAutorec-range":
      component = BuildRange;
      break;
    case "aaAutorec-ontoken":
      component = BuildOnToken;
      break;
    case "aaAutorec-templatefx":
      component = BuildTemplateFX;
      break;
    case "aaAutorec-aura":
      component = BuildAura;
      break;
    case "aaAutorec-preset":
      component = BuildPreset;
      break;
    case "aaAutorec-aefx":
      component = BuildActiveEffects;
      break;
    default:
      throw new Error(`'selectBuildMenu' error: unknown category key: ${categoryKey}`);
  }
  return component;
}
const Animation_svelte_svelte_type_style_lang = "";
function create_default_slot$3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = selectBuildMenu(
    /*category*/
    ctx[1].key
  );
  function switch_props(ctx2) {
    return {
      props: {
        animation: (
          /*animation*/
          ctx2[0]
        ),
        idx: (
          /*idx*/
          ctx2[2]
        ),
        category: (
          /*category*/
          ctx2[1]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target2, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target2, anchor);
      insert(target2, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*animation*/
      1)
        switch_instance_changes.animation = /*animation*/
        ctx2[0];
      if (dirty & /*idx*/
      4)
        switch_instance_changes.idx = /*idx*/
        ctx2[2];
      if (dirty & /*category*/
      2)
        switch_instance_changes.category = /*category*/
        ctx2[1];
      if (dirty & /*category*/
      2 && switch_value !== (switch_value = selectBuildMenu(
        /*category*/
        ctx2[1].key
      ))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_label_slot(ctx) {
  let tjsinput;
  let current;
  tjsinput = new TJSInput({
    props: { input: (
      /*input*/
      ctx[5]
    ), slot: "label" }
  });
  return {
    c() {
      create_component(tjsinput.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjsinput, target2, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsinput, detaching);
    }
  };
}
function create_summary_end_slot(ctx) {
  let overflowslot;
  let current;
  overflowslot = new OverflowSlot({
    props: {
      info: (
        /*exactMatchButton*/
        ctx[3]
      ),
      menu: (
        /*menu*/
        ctx[6]
      ),
      slot: "summary-end"
    }
  });
  return {
    c() {
      create_component(overflowslot.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(overflowslot, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overflowslot_changes = {};
      if (dirty & /*exactMatchButton*/
      8)
        overflowslot_changes.info = /*exactMatchButton*/
        ctx2[3];
      overflowslot.$set(overflowslot_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overflowslot.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overflowslot.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overflowslot, detaching);
    }
  };
}
function create_fragment$g(ctx) {
  let div;
  let tjssvgfolder;
  let current;
  tjssvgfolder = new TJSSvgFolder({
    props: {
      folder: (
        /*folder*/
        ctx[4]
      ),
      $$slots: {
        "summary-end": [create_summary_end_slot],
        label: [create_label_slot],
        default: [create_default_slot$3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(tjssvgfolder.$$.fragment);
      attr(div, "class", "animation svelte-auto-r7wy3l");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      mount_component(tjssvgfolder, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tjssvgfolder_changes = {};
      if (dirty & /*$$scope, exactMatchButton, category, animation, idx*/
      2063) {
        tjssvgfolder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssvgfolder.$set(tjssvgfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssvgfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssvgfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjssvgfolder);
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let isExactMatch;
  let excludedTerms;
  let exactMatchButton;
  let $animation, $$unsubscribe_animation = noop, $$subscribe_animation = () => ($$unsubscribe_animation(), $$unsubscribe_animation = subscribe(animation, ($$value) => $$invalidate(9, $animation = $$value)), animation);
  $$self.$$.on_destroy.push(() => $$unsubscribe_animation());
  let { animation = void 0 } = $$props;
  $$subscribe_animation();
  let { category = void 0 } = $$props;
  let { idx = void 0 } = $$props;
  setContext("animation-data", { animation, category, idx });
  const folder = {
    options: { chevronOnly: true },
    store: animation.stores.folderOpen
  };
  const input = {
    store: animation.stores.label,
    efx: rippleFocus(),
    placeholder: "autoanimations.menus.itemName",
    options: { cancelOnEscKey: true }
  };
  const menu = {
    items: createOverflowItems(animation, category)
  };
  $$self.$$set = ($$props2) => {
    if ("animation" in $$props2)
      $$subscribe_animation($$invalidate(0, animation = $$props2.animation));
    if ("category" in $$props2)
      $$invalidate(1, category = $$props2.category);
    if ("idx" in $$props2)
      $$invalidate(2, idx = $$props2.idx);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    512) {
      $$invalidate(8, isExactMatch = $animation.advanced?.exactMatch);
    }
    if ($$self.$$.dirty & /*$animation*/
    512) {
      $$invalidate(7, excludedTerms = $animation.advanced?.excludedTerms);
    }
    if ($$self.$$.dirty & /*isExactMatch, excludedTerms*/
    384) {
      $$invalidate(3, exactMatchButton = {
        icon: isExactMatch ? "fas fa-equals" : excludedTerms?.length ? "fas fa-not-equal" : "",
        title: isExactMatch ? "Exact Match" : excludedTerms?.length ? "Has Excluded Terms" : ""
      });
    }
  };
  return [
    animation,
    category,
    idx,
    exactMatchButton,
    folder,
    input,
    menu,
    excludedTerms,
    isExactMatch,
    $animation
  ];
}
class Animation extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$e, create_fragment$g, safe_not_equal, { animation: 0, category: 1, idx: 2 });
  }
}
const CategoryList_svelte_svelte_type_style_lang$1 = "";
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[9] = i;
  return child_ctx;
}
function create_each_block$2(key_1, ctx) {
  let section2;
  let animation;
  let t;
  let rect;
  let stop_animation = noop;
  let current;
  animation = new Animation({
    props: {
      animation: (
        /*animation*/
        ctx[7]
      ),
      idx: (
        /*idx*/
        ctx[9]
      ),
      category: (
        /*category*/
        ctx[0]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      section2 = element("section");
      create_component(animation.$$.fragment);
      t = space();
      attr(section2, "class", "svelte-auto-1sq79pi");
      this.first = section2;
    },
    m(target2, anchor) {
      insert(target2, section2, anchor);
      mount_component(animation, section2, null);
      append(section2, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const animation_changes = {};
      if (dirty & /*$dataReducer*/
      2)
        animation_changes.animation = /*animation*/
        ctx[7];
      if (dirty & /*$dataReducer*/
      2)
        animation_changes.idx = /*idx*/
        ctx[9];
      if (dirty & /*category*/
      1)
        animation_changes.category = /*category*/
        ctx[0];
      animation.$set(animation_changes);
    },
    r() {
      rect = section2.getBoundingClientRect();
    },
    f() {
      fix_position(section2);
      stop_animation();
    },
    a() {
      stop_animation();
      stop_animation = create_animation(
        section2,
        rect,
        /*flipWithEvents*/
        ctx[5],
        { duration: 250, easing: quintOut }
      );
    },
    i(local) {
      if (current)
        return;
      transition_in(animation.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(animation.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section2);
      destroy_component(animation);
    }
  };
}
function create_fragment$f(ctx) {
  let main2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let applyScrolltop_action;
  let current;
  let mounted;
  let dispose;
  let each_value = [.../*$dataReducer*/
  ctx[1]];
  const get_key = (ctx2) => (
    /*animation*/
    ctx2[7].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
  }
  return {
    c() {
      main2 = element("main");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(main2, "class", "svelte-auto-1sq79pi");
      toggle_class(
        main2,
        "no-scroll",
        /*$isAnimating*/
        ctx[3]
      );
    },
    m(target2, anchor) {
      insert(target2, main2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(main2, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(applyScrolltop_action = applyScrolltop.call(
            null,
            main2,
            /*category*/
            ctx[0].stores.scrollTop
          )),
          listen(
            main2,
            "openAny",
            /*onFolderChange*/
            ctx[6]
          ),
          listen(
            main2,
            "closeAny",
            /*onFolderChange*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$dataReducer, category*/
      3) {
        each_value = [.../*$dataReducer*/
        ctx2[1]];
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, main2, fix_and_outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
      if (applyScrolltop_action && is_function(applyScrolltop_action.update) && dirty & /*category*/
      1)
        applyScrolltop_action.update.call(
          null,
          /*category*/
          ctx2[0].stores.scrollTop
        );
      if (!current || dirty & /*$isAnimating*/
      8) {
        toggle_class(
          main2,
          "no-scroll",
          /*$isAnimating*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let dataReducer;
  let $dataReducer, $$unsubscribe_dataReducer = noop, $$subscribe_dataReducer = () => ($$unsubscribe_dataReducer(), $$unsubscribe_dataReducer = subscribe(dataReducer, ($$value) => $$invalidate(1, $dataReducer = $$value)), dataReducer);
  let $isAnimating;
  $$self.$$.on_destroy.push(() => $$unsubscribe_dataReducer());
  let { category } = $$props;
  const isAnimating = writable$1(false);
  component_subscribe($$self, isAnimating, (value) => $$invalidate(3, $isAnimating = value));
  const flipWithEvents = animateEvents(flip, isAnimating);
  const onFolderChange = foundry.utils.debounce(() => category.calcAllFolderState(), 100);
  $$self.$$set = ($$props2) => {
    if ("category" in $$props2)
      $$invalidate(0, category = $$props2.category);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*category*/
    1) {
      $$subscribe_dataReducer($$invalidate(2, dataReducer = category.dataReducer));
    }
    if ($$self.$$.dirty & /*$dataReducer*/
    2) {
      onFolderChange($dataReducer);
    }
  };
  return [
    category,
    $dataReducer,
    dataReducer,
    $isAnimating,
    isAnimating,
    flipWithEvents,
    onFolderChange
  ];
}
let CategoryList$1 = class CategoryList3 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$d, create_fragment$f, safe_not_equal, { category: 0 });
  }
};
const ImportMenus_svelte_svelte_type_style_lang = "";
function create_fragment$e(ctx) {
  let header;
  let t1;
  let table;
  let tr0;
  let th;
  let div1;
  let input0;
  let t2;
  let label1;
  let t4;
  let tr1;
  let td0;
  let div2;
  let input1;
  let t5;
  let label2;
  let t7;
  let td1;
  let div3;
  let input2;
  let t8;
  let label3;
  let t10;
  let tr2;
  let td2;
  let div4;
  let input3;
  let t11;
  let label4;
  let t13;
  let td3;
  let div5;
  let input4;
  let t14;
  let label5;
  let t16;
  let tr3;
  let td4;
  let div6;
  let input5;
  let t17;
  let label6;
  let t19;
  let td5;
  let div7;
  let input6;
  let t20;
  let label7;
  let t22;
  let tr4;
  let td6;
  let div8;
  let input7;
  let t23;
  let label8;
  let t25;
  let div9;
  let t26;
  let footer;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      header = element("header");
      header.innerHTML = `<div style="text-align: center; font-size: 1.5em"><label for="">Choose Menus Import</label></div>`;
      t1 = space();
      table = element("table");
      tr0 = element("tr");
      th = element("th");
      div1 = element("div");
      input0 = element("input");
      t2 = space();
      label1 = element("label");
      label1.textContent = "Check / Uncheck All";
      t4 = space();
      tr1 = element("tr");
      td0 = element("td");
      div2 = element("div");
      input1 = element("input");
      t5 = space();
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.animTypes.melee")}`;
      t7 = space();
      td1 = element("td");
      div3 = element("div");
      input2 = element("input");
      t8 = space();
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.animTypes.range")}`;
      t10 = space();
      tr2 = element("tr");
      td2 = element("td");
      div4 = element("div");
      input3 = element("input");
      t11 = space();
      label4 = element("label");
      label4.textContent = `${localize("autoanimations.animTypes.ontoken")}`;
      t13 = space();
      td3 = element("td");
      div5 = element("div");
      input4 = element("input");
      t14 = space();
      label5 = element("label");
      label5.textContent = `${localize("autoanimations.animTypes.templatefx")}`;
      t16 = space();
      tr3 = element("tr");
      td4 = element("td");
      div6 = element("div");
      input5 = element("input");
      t17 = space();
      label6 = element("label");
      label6.textContent = `${localize("autoanimations.animTypes.aura")}`;
      t19 = space();
      td5 = element("td");
      div7 = element("div");
      input6 = element("input");
      t20 = space();
      label7 = element("label");
      label7.textContent = `${localize("autoanimations.animTypes.preset")}`;
      t22 = space();
      tr4 = element("tr");
      td6 = element("td");
      div8 = element("div");
      input7 = element("input");
      t23 = space();
      label8 = element("label");
      label8.textContent = `${localize("autoanimations.animTypes.aefx")}`;
      t25 = space();
      div9 = element("div");
      t26 = space();
      footer = element("footer");
      button = element("button");
      button.textContent = "Import";
      attr(input0, "type", "checkbox");
      attr(label1, "for", "");
      attr(label1, "class", "svelte-auto-1qtj224");
      attr(th, "colspan", "2");
      attr(input1, "type", "checkbox");
      attr(label2, "for", "");
      attr(label2, "class", "svelte-auto-1qtj224");
      attr(input2, "type", "checkbox");
      attr(label3, "for", "");
      attr(label3, "class", "svelte-auto-1qtj224");
      attr(input3, "type", "checkbox");
      attr(label4, "for", "");
      attr(label4, "class", "svelte-auto-1qtj224");
      attr(input4, "type", "checkbox");
      attr(label5, "for", "");
      attr(label5, "class", "svelte-auto-1qtj224");
      attr(input5, "type", "checkbox");
      attr(label6, "for", "");
      attr(label6, "class", "svelte-auto-1qtj224");
      attr(input6, "type", "checkbox");
      attr(label7, "for", "");
      attr(label7, "class", "svelte-auto-1qtj224");
      attr(input7, "type", "checkbox");
      attr(label8, "for", "");
      attr(label8, "class", "svelte-auto-1qtj224");
      attr(table, "class", "e svelte-auto-1qtj224");
      attr(div9, "class", "aa-list");
    },
    m(target2, anchor) {
      insert(target2, header, anchor);
      insert(target2, t1, anchor);
      insert(target2, table, anchor);
      append(table, tr0);
      append(tr0, th);
      append(th, div1);
      append(div1, input0);
      input0.checked = /*allMenus*/
      ctx[0];
      append(div1, t2);
      append(div1, label1);
      append(table, t4);
      append(table, tr1);
      append(tr1, td0);
      append(td0, div2);
      append(div2, input1);
      input1.checked = /*melee*/
      ctx[1];
      append(div2, t5);
      append(div2, label2);
      append(tr1, t7);
      append(tr1, td1);
      append(td1, div3);
      append(div3, input2);
      input2.checked = /*range*/
      ctx[2];
      append(div3, t8);
      append(div3, label3);
      append(table, t10);
      append(table, tr2);
      append(tr2, td2);
      append(td2, div4);
      append(div4, input3);
      input3.checked = /*ontoken*/
      ctx[3];
      append(div4, t11);
      append(div4, label4);
      append(tr2, t13);
      append(tr2, td3);
      append(td3, div5);
      append(div5, input4);
      input4.checked = /*templatefx*/
      ctx[4];
      append(div5, t14);
      append(div5, label5);
      append(table, t16);
      append(table, tr3);
      append(tr3, td4);
      append(td4, div6);
      append(div6, input5);
      input5.checked = /*aura*/
      ctx[5];
      append(div6, t17);
      append(div6, label6);
      append(tr3, t19);
      append(tr3, td5);
      append(td5, div7);
      append(div7, input6);
      input6.checked = /*preset*/
      ctx[6];
      append(div7, t20);
      append(div7, label7);
      append(table, t22);
      append(table, tr4);
      append(tr4, td6);
      append(td6, div8);
      append(div8, input7);
      input7.checked = /*aefx*/
      ctx[7];
      append(div8, t23);
      append(div8, label8);
      insert(target2, t25, anchor);
      insert(target2, div9, anchor);
      insert(target2, t26, anchor);
      insert(target2, footer, anchor);
      append(footer, button);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[11]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[12]
          ),
          listen(
            input2,
            "change",
            /*input2_change_handler*/
            ctx[13]
          ),
          listen(
            input3,
            "change",
            /*input3_change_handler*/
            ctx[14]
          ),
          listen(
            input4,
            "change",
            /*input4_change_handler*/
            ctx[15]
          ),
          listen(
            input5,
            "change",
            /*input5_change_handler*/
            ctx[16]
          ),
          listen(
            input6,
            "change",
            /*input6_change_handler*/
            ctx[17]
          ),
          listen(
            input7,
            "change",
            /*input7_change_handler*/
            ctx[18]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[19]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*allMenus*/
      1) {
        input0.checked = /*allMenus*/
        ctx2[0];
      }
      if (dirty & /*melee*/
      2) {
        input1.checked = /*melee*/
        ctx2[1];
      }
      if (dirty & /*range*/
      4) {
        input2.checked = /*range*/
        ctx2[2];
      }
      if (dirty & /*ontoken*/
      8) {
        input3.checked = /*ontoken*/
        ctx2[3];
      }
      if (dirty & /*templatefx*/
      16) {
        input4.checked = /*templatefx*/
        ctx2[4];
      }
      if (dirty & /*aura*/
      32) {
        input5.checked = /*aura*/
        ctx2[5];
      }
      if (dirty & /*preset*/
      64) {
        input6.checked = /*preset*/
        ctx2[6];
      }
      if (dirty & /*aefx*/
      128) {
        input7.checked = /*aefx*/
        ctx2[7];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(header);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(table);
      if (detaching)
        detach(t25);
      if (detaching)
        detach(div9);
      if (detaching)
        detach(t26);
      if (detaching)
        detach(footer);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  const { application } = getContext("#external");
  let { type } = $$props;
  let { menu } = $$props;
  let allMenus = false, melee2, range2, ontoken2, templatefx2, aura2, preset2, aefx2;
  function importSelected() {
    let selectedMenus = {
      melee: melee2,
      range: range2,
      ontoken: ontoken2,
      templatefx: templatefx2,
      aura: aura2,
      preset: preset2,
      aefx: aefx2
    };
    if (type === "merge") {
      mergeMenus(selectedMenus);
    } else if (type === "overwrite") {
      overwriteMenus(selectedMenus);
    }
    application.close();
  }
  async function mergeMenus(selectedMenus) {
    let isValid = validateJson(menu);
    if (!isValid) {
      custom_error("You did not provide a valid JSON!");
      return;
    }
    const menuData = JSON.parse(menu);
    function validateJson(json) {
      try {
        JSON.parse(json);
        return true;
      } catch (e) {
        return false;
      }
    }
    AAAutorecManager.mergeMenus(menuData, { ...selectedMenus });
  }
  async function overwriteMenus(selectedMenus) {
    AAAutorecManager.overwriteMenus(menu, { shouldSubmit: true, ...selectedMenus });
  }
  function input0_change_handler() {
    allMenus = this.checked;
    $$invalidate(0, allMenus);
  }
  function input1_change_handler() {
    melee2 = this.checked;
    $$invalidate(1, melee2), $$invalidate(0, allMenus);
  }
  function input2_change_handler() {
    range2 = this.checked;
    $$invalidate(2, range2), $$invalidate(0, allMenus);
  }
  function input3_change_handler() {
    ontoken2 = this.checked;
    $$invalidate(3, ontoken2), $$invalidate(0, allMenus);
  }
  function input4_change_handler() {
    templatefx2 = this.checked;
    $$invalidate(4, templatefx2), $$invalidate(0, allMenus);
  }
  function input5_change_handler() {
    aura2 = this.checked;
    $$invalidate(5, aura2), $$invalidate(0, allMenus);
  }
  function input6_change_handler() {
    preset2 = this.checked;
    $$invalidate(6, preset2), $$invalidate(0, allMenus);
  }
  function input7_change_handler() {
    aefx2 = this.checked;
    $$invalidate(7, aefx2), $$invalidate(0, allMenus);
  }
  const click_handler = () => importSelected();
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(9, type = $$props2.type);
    if ("menu" in $$props2)
      $$invalidate(10, menu = $$props2.menu);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*allMenus*/
    1) {
      $$invalidate(1, melee2 = $$invalidate(2, range2 = $$invalidate(3, ontoken2 = $$invalidate(4, templatefx2 = $$invalidate(5, aura2 = $$invalidate(6, preset2 = $$invalidate(7, aefx2 = allMenus)))))));
    }
  };
  return [
    allMenus,
    melee2,
    range2,
    ontoken2,
    templatefx2,
    aura2,
    preset2,
    aefx2,
    importSelected,
    type,
    menu,
    input0_change_handler,
    input1_change_handler,
    input2_change_handler,
    input3_change_handler,
    input4_change_handler,
    input5_change_handler,
    input6_change_handler,
    input7_change_handler,
    click_handler
  ];
}
class ImportMenus extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$c, create_fragment$e, safe_not_equal, { type: 9, menu: 10 });
  }
}
const MenuManager_svelte_svelte_type_style_lang = "";
function create_fragment$d(ctx) {
  let div2;
  let div0;
  let button0;
  let t1;
  let div1;
  let label0;
  let t3;
  let div5;
  let div3;
  let button1;
  let t7;
  let div4;
  let label1;
  let t9;
  let div8;
  let div6;
  let button2;
  let t13;
  let div7;
  let label2;
  let t15;
  let div11;
  let div9;
  let button3;
  let t19;
  let div10;
  let label3;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.textContent = `${localize("autoanimations.settings.restoreDefault")}`;
      t1 = space();
      div1 = element("div");
      label0 = element("label");
      label0.textContent = `${localize("autoanimations.settings.restoreHint")}`;
      t3 = space();
      div5 = element("div");
      div3 = element("div");
      button1 = element("button");
      button1.textContent = `${localize("autoanimations.menus.merge")} 
            ${localize("autoanimations.menus.menu")}`;
      t7 = space();
      div4 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("autoanimations.settings.mergeHint")}`;
      t9 = space();
      div8 = element("div");
      div6 = element("div");
      button2 = element("button");
      button2.textContent = `${localize("autoanimations.menus.overwrite")} 
            ${localize("autoanimations.menus.menu")}`;
      t13 = space();
      div7 = element("div");
      label2 = element("label");
      label2.textContent = `${localize("autoanimations.settings.overwriteHint")}`;
      t15 = space();
      div11 = element("div");
      div9 = element("div");
      button3 = element("button");
      button3.textContent = `${localize("autoanimations.menus.export")} 
            ${localize("autoanimations.menus.menu")}`;
      t19 = space();
      div10 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("autoanimations.settings.exportHint")}`;
      attr(button0, "class", "aa-orange svelte-auto-1gugmsw");
      set_style(div0, "grid-row", "1/2");
      set_style(div0, "grid-column", "1/2");
      attr(label0, "for", "");
      set_style(div1, "grid-row", "1/2");
      set_style(div1, "grid-column", "2/3");
      attr(div2, "class", "flexcol aa-tabs svelte-auto-1gugmsw");
      attr(button1, "class", "aa-green svelte-auto-1gugmsw");
      set_style(div3, "grid-row", "2/3");
      set_style(div3, "grid-column", "1/2");
      attr(label1, "for", "");
      set_style(div4, "grid-row", "2/3");
      set_style(div4, "grid-column", "2/3");
      attr(div5, "class", "flexcol aa-tabs svelte-auto-1gugmsw");
      attr(button2, "class", "aa-red svelte-auto-1gugmsw");
      set_style(div6, "grid-row", "3/4");
      set_style(div6, "grid-column", "1/2");
      attr(label2, "for", "");
      set_style(div7, "grid-row", "3/4");
      set_style(div7, "grid-column", "2/3");
      attr(div8, "class", "flexcol aa-tabs svelte-auto-1gugmsw");
      attr(button3, "class", "aa-blue svelte-auto-1gugmsw");
      set_style(div9, "grid-row", "4/5");
      set_style(div9, "grid-column", "1/2");
      attr(label3, "for", "");
      set_style(div10, "grid-row", "4/5");
      set_style(div10, "grid-column", "2/3");
      attr(div11, "class", "flexcol aa-tabs svelte-auto-1gugmsw");
    },
    m(target2, anchor) {
      insert(target2, div2, anchor);
      append(div2, div0);
      append(div0, button0);
      append(div2, t1);
      append(div2, div1);
      append(div1, label0);
      insert(target2, t3, anchor);
      insert(target2, div5, anchor);
      append(div5, div3);
      append(div3, button1);
      append(div5, t7);
      append(div5, div4);
      append(div4, label1);
      insert(target2, t9, anchor);
      insert(target2, div8, anchor);
      append(div8, div6);
      append(div6, button2);
      append(div8, t13);
      append(div8, div7);
      append(div7, label2);
      insert(target2, t15, anchor);
      insert(target2, div11, anchor);
      append(div11, div9);
      append(div9, button3);
      append(div11, t19);
      append(div11, div10);
      append(div10, label3);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(button1, "click", prevent_default(
            /*click_handler_1*/
            ctx[5]
          )),
          listen(
            button2,
            "click",
            /*click_handler_2*/
            ctx[6]
          ),
          listen(button3, "click", prevent_default(
            /*click_handler_3*/
            ctx[7]
          ))
        ];
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div5);
      if (detaching)
        detach(t9);
      if (detaching)
        detach(div8);
      if (detaching)
        detach(t15);
      if (detaching)
        detach(div11);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$b($$self) {
  const { application } = getContext("#external");
  async function restoreDefault() {
    TJSDialog.confirm({
      modal: true,
      title: "WARNING!!",
      content: `<p style="font-weight: bold; text-align: center; font-size: medium;">This will ERASE your current Menu. ARE YOU SURE?</p>
                    <br>
                    <p style="text-align: center; font-size: small;">A Backup will be Exported for Insurance</p> `,
      onYes: () => setDefault(),
      onNo: () => console.log("Exiting without default restore"),
      defaultYes: false
    });
    async function setDefault() {
      AAAutorecManager.exportMenu("-backup");
      Hooks.call("AutomaticAnimations.Clear.Data");
      application.close();
    }
  }
  async function mergeMenu() {
    TJSDialog.confirm({
      title: "WARNING!!",
      modal: true,
      content: `<p style="text-align:center">This will <strong>Merge</strong> menus and is <strong>IRREVERSIBLE. Continue?</strong></p>`,
      onYes: () => getFiles(),
      onNo: () => console.log("Exiting without default restore"),
      defaultYes: false
    });
    async function getFiles() {
      const content = await renderTemplate("modules/autoanimations/htmlTemplate/import-data.html", {
        entity: "autoanimations",
        name: "aaAutorec"
      });
      TJSDialog.prompt({
        title: "Merge Menus",
        content,
        modal: true,
        onOk: (app) => {
          const form = app.element.find("form")[0];
          if (!form.data.files.length)
            return ui.notifications?.error("You did not upload a data file!");
          readTextFromFile(form.data.files[0]).then(async (json) => {
            selectMenus(json, "merge");
            await application.close();
          });
        }
      });
    }
  }
  function selectMenus(json, option) {
    new TJSDialog({
      modal: true,
      title: "IMPORT SETTINGS",
      content: {
        class: ImportMenus,
        props: { type: option, menu: json }
      },
      defaultYes: false
    }).render(true);
  }
  async function overwriteMenu() {
    TJSDialog.confirm({
      title: "WARNING!!",
      modal: true,
      content: `<p style="text-align:center">This will <strong>ERASE</strong> your current menu and is <strong>IRREVERSIBLE. Continue?</strong></p>`,
      onYes: () => getFiles(),
      onNo: () => console.log("Exiting without overwrite"),
      defaultYes: false
    });
    async function getFiles() {
      const content = await renderTemplate("modules/autoanimations/htmlTemplate/import-data.html", {
        entity: "autoanimations",
        name: "aaAutorec"
      });
      TJSDialog.prompt({
        title: "Overwrite Menu",
        content,
        modal: true,
        onOk: (app) => {
          const form = app.element.find("form")[0];
          if (!form.data.files.length)
            return ui.notifications?.error("You did not upload a data file!");
          readTextFromFile(form.data.files[0]).then(async (json) => {
            selectMenus(json, "overwrite");
            await application.close();
          });
        }
      });
    }
  }
  async function exportMenu() {
    AAAutorecManager.exportMenu(`-${game.system.id}`);
    application.close();
  }
  const click_handler = () => restoreDefault();
  const click_handler_1 = () => mergeMenu();
  const click_handler_2 = () => overwriteMenu();
  const click_handler_3 = () => exportMenu();
  return [
    restoreDefault,
    mergeMenu,
    overwriteMenu,
    exportMenu,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
let MenuManager$1 = class MenuManager2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$b, create_fragment$d, safe_not_equal, {});
  }
};
class MenuManager extends TJSDialog {
  static #app;
  /** @inheritDoc */
  constructor() {
    super({
      title: "Menu Manager",
      resizable: false,
      content: {
        class: MenuManager$1
      }
    }, {
      id: `Autorec-Menu-Manager`,
      minimizable: false,
      width: "auto",
      height: "auto"
    });
  }
  /**
   * @inheritDoc
   */
  async close(options2) {
    Object.values(ui.windows).filter((app) => app.id === "Options-Information" || app.id === "Autorec-Video-Preview").forEach((app) => app.close());
    MenuManager.#app = void 0;
    return super.close(options2);
  }
  /**
   * Show a single static instance of MenuManager; if it is already open then bring it to top.
   */
  static show() {
    if (this.#app) {
      this.#app.bringToTop();
    } else {
      this.#app = new MenuManager().render(true, { focus: true });
    }
  }
}
class AutorecShim extends FormApplication {
  /**
   * @inheritDoc
   */
  constructor(options2 = {}) {
    super({}, options2);
    showAutorecMenu();
  }
  async _updateObject(event, formData) {
  }
  render() {
    this.close();
  }
}
class aaAutorec {
  static get defaultConfiguration() {
    const defaultConfig = {
      version: currentAutorecVersion()
    };
    return defaultConfig;
  }
  constructor() {
    this._enabled = false;
  }
}
class AAGameSettings extends TJSGameSettings {
  constructor() {
    super("autoanimations");
  }
  initialize() {
    const namespace = this.namespace;
    const scope = {
      client: "client",
      world: "world"
    };
    const settings = [];
    Hooks.on("AA.Open.AutorecSetting", () => {
      if (game.user.isGM) {
        new AutorecShim();
      }
    });
    game.settings.registerMenu(namespace, "custom-autorec", {
      name: "autoanimations.settings.menuName",
      hint: "autoanimations.settings.menuHint",
      label: "autoanimations.settings.launchMenu",
      icon: "fas fa-dice-d20",
      type: AutorecShim,
      restricted: true
    });
    game.settings.register(namespace, "aaAutorec", {
      name: "Automatic Recognition",
      hint: "Configure Automatic Recognition",
      scope: scope.world,
      config: false,
      default: aaAutorec.defaultConfiguration,
      type: Object
    });
    settings.push({
      namespace,
      key: "killAllAnim",
      options: {
        name: "autoanimations.settings.toggleAnimations",
        hint: "autoanimations.settings.toggleAnimations_hint",
        scope: scope.client,
        config: true,
        type: String,
        choices: {
          on: "autoanimations.settings.ON",
          off: "autoanimations.settings.OFF"
        },
        default: "on",
        onChange: (value) => {
          if (value === "off") {
            AnimationState.enabled = false;
          }
          if (value === "on") {
            AnimationState.enabled = true;
          }
        }
      }
    });
    settings.push({
      namespace,
      key: "disableAutoRec",
      options: {
        name: "autoanimations.settings.settingDisableAutoRec",
        hint: "autoanimations.settings.settingDisableAutoRecHint",
        scope: scope.world,
        config: true,
        type: Boolean,
        default: false
      }
    });
    settings.push({
      namespace,
      key: "globaldelay",
      options: {
        name: "autoanimations.settings.globaldelay_name",
        hint: "autoanimations.settings.globaldelay_hint",
        scope: scope.world,
        config: true,
        default: 100,
        type: Number
      }
    });
    settings.push({
      namespace,
      key: "jb2aLocation",
      options: {
        name: "autoanimations.settings.s3Name",
        hint: "autoanimations.settings.s3Hint",
        scope: scope.world,
        config: true,
        type: String,
        default: "",
        requiresReload: true
      }
    });
    settings.push({
      namespace,
      key: "hideFromPlayers",
      options: {
        name: "autoanimations.settings.animtab_name",
        hint: "autoanimations.settings.animtab_hint",
        scope: scope.world,
        config: true,
        type: Boolean,
        default: false
      }
    });
    settings.push({
      namespace,
      key: "rangeSwitch",
      options: {
        name: "autoanimations.settings.settingRangeSwitch",
        hint: "autoanimations.settings.settingRangeSwitchhint",
        scope: scope.world,
        config: true,
        type: Boolean,
        default: false
      }
    });
    settings.push({
      namespace,
      key: "disableAEAnimations",
      options: {
        name: "autoanimations.settings.disableAEAnimations",
        hint: "autoanimations.settings.disableAEAnimationsHint",
        scope: scope.world,
        type: Boolean,
        default: false,
        config: true
      }
    });
    settings.push({
      namespace,
      key: "noTips",
      options: {
        name: "autoanimations.settings.noTips",
        hint: "autoanimations.settings.noTipsHint",
        scope: scope.world,
        config: true,
        type: Boolean,
        default: false
      }
    });
    settings.push({
      namespace,
      key: "hideTemplateGrid",
      options: {
        name: "autoanimations.settings.hideTemplate_name",
        hint: "autoanimations.settings.hideTemplate_hint",
        scope: scope.client,
        config: true,
        type: String,
        choices: {
          off: "autoanimations.settings.OFF",
          templateLayer: "autoanimations.settings.hoverInTemplateLayer",
          full: "autoanimations.settings.hoverInTemplate"
        },
        default: "off",
        requiresReload: true
      }
    });
    settings.push({
      namespace,
      key: "debug",
      options: {
        name: "autoanimations.settings.debugging",
        scope: scope.world,
        config: true,
        default: false,
        type: Boolean
      }
    });
    switch (game.system.id) {
      case "cyphersystem":
        settings.push({
          namespace,
          key: "EnableCritical",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.cypherCrit_name",
            hint: "autoanimations.settings.cypherCrit_hint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        settings.push({
          namespace,
          key: "CriticalAnimation",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.cypherCritAnim_name",
            scope: scope.world,
            type: String,
            config: true,
            default: "",
            filePicker: "imagevideo"
          }
        });
        settings.push({
          namespace,
          key: "EnableFumble",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.cypherFumble_name",
            hint: "autoanimations.settings.cypherFumble_hint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        settings.push({
          namespace,
          key: "FumbleAnimation",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.cypherFumbleAnim_name",
            scope: scope.world,
            type: String,
            config: true,
            default: "",
            filePicker: "imagevideo"
          }
        });
        settings.push({
          namespace,
          key: "EnableOnRecoveryRoll",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.recovery_name",
            hint: "autoanimations.settings.recovery_hint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        settings.push({
          namespace,
          key: "RecoveryRollAnimation",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.recoveryAnim_name",
            scope: scope.world,
            type: String,
            config: true,
            default: "",
            filePicker: "imagevideo"
          }
        });
        settings.push({
          namespace,
          key: "EnableOnMightRoll",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.mightroll_name",
            hint: "autoanimations.settings.mightroll_hint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        settings.push({
          namespace,
          key: "MightRollAnimation",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.mightRollAnim_name",
            scope: scope.world,
            type: String,
            config: true,
            default: "",
            filePicker: "imagevideo"
          }
        });
        settings.push({
          namespace,
          key: "EnableOnSpeedRoll",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.speedroll_name",
            hint: "autoanimations.settings.speedroll_hint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        settings.push({
          namespace,
          key: "SpeedRollAnimation",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.speedRollAnim_name",
            scope: scope.world,
            type: String,
            config: true,
            default: "",
            filePicker: "imagevideo"
          }
        });
        settings.push({
          namespace,
          key: "EnableOnIntellecRoll",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.intellectroll_name",
            hint: "autoanimations.settings.intellectroll_hint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        settings.push({
          namespace,
          key: "IntellectRollAnimation",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.intellectRollAnim_name",
            scope: scope.world,
            type: String,
            config: true,
            default: "",
            filePicker: "imagevideo"
          }
        });
        break;
      case "demonlord":
        settings.push({
          namespace,
          key: "playtrigger",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.demonlordtrigger_name",
            hint: "autoanimations.settings.demonlordtrigger_hint",
            scope: scope.world,
            type: String,
            choices: {
              rollattack: "autoanimations.settings.demonlordtrigger_rollattack",
              hits: "autoanimations.settings.demonlordtrigger_hits",
              misses: "autoanimations.settings.demonlordtrigger_misses",
              rolldamage: "autoanimations.settings.demonlordtrigger_rolldamage",
              applydamage: "autoanimations.settings.demonlordtrigger_applydamage"
            },
            default: "rollattack",
            config: true
          }
        });
        break;
      case "sfrpg":
        settings.push({
          namespace,
          key: "playonDamage",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.midiondmg_name",
            hint: "autoanimations.settings.midiondmg_hint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        break;
      case "dnd5e":
      case "sw5e":
        if (game.modules.get("midi-qol")?.active) {
          settings.push({
            namespace,
            key: "playonhit",
            folder: "Midi-QOL",
            options: {
              name: "autoanimations.settings.midionhit_name",
              hint: "autoanimations.settings.midionhit_hint",
              scope: scope.world,
              type: Boolean,
              default: false,
              config: true
            }
          });
          settings.push({
            namespace,
            key: "playonmiss",
            folder: "Midi-QOL",
            options: {
              name: "autoanimations.settings.midionmiss_name",
              hint: "autoanimations.settings.midionmiss_hint",
              scope: scope.world,
              type: Boolean,
              default: false,
              config: true
            }
          });
          settings.push({
            namespace,
            key: "playonDamage",
            folder: "Midi-QOL",
            options: {
              name: "autoanimations.settings.midiondmg_name",
              hint: "autoanimations.settings.midiondmg_hint",
              scope: scope.world,
              type: Boolean,
              default: false,
              config: true
            }
          });
          settings.push({
            namespace,
            key: "EnableCritical",
            folder: "Midi-QOL",
            options: {
              name: "autoanimations.settings.crithit_name",
              hint: "autoanimations.settings.crithit_hint",
              scope: scope.world,
              type: Boolean,
              default: false,
              config: true
            }
          });
          settings.push({
            namespace,
            key: "CriticalAnimation",
            folder: "Midi-QOL",
            options: {
              name: "autoanimations.settings.crithitAnim_name",
              //name: 'Choose A File',
              scope: scope.world,
              config: true,
              type: String,
              default: "",
              filePicker: "imagevideo"
            }
          });
          settings.push({
            namespace,
            key: "EnableCriticalMiss",
            folder: "Midi-QOL",
            options: {
              name: "autoanimations.settings.critmiss_name",
              hint: "autoanimations.settings.critmiss_hint",
              scope: scope.world,
              type: Boolean,
              default: false,
              config: true
            }
          });
          settings.push({
            namespace,
            key: "CriticalMissAnimation",
            folder: "Midi-QOL",
            options: {
              name: "autoanimations.settings.critmissAnim_name",
              scope: scope.world,
              config: true,
              type: String,
              default: "",
              filePicker: "imagevideo"
            }
          });
        } else {
          settings.push({
            namespace,
            key: "playonDamageCore",
            folder: game.system.title || game.system.name,
            options: {
              name: "autoanimations.settings.coreondmg_name",
              hint: "autoanimations.settings.coreondmg_hint",
              scope: scope.world,
              type: Boolean,
              default: false,
              config: true
            }
          });
          settings.push({
            namespace,
            key: "EnableCritical",
            folder: game.system.title || game.system.name,
            options: {
              name: "autoanimations.settings.crithit_name",
              hint: "autoanimations.settings.crithit_hint",
              scope: scope.world,
              type: Boolean,
              default: false,
              config: true
            }
          });
          settings.push({
            namespace,
            key: "CriticalAnimation",
            folder: game.system.title || game.system.name,
            options: {
              name: "autoanimations.settings.crithitAnim_name",
              //name: 'Choose A File',
              scope: scope.world,
              config: true,
              type: String,
              default: "",
              filePicker: "imagevideo"
            }
          });
          settings.push({
            namespace,
            key: "EnableCriticalMiss",
            folder: game.system.title || game.system.name,
            options: {
              name: "autoanimations.settings.critmiss_name",
              hint: "autoanimations.settings.critmiss_hint",
              scope: scope.world,
              type: Boolean,
              default: false,
              config: true
            }
          });
          settings.push({
            namespace,
            key: "CriticalMissAnimation",
            folder: game.system.title || game.system.name,
            options: {
              name: "autoanimations.settings.critmissAnim_name",
              scope: scope.world,
              config: true,
              type: String,
              default: "",
              filePicker: "imagevideo"
            }
          });
        }
        break;
      case "pf2e":
        settings.push({
          namespace,
          key: "playonDamageCore",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.coreondmg_name",
            hint: "autoanimations.settings.coreondmg_hint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        settings.push({
          namespace,
          key: "playonmiss",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.midionmiss_name",
            hint: "Requires Animations to be played on Attack rolls",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        settings.push({
          namespace,
          key: "disableNestedEffects",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.disableNested",
            hint: "autoanimations.settings.disableNestedHint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        settings.push({
          namespace,
          key: "disableGrantedAuraEffects",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.disableGrantedAura",
            hint: "autoanimations.settings.disableGrantedAuraHint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        break;
      case "pf1":
        settings.push({
          namespace,
          key: "disableAEAnimations",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.disableAEAnimations",
            hint: "autoanimations.settings.disableAEAnimationsHint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        break;
      case "wfrp4e":
        settings.push({
          namespace,
          key: "castOnlyOnSuccess",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.wfrp4eCastOnlyOnSuccess",
            hint: "autoanimations.settings.wfrp4eCastOnlyOnSuccessHint",
            scope: scope.world,
            type: Boolean,
            default: false,
            config: true
          }
        });
        break;
      case "cyberpunk-red-core":
        settings.push({
          namespace,
          key: "autofire",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.cyberPunkAutoFire",
            hint: "autoanimations.settings.cyberPunkAutoFire_hint",
            scope: scope.world,
            type: Boolean,
            default: true,
            config: true
          }
        }, {
          namespace,
          key: "canMissTarget",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.cyberPunkCanMiss",
            hint: "autoanimations.settings.cyberPunkCanMiss_hint",
            scope: scope.world,
            type: Boolean,
            default: true,
            config: true
          }
        }, {
          namespace,
          key: "useElevation",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.cyberPunkElevation",
            hint: "autoanimations.settings.cyberPunkElevation_hint",
            scope: scope.world,
            type: Boolean,
            default: true,
            config: true
          }
        });
        break;
      case "TheWitcherTRPG":
        settings.push({
          namespace,
          key: "attackSkill",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.coreonatk_name",
            hint: "autoanimations.settings.coreonatk_hint",
            scope: scope.world,
            type: Boolean,
            default: true,
            config: true
          }
        });
        settings.push({
          namespace,
          key: "damage",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.coreondmg_name",
            hint: "autoanimations.settings.coreondmg_hint",
            scope: scope.world,
            type: Boolean,
            default: true,
            config: true
          }
        });
        settings.push({
          namespace,
          key: "spell",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.coreonatk_name",
            hint: "autoanimations.settings.coreonatk_hint",
            scope: scope.world,
            type: Boolean,
            default: true,
            config: true
          }
        });
        break;
      case "twodsix":
        settings.push({
          namespace,
          key: "playtrigger",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.playAnimations",
            scope: scope.world,
            type: String,
            choices: {
              onAttack: "autoanimations.settings.attack",
              onDamage: "autoanimations.settings.damage"
            },
            default: "onAttack",
            config: true
          }
        });
        break;
      case "swade":
        settings.push({
          namespace,
          key: "playtrigger",
          folder: game.system.title || game.system.name,
          options: {
            name: "autoanimations.settings.playAnimations",
            scope: scope.world,
            type: String,
            choices: {
              onAttack: "autoanimations.settings.swadeTraitRolls",
              onDamage: "autoanimations.settings.damage"
            },
            default: "onDamage",
            config: true
          }
        });
        break;
    }
    this.registerAll(settings, !game.user.isGM);
  }
}
const gameSettings = new AAGameSettings();
function create_fragment$c(ctx) {
  let textarea_1;
  let mounted;
  let dispose;
  return {
    c() {
      textarea_1 = element("textarea");
    },
    m(target2, anchor) {
      insert(target2, textarea_1, anchor);
      set_input_value(
        textarea_1,
        /*dbPath*/
        ctx[0]
      );
      ctx[3](textarea_1);
      if (!mounted) {
        dispose = listen(
          textarea_1,
          "input",
          /*textarea_1_input_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*dbPath*/
      1) {
        set_input_value(
          textarea_1,
          /*dbPath*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(textarea_1);
      ctx[3](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let { dbPath } = $$props;
  let textarea = dbPath;
  onMount(() => {
    textarea.select();
    document.execCommand("copy");
  });
  function textarea_1_input_handler() {
    dbPath = this.value;
    $$invalidate(0, dbPath);
  }
  function textarea_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      textarea = $$value;
      $$invalidate(1, textarea);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("dbPath" in $$props2)
      $$invalidate(0, dbPath = $$props2.dbPath);
  };
  return [dbPath, textarea, textarea_1_input_handler, textarea_1_binding];
}
class CopyOnClick extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$a, create_fragment$c, safe_not_equal, { dbPath: 0 });
  }
}
class CategoryStore extends WorldSettingArrayStore {
  /**
   * A filter function / Svelte store that can be used with DynArrayReducer and set as a store to TJSInput.
   *
   * @type {(data: object) => boolean}
   */
  static #filterSearch = createFilterQuery("label");
  /**
   * @type {CategoryStores}
   */
  #stores;
  /**
   * @param {string}   key -
   *
   * @param {typeof import('svelte/store').Writable} StoreClass -
   *
   * @param {object[]} [defaultData] -
   */
  constructor(key, StoreClass, defaultData2 = []) {
    super({
      gameSettings,
      namespace: constants.moduleId,
      key,
      StoreClass,
      defaultData: defaultData2,
      dataReducer: true
    });
    this.dataReducer.filters.add(CategoryStore.#filterSearch);
    this.#stores = {
      allFoldersOpened: writable$1(void 0),
      scrollTop: aaSessionStorage.getStore(`${constants.moduleId}-category-scrolltop-${key}`, 0),
      // This allow setting the current Index of the section for the Video Preview app
      videoIDX: writable$1(void 0),
      animationSourceOption: game.system.id === "dnd5e" || game.system.id === "pf2e"
    };
  }
  get filterSearch() {
    return CategoryStore.#filterSearch;
  }
  get icon() {
    return localize(`autoanimations.app.${this.key}.icon`);
  }
  get label() {
    return localize(`autoanimations.app.${this.key}.label`);
  }
  /**
   * @returns {CategoryStores}
   */
  get stores() {
    return this.#stores;
  }
  /**
   * In this case this solution is better than creating a derived store from the AnimationStore sessionStorage folder
   * state. The below code uses the current dataReducer count and is also triggered by any open / close of any children
   * folders. The calculation for "all folders open" can short circuit on the first false / closed value.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/store').DynArrayReducer<AnimationStore>}   dataReducer -
   */
  calcAllFolderState() {
    let allFoldersOpened = true;
    for (const store of this.dataReducer) {
      if (!(allFoldersOpened &= store.folderState)) {
        break;
      }
    }
    this.#stores.allFoldersOpened.set(!!allFoldersOpened);
  }
  /**
   * Sorts data entries by name attribute.
   */
  sortAlpha() {
    this._data.sort((a, b) => {
      const aLabel = a?.label ?? "";
      const bLabel = b?.label ?? "";
      return aLabel.localeCompare(bLabel);
    });
    this.updateSubscribers();
  }
  loadPreviews() {
    TotalPreview.show();
  }
  getMenuDB(section2, idx, isOnToken) {
    let menuDB = isOnToken ? "static" : this._data[idx]._data.menu === "ontoken" || this._data[idx]._data.menu === "aura" ? "static" : this._data[idx]._data.menu;
    menuDB = section2 === "secondary" ? "static" : menuDB;
    return menuDB;
  }
  menuTypeList(menuDB = "static") {
    return newTypeMenu[menuDB] || [];
  }
  animationList(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[idx]._data[section2][section02].menuType;
    return newNameMenu[menuDB][menuType] || [];
  }
  variantList(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[idx]._data[section2][section02].menuType;
    let animation = this._data[idx]._data[section2][section02].animation;
    return newVariantMenu[menuDB][menuType]?.[animation] || [];
  }
  colorList(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[idx]._data[section2][section02].menuType;
    let animation = this._data[idx]._data[section2][section02].animation;
    let variant = this._data[idx]._data[section2][section02].variant;
    return newColorMenu[menuDB][menuType]?.[animation]?.[variant] || [];
  }
  async databaseToClipboard(section2, idx, section02, dbSection) {
    const dbPath = await this.getDBPath(section2, idx, section02, dbSection);
    const app = new CopyOnClick({
      target: document.getElementById("clipboard"),
      props: { dbPath }
    });
    app.$destroy();
  }
  async getDBPath(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[idx]._data[section2][section02].menuType;
    let animation = this._data[idx]._data[section2][section02].animation;
    let variant = this._data[idx]._data[section2][section02].variant;
    let color = this._data[idx]._data[section2][section02].color;
    return color === "random" ? `autoanimations.${menuDB}.${menuType}.${animation}.${variant}` : `autoanimations.${menuDB}.${menuType}.${animation}.${variant}.${color}`;
  }
  menuTypeChange(section2, idx, section02 = "video", menuDB = "static") {
    delete this._data[idx]._data.metaData;
    let menuType = this._data[idx]._data[section2][section02].menuType;
    this._data[idx]._data[section2][section02].animation = newNameMenu[menuDB][menuType][0][0];
    let animation = this._data[idx]._data[section2][section02].animation;
    this._data[idx]._data[section2][section02].variant = newVariantMenu[menuDB][menuType][animation][0][0];
    let variant = this._data[idx]._data[section2][section02].variant;
    this._data[idx]._data[section2][section02].color = newColorMenu[menuDB][menuType][animation][variant][0][0];
  }
  animationChange(section2, idx, section02 = "video", menuDB = "static") {
    delete this._data[idx]._data.metaData;
    let menuType = this._data[idx]._data[section2][section02].menuType;
    let animation = this._data[idx]._data[section2][section02].animation;
    this._data[idx]._data[section2][section02].variant = newVariantMenu[menuDB][menuType][animation][0][0];
    let variant = this._data[idx]._data[section2][section02].variant;
    this._data[idx]._data[section2][section02].color = newColorMenu[menuDB][menuType][animation][variant][0][0];
  }
  variantChange(section2, idx, section02 = "video", menuDB = "static") {
    delete this._data[idx]._data.metaData;
    let menuType = this._data[idx]._data[section2][section02].menuType;
    let animation = this._data[idx]._data[section2][section02].animation;
    let variant = this._data[idx]._data[section2][section02].variant;
    this._data[idx]._data[section2][section02].color = newColorMenu[menuDB][menuType][animation][variant][0][0];
  }
  get typeMenu() {
    return newTypeMenu;
  }
  get animationMenu() {
    return newNameMenu;
  }
  get variantMenu() {
    return newVariantMenu;
  }
  get colorMenu() {
    return newColorMenu;
  }
  get returnWeapons() {
    return aaReturnWeapons;
  }
  async openMacro(data2) {
    if (!data2) {
      ui.notifications.info(`Automated Animations: Cannot locate Macro ${data2}`);
      return;
    }
    if (data2.startsWith("Compendium")) {
      let packArray = data2.split(".");
      let pack = game.packs.get(`${packArray[1]}.${packArray[2]}`);
      if (!pack) {
        ui.notifications.info(
          `Autoanimations | Compendium ${packArray[1]}.${packArray[2]} was not found`
        );
        return;
      }
      let macroFilter = pack.index.filter((m) => m.name === packArray[3]);
      if (!macroFilter.length) {
        ui.notifications.info(
          `Autoanimations | A macro named ${packArray[3]} was not found in Compendium ${packArray[1]}.${packArray[2]}`
        );
        return;
      }
      let macroDocument = await pack.getDocument(macroFilter[0]._id);
      macroDocument.sheet.render(true);
    } else {
      if (!data2) {
        return;
      }
      let getTest = game.macros.getName(data2);
      if (!getTest) {
        ui.notifications.info(
          `Autoanimations | Could not find the macro named ${data2}`
        );
        return;
      }
      game.macros.getName(data2).sheet.render(true);
    }
  }
  playSound(data2) {
    const currentSection = data2 || {};
    const file = currentSection?.file;
    const volume = currentSection?.volume ?? 0.75;
    const startTime = currentSection?.startTime ?? 0;
    new Sequence().sound().file(file).volume(volume).startTime(startTime).play();
  }
  async selectCustom(section2, section02 = "video", idx) {
    const current = this._data[idx]._data[section2][section02].customPath;
    const picker = new FilePicker({
      type: "imagevideo",
      current,
      callback: (path) => {
        this._data[idx]._data[section2][section02].customPath = path;
        this._data[idx]._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  async selectSound(section2, idx) {
    const current = this._data[idx]._data[section2].sound.file;
    const picker = new FilePicker({
      type: "audio",
      current,
      callback: (path) => {
        this._data[idx]._data[section2].sound.file = path;
        this._data[idx]._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  async selectSoundNested(section2, section02, idx) {
    const current = this._data[idx]._data[section2][section02].sound.file;
    const picker = new FilePicker({
      type: "audio",
      current,
      callback: (path) => {
        this._data[idx]._data[section2][section02].sound.file = path;
        this._data[idx]._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  openSequencerViewer() {
    Sequencer.DatabaseViewer.show();
  }
}
let AnimationStore$1 = class AnimationStore3 extends CategoryStore.EntryStore {
  /** @type {AnimationPropertyStores} */
  #stores;
  #sessionStorage = {};
  /**
   * @param {object}   data -
   */
  constructor(data2 = {}) {
    super(data2);
    this.#sessionStorage.folderOpen = `${constants.moduleId}-anim-folder-${this.id}`;
    this.#stores = {
      folderOpen: aaSessionStorage.getStore(this.#sessionStorage.folderOpen, false),
      label: propertyStore(this, "label")
    };
  }
  /**
   * Invoked by WorldSettingArrayStore to provide custom duplication.
   *
   * @param {object}   data - A copy of local data w/ new ID already set.
   *
   * @param {CategoryStore} categoryStore - The source WorldSettingArrayStore instance.
   */
  static duplicate(data2, categoryStore) {
    if (typeof data2?.label === "string") {
      let cntr = 1;
      const baseName = data2.label ?? "";
      delete data2.metaData;
      do {
        data2.label = `${baseName}-${cntr++}`;
      } while (categoryStore.findEntry((entry) => entry.label === data2.label) !== void 0);
    }
  }
  /**
   * @returns {AnimationPropertyStores}
   */
  get stores() {
    return this.#stores;
  }
  // ----------------------------------------------------------------------------------------------------------------
  /**
   * @returns {boolean} Current folder open state.
   */
  get folderState() {
    return aaSessionStorage.getItem(this.#sessionStorage.folderOpen);
  }
  /**
   * @returns {string}
   */
  get label() {
    return this._data.label ?? "";
  }
  /**
   * @param {boolean}  folderOpen - Sets folder opened state.
   */
  set folderState(folderOpen) {
    this.#stores.folderOpen.set(folderOpen);
  }
  /**
   * @param {string} label -
   */
  set label(label) {
    this.#stores.label.set(label);
  }
  /**
   * @param {object}   data -
   */
  set(data2) {
    if (data2.label !== void 0) {
      if (typeof data2.label !== "string") {
        throw new TypeError(`'data.label' is not a string.`);
      }
      this._data.label = data2.label;
    }
    this._updateSubscribers();
  }
  async selectCustom(section2, section02 = "video") {
    const current = this._data[section2][section02].customPath;
    const picker = new FilePicker({
      type: "imagevideo",
      current,
      callback: (path) => {
        this._data[section2][section02].customPath = path;
        this._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  async selectSound(section2) {
    const current = this._data[section2].sound.file;
    const picker = new FilePicker({
      type: "audio",
      current,
      callback: (path) => {
        this._data[section2].sound.file = path;
        this._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  async getSource() {
    if (!this._data.metaData) {
      ui.notifications.info(`Automated Animations | No Defined MetaData on this Entry`);
    } else {
      console.log(this._data.metaData);
      ui.notifications.info("Automated Animations | MetaData logged to Dev Console");
      Hooks.callAll("AutomatedAnimations.metaData", this._data);
    }
  }
};
class AutoRecStores {
  /** @type {CategoryStore[]} */
  #categories = [];
  /**
   * Provides a writable store with the selected CategoryStore.
   *
   * @type {import('svelte/store').Writable<CategoryStore>}
   */
  #selected;
  /** @type {CategoryStore} */
  #aefx;
  /** @type {CategoryStore} */
  #aura;
  /** @type {CategoryStore} */
  #melee;
  /** @type {CategoryStore} */
  #ontoken;
  /** @type {CategoryStore} */
  #preset;
  /** @type {CategoryStore} */
  #range;
  /** @type {CategoryStore} */
  #templatefx;
  constructor() {
  }
  /**
   * @returns {CategoryStore[]}
   */
  get categories() {
    return this.#categories;
  }
  /**
   * @returns {import('svelte/store').Writable<CategoryStore>}
   */
  get selected() {
    return this.#selected;
  }
  // ----------------------------------------------------------------------------------------------------------------
  /** @returns {CategoryStore} */
  get aefx() {
    return this.#aefx;
  }
  /** @returns {CategoryStore} */
  get aura() {
    return this.#aura;
  }
  /** @returns {CategoryStore} */
  get melee() {
    return this.#melee;
  }
  /** @returns {CategoryStore} */
  get preset() {
    return this.#preset;
  }
  /** @returns {CategoryStore} */
  get range() {
    return this.#range;
  }
  /** @returns {CategoryStore} */
  get ontoken() {
    return this.#ontoken;
  }
  /** @returns {CategoryStore} */
  get templatefx() {
    return this.#templatefx;
  }
  /**
   * Initializes all stores and registers settings for each store.
   */
  initialize() {
    const cat = this.#categories;
    cat.push(this.#melee = new CategoryStore("aaAutorec-melee", AnimationStore$1, loadDefault("melee")));
    cat.push(this.#range = new CategoryStore("aaAutorec-range", AnimationStore$1, loadDefault("range")));
    cat.push(this.#ontoken = new CategoryStore("aaAutorec-ontoken", AnimationStore$1, loadDefault("ontoken")));
    cat.push(this.#templatefx = new CategoryStore("aaAutorec-templatefx", AnimationStore$1, loadDefault("templatefx")));
    cat.push(this.#aura = new CategoryStore("aaAutorec-aura", AnimationStore$1, loadDefault("aura")));
    cat.push(this.#preset = new CategoryStore("aaAutorec-preset", AnimationStore$1, loadDefault("preset")));
    cat.push(this.#aefx = new CategoryStore("aaAutorec-aefx", AnimationStore$1, loadDefault("aefx")));
    this.#selected = writable$1(this.#melee);
  }
}
const autoRecStores = new AutoRecStores();
const CategorySelect_svelte_svelte_type_style_lang = "";
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_each_block$1(ctx) {
  let li;
  let i;
  let t0_value = (
    /*category*/
    ctx[6].label + ""
  );
  let t0;
  let t1;
  let span;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[3](
        /*category*/
        ctx[6]
      )
    );
  }
  return {
    c() {
      li = element("li");
      i = element("i");
      t0 = text(t0_value);
      t1 = space();
      span = element("span");
      attr(i, "class", null_to_empty(
        /*category*/
        ctx[6].icon
      ) + " svelte-auto-1g5ic18");
      attr(li, "role", "presentation");
      attr(li, "class", "svelte-auto-1g5ic18");
      toggle_class(
        li,
        "active",
        /*$selected*/
        ctx[0] === /*category*/
        ctx[6]
      );
      attr(span, "class", "svelte-auto-1g5ic18");
    },
    m(target2, anchor) {
      insert(target2, li, anchor);
      append(li, i);
      append(li, t0);
      insert(target2, t1, anchor);
      insert(target2, span, anchor);
      if (!mounted) {
        dispose = listen(li, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$selected, autoRecStores*/
      1) {
        toggle_class(
          li,
          "active",
          /*$selected*/
          ctx[0] === /*category*/
          ctx[6]
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$b(ctx) {
  let header;
  let ul0;
  let t0;
  let categorycontrol;
  let t1;
  let categorylist;
  let t2;
  let footer;
  let ul1;
  let current;
  let mounted;
  let dispose;
  let each_value = autoRecStores.categories;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  categorycontrol = new CategoryControl$1({
    props: { category: (
      /*$selected*/
      ctx[0]
    ) }
  });
  categorylist = new CategoryList$1({
    props: { category: (
      /*$selected*/
      ctx[0]
    ) }
  });
  return {
    c() {
      header = element("header");
      ul0 = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      create_component(categorycontrol.$$.fragment);
      t1 = space();
      create_component(categorylist.$$.fragment);
      t2 = space();
      footer = element("footer");
      ul1 = element("ul");
      ul1.textContent = `${/*bottomLabel*/
      ctx[2]}`;
      attr(ul0, "class", "svelte-auto-1g5ic18");
      attr(header, "class", "svelte-auto-1g5ic18");
      attr(ul1, "class", "svelte-auto-1g5ic18");
      attr(footer, "class", "aa-AutorecManager svelte-auto-1g5ic18");
      attr(footer, "role", "presentation");
    },
    m(target2, anchor) {
      insert(target2, header, anchor);
      append(header, ul0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul0, null);
        }
      }
      insert(target2, t0, anchor);
      mount_component(categorycontrol, target2, anchor);
      insert(target2, t1, anchor);
      mount_component(categorylist, target2, anchor);
      insert(target2, t2, anchor);
      insert(target2, footer, anchor);
      append(footer, ul1);
      current = true;
      if (!mounted) {
        dispose = listen(
          footer,
          "click",
          /*click_handler_1*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$selected, autoRecStores*/
      1) {
        each_value = autoRecStores.categories;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      const categorycontrol_changes = {};
      if (dirty & /*$selected*/
      1)
        categorycontrol_changes.category = /*$selected*/
        ctx2[0];
      categorycontrol.$set(categorycontrol_changes);
      const categorylist_changes = {};
      if (dirty & /*$selected*/
      1)
        categorylist_changes.category = /*$selected*/
        ctx2[0];
      categorylist.$set(categorylist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(categorycontrol.$$.fragment, local);
      transition_in(categorylist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(categorycontrol.$$.fragment, local);
      transition_out(categorylist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(header);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t0);
      destroy_component(categorycontrol, detaching);
      if (detaching)
        detach(t1);
      destroy_component(categorylist, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(footer);
      mounted = false;
      dispose();
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let $selected;
  const selected = autoRecStores.selected;
  component_subscribe($$self, selected, (value) => $$invalidate(0, $selected = value));
  const bottomLabel = game.i18n.localize("autoanimations.menus.menuManager");
  getContext("#external");
  const click_handler = (category) => set_store_value(selected, $selected = category, $selected);
  const click_handler_1 = () => MenuManager.show();
  return [$selected, selected, bottomLabel, click_handler, click_handler_1];
}
class CategorySelect extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$9, create_fragment$b, safe_not_equal, {});
  }
}
const SettingsFooter_svelte_svelte_type_style_lang = "";
function create_fragment$a(ctx) {
  let div;
  let img;
  let img_src_value;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      img = element("img");
      t = text("\n    Automatic Recognition Menu Macro");
      attr(img, "draggable", "true");
      if (!src_url_equal(img.src, img_src_value = "modules/autoanimations/assets/icons/aa-icon.webp"))
        attr(img, "src", img_src_value);
      attr(img, "alt", "Macro");
      attr(img, "class", "svelte-auto-6s7r6c");
      attr(div, "draggable", "true");
      attr(div, "title", "Drag to hot bar");
      attr(div, "class", "svelte-auto-6s7r6c");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      append(div, img);
      ctx[2](img);
      append(div, t);
      if (!mounted) {
        dispose = [
          listen(
            img,
            "dragstart",
            /*onDragStart*/
            ctx[1]
          ),
          listen(
            div,
            "dragstart",
            /*onDragStart*/
            ctx[1]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[2](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function hotbarDrop(hotbar, data2, slot) {
  let handled = false;
  if (data2?.type === "AutomaticAnimationMacro") {
    handled = true;
    (async () => {
      const command = `Hooks.call("AA.Open.AutorecSetting");`;
      const macroData = {
        name: "A-A Automatic Recognition Menu",
        type: "script",
        command,
        img: "modules/autoanimations/assets/icons/aa-icon.webp"
      };
      let macro2 = game.macros.contents.find((m) => m.command === command);
      if (!macro2) {
        macro2 = await Macro.create(macroData, { displaySheet: false });
      }
      await game.user.assignHotbarMacro(macro2, slot);
    })();
  }
  return handled;
}
function instance$8($$self, $$props, $$invalidate) {
  let imageEl;
  Hooks.on("hotbarDrop", hotbarDrop);
  onDestroy(() => Hooks.off("hotbarDrop", hotbarDrop));
  function onDragStart(event) {
    const dataTransfer = { type: "AutomaticAnimationMacro" };
    event.dataTransfer.dropEffect = "move";
    event.dataTransfer.setDragImage(imageEl, 18, 18);
    event.dataTransfer.setData("text/plain", JSON.stringify(dataTransfer));
  }
  function img_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      imageEl = $$value;
      $$invalidate(0, imageEl);
    });
  }
  return [imageEl, onDragStart, img_binding];
}
class SettingsFooter extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$8, create_fragment$a, safe_not_equal, {});
  }
}
function create_default_slot_1(ctx) {
  let categoryselect;
  let current;
  categoryselect = new CategorySelect({});
  return {
    c() {
      create_component(categoryselect.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(categoryselect, target2, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(categoryselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(categoryselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(categoryselect, detaching);
    }
  };
}
function create_settings_footer_slot(ctx) {
  let settingsfooter;
  let current;
  settingsfooter = new SettingsFooter({ props: { slot: "settings-footer" } });
  return {
    c() {
      create_component(settingsfooter.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(settingsfooter, target2, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(settingsfooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingsfooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingsfooter, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let tjssettingsswap;
  let current;
  tjssettingsswap = new TJSSettingsSwap({
    props: {
      settings: gameSettings,
      options: { storage: aaSessionStorage },
      $$slots: {
        "settings-footer": [create_settings_footer_slot],
        default: [create_default_slot_1]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tjssettingsswap.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjssettingsswap, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjssettingsswap_changes = {};
      if (dirty & /*$$scope*/
      256) {
        tjssettingsswap_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjssettingsswap.$set(tjssettingsswap_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjssettingsswap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjssettingsswap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjssettingsswap, detaching);
    }
  };
}
function create_fragment$9(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[4](value);
  }
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$2] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(applicationshell, target2, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope*/
      256) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let $position;
  let $stateStore;
  AutorecSanitizer.checkForDuplicates();
  let { elementRoot } = $$props;
  const { application } = getContext("#external");
  const stateStore = aaSessionStorage.getStore(`${constants.moduleId}-autorec-appstate`);
  component_subscribe($$self, stateStore, (value) => $$invalidate(5, $stateStore = value));
  const position = application.position;
  component_subscribe($$self, position, (value) => $$invalidate(3, $position = value));
  const storePosition = debounce(() => set_store_value(stateStore, $stateStore = application.state.get(), $stateStore), 500);
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$position*/
    8) {
      storePosition($position);
    }
  };
  return [
    elementRoot,
    stateStore,
    position,
    $position,
    applicationshell_elementRoot_binding
  ];
}
class AutorecAppShell extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$7, create_fragment$9, safe_not_equal, { elementRoot: 0 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
}
const Diagnostics_svelte_svelte_type_style_lang = "";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i][0];
  child_ctx[18] = list[i][1];
  return child_ctx;
}
function create_each_block(ctx) {
  let option;
  let t_value = (
    /*name*/
    ctx[18] + ""
  );
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = /*key*/
      ctx[17];
      option.value = option.__value;
    },
    m(target2, anchor) {
      insert(target2, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_else_block_5(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-check isGreen svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Photosensitive mode is disabled";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_if_block_6(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-exclamation isRed svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Photosensitive mode is enabled";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_else_block_4(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-check isGreen svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Effects are Enabled";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_if_block_5$1(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-exclamation isRed svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Effects are Disabled!!";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_else_block_3(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-check isGreen svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Sounds are Enabled";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_if_block_4$1(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-exclamation isRed svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Sounds are Disabled!!";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_else_block_2(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-check isGreen svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Effects are Enabled";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_if_block_3$2(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-exclamation isRed svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Effects are Disabled!!";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_else_block_1$2(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-check isGreen svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Global Automatic Recognition Menu is Enabled (GM Only Setting)";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_if_block_2$2(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-exclamation isRed svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Global Automatic Recognition Menu is Disabled!! (GM Only Setting)";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_if_block$4(ctx) {
  let table;
  let tr0;
  let t1;
  let tr1;
  function select_block_type_5(ctx2, dirty) {
    if (!/*midiWorkflow*/
    ctx2[10])
      return create_if_block_1$2;
    return create_else_block$2;
  }
  let current_block_type = select_block_type_5(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2" class="AAheader svelte-auto-1bd3kd8">Midi-QOL Settings</th>`;
      t1 = space();
      tr1 = element("tr");
      if_block.c();
      attr(tr1, "class", null_to_empty(
        /*midiWorkflow*/
        ctx[10] ? "isGood" : "isBad"
      ) + " svelte-auto-1bd3kd8");
      attr(table, "cellpadding", "0");
      attr(table, "cellspacing", "0");
      attr(table, "border", "1");
      attr(table, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(table, t1);
      append(table, tr1);
      if_block.m(tr1, null);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(table);
      if_block.d();
    }
  };
}
function create_else_block$2(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-check isGreen svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Midi-QOL Roll Automation is Enabled";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_if_block_1$2(ctx) {
  let td0;
  let t0;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-exclamation isRed svelte-auto-1bd3kd8"></i>`;
      t0 = space();
      td1 = element("td");
      td1.textContent = "Midi-QOL Roll Automation is disabled!!";
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
    },
    m(target2, anchor) {
      insert(target2, td0, anchor);
      insert(target2, t0, anchor);
      insert(target2, td1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(td1);
    }
  };
}
function create_fragment$8(ctx) {
  let div3;
  let div0;
  let t1;
  let div1;
  let label1;
  let t3;
  let select;
  let t4;
  let div2;
  let t8;
  let table0;
  let tr0;
  let t10;
  let tr1;
  let tr1_class_value;
  let t11;
  let table1;
  let tr2;
  let t13;
  let tr3;
  let tr3_class_value;
  let t14;
  let tr4;
  let tr4_class_value;
  let t15;
  let tr5;
  let td0;
  let t16;
  let td1;
  let t17;
  let strong1;
  let t18_value = (
    /*permissionLevels*/
    ctx[7][
      /*sequencerPermissions*/
      ctx[2]
    ] + ""
  );
  let t18;
  let t19;
  let t20;
  let table2;
  let tr6;
  let t22;
  let tr7;
  let tr7_class_value;
  let t23;
  let tr8;
  let tr8_class_value;
  let t24;
  let t25;
  let table3;
  let t36;
  let div4;
  let button;
  let t38;
  let div6;
  let mounted;
  let dispose;
  let each_value = (
    /*connectedClients*/
    ctx[8]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  function select_block_type(ctx2, dirty) {
    if (
      /*photoSensitive*/
      ctx2[1]
    )
      return create_if_block_6;
    return create_else_block_5;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (!/*sequencerEffectsEnabled*/
    ctx2[3])
      return create_if_block_5$1;
    return create_else_block_4;
  }
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block1 = current_block_type_1(ctx);
  function select_block_type_2(ctx2, dirty) {
    if (!/*sequencerSoundsEnabled*/
    ctx2[4])
      return create_if_block_4$1;
    return create_else_block_3;
  }
  let current_block_type_2 = select_block_type_2(ctx);
  let if_block2 = current_block_type_2(ctx);
  function select_block_type_3(ctx2, dirty) {
    if (!/*aaEffectsEnabled*/
    ctx2[5])
      return create_if_block_3$2;
    return create_else_block_2;
  }
  let current_block_type_3 = select_block_type_3(ctx);
  let if_block3 = current_block_type_3(ctx);
  function select_block_type_4(ctx2, dirty) {
    if (
      /*aaAutorecDisabled*/
      ctx2[6]
    )
      return create_if_block_2$2;
    return create_else_block_1$2;
  }
  let current_block_type_4 = select_block_type_4(ctx);
  let if_block4 = current_block_type_4(ctx);
  let if_block5 = (
    /*midiActive*/
    ctx[9] && create_if_block$4(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<label for="" style="font-weight:bold; font-size: 1.2em; text-decoration:underline">This Diagnostics menu will check common settings that may cause Animations to stop working</label>`;
      t1 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Showing settings for user:";
      t3 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      div2 = element("div");
      div2.innerHTML = `<label for="" style="font-size: 0.9em; font-style: italic">Only shows <strong>active</strong> users</label>`;
      t8 = space();
      table0 = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2" class="AAheader svelte-auto-1bd3kd8">Foundry Core Settings</th>`;
      t10 = space();
      tr1 = element("tr");
      if_block0.c();
      t11 = space();
      table1 = element("table");
      tr2 = element("tr");
      tr2.innerHTML = `<th colspan="2" class="AAheader svelte-auto-1bd3kd8">Sequencer Settings</th>`;
      t13 = space();
      tr3 = element("tr");
      if_block1.c();
      t14 = space();
      tr4 = element("tr");
      if_block2.c();
      t15 = space();
      tr5 = element("tr");
      td0 = element("td");
      td0.innerHTML = `<i class="fas fa-circle-info isBlue svelte-auto-1bd3kd8"></i>`;
      t16 = space();
      td1 = element("td");
      t17 = text("Sequencer Effects permissions are set to ");
      strong1 = element("strong");
      t18 = text(t18_value);
      t19 = text(" (GM Only Setting)");
      t20 = space();
      table2 = element("table");
      tr6 = element("tr");
      tr6.innerHTML = `<th colspan="2" class="AAheader svelte-auto-1bd3kd8">Automated Animations Settings</th>`;
      t22 = space();
      tr7 = element("tr");
      if_block3.c();
      t23 = space();
      tr8 = element("tr");
      if_block4.c();
      t24 = space();
      if (if_block5)
        if_block5.c();
      t25 = space();
      table3 = element("table");
      table3.innerHTML = `<tr><th colspan="2" class="AAheader02 svelte-auto-1bd3kd8" style="background-color: rgba(0, 0, 0, 0.2)">Legend</th></tr> 
        <tr><td class="isBad svelte-auto-1bd3kd8"><i class="fas fa-exclamation isRed svelte-auto-1bd3kd8"></i></td> 
            <td class="svelte-auto-1bd3kd8">Will cause issues</td></tr> 
        <tr><td class="isGood svelte-auto-1bd3kd8"><i class="fas fa-check isGreen svelte-auto-1bd3kd8"></i></td> 
            <td class="svelte-auto-1bd3kd8">No issues</td></tr> 
        <tr><td class="isOk svelte-auto-1bd3kd8"><i class="fas fa-circle-info isBlue svelte-auto-1bd3kd8"></i></td> 
            <td class="svelte-auto-1bd3kd8">May cause issues depending on Player trusted level</td></tr>`;
      t36 = space();
      div4 = element("div");
      button = element("button");
      button.innerHTML = `<strong>Re-Run Diagnostics</strong>`;
      t38 = space();
      div6 = element("div");
      div6.innerHTML = `<div style="text-align: center"><label for="" style="font-weight:bold; font-size: 1.2em; text-decoration:underline">Below you can find general troubleshooting tips</label></div> 
    <table cellpadding="0" cellspacing="0" border="1" class="svelte-auto-1bd3kd8"><tr><th colspan="2" class="AAheader02 svelte-auto-1bd3kd8">General Troubleshooting</th></tr> 
        <tr><td class="svelte-auto-1bd3kd8">1</td> 
            <td class="svelte-auto-1bd3kd8">Melee, Range, On Token, and some Preset animations REQUIRE use of the Foundry Targetting System</td></tr> 
        <tr><td class="svelte-auto-1bd3kd8">2</td> 
            <td class="svelte-auto-1bd3kd8">Enable Debugging inside the Automated Animations module settings. Then open the console (F12) and check for any error messages when you expect an animation</td></tr> 
        <tr><td class="svelte-auto-1bd3kd8">3</td> 
            <td class="svelte-auto-1bd3kd8">Check the menu where the animation is defined, and make sure everything is filled out correctly</td></tr> 
        <tr><td class="svelte-auto-1bd3kd8">4</td> 
            <td class="svelte-auto-1bd3kd8">Use the Find the Culprit module to test with ONLY Automated Animations, Sequencer Socketlib active</td></tr> 
        <tr><td class="svelte-auto-1bd3kd8">5</td> 
            <td class="svelte-auto-1bd3kd8">Make sure your Game System is supported</td></tr> 
        <tr><td class="svelte-auto-1bd3kd8">6</td> 
            <td class="svelte-auto-1bd3kd8">Still not working? File an Issue on the Automated Animations GitHub repository.</td></tr></table>`;
      set_style(div0, "text-align", "center");
      attr(label1, "for", "");
      set_style(label1, "font-weight", "bold");
      set_style(label1, "font-size", "1.2em");
      attr(select, "name", "");
      attr(select, "id", "");
      if (
        /*currentUserId*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[12].call(select)
        ));
      set_style(div1, "text-align", "center");
      set_style(div1, "padding-top", "1.5em");
      set_style(div2, "text-align", "center");
      attr(tr1, "class", tr1_class_value = null_to_empty(!/*photoSensitive*/
      ctx[1] ? "isGood" : "isBad") + " svelte-auto-1bd3kd8");
      attr(table0, "cellpadding", "0");
      attr(table0, "cellspacing", "0");
      attr(table0, "border", "1");
      attr(table0, "class", "svelte-auto-1bd3kd8");
      attr(tr3, "class", tr3_class_value = null_to_empty(
        /*sequencerEffectsEnabled*/
        ctx[3] ? "isGood" : "isBad"
      ) + " svelte-auto-1bd3kd8");
      attr(tr4, "class", tr4_class_value = null_to_empty(
        /*sequencerSoundsEnabled*/
        ctx[4] ? "isGood" : "isBad"
      ) + " svelte-auto-1bd3kd8");
      attr(td0, "class", "svelte-auto-1bd3kd8");
      attr(td1, "class", "svelte-auto-1bd3kd8");
      attr(tr5, "class", "isOk svelte-auto-1bd3kd8");
      attr(table1, "cellpadding", "0");
      attr(table1, "cellspacing", "0");
      attr(table1, "border", "1");
      attr(table1, "class", "svelte-auto-1bd3kd8");
      attr(tr7, "class", tr7_class_value = null_to_empty(
        /*aaEffectsEnabled*/
        ctx[5] ? "isGood" : "isBad"
      ) + " svelte-auto-1bd3kd8");
      attr(tr8, "class", tr8_class_value = null_to_empty(!/*aaAutorecDisabled*/
      ctx[6] ? "isGood" : "isBad") + " svelte-auto-1bd3kd8");
      attr(table2, "cellpadding", "0");
      attr(table2, "cellspacing", "0");
      attr(table2, "border", "1");
      attr(table2, "class", "svelte-auto-1bd3kd8");
      attr(table3, "cellpadding", "0");
      attr(table3, "cellspacing", "0");
      attr(table3, "border", "1");
      attr(table3, "class", "svelte-auto-1bd3kd8");
      set_style(div3, "font-size", "1.1em");
      set_style(div4, "margin", "2em, font-size: 1.3em");
      set_style(div6, "font-size", "1.1em");
      set_style(div6, "margin-top", "2em");
    },
    m(target2, anchor) {
      insert(target2, div3, anchor);
      append(div3, div0);
      append(div3, t1);
      append(div3, div1);
      append(div1, label1);
      append(div1, t3);
      append(div1, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*currentUserId*/
        ctx[0],
        true
      );
      append(div3, t4);
      append(div3, div2);
      append(div3, t8);
      append(div3, table0);
      append(table0, tr0);
      append(table0, t10);
      append(table0, tr1);
      if_block0.m(tr1, null);
      append(div3, t11);
      append(div3, table1);
      append(table1, tr2);
      append(table1, t13);
      append(table1, tr3);
      if_block1.m(tr3, null);
      append(table1, t14);
      append(table1, tr4);
      if_block2.m(tr4, null);
      append(table1, t15);
      append(table1, tr5);
      append(tr5, td0);
      append(tr5, t16);
      append(tr5, td1);
      append(td1, t17);
      append(td1, strong1);
      append(strong1, t18);
      append(td1, t19);
      append(div3, t20);
      append(div3, table2);
      append(table2, tr6);
      append(table2, t22);
      append(table2, tr7);
      if_block3.m(tr7, null);
      append(table2, t23);
      append(table2, tr8);
      if_block4.m(tr8, null);
      append(div3, t24);
      if (if_block5)
        if_block5.m(div3, null);
      append(div3, t25);
      append(div3, table3);
      insert(target2, t36, anchor);
      insert(target2, div4, anchor);
      append(div4, button);
      insert(target2, t38, anchor);
      insert(target2, div6, anchor);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[12]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[13]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*connectedClients*/
      256) {
        each_value = /*connectedClients*/
        ctx2[8];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*currentUserId, connectedClients*/
      257) {
        select_option(
          select,
          /*currentUserId*/
          ctx2[0]
        );
      }
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(tr1, null);
        }
      }
      if (dirty & /*photoSensitive*/
      2 && tr1_class_value !== (tr1_class_value = null_to_empty(!/*photoSensitive*/
      ctx2[1] ? "isGood" : "isBad") + " svelte-auto-1bd3kd8")) {
        attr(tr1, "class", tr1_class_value);
      }
      if (current_block_type_1 !== (current_block_type_1 = select_block_type_1(ctx2))) {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(tr3, null);
        }
      }
      if (dirty & /*sequencerEffectsEnabled*/
      8 && tr3_class_value !== (tr3_class_value = null_to_empty(
        /*sequencerEffectsEnabled*/
        ctx2[3] ? "isGood" : "isBad"
      ) + " svelte-auto-1bd3kd8")) {
        attr(tr3, "class", tr3_class_value);
      }
      if (current_block_type_2 !== (current_block_type_2 = select_block_type_2(ctx2))) {
        if_block2.d(1);
        if_block2 = current_block_type_2(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(tr4, null);
        }
      }
      if (dirty & /*sequencerSoundsEnabled*/
      16 && tr4_class_value !== (tr4_class_value = null_to_empty(
        /*sequencerSoundsEnabled*/
        ctx2[4] ? "isGood" : "isBad"
      ) + " svelte-auto-1bd3kd8")) {
        attr(tr4, "class", tr4_class_value);
      }
      if (dirty & /*sequencerPermissions*/
      4 && t18_value !== (t18_value = /*permissionLevels*/
      ctx2[7][
        /*sequencerPermissions*/
        ctx2[2]
      ] + ""))
        set_data(t18, t18_value);
      if (current_block_type_3 !== (current_block_type_3 = select_block_type_3(ctx2))) {
        if_block3.d(1);
        if_block3 = current_block_type_3(ctx2);
        if (if_block3) {
          if_block3.c();
          if_block3.m(tr7, null);
        }
      }
      if (dirty & /*aaEffectsEnabled*/
      32 && tr7_class_value !== (tr7_class_value = null_to_empty(
        /*aaEffectsEnabled*/
        ctx2[5] ? "isGood" : "isBad"
      ) + " svelte-auto-1bd3kd8")) {
        attr(tr7, "class", tr7_class_value);
      }
      if (current_block_type_4 !== (current_block_type_4 = select_block_type_4(ctx2))) {
        if_block4.d(1);
        if_block4 = current_block_type_4(ctx2);
        if (if_block4) {
          if_block4.c();
          if_block4.m(tr8, null);
        }
      }
      if (dirty & /*aaAutorecDisabled*/
      64 && tr8_class_value !== (tr8_class_value = null_to_empty(!/*aaAutorecDisabled*/
      ctx2[6] ? "isGood" : "isBad") + " svelte-auto-1bd3kd8")) {
        attr(tr8, "class", tr8_class_value);
      }
      if (
        /*midiActive*/
        ctx2[9]
      )
        if_block5.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_each(each_blocks, detaching);
      if_block0.d();
      if_block1.d();
      if_block2.d();
      if_block3.d();
      if_block4.d();
      if (if_block5)
        if_block5.d();
      if (detaching)
        detach(t36);
      if (detaching)
        detach(div4);
      if (detaching)
        detach(t38);
      if (detaching)
        detach(div6);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  const permissionLevels = game.modules.get("sequencer")?.active ? [
    game.i18n.localize("SEQUENCER.Permission.Player"),
    game.i18n.localize("SEQUENCER.Permission.Trusted"),
    game.i18n.localize("SEQUENCER.Permission.Assistant"),
    game.i18n.localize("SEQUENCER.Permission.GM")
  ] : custom_error$1("Sequencer is not active!!!! You must enable Sequencer!!!!");
  let connectedClients = Array.from(game.users).filter((c) => c.active).map((x) => [x.id, x.name]);
  let currentUserId = connectedClients[0][0];
  let midiActive = game.modules.get("midi-qol")?.active;
  let midiWorkflow = midiActive ? game.settings.get("midi-qol", "EnableWorkflow") : false;
  async function settingsGetter() {
    let currentSetting = await socketlibSocket.executeAsUser("checkSettings", currentUserId);
    updateSettings(currentSetting);
  }
  settingsGetter();
  function updateSettings(currentSetting) {
    $$invalidate(1, photoSensitive = currentSetting.coreSettings.photoSensitive);
    $$invalidate(2, sequencerPermissions = currentSetting.sequencerSettings.permission);
    $$invalidate(3, sequencerEffectsEnabled = currentSetting.sequencerSettings.effects);
    $$invalidate(4, sequencerSoundsEnabled = currentSetting.sequencerSettings.sounds);
    $$invalidate(5, aaEffectsEnabled = currentSetting.aaSettings.effects);
    $$invalidate(6, aaAutorecDisabled = currentSetting.aaSettings.autorec);
  }
  let photoSensitive;
  let sequencerPermissions;
  let sequencerEffectsEnabled;
  let sequencerSoundsEnabled;
  let aaEffectsEnabled;
  let aaAutorecDisabled;
  async function runDiagnostics() {
    await settingsGetter();
  }
  function select_change_handler() {
    currentUserId = select_value(this);
    $$invalidate(0, currentUserId);
    $$invalidate(8, connectedClients);
  }
  const change_handler = () => runDiagnostics();
  const click_handler = () => runDiagnostics();
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*currentUserId*/
    1)
      ;
    if ($$self.$$.dirty & /*photoSensitive*/
    2)
      ;
    if ($$self.$$.dirty & /*sequencerPermissions*/
    4)
      ;
    if ($$self.$$.dirty & /*sequencerEffectsEnabled*/
    8)
      ;
    if ($$self.$$.dirty & /*sequencerSoundsEnabled*/
    16)
      ;
    if ($$self.$$.dirty & /*aaEffectsEnabled*/
    32)
      ;
    if ($$self.$$.dirty & /*aaAutorecDisabled*/
    64)
      ;
  };
  return [
    currentUserId,
    photoSensitive,
    sequencerPermissions,
    sequencerEffectsEnabled,
    sequencerSoundsEnabled,
    aaEffectsEnabled,
    aaAutorecDisabled,
    permissionLevels,
    connectedClients,
    midiActive,
    midiWorkflow,
    runDiagnostics,
    select_change_handler,
    change_handler,
    click_handler
  ];
}
class Diagnostics extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$6, create_fragment$8, safe_not_equal, {});
  }
}
class AADiagnostics extends TJSDialog {
  constructor(data2) {
    super({
      title: "Automated Animations Diagnostics",
      draggable: true,
      resizable: true,
      modal: false,
      zIndex: null,
      content: {
        class: Diagnostics
      }
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      minimizable: true,
      width: 600,
      height: "auto",
      closeOnSubmit: true,
      id: `AutomatedAnimations-Diagnostics`
    });
  }
}
class AutorecMenuApp extends SvelteApplication {
  /** @inheritDoc */
  constructor(options2) {
    super(options2);
    try {
      this.state.set(JSON.parse(sessionStorage.getItem(`${constants.moduleId}-autorec-appstate`)));
    } catch (err) {
    }
  }
  /**
   *
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: `A-A Automatic Recognition Menu`,
      id: `AA-autorec-settings`,
      zIndex: 102,
      resizable: true,
      minimizable: true,
      width: 600,
      height: 750,
      minWidth: 550,
      svelte: {
        class: AutorecAppShell,
        target: document.body
      }
    });
  }
  /**
   * @inheritDoc
   */
  async close(options2) {
    Object.values(ui.windows).filter((app) => app.id === "Options-Information" || app.id === "AA-Video-Preview" || app.id === "Autorec-Menu-Manager" || app.id === "AutomatedAnimations-Diagnostics").forEach((app) => app.close());
    return super.close(options2);
  }
  /**
   * Specify the set of config buttons which should appear in the Application header. Buttons should be returned as an
   * Array of objects.
   *
   * Provides an explicit override of Application._getHeaderButtons to add
   *
   * @returns {ApplicationHeaderButton[]} The app header buttons.
   * @override
   */
  _getHeaderButtons() {
    const buttons = super._getHeaderButtons();
    const showSettings = gameSettings.uiControl.showSettings;
    buttons.unshift(
      {
        class: "settings",
        icon: showSettings ? "fa-regular fa-square-list" : "fa-regular fa-gear",
        label: showSettings ? "Main Menu" : "Settings",
        onPress: function() {
          const newShowSettings = gameSettings.uiControl.swapShowSettings();
          this.icon = newShowSettings ? "fa-regular fa-square-list" : "fa-regular fa-gear";
          this.label = newShowSettings ? "Main Menu" : "Settings";
        }
      },
      {
        icon: "fas fa-stethoscope",
        label: "Diagnostics",
        onPress: function() {
          let diagnosticApp = new AADiagnostics();
          diagnosticApp.render(true, { focus: true });
        }
      }
    );
    return buttons;
  }
}
let mainAutorecMenu;
function showAutorecMenu() {
  mainAutorecMenu = mainAutorecMenu ? mainAutorecMenu : new AutorecMenuApp();
  mainAutorecMenu.render(true, { focus: true });
  return mainAutorecMenu;
}
const ItemInformation_svelte_svelte_type_style_lang$1 = "";
function create_if_block$3(ctx) {
  let table;
  let tr0;
  let t1;
  let tr1;
  let td0;
  let strong0;
  let t5;
  let td1;
  let t7;
  let tr2;
  let td2;
  let strong1;
  let t11;
  let td3;
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2" class="svelte-auto-o1b2bf">Item Settings</th>`;
      t1 = space();
      tr1 = element("tr");
      td0 = element("td");
      strong0 = element("strong");
      strong0.textContent = `${localize("autoanimations.menus.animation")} 
                        ${localize("autoanimations.menus.enabled")}`;
      t5 = space();
      td1 = element("td");
      td1.textContent = "Turn Animations for this item ON or OFF";
      t7 = space();
      tr2 = element("tr");
      td2 = element("td");
      strong1 = element("strong");
      strong1.textContent = `${localize("autoanimations.menus.customize")} 
                        ${localize("autoanimations.menus.item")}`;
      t11 = space();
      td3 = element("td");
      td3.textContent = "Toggle custom Item Animation. If enabled the Autorec menu\n                    will be disabled for this Item.";
      attr(tr0, "class", "svelte-auto-o1b2bf");
      attr(td0, "class", "aa-table svelte-auto-o1b2bf");
      attr(td1, "class", "svelte-auto-o1b2bf");
      attr(tr1, "class", "svelte-auto-o1b2bf");
      attr(td2, "class", "aa-table svelte-auto-o1b2bf");
      attr(td3, "class", "svelte-auto-o1b2bf");
      attr(tr2, "class", "svelte-auto-o1b2bf");
      attr(table, "id", "options-table");
      attr(table, "cellpadding", "0");
      attr(table, "cellspacing", "0");
      attr(table, "border", "1");
      attr(table, "class", "svelte-auto-o1b2bf");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(table, t1);
      append(table, tr1);
      append(tr1, td0);
      append(td0, strong0);
      append(tr1, t5);
      append(tr1, td1);
      append(table, t7);
      append(table, tr2);
      append(tr2, td2);
      append(td2, strong1);
      append(tr2, t11);
      append(tr2, td3);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(table);
    }
  };
}
function create_fragment$7(ctx) {
  let div;
  let if_block = (
    /*currentSelected*/
    ctx[0] === "melee" && create_if_block$3()
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "aa-options-info svelte-auto-o1b2bf");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*currentSelected*/
        ctx2[0] === "melee"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$3();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let { currentSelected: currentSelected2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("currentSelected" in $$props2)
      $$invalidate(0, currentSelected2 = $$props2.currentSelected);
  };
  return [currentSelected2];
}
let ItemInformation$1 = class ItemInformation2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$5, create_fragment$7, safe_not_equal, { currentSelected: 0 });
  }
};
function create_fragment$6(ctx) {
  let iteminformation;
  let current;
  iteminformation = new ItemInformation$1({ props: { currentSelected: currentSelected$1 } });
  return {
    c() {
      create_component(iteminformation.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(iteminformation, target2, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(iteminformation.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iteminformation.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iteminformation, detaching);
    }
  };
}
let currentSelected$1 = "melee";
let ItemInfo$1 = class ItemInfo2 extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, null, create_fragment$6, safe_not_equal, {});
  }
};
let ItemInfoDialog$1 = class ItemInfoDialog2 extends TJSDialog {
  constructor(data2) {
    super({
      title: "Options Info",
      draggable: true,
      resizable: true,
      modal: false,
      zIndex: null,
      content: {
        class: ItemInfo$1,
        props: {
          ...data2
        }
      }
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      minimizable: true,
      width: 600,
      height: "auto",
      closeOnSubmit: true,
      id: `Item-Information`
    });
  }
};
class AEMenuApp extends SvelteApplication {
  /** @inheritDoc */
  constructor(item2) {
    super({
      title: `A-A Item Menu`,
      id: `AA-ae-settings`,
      zIndex: 102,
      svelte: {
        class: AEAppShell,
        target: document.body,
        props: {
          item: item2,
          itemFlags: item2.flags,
          storageStore: aaSessionStorage.getStore(sessionConstants.activeEffectAppState)
        }
      }
    });
    try {
      this.state.set(aaSessionStorage.getItem(sessionConstants.activeEffectAppState));
    } catch (err) {
    }
  }
  /**
   *
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      resizable: true,
      minimizable: true,
      width: 600,
      height: 750,
      minWidth: 550
    });
  }
  _getHeaderButtons() {
    const buttons = super._getHeaderButtons();
    buttons.unshift({
      icon: "fas fa-circle-info",
      title: "Item Information",
      label: "Info",
      styles: { color: "lightblue", position: "relative", right: "5px" },
      onPress: function() {
        if (Object.values(ui.windows).find(
          (w) => w.id === `Options-Information`
        )) {
          return;
        }
        new ItemInfoDialog$1().render(true);
      }
    });
    buttons.unshift({
      class: "autorec-shortcut",
      icon: "fas fa-globe",
      title: "Launch Autorec",
      label: "Global Automatic Recognition Menu",
      styles: { color: "lightblue", position: "relative", right: "30px" },
      onPress: function() {
        if (game.user.isGM) {
          new showAutorecMenu();
        }
      }
    });
    return buttons;
  }
  /**
   * @inheritDoc
   */
  async close(options2) {
    Object.values(ui.windows).filter((app) => app.id === "Options-Information" || app.id === "Autorec-Video-Preview" || app.id === "Autorec-Menu-Manager" || app.id === "Item-Information" || app.id === "AA-Copy-Item-To-Global").forEach((app) => app.close());
    return super.close(options2);
  }
}
class AnimationStore extends ObjectEntryStore {
  /** @type {AnimationPropertyStores} */
  #stores;
  /**
   * @param {object}   data -
   */
  constructor(data2 = {}) {
    super(data2);
    this.#stores = {
      videoIDX: writable$1(void 0)
    };
  }
  /**
   * @returns {AnimationPropertyStores}
   */
  get stores() {
    return this.#stores;
  }
  // ----------------------------------------------------------------------------------------------------------------
  /**
  * @param {object}   data -
  */
  set() {
    this._updateSubscribers();
  }
  async selectCustom(section2, section02 = "video") {
    const current = this._data[section2][section02].customPath;
    const picker = new FilePicker({
      type: "imagevideo",
      current,
      callback: (path) => {
        this._data[section2][section02].customPath = path;
        this._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  loadPreviews() {
    TotalPreview.show();
  }
  getMenuDB(section2, idx, isOnToken) {
    let menuDB = isOnToken ? "static" : this._data.menu === "ontoken" || this._data.menu === "aura" ? "static" : this._data.menu;
    menuDB = section2 === "secondary" ? "static" : menuDB;
    return menuDB;
  }
  menuTypeList(menuDB = "static") {
    return newTypeMenu[menuDB] || [];
  }
  animationList(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    return newNameMenu[menuDB][menuType] || [];
  }
  variantList(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    let animation = this._data[section2][section02].animation;
    return newVariantMenu[menuDB][menuType]?.[animation] || [];
  }
  colorList(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    let animation = this._data[section2][section02].animation;
    let variant = this._data[section2][section02].variant;
    return newColorMenu[menuDB][menuType]?.[animation]?.[variant] || [];
  }
  async databaseToClipboard(section2, idx, section02, dbSection) {
    const dbPath = await this.getDBPath(section2, idx, section02, dbSection);
    const app = new CopyClipBoard({
      target: document.getElementById("clipboard"),
      props: { dbPath }
    });
    app.$destroy();
  }
  async getDBPath(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    let animation = this._data[section2][section02].animation;
    let variant = this._data[section2][section02].variant;
    let color = this._data[section2][section02].color;
    return color === "random" ? `autoanimations.${menuDB}.${menuType}.${animation}.${variant}` : `autoanimations.${menuDB}.${menuType}.${animation}.${variant}.${color}`;
  }
  menuTypeChange(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    this._data[section2][section02].animation = newNameMenu[menuDB][menuType][0][0];
    let animation = this._data[section2][section02].animation;
    this._data[section2][section02].variant = newVariantMenu[menuDB][menuType][animation][0][0];
    let variant = this._data[section2][section02].variant;
    this._data[section2][section02].color = newColorMenu[menuDB][menuType][animation][variant][0][0];
  }
  animationChange(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    let animation = this._data[section2][section02].animation;
    this._data[section2][section02].variant = newVariantMenu[menuDB][menuType][animation][0][0];
    let variant = this._data[section2][section02].variant;
    this._data[section2][section02].color = newColorMenu[menuDB][menuType][animation][variant][0][0];
  }
  variantChange(section2, idx, section02 = "video", menuDB = "static") {
    let menuType = this._data[section2][section02].menuType;
    let animation = this._data[section2][section02].animation;
    let variant = this._data[section2][section02].variant;
    this._data[section2][section02].color = newColorMenu[menuDB][menuType][animation][variant][0][0];
  }
  get typeMenu() {
    return newTypeMenu;
  }
  get animationMenu() {
    return newNameMenu;
  }
  get variantMenu() {
    return newVariantMenu;
  }
  get colorMenu() {
    return newColorMenu;
  }
  get returnWeapons() {
    return aaReturnWeapons;
  }
  async openMacro(data2) {
    if (!data2) {
      ui.notifications.info(`Automated Animations: Cannot locate Macro ${data2}`);
      return;
    }
    if (data2.startsWith("Compendium")) {
      let packArray = data2.split(".");
      let pack = game.packs.get(`${packArray[1]}.${packArray[2]}`);
      if (!pack) {
        ui.notifications.info(
          `Autoanimations | Compendium ${packArray[1]}.${packArray[2]} was not found`
        );
        return;
      }
      let macroFilter = pack.index.filter((m) => m.name === packArray[3]);
      if (!macroFilter.length) {
        ui.notifications.info(
          `Autoanimations | A macro named ${packArray[3]} was not found in Compendium ${packArray[1]}.${packArray[2]}`
        );
        return;
      }
      let macroDocument = await pack.getDocument(macroFilter[0]._id);
      macroDocument.sheet.render(true);
    } else {
      if (!data2) {
        return;
      }
      let getTest = game.macros.getName(data2);
      if (!getTest) {
        ui.notifications.info(
          `Autoanimations | Could not find the macro named ${data2}`
        );
        return;
      }
      game.macros.getName(data2).sheet.render(true);
    }
  }
  playSound(data2) {
    const currentSection = data2 || {};
    const file = currentSection?.file;
    const volume = currentSection?.volume ?? 0.75;
    const startTime = currentSection?.startTime ?? 0;
    new Sequence().sound().file(file).volume(volume).startTime(startTime).play();
  }
  async selectCustom(section2, section02 = "video", idx) {
    const current = this._data[section2][section02].customPath;
    const picker = new FilePicker({
      type: "imagevideo",
      current,
      callback: (path) => {
        this._data[section2][section02].customPath = path;
        this._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  async selectSound(section2, idx) {
    const current = this._data[section2].sound.file;
    const picker = new FilePicker({
      type: "audio",
      current,
      callback: (path) => {
        this._data[section2].sound.file = path;
        this._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  async selectSoundNested(section2, section02, idx) {
    const current = this._data[section2][section02].sound.file;
    const picker = new FilePicker({
      type: "audio",
      current,
      callback: (path) => {
        this._data[section2][section02].sound.file = path;
        this._updateSubscribers();
      }
    });
    setTimeout(() => {
      picker.element[0].style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
    }, 100);
    await picker.browse(current);
  }
  openSequencerViewer() {
    Sequencer.DatabaseViewer.show();
  }
  async copyFromAutorec(autorec) {
    if (!autorec) {
      ui.notifications.info("Automated Animations | There is no Global match found to copy!");
      return;
    }
    if (!isObject(autorec)) {
      ui.notifications.info("Automated Animations | Global Autorec data is not valid");
    }
    let data2 = foundry.utils.deepClone(autorec);
    this._data.isCustomized;
    this._data.isEnabled;
    this._data.label;
    this._data.id;
    let menu = data2.menu;
    switch (menu) {
      case "melee":
        this._data.menu = data2.menu;
        this._data.levels3d = data2.levels3d;
        this._data.macro = data2.macro;
        this._data.meleeSwitch = data2.meleeSwitch;
        this._data.primary = data2.primary;
        this._data.secondary = data2.secondary;
        this._data.source = data2.source;
        this._data.target = data2.target;
        this._data.soundOnly = data2.soundOnly;
        break;
      case "range":
      case "ontoken":
      case "templatefx":
      case "aura":
        this._data.menu = data2.menu;
        this._data.levels3d = data2.levels3d;
        this._data.macro = data2.macro;
        this._data.primary = data2.primary;
        this._data.secondary = data2.secondary;
        this._data.source = data2.source;
        this._data.target = data2.target;
        this._data.soundOnly = data2.soundOnly;
        break;
      case "preset":
        this._data.menu = data2.menu;
        this._data.presetType = data2.presetType;
        this._data.primary = data2.primary;
        this._data.soundOnly = data2.soundOnly;
        this._data.macro = data2.macro;
        break;
    }
    this._updateSubscribers();
  }
  async copyToAutorec(label) {
    let menu = this._data.menu;
    if (!this._data.isCustomized) {
      custom_warning("You are attempting to copy an Item to the Global menu, but you haven't configured the item!", true);
    }
    let data2 = foundry.utils.deepClone(this._data);
    data2.id = uuidv4();
    data2.label = label;
    switch (menu) {
      case "melee":
        delete data2.presetType;
        break;
      case "range":
        delete data2.presetType;
        delete data2.meleeSwitch;
        break;
      case "ontoken":
        delete data2.presetType;
        delete data2.meleeSwitch;
        break;
      case "templatefx":
        delete data2.presetType;
        delete data2.meleeSwitch;
        delete data2.levels3d;
        break;
      case "aura":
        delete data2.presetType;
        delete data2.meleeSwitch;
        delete data2.levels3d;
        break;
      case "preset":
        delete data2.meleeSwitch;
        delete data2.levels3d;
        delete data2.source;
        break;
    }
    delete data2.fromAmmo;
    delete data2.isCustomized;
    delete data2.isEnabled;
    let currentMenu = await game.settings.get("autoanimations", `aaAutorec-${menu}`);
    currentMenu.push(data2);
    await game.settings.set("autoanimations", `aaAutorec-${menu}`, currentMenu);
  }
  async switchVideo() {
    let newMenu = this._data.menu;
    if (!newMenu) {
      return;
    }
    let newData = changeSection[newMenu](this._data);
    if (!newMenu) {
      delete this._data.data;
      this._data.primary = {};
      return;
    }
    switch (newMenu) {
      case "preset":
        this._data.macro = newData.macro;
        this._data.soundOnly = newData.soundOnly;
        this._data.presetType = newData.presetType;
        this._data.secondary = newData.secondary;
        this._data.target = newData.target;
        this._data.data = newData.data;
        break;
      case "melee":
        this._data.levels3d = newData.levels3d;
        this._data.macro = newData.macro;
        this._data.meleeSwitch = newData.meleeSwitch;
        this._data.primary = newData.primary;
        this._data.secondary = newData.secondary;
        this._data.soundOnly = newData.soundOnly;
        this._data.source = newData.source;
        this._data.target = newData.target;
        break;
      case "range":
      case "ontoken":
        this._data.levels3d = newData.levels3d;
        this._data.macro = newData.macro;
        this._data.primary = newData.primary;
        this._data.secondary = newData.secondary;
        this._data.soundOnly = newData.soundOnly;
        this._data.source = newData.source;
        this._data.target = newData.target;
        break;
      default:
        this._data.macro = newData.macro;
        this._data.primary = newData.primary;
        this._data.secondary = newData.secondary;
        this._data.soundOnly = newData.soundOnly;
        this._data.source = newData.source;
        this._data.target = newData.target;
        break;
    }
  }
  deleteOld() {
    let newMenu = this._data.menu;
    if (!newMenu) {
      return;
    }
    switch (newMenu) {
      case "preset":
        delete this._data.primary;
        delete this._data.levels3d;
        delete this._data.meleeSwitch;
        delete this._data.primary;
        delete this._data.source;
        break;
      case "melee":
        delete this._data.presetType;
        delete this._data.data;
        break;
      case "range":
      case "ontoken":
        delete this._data.meleeSwitch;
        delete this._data.presetType;
        delete this._data.data;
        break;
      default:
        delete this._data.levels3d;
        delete this._data.meleeSwitch;
        delete this._data.presetType;
        delete this._data.data;
        break;
    }
  }
}
const CategoryList_svelte_svelte_type_style_lang = "";
function create_fragment$5(ctx) {
  let div1;
  let div0;
  let switch_instance;
  let div1_class_value;
  let current;
  var switch_value = (
    /*menuRoute*/
    ctx[2]
  );
  function switch_props(ctx2) {
    return { props: { fromMenu: "item" } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div0, "class", "sectionBorder svelte-auto-1cwie9g");
      attr(div1, "class", div1_class_value = "animation " + (!/*isEnabled*/
      ctx[1] || !/*isCustomized*/
      ctx[0] ? "aa-disableOpacity" : ""));
    },
    m(target2, anchor) {
      insert(target2, div1, anchor);
      append(div1, div0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*menuRoute*/
      4 && switch_value !== (switch_value = /*menuRoute*/
      ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, null);
        } else {
          switch_instance = null;
        }
      }
      if (!current || dirty & /*isEnabled, isCustomized*/
      3 && div1_class_value !== (div1_class_value = "animation " + (!/*isEnabled*/
      ctx2[1] || !/*isCustomized*/
      ctx2[0] ? "aa-disableOpacity" : ""))) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let menuRoute;
  let isEnabled;
  let isCustomized;
  let $animation;
  let { animation } = getContext("animation-data");
  component_subscribe($$self, animation, (value) => $$invalidate(5, $animation = value));
  let { chosenMenu } = $$props;
  let newContentOptions = {
    melee: { component: BuildMelee },
    range: { component: BuildRange },
    ontoken: { component: BuildOnToken },
    templatefx: { component: BuildTemplateFX },
    aura: { component: BuildAura },
    preset: { component: BuildPreset }
  };
  $$self.$$set = ($$props2) => {
    if ("chosenMenu" in $$props2)
      $$invalidate(4, chosenMenu = $$props2.chosenMenu);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*chosenMenu*/
    16) {
      $$invalidate(2, menuRoute = newContentOptions[chosenMenu].component);
    }
    if ($$self.$$.dirty & /*$animation*/
    32) {
      $$invalidate(1, isEnabled = $animation.isEnabled);
    }
    if ($$self.$$.dirty & /*$animation*/
    32) {
      $$invalidate(0, isCustomized = $animation.isCustomized);
    }
  };
  return [isCustomized, isEnabled, menuRoute, animation, chosenMenu, $animation];
}
class CategoryList extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$4, create_fragment$5, safe_not_equal, { chosenMenu: 4 });
  }
}
const NoneChosen_svelte_svelte_type_style_lang = "";
function create_else_block_1$1(ctx) {
  let ul;
  return {
    c() {
      ul = element("ul");
      ul.innerHTML = `<li><strong>Animations are disabled for this item</strong>   <i class="fas fa-xmark aa-red"></i></li>`;
    },
    m(target2, anchor) {
      insert(target2, ul, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(ul);
    }
  };
}
function create_if_block_4(ctx) {
  let ul;
  let t2;
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*isInAutorec*/
      ctx2[2]
    )
      return create_if_block_5;
    return create_else_block$1;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      ul = element("ul");
      ul.innerHTML = `<li><strong>Item Animation is enabled but not configured!!</strong>   <i class="fas fa-xmark aa-red"></i></li>`;
      t2 = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target2, anchor) {
      insert(target2, ul, anchor);
      insert(target2, t2, anchor);
      if_block.m(target2, anchor);
      insert(target2, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      if (detaching)
        detach(t2);
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3$1(ctx) {
  let ul0;
  let t2;
  let ul1;
  return {
    c() {
      ul0 = element("ul");
      ul0.innerHTML = `<li><strong>Item Animation is enabled but not customized</strong>   <i class="fas fa-check aa-green"></i></li>`;
      t2 = space();
      ul1 = element("ul");
      ul1.innerHTML = `<li><strong>No Global Automatic Recognition is matched</strong>   <i class="fas fa-xmark aa-red"></i></li>`;
    },
    m(target2, anchor) {
      insert(target2, ul0, anchor);
      insert(target2, t2, anchor);
      insert(target2, ul1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(ul0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(ul1);
    }
  };
}
function create_if_block$2(ctx) {
  let ul0;
  let t2;
  let ul1;
  let t5;
  let ul2;
  let t6;
  let if_block0 = (
    /*isInAutorec*/
    ctx[2] && create_if_block_2$1(ctx)
  );
  let if_block1 = (
    /*isInAEAutorec*/
    ctx[3] && create_if_block_1$1(ctx)
  );
  return {
    c() {
      ul0 = element("ul");
      ul0.innerHTML = `<li><strong>Item Animation is enabled but not customized</strong>   <i class="fas fa-check aa-green"></i></li>`;
      t2 = space();
      ul1 = element("ul");
      ul1.innerHTML = `<li><strong>Global Automatic Recogntion is matched</strong>   <i class="fas fa-check aa-green"></i></li>`;
      t5 = space();
      ul2 = element("ul");
      if (if_block0)
        if_block0.c();
      t6 = space();
      if (if_block1)
        if_block1.c();
    },
    m(target2, anchor) {
      insert(target2, ul0, anchor);
      insert(target2, t2, anchor);
      insert(target2, ul1, anchor);
      insert(target2, t5, anchor);
      insert(target2, ul2, anchor);
      if (if_block0)
        if_block0.m(ul2, null);
      append(ul2, t6);
      if (if_block1)
        if_block1.m(ul2, null);
    },
    p(ctx2, dirty) {
      if (
        /*isInAutorec*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$1(ctx2);
          if_block0.c();
          if_block0.m(ul2, t6);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*isInAEAutorec*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$1(ctx2);
          if_block1.c();
          if_block1.m(ul2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(ul0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(ul1);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(ul2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_else_block$1(ctx) {
  let ul;
  return {
    c() {
      ul = element("ul");
      ul.innerHTML = `<li><strong>No Global Automatic Recognition is matched</strong>   <i class="fas fa-xmark aa-red"></i></li>`;
    },
    m(target2, anchor) {
      insert(target2, ul, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(ul);
    }
  };
}
function create_if_block_5(ctx) {
  let ul0;
  let t1;
  let ul1;
  let t4;
  let ul2;
  let li2;
  let strong2;
  let t5;
  let t6;
  let t7;
  let t8_value = (
    /*isInAutorec*/
    ctx[2].label + ""
  );
  let t8;
  let t9;
  let i1;
  return {
    c() {
      ul0 = element("ul");
      ul0.innerHTML = `<li><strong>Global Automatic Recognition will be used</strong></li>`;
      t1 = space();
      ul1 = element("ul");
      ul1.innerHTML = `<li><strong>Global Automatic Recogntion is matched</strong>   <i class="fas fa-check aa-green"></i></li>`;
      t4 = space();
      ul2 = element("ul");
      li2 = element("li");
      strong2 = element("strong");
      t5 = text("Menu: ");
      t6 = text(
        /*autorecLabel*/
        ctx[4]
      );
      t7 = text(" - Label: ");
      t8 = text(t8_value);
      t9 = space();
      i1 = element("i");
      attr(i1, "class", "fas fa-check aa-green");
    },
    m(target2, anchor) {
      insert(target2, ul0, anchor);
      insert(target2, t1, anchor);
      insert(target2, ul1, anchor);
      insert(target2, t4, anchor);
      insert(target2, ul2, anchor);
      append(ul2, li2);
      append(li2, strong2);
      append(strong2, t5);
      append(strong2, t6);
      append(strong2, t7);
      append(strong2, t8);
      append(li2, t9);
      append(li2, i1);
    },
    p(ctx2, dirty) {
      if (dirty & /*autorecLabel*/
      16)
        set_data(
          t6,
          /*autorecLabel*/
          ctx2[4]
        );
      if (dirty & /*isInAutorec*/
      4 && t8_value !== (t8_value = /*isInAutorec*/
      ctx2[2].label + ""))
        set_data(t8, t8_value);
    },
    d(detaching) {
      if (detaching)
        detach(ul0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(ul1);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(ul2);
    }
  };
}
function create_if_block_2$1(ctx) {
  let li;
  let strong;
  let t0;
  let t1;
  let t2;
  let t3_value = (
    /*isInAutorec*/
    ctx[2].label + ""
  );
  let t3;
  let t4;
  let i;
  return {
    c() {
      li = element("li");
      strong = element("strong");
      t0 = text("Menu: ");
      t1 = text(
        /*autorecLabel*/
        ctx[4]
      );
      t2 = text(" - Label: ");
      t3 = text(t3_value);
      t4 = space();
      i = element("i");
      attr(i, "class", "fas fa-check aa-green");
    },
    m(target2, anchor) {
      insert(target2, li, anchor);
      append(li, strong);
      append(strong, t0);
      append(strong, t1);
      append(strong, t2);
      append(strong, t3);
      append(li, t4);
      append(li, i);
    },
    p(ctx2, dirty) {
      if (dirty & /*autorecLabel*/
      16)
        set_data(
          t1,
          /*autorecLabel*/
          ctx2[4]
        );
      if (dirty & /*isInAutorec*/
      4 && t3_value !== (t3_value = /*isInAutorec*/
      ctx2[2].label + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_if_block_1$1(ctx) {
  let li;
  let strong;
  let t0;
  let t1;
  let t2;
  let t3_value = (
    /*isInAEAutorec*/
    ctx[3].label + ""
  );
  let t3;
  let t4;
  let i;
  return {
    c() {
      li = element("li");
      strong = element("strong");
      t0 = text("Menu: ");
      t1 = text(
        /*aeLabel*/
        ctx[5]
      );
      t2 = text(" - Label: ");
      t3 = text(t3_value);
      t4 = space();
      i = element("i");
      attr(i, "class", "fas fa-check aa-green");
    },
    m(target2, anchor) {
      insert(target2, li, anchor);
      append(li, strong);
      append(strong, t0);
      append(strong, t1);
      append(strong, t2);
      append(strong, t3);
      append(li, t4);
      append(li, i);
    },
    p(ctx2, dirty) {
      if (dirty & /*isInAEAutorec*/
      8 && t3_value !== (t3_value = /*isInAEAutorec*/
      ctx2[3].label + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_fragment$4(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (
      /*isEnabled*/
      ctx2[0] && !/*isCustomized*/
      ctx2[1] && /*isInAutorec*/
      (ctx2[2] || /*isInAEAutorec*/
      ctx2[3])
    )
      return create_if_block$2;
    if (
      /*isEnabled*/
      ctx2[0] && !/*isCustomized*/
      ctx2[1] && !/*isInAutorec*/
      ctx2[2]
    )
      return create_if_block_3$1;
    if (
      /*isEnabled*/
      ctx2[0] && /*isCustomized*/
      ctx2[1]
    )
      return create_if_block_4;
    return create_else_block_1$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "aa-Info svelte-auto-2ogv0j");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let autorecLabel;
  let { isEnabled } = $$props;
  let { isCustomized } = $$props;
  let { isInAutorec } = $$props;
  let { isInAEAutorec } = $$props;
  let aeLabel = game.i18n.localize(`autoanimations.animTypes.aefx`);
  $$self.$$set = ($$props2) => {
    if ("isEnabled" in $$props2)
      $$invalidate(0, isEnabled = $$props2.isEnabled);
    if ("isCustomized" in $$props2)
      $$invalidate(1, isCustomized = $$props2.isCustomized);
    if ("isInAutorec" in $$props2)
      $$invalidate(2, isInAutorec = $$props2.isInAutorec);
    if ("isInAEAutorec" in $$props2)
      $$invalidate(3, isInAEAutorec = $$props2.isInAEAutorec);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isInAutorec*/
    4) {
      $$invalidate(4, autorecLabel = isInAutorec ? game.i18n.localize(`autoanimations.animTypes.${isInAutorec.menu}`) : "");
    }
  };
  return [isEnabled, isCustomized, isInAutorec, isInAEAutorec, autorecLabel, aeLabel];
}
class NoneChosen extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$3, create_fragment$4, safe_not_equal, {
      isEnabled: 0,
      isCustomized: 1,
      isInAutorec: 2,
      isInAEAutorec: 3
    });
  }
}
const CategoryControl_svelte_svelte_type_style_lang = "";
function create_else_block_1(ctx) {
  let label;
  return {
    c() {
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.globalNotFound")}`;
      attr(label, "for", "");
      set_style(label, "font-size", "15px");
      set_style(label, "font-weight", "bold");
    },
    m(target2, anchor) {
      insert(target2, label, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_if_block_3(ctx) {
  let label;
  let t0_value = localize("autoanimations.menus.activeEffect") + "";
  let t0;
  let t1;
  let t2_value = localize("autoanimations.menus.matchFound") + "";
  let t2;
  let t3;
  let br;
  return {
    c() {
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      br = element("br");
      attr(label, "for", "");
      set_style(label, "font-size", "15px");
      set_style(label, "font-weight", "bold");
    },
    m(target2, anchor) {
      insert(target2, label, anchor);
      append(label, t0);
      append(label, t1);
      append(label, t2);
      append(label, t3);
      append(label, br);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_if_block_2(ctx) {
  let label;
  let t0_value = localize("autoanimations.menus.globalFound") + "";
  let t0;
  let t1;
  let br;
  return {
    c() {
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      br = element("br");
      attr(label, "for", "");
      set_style(label, "font-size", "15px");
      set_style(label, "font-weight", "bold");
    },
    m(target2, anchor) {
      insert(target2, label, anchor);
      append(label, t0);
      append(label, t1);
      append(label, br);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_if_block_1(ctx) {
  let label;
  let t0_value = localize("autoanimations.menus.globalFound") + "";
  let t0;
  let t1;
  let t2_value = localize("autoanimations.menus.activeEffect") + "";
  let t2;
  let t3;
  let br;
  return {
    c() {
      label = element("label");
      t0 = text(t0_value);
      t1 = text(" + ");
      t2 = text(t2_value);
      t3 = space();
      br = element("br");
      attr(label, "for", "");
      set_style(label, "font-size", "15px");
      set_style(label, "font-weight", "bold");
    },
    m(target2, anchor) {
      insert(target2, label, anchor);
      append(label, t0);
      append(label, t1);
      append(label, t2);
      append(label, t3);
      append(label, br);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_default_slot$1(ctx) {
  let tjsmenu;
  let current;
  tjsmenu = new TJSMenu({ props: { menu: (
    /*subMenu*/
    ctx[12]
  ) } });
  return {
    c() {
      create_component(tjsmenu.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(tjsmenu, target2, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjsmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsmenu, detaching);
    }
  };
}
function create_else_block(ctx) {
  let categorylist;
  let current;
  categorylist = new CategoryList({
    props: { chosenMenu: (
      /*chosenMenu*/
      ctx[1]
    ) }
  });
  return {
    c() {
      create_component(categorylist.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(categorylist, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const categorylist_changes = {};
      if (dirty & /*chosenMenu*/
      2)
        categorylist_changes.chosenMenu = /*chosenMenu*/
        ctx2[1];
      categorylist.$set(categorylist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(categorylist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(categorylist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(categorylist, detaching);
    }
  };
}
function create_if_block$1(ctx) {
  let div;
  let switch_instance;
  let current;
  var switch_value = NoneChosen;
  function switch_props(ctx2) {
    return {
      props: {
        isEnabled: (
          /*isEnabled*/
          ctx2[5]
        ),
        isCustomized: (
          /*isCustomized*/
          ctx2[4]
        ),
        isInAutorec: (
          /*isInAutorec*/
          ctx2[7]
        ),
        isInAEAutorec: (
          /*isInAEAutorec*/
          ctx2[8]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", "sectionBorder svelte-auto-1iu6c13");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*isEnabled*/
      32)
        switch_instance_changes.isEnabled = /*isEnabled*/
        ctx2[5];
      if (dirty & /*isCustomized*/
      16)
        switch_instance_changes.isCustomized = /*isCustomized*/
        ctx2[4];
      if (dirty & /*isInAutorec*/
      128)
        switch_instance_changes.isInAutorec = /*isInAutorec*/
        ctx2[7];
      if (dirty & /*isInAEAutorec*/
      256)
        switch_instance_changes.isInAEAutorec = /*isInAEAutorec*/
        ctx2[8];
      if (switch_value !== (switch_value = NoneChosen)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment$3(ctx) {
  let header;
  let ul0;
  let div0;
  let slider0;
  let t0;
  let div1;
  let slider1;
  let div1_class_value;
  let t1;
  let div2;
  let div2_class_value;
  let t2;
  let div3;
  let tjstoggleiconbutton;
  let div3_class_value;
  let t3;
  let div4;
  let label;
  let t7;
  let select;
  let option0;
  let option1;
  let option2;
  let option3;
  let option4;
  let option5;
  let div4_class_value;
  let t14;
  let main2;
  let current_block_type_index;
  let if_block1;
  let t15;
  let footer;
  let ul1;
  let button0;
  let t17;
  let button1;
  let current;
  let mounted;
  let dispose;
  slider0 = new Slider({
    props: {
      label: (
        /*disabledLabel*/
        ctx[6]
      ),
      field: "isEnabled"
    }
  });
  slider1 = new Slider({
    props: {
      label: localize("autoanimations.menus.customize") + " Item",
      field: "isCustomized"
    }
  });
  function select_block_type(ctx2, dirty) {
    if (
      /*isInAutorec*/
      ctx2[7] && /*isInAEAutorec*/
      ctx2[8]
    )
      return create_if_block_1;
    if (
      /*isInAutorec*/
      ctx2[7]
    )
      return create_if_block_2;
    if (
      /*isInAEAutorec*/
      ctx2[8]
    )
      return create_if_block_3;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  tjstoggleiconbutton = new TJSToggleIconButton({
    props: {
      button: (
        /*buttonOverflow*/
        ctx[11]
      ),
      slot: "summary-end",
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block$1, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (!/*menuType*/
    ctx2[3] || !/*isEnabled*/
    ctx2[5] || !/*isCustomized*/
    ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      header = element("header");
      ul0 = element("ul");
      div0 = element("div");
      create_component(slider0.$$.fragment);
      t0 = space();
      div1 = element("div");
      create_component(slider1.$$.fragment);
      t1 = space();
      div2 = element("div");
      if_block0.c();
      t2 = space();
      div3 = element("div");
      create_component(tjstoggleiconbutton.$$.fragment);
      t3 = space();
      div4 = element("div");
      label = element("label");
      label.textContent = `${localize("autoanimations.menus.animation")} 
        ${localize("autoanimations.menus.type")}`;
      t7 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("autoanimations.animTypes.melee")}`;
      option1 = element("option");
      option1.textContent = `${localize("autoanimations.animTypes.range")}`;
      option2 = element("option");
      option2.textContent = `${localize("autoanimations.animTypes.ontoken")}`;
      option3 = element("option");
      option3.textContent = `${localize("autoanimations.animTypes.templatefx")}`;
      option4 = element("option");
      option4.textContent = `${localize("autoanimations.animTypes.aura")}`;
      option5 = element("option");
      option5.textContent = `${localize("autoanimations.animTypes.preset")}`;
      t14 = space();
      main2 = element("main");
      if_block1.c();
      t15 = space();
      footer = element("footer");
      ul1 = element("ul");
      button0 = element("button");
      button0.textContent = "Submit";
      t17 = space();
      button1 = element("button");
      button1.textContent = "Submit and Close";
      set_style(div0, "grid-row", "1/2");
      set_style(div0, "grid-column", "1/2");
      set_style(div1, "grid-row", "2/3");
      set_style(div1, "grid-column", "1/2");
      attr(div1, "class", div1_class_value = !/*isEnabled*/
      ctx[5] ? "aa-disableOpacity" : "");
      set_style(div2, "grid-row", "1 / 2");
      set_style(div2, "grid-column", "2/3");
      attr(div2, "class", div2_class_value = "autorecLabel " + /*isInAutorec*/
      (ctx[7] || /*isInAEAutorec*/
      ctx[8] ? "aa-bgGreen" : "aa-bgRed") + " " + (!/*isEnabled*/
      ctx[5] ? "aa-disableOpacity" : "") + " svelte-auto-1iu6c13");
      set_style(div3, "grid-row", "1/2");
      set_style(div3, "grid-column", "3/4");
      attr(div3, "class", div3_class_value = !/*isEnabled*/
      ctx[5] ? "aa-disableOpacity" : "");
      attr(label, "for", "");
      set_style(label, "font-weight", "bold");
      option0.__value = "melee";
      option0.value = option0.__value;
      option1.__value = "range";
      option1.value = option1.__value;
      option2.__value = "ontoken";
      option2.value = option2.__value;
      option3.__value = "templatefx";
      option3.value = option3.__value;
      option4.__value = "aura";
      option4.value = option4.__value;
      option5.__value = "preset";
      option5.value = option5.__value;
      if (
        /*$animation*/
        ctx[2].menu === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[14].call(select)
        ));
      set_style(div4, "grid-row", "2/3");
      set_style(div4, "grid-column", "2/4");
      set_style(div4, "padding-bottom", "10px");
      set_style(div4, "margin-left", "1.5em");
      attr(div4, "class", div4_class_value = !/*isEnabled*/
      ctx[5] || !/*isCustomized*/
      ctx[4] ? "aa-disableOpacity" : "");
      attr(ul0, "class", "svelte-auto-1iu6c13");
      attr(header, "class", "animation svelte-auto-1iu6c13");
      attr(main2, "class", "svelte-auto-1iu6c13");
      set_style(button0, "background-color", "rgba(0, 0, 0, 0.2)");
      attr(button0, "class", "svelte-auto-1iu6c13");
      attr(button1, "class", "svelte-auto-1iu6c13");
      attr(ul1, "class", "svelte-auto-1iu6c13");
      attr(footer, "class", "svelte-auto-1iu6c13");
    },
    m(target2, anchor) {
      insert(target2, header, anchor);
      append(header, ul0);
      append(ul0, div0);
      mount_component(slider0, div0, null);
      append(ul0, t0);
      append(ul0, div1);
      mount_component(slider1, div1, null);
      append(ul0, t1);
      append(ul0, div2);
      if_block0.m(div2, null);
      append(ul0, t2);
      append(ul0, div3);
      mount_component(tjstoggleiconbutton, div3, null);
      append(ul0, t3);
      append(ul0, div4);
      append(div4, label);
      append(div4, t7);
      append(div4, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      append(select, option3);
      append(select, option4);
      append(select, option5);
      select_option(
        select,
        /*$animation*/
        ctx[2].menu,
        true
      );
      insert(target2, t14, anchor);
      insert(target2, main2, anchor);
      if_blocks[current_block_type_index].m(main2, null);
      insert(target2, t15, anchor);
      insert(target2, footer, anchor);
      append(footer, ul1);
      append(ul1, button0);
      append(ul1, t17);
      append(ul1, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[14]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[15]
          ),
          listen(button0, "click", prevent_default(
            /*click_handler*/
            ctx[16]
          )),
          listen(button1, "click", prevent_default(
            /*click_handler_1*/
            ctx[17]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const slider0_changes = {};
      if (dirty & /*disabledLabel*/
      64)
        slider0_changes.label = /*disabledLabel*/
        ctx2[6];
      slider0.$set(slider0_changes);
      if (!current || dirty & /*isEnabled*/
      32 && div1_class_value !== (div1_class_value = !/*isEnabled*/
      ctx2[5] ? "aa-disableOpacity" : "")) {
        attr(div1, "class", div1_class_value);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div2, null);
        }
      }
      if (!current || dirty & /*isInAutorec, isInAEAutorec, isEnabled*/
      416 && div2_class_value !== (div2_class_value = "autorecLabel " + /*isInAutorec*/
      (ctx2[7] || /*isInAEAutorec*/
      ctx2[8] ? "aa-bgGreen" : "aa-bgRed") + " " + (!/*isEnabled*/
      ctx2[5] ? "aa-disableOpacity" : "") + " svelte-auto-1iu6c13")) {
        attr(div2, "class", div2_class_value);
      }
      const tjstoggleiconbutton_changes = {};
      if (dirty & /*$$scope*/
      8388608) {
        tjstoggleiconbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjstoggleiconbutton.$set(tjstoggleiconbutton_changes);
      if (!current || dirty & /*isEnabled*/
      32 && div3_class_value !== (div3_class_value = !/*isEnabled*/
      ctx2[5] ? "aa-disableOpacity" : "")) {
        attr(div3, "class", div3_class_value);
      }
      if (dirty & /*$animation*/
      4) {
        select_option(
          select,
          /*$animation*/
          ctx2[2].menu
        );
      }
      if (!current || dirty & /*isEnabled, isCustomized*/
      48 && div4_class_value !== (div4_class_value = !/*isEnabled*/
      ctx2[5] || !/*isCustomized*/
      ctx2[4] ? "aa-disableOpacity" : "")) {
        attr(div4, "class", div4_class_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(main2, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(slider0.$$.fragment, local);
      transition_in(slider1.$$.fragment, local);
      transition_in(tjstoggleiconbutton.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(slider0.$$.fragment, local);
      transition_out(slider1.$$.fragment, local);
      transition_out(tjstoggleiconbutton.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(header);
      destroy_component(slider0);
      destroy_component(slider1);
      if_block0.d();
      destroy_component(tjstoggleiconbutton);
      if (detaching)
        detach(t14);
      if (detaching)
        detach(main2);
      if_blocks[current_block_type_index].d();
      if (detaching)
        detach(t15);
      if (detaching)
        detach(footer);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let isInAutorec;
  let isInAEAutorec;
  let disabledLabel;
  let isEnabled;
  let isCustomized;
  let menuType;
  let $animation, $$unsubscribe_animation = noop, $$subscribe_animation = () => ($$unsubscribe_animation(), $$unsubscribe_animation = subscribe(animation, ($$value) => $$invalidate(2, $animation = $$value)), animation);
  $$self.$$.on_destroy.push(() => $$unsubscribe_animation());
  let { animation } = $$props;
  $$subscribe_animation();
  setContext("animation-data", { animation, category: animation, idx: 0 });
  let { item: item2 } = $$props;
  game.system.id === "dnd5e";
  const { application } = getContext("#external");
  let autorecSettings = {
    melee: game.settings.get("autoanimations", "aaAutorec-melee"),
    range: game.settings.get("autoanimations", "aaAutorec-range"),
    ontoken: game.settings.get("autoanimations", "aaAutorec-ontoken"),
    templatefx: game.settings.get("autoanimations", "aaAutorec-templatefx"),
    aura: game.settings.get("autoanimations", "aaAutorec-aura"),
    preset: game.settings.get("autoanimations", "aaAutorec-preset"),
    aefx: game.settings.get("autoanimations", "aaAutorec-aefx")
  };
  async function applyFlags() {
    await item2.update({ "flags.-=autoanimations": null });
    await item2.update({ "flags.autoanimations": $animation });
  }
  async function closeApp() {
    await item2.update({ "flags.-=autoanimations": null });
    await item2.update({ "flags.autoanimations": $animation });
    application.close();
  }
  let filteredSettings = AAAutorecFunctions.sortAndFilterMenus(autorecSettings);
  isInAutorec ? game.i18n.localize(`autoanimations.animTypes.${isInAutorec.menu}`) : "";
  const buttonOverflow = {
    icon: "fas fa-ellipsis-v",
    efx: ripple(),
    title: "Copy To/From",
    styles: { "margin-left": "0.5em" },
    onClickPropagate: false
    // Necessary to capture click for Firefox.
  };
  const subMenu = {
    items: copyToFrom(animation, item2, autorecSettings)
  };
  let chosenMenu = $animation.menu;
  function select_change_handler() {
    $animation.menu = select_value(this);
    animation.set($animation);
  }
  const change_handler = async () => {
    await animation.switchVideo();
    $$invalidate(1, chosenMenu = $animation.menu);
    animation.deleteOld();
  };
  const click_handler = () => applyFlags();
  const click_handler_1 = () => closeApp();
  $$self.$$set = ($$props2) => {
    if ("animation" in $$props2)
      $$subscribe_animation($$invalidate(0, animation = $$props2.animation));
    if ("item" in $$props2)
      $$invalidate(13, item2 = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(7, isInAutorec = AAAutorecFunctions.allMenuSearch(filteredSettings, AAAutorecFunctions.rinseName($animation.label), $animation.label));
    }
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(8, isInAEAutorec = AAAutorecFunctions.singleMenuSearch(autorecSettings.aefx, AAAutorecFunctions.rinseName($animation.label), $animation.label));
    }
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(6, disabledLabel = $animation.isEnabled ? game.i18n.localize("autoanimations.menus.animation") + " " + game.i18n.localize("autoanimations.menus.enabled") : game.i18n.localize("autoanimations.menus.animation") + " " + game.i18n.localize("autoanimations.menus.disabled"));
    }
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(5, isEnabled = $animation.isEnabled);
    }
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(4, isCustomized = $animation.isCustomized);
    }
    if ($$self.$$.dirty & /*$animation*/
    4) {
      $$invalidate(3, menuType = $animation.menu);
    }
    if ($$self.$$.dirty & /*chosenMenu*/
    2)
      ;
  };
  return [
    animation,
    chosenMenu,
    $animation,
    menuType,
    isCustomized,
    isEnabled,
    disabledLabel,
    isInAutorec,
    isInAEAutorec,
    applyFlags,
    closeApp,
    buttonOverflow,
    subMenu,
    item2,
    select_change_handler,
    change_handler,
    click_handler,
    click_handler_1
  ];
}
class CategoryControl extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$2, create_fragment$3, safe_not_equal, { animation: 0, item: 13 });
  }
}
function create_default_slot(ctx) {
  let categorycontrol;
  let current;
  categorycontrol = new CategoryControl({
    props: {
      item: (
        /*item*/
        ctx[2]
      ),
      animation: (
        /*animation*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(categorycontrol.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(categorycontrol, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const categorycontrol_changes = {};
      if (dirty & /*item*/
      4)
        categorycontrol_changes.item = /*item*/
        ctx2[2];
      categorycontrol.$set(categorycontrol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(categorycontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(categorycontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(categorycontrol, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[9](value);
  }
  let applicationshell_props = {
    stylesContent: { color: "black" },
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(applicationshell, target2, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope, item*/
      65540) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $position;
  let $storageStore, $$unsubscribe_storageStore = noop, $$subscribe_storageStore = () => ($$unsubscribe_storageStore(), $$unsubscribe_storageStore = subscribe(storageStore, ($$value) => $$invalidate(11, $storageStore = $$value)), storageStore);
  let $doc;
  let $animation;
  $$self.$$.on_destroy.push(() => $$unsubscribe_storageStore());
  let { elementRoot } = $$props;
  let { storageStore = void 0 } = $$props;
  $$subscribe_storageStore();
  let { item: item2 } = $$props;
  let { itemFlags } = $$props;
  const doc = new TJSDocument(item2);
  component_subscribe($$self, doc, (value) => $$invalidate(8, $doc = value));
  let aaFlags = itemFlags.autoanimations || {};
  const { application } = getContext("#external");
  let newFlagData = foundry.utils.deepClone(aaFlags);
  if (!newFlagData.hasOwnProperty("menu")) {
    newFlagData = melee();
  }
  if (!newFlagData.hasOwnProperty("isEnabled")) {
    newFlagData.isEnabled = true;
  }
  if (!newFlagData.hasOwnProperty("isCustomized")) {
    newFlagData.isCustomized = false;
  }
  if (!newFlagData.hasOwnProperty("fromAmmo")) {
    newFlagData.fromAmmo = false;
  }
  if (!newFlagData.hasOwnProperty("version")) {
    newFlagData.version = Object.keys(flagMigrations.migrations).map((n) => Number(n)).reverse()[0];
  }
  newFlagData.label = item2.name;
  let animation = new AnimationStore(newFlagData);
  component_subscribe($$self, animation, (value) => $$invalidate(12, $animation = value));
  const position = application.position;
  component_subscribe($$self, position, (value) => $$invalidate(7, $position = value));
  const storeAppState = foundry.utils.debounce(() => set_store_value(storageStore, $storageStore = application.state.get(), $storageStore), 500);
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("storageStore" in $$props2)
      $$subscribe_storageStore($$invalidate(1, storageStore = $$props2.storageStore));
    if ("item" in $$props2)
      $$invalidate(2, item2 = $$props2.item);
    if ("itemFlags" in $$props2)
      $$invalidate(6, itemFlags = $$props2.itemFlags);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$doc*/
    256) {
      {
        set_store_value(animation, $animation.label = $doc.name, $animation);
      }
    }
    if ($$self.$$.dirty & /*$position*/
    128) {
      storeAppState($position);
    }
  };
  return [
    elementRoot,
    storageStore,
    item2,
    doc,
    animation,
    position,
    itemFlags,
    $position,
    $doc,
    applicationshell_elementRoot_binding
  ];
}
class ItemAppShell extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance$1, create_fragment$2, safe_not_equal, {
      elementRoot: 0,
      storageStore: 1,
      item: 2,
      itemFlags: 6
    });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get storageStore() {
    return this.$$.ctx[1];
  }
  set storageStore(storageStore) {
    this.$$set({ storageStore });
    flush();
  }
  get item() {
    return this.$$.ctx[2];
  }
  set item(item2) {
    this.$$set({ item: item2 });
    flush();
  }
  get itemFlags() {
    return this.$$.ctx[6];
  }
  set itemFlags(itemFlags) {
    this.$$set({ itemFlags });
    flush();
  }
}
const ItemInformation_svelte_svelte_type_style_lang = "";
function create_if_block(ctx) {
  let table;
  let tr0;
  let t1;
  let tr1;
  let td0;
  let strong0;
  let t5;
  let td1;
  let t7;
  let tr2;
  let td2;
  let strong1;
  let t11;
  let td3;
  return {
    c() {
      table = element("table");
      tr0 = element("tr");
      tr0.innerHTML = `<th colspan="2" class="svelte-auto-o1b2bf">Item Settings</th>`;
      t1 = space();
      tr1 = element("tr");
      td0 = element("td");
      strong0 = element("strong");
      strong0.textContent = `${localize("autoanimations.menus.animation")} 
                        ${localize("autoanimations.menus.enabled")}`;
      t5 = space();
      td1 = element("td");
      td1.textContent = "Turn Animations for this item ON or OFF";
      t7 = space();
      tr2 = element("tr");
      td2 = element("td");
      strong1 = element("strong");
      strong1.textContent = `${localize("autoanimations.menus.customize")} 
                        ${localize("autoanimations.menus.item")}`;
      t11 = space();
      td3 = element("td");
      td3.textContent = "Toggle custom Item Animation. If enabled the Autorec menu\n                    will be disabled for this Item.";
      attr(tr0, "class", "svelte-auto-o1b2bf");
      attr(td0, "class", "aa-table svelte-auto-o1b2bf");
      attr(td1, "class", "svelte-auto-o1b2bf");
      attr(tr1, "class", "svelte-auto-o1b2bf");
      attr(td2, "class", "aa-table svelte-auto-o1b2bf");
      attr(td3, "class", "svelte-auto-o1b2bf");
      attr(tr2, "class", "svelte-auto-o1b2bf");
      attr(table, "id", "options-table");
      attr(table, "cellpadding", "0");
      attr(table, "cellspacing", "0");
      attr(table, "border", "1");
      attr(table, "class", "svelte-auto-o1b2bf");
    },
    m(target2, anchor) {
      insert(target2, table, anchor);
      append(table, tr0);
      append(table, t1);
      append(table, tr1);
      append(tr1, td0);
      append(td0, strong0);
      append(tr1, t5);
      append(tr1, td1);
      append(table, t7);
      append(table, tr2);
      append(tr2, td2);
      append(td2, strong1);
      append(tr2, t11);
      append(tr2, td3);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(table);
    }
  };
}
function create_fragment$1(ctx) {
  let div;
  let if_block = (
    /*currentSelected*/
    ctx[0] === "melee" && create_if_block()
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "aa-options-info svelte-auto-o1b2bf");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*currentSelected*/
        ctx2[0] === "melee"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { currentSelected: currentSelected2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("currentSelected" in $$props2)
      $$invalidate(0, currentSelected2 = $$props2.currentSelected);
  };
  return [currentSelected2];
}
class ItemInformation extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, instance, create_fragment$1, safe_not_equal, { currentSelected: 0 });
  }
}
function create_fragment(ctx) {
  let iteminformation;
  let current;
  iteminformation = new ItemInformation({ props: { currentSelected } });
  return {
    c() {
      create_component(iteminformation.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(iteminformation, target2, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(iteminformation.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iteminformation.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iteminformation, detaching);
    }
  };
}
let currentSelected = "melee";
class ItemInfo extends SvelteComponent {
  constructor(options2) {
    super();
    init(this, options2, null, create_fragment, safe_not_equal, {});
  }
}
class ItemInfoDialog extends TJSDialog {
  constructor(data2) {
    super({
      title: "Menu Information",
      draggable: true,
      resizable: true,
      modal: false,
      zIndex: null,
      content: {
        class: ItemInfo,
        props: {
          ...data2
        }
      }
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      minimizable: true,
      width: 600,
      height: "auto",
      closeOnSubmit: true,
      id: `ItemInformation`
    });
  }
}
class ItemMenuApp extends SvelteApplication {
  /** @inheritDoc */
  constructor(item2) {
    super({
      title: `A-A Item Menu`,
      id: `AA-item-settings`,
      zIndex: 102,
      svelte: {
        class: ItemAppShell,
        target: document.body,
        props: {
          item: item2,
          itemFlags: item2.flags,
          storageStore: aaSessionStorage.getStore(sessionConstants.itemAppState)
        }
      }
    });
    try {
      this.state.set(aaSessionStorage.getItem(sessionConstants.itemAppState));
    } catch (err) {
    }
  }
  /**
   *
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      resizable: true,
      minimizable: true,
      width: 600,
      height: 750,
      minWidth: 550
    });
  }
  _getHeaderButtons() {
    const buttons = super._getHeaderButtons();
    buttons.unshift({
      icon: "fas fa-circle-info",
      title: "Item Information",
      label: "Info",
      styles: { color: "lightblue", position: "relative", right: "5px" },
      onPress: function() {
        if (Object.values(ui.windows).find(
          (w) => w.id === `Options-Information`
        )) {
          return;
        }
        new ItemInfoDialog().render(true);
      }
    });
    buttons.unshift({
      class: "autorec-shortcut",
      icon: "fas fa-globe",
      title: "Launch Autorec",
      label: "Global Automatic Recognition Menu",
      styles: { color: "lightblue", position: "relative", right: "30px" },
      onPress: function() {
        if (game.user.isGM) {
          new showAutorecMenu();
        }
      }
    });
    return buttons;
  }
  /**
   * @inheritDoc
   */
  async close(options2) {
    Object.values(ui.windows).filter((app) => app.id === "Options-Information" || app.id === "Autorec-Video-Preview" || app.id === "Autorec-Menu-Manager" || app.id === "Item-Information" || app.id === "AA-Copy-Item-To-Global").forEach((app) => app.close());
    return super.close(options2);
  }
}
const aaDeletedItems = /* @__PURE__ */ new Map();
async function getRequiredData(data2) {
  if (!data2.token) {
    data2.token = getToken(data2);
  }
  if (!data2.item) {
    data2.item = await getItem(data2);
  }
  if (!data2.item && data2.itemUuid) {
    if (game.modules.get("magicitems")?.active) {
      const splitUuid = data2.itemUuid.split(".");
      const id = splitUuid[splitUuid.length - 1];
      data2.item = game.packs.get("dnd5e.spells")?.index?.get(id);
    }
  }
  if (!data2.token && data2.item) {
    data2.token = data2.item.parent?.token ?? getTokenFromItemID(data2.item.id) ?? _token;
  }
  if (!data2.token) {
    data2.token = _token;
  }
  if (!data2.targets) {
    data2.targets = Array.from(game.user.targets);
  }
  return { ...data2 };
}
async function getItem(data2) {
  let { item: item2, itemId, itemUuid, itemName, token, tokenId, tokenUuid, targets: targets2, actorId, actor } = data2;
  return itemUuid ? await getItemFromUuid(itemUuid) : token && itemId ? getItemFromToken(token, itemId) : tokenId && itemId ? getItemFromTokenId(tokenId, itemId) : tokenUuid && itemId ? getItemFromTokenUuid(tokenUuid, itemId) : token && itemName ? getItemFromName(token, itemName) : itemId && (actorId || actor) ? await getItemFromCompiledUuid(itemId, actor, actorId) : itemId ? checkDeletedItems(itemId) || getItemFromIdBlind(itemId) : null;
}
async function getItemFromUuid(uuid) {
  return await fromUuid(uuid) || checkDeletedItems(uuid);
}
function checkDeletedItems(id) {
  let idSplit = id.split(".");
  return aaDeletedItems.get(idSplit[idSplit.length - 1]) || false;
}
async function getItemFromCompiledUuid(itemId, actor, actorId) {
  const idActor = actor ? actor.id : actorId;
  return await fromUuid(`Actor.${idActor}.Item.${itemId}`);
}
function getItemFromToken(token, itemId) {
  return token.actor?.items?.get(itemId);
}
function getItemFromTokenId(tokenId, itemId) {
  let token = getTokenFromScene(tokenId) || getTokenFromCompiledUuid(tokenId);
  if (!token) {
    return;
  }
  return getItemFromToken(token, itemId);
}
function getItemFromTokenUuid(tokenUuid, itemId) {
  let token = getTokenFromUuid(tokenUuid);
  if (!token) {
    return;
  }
  return getItemFromToken(token, itemId);
}
function getItemFromName(token, name) {
  let items = Array.from(token.actor.items);
  return items.find((x) => x.name === name);
}
function getItemFromIdBlind(id) {
  for (let token of canvas.tokens.placeables) {
    let items = Array.from(token.actor.items);
    let foundItem = items.find((c) => c.id === id);
    if (foundItem) {
      return foundItem || false;
    }
  }
}
function getToken(data2) {
  let { item: item2, itemId, itemUuid, itemName, token, tokenId, tokenUuid, targets: targets2, actorId, actor } = data2;
  return item2 ? item2.parent?.token ?? getTokenFromItemID(item2.id) : tokenUuid ? getTokenFromUuid(tokenUuid) : tokenId ? getTokenFromScene(tokenId) || getTokenFromCompiledUuid(tokenId) : itemId ? getTokenFromItemID(itemId) : actor || actorId ? getTokenFromActor(actor, actorId) : null;
}
function getTokenFromItemID(id) {
  let tokens = canvas.tokens.placeables.filter((token) => token.actor?.items?.get(id));
  let trueToken = tokens.length > 1 ? tokens.find((x) => x.id === _token.id) || tokens[0] : tokens[0];
  return trueToken;
}
function getTokenFromScene(id) {
  return canvas.scene.tokens.get(id);
}
function getTokenFromUuid(uuid) {
  return fromUuidSync(uuid)?.object;
}
function getTokenFromCompiledUuid(id) {
  return fromUuidSync(`${canvas.scene.uuid}.Token.${id}`)?.object;
}
function getTokenFromActor(actor, actorId) {
  let idActor = actor ? actor.id : actorId;
  let foundActor = fromUuidSync(idActor);
  if (!foundActor) {
    return null;
  }
  let token = foundActor.getActiveTokens();
  return Array.isArray(token) ? token[0] : token;
}
function systemHooks$o() {
  if (game.modules.get("midi-qol")?.active) {
    Hooks.on("midi-qol.AttackRollComplete", (workflow) => {
      let playOnDamage = game.settings.get("autoanimations", "playonDamage");
      if (workflow.item?.hasAreaTarget || workflow.item?.hasDamage && playOnDamage) {
        return;
      }
      attack$1(getWorkflowData$1(workflow));
      criticalCheck$1(workflow);
    });
    Hooks.on("midi-qol.DamageRollComplete", (workflow) => {
      let playOnDamage = game.settings.get("autoanimations", "playonDamage");
      if (workflow.item?.hasAreaTarget || !playOnDamage && workflow.item?.hasAttack) {
        return;
      }
      damage$1(getWorkflowData$1(workflow));
    });
    Hooks.on("midi-qol.RollComplete", (workflow) => {
      if (workflow.item?.hasAreaTarget || workflow.item?.hasAttack || workflow.item?.hasDamage) {
        return;
      }
      useItem$1(getWorkflowData$1(workflow));
    });
  } else {
    Hooks.on("dnd5e.preRollAttack", async (item2, options2) => {
      let spellLevel = options2.spellLevel ?? void 0;
      Hooks.once("dnd5e.rollAttack", async (item3, roll) => {
        criticalCheck$1(roll, item3);
        let playOnDamage = game.settings.get("autoanimations", "playonDamageCore");
        if (item3.hasAreaTarget || item3.hasDamage && playOnDamage) {
          return;
        }
        attack$1(await getRequiredData({ item: item3, actor: item3.actor, workflow: item3, rollAttackHook: { item: item3, roll }, spellLevel }));
      });
    });
    Hooks.on("dnd5e.rollDamage", async (item2, roll) => {
      let playOnDamage = game.settings.get("autoanimations", "playonDamageCore");
      if (item2.hasAreaTarget || item2.hasAttack && !playOnDamage) {
        return;
      }
      damage$1(await getRequiredData({ item: item2, actor: item2.actor, workflow: item2, rollDamageHook: { item: item2, roll }, spellLevel: roll?.data?.item?.level ?? void 0 }));
    });
    Hooks.on("dnd5e.useItem", async (item2, config, options2) => {
      if (item2?.hasAreaTarget || item2.hasAttack || item2.hasDamage) {
        return;
      }
      useItem$1(await getRequiredData({ item: item2, actor: item2.actor, workflow: item2, useItemHook: { item: item2, config, options: options2 }, spellLevel: options2?.flags?.dnd5e?.use?.spellLevel || void 0 }));
    });
  }
  Hooks.on("createMeasuredTemplate", async (template, data2, userId) => {
    if (userId !== game.user.id) {
      return;
    }
    templateAnimation$6(await getRequiredData({ itemUuid: template.flags?.dnd5e?.origin, templateData: template, workflow: template, isTemplate: true }));
  });
}
async function useItem$1(input) {
  debug$1("Item used, checking for animations");
  const handler = await AAHandler.make(input);
  if (!handler?.item || !handler?.sourceToken) {
    console.log("Automated Animations: No Item or Source Token", handler);
    return;
  }
  trafficCop$1(handler);
}
async function attack$1(input) {
  checkAmmo$2(input);
  checkReach$1(input);
  debug$1("Attack rolled, checking for animations");
  const handler = await AAHandler.make(input);
  if (!handler?.item || !handler?.sourceToken) {
    console.log("Automated Animations: No Item or Source Token", handler);
    return;
  }
  trafficCop$1(handler);
}
async function damage$1(input) {
  checkAmmo$2(input);
  checkReach$1(input);
  debug$1("Damage rolled, checking for animations");
  const handler = await AAHandler.make(input);
  if (!handler?.item || !handler?.sourceToken) {
    console.log("Automated Animations: No Item or Source Token", handler);
    return;
  }
  trafficCop$1(handler);
}
async function templateAnimation$6(input) {
  debug$1("Template placed, checking for animations");
  if (!input.item) {
    debug$1("No Item could be found");
    return;
  }
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
function checkAmmo$2(data2) {
  const ammoType = data2.item?.system?.consume?.type;
  data2.ammoItem = ammoType === "ammo" ? data2.token?.actor?.items?.get(data2.item?.system?.consume?.target) : null;
}
function checkReach$1(data2) {
  let reach = 0;
  if (data2.item.system?.properties?.rch) {
    reach += 1;
  }
  data2.reach = reach;
}
function getWorkflowData$1(data2) {
  return {
    item: data2.item,
    token: data2.token,
    targets: Array.from(data2.targets),
    hitTargets: Array.from(data2.hitTargets),
    spellLevel: data2.castData?.castLevel ?? void 0,
    workflow: data2
  };
}
function criticalCheck$1(workflow, item2 = {}) {
  if (!workflow.isCritical && !workflow.isFumble) {
    return;
  }
  debug$1("Checking for Crit or Fumble");
  let critical = workflow.isCritical;
  let fumble = workflow.isFumble;
  let token = canvas.tokens.get(workflow.tokenId) || getTokenFromItem(item2);
  let critAnim = game.settings.get("autoanimations", "CriticalAnimation");
  let critMissAnim = game.settings.get("autoanimations", "CriticalMissAnimation");
  switch (true) {
    case (game.settings.get("autoanimations", "EnableCritical") && critical):
      new Sequence({ moduleName: "Automated Animations", softFail: !game.settings.get("autoanimations", "debug") }).effect().file(critAnim).atLocation(token).play();
      break;
    case (game.settings.get("autoanimations", "EnableCriticalMiss") && fumble):
      new Sequence({ moduleName: "Automated Animations", softFail: !game.settings.get("autoanimations", "debug") }).effect().file(critMissAnim).atLocation(token).play();
      break;
  }
  function getTokenFromItem(item3) {
    let token2 = item3?.parent?.token;
    if (token2) {
      return token2;
    }
    let tokens = canvas.tokens.placeables.filter((token3) => token3.actor?.items?.get(item3.id));
    let trueToken = tokens.length > 1 ? tokens.find((x) => x.id === _token.id) || tokens[0] : tokens[0];
    return trueToken;
  }
}
const aaDnd5e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$o
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$n() {
  if (game.modules.get("midi-qol")?.active) {
    Hooks.on("midi-qol.AttackRollComplete", (workflow) => {
      let playOnDamage = game.settings.get("autoanimations", "playonDamage");
      if (workflow.item?.hasAreaTarget || workflow.item?.hasDamage && playOnDamage) {
        return;
      }
      attack(getWorkflowData(workflow));
      criticalCheck(workflow);
    });
    Hooks.on("midi-qol.DamageRollComplete", (workflow) => {
      let playOnDamage = game.settings.get("autoanimations", "playonDamage");
      if (workflow.item?.hasAreaTarget || !playOnDamage && workflow.item?.hasAttack) {
        return;
      }
      damage(getWorkflowData(workflow));
    });
    Hooks.on("midi-qol.RollComplete", (workflow) => {
      if (workflow.item?.hasAreaTarget || workflow.item?.hasAttack || workflow.item?.hasDamage) {
        return;
      }
      useItem(getWorkflowData(workflow));
    });
  } else {
    Hooks.on("sw5e.rollAttack", async (item2, roll) => {
      let playOnDamage = game.settings.get("autoanimations", "playonDamageCore");
      if (item2.hasAreaTarget || item2.hasDamage && playOnDamage) {
        return;
      }
      attack(await getRequiredData({ item: item2, actor: item2.actor, workflow: item2 }));
    });
    Hooks.on("sw5e.rollDamage", async (item2, roll) => {
      let playOnDamage = game.settings.get("autoanimations", "playonDamageCore");
      if (item2.hasAreaTarget || item2.hasAttack && !playOnDamage) {
        return;
      }
      damage(await getRequiredData({ item: item2, actor: item2.actor, workflow: item2 }));
    });
    Hooks.on("sw5e.useItem", async (item2, config, options2) => {
      if (item2?.hasAreaTarget || item2.hasAttack || item2.hasDamage) {
        return;
      }
      useItem(await getRequiredData({ item: item2, actor: item2.actor, workflow: item2 }));
    });
  }
  Hooks.on("createMeasuredTemplate", async (template, data2, userId) => {
    if (userId !== game.user.id) {
      return;
    }
    templateAnimation$5(await getRequiredData({ itemUuid: template.flags?.sw5e?.origin, templateData: template, workflow: template, isTemplate: true }));
  });
}
async function useItem(input) {
  debug$1("Item used, checking for animations");
  const handler = await AAHandler.make(input);
  if (!handler?.item || !handler?.sourceToken) {
    console.log("Automated Animations: No Item or Source Token", handler);
    return;
  }
  trafficCop$1(handler);
}
async function attack(input) {
  checkAmmo$1(input);
  checkReach(input);
  debug$1("Attack rolled, checking for animations");
  const handler = await AAHandler.make(input);
  if (!handler?.item || !handler?.sourceToken) {
    console.log("Automated Animations: No Item or Source Token", handler);
    return;
  }
  trafficCop$1(handler);
}
async function damage(input) {
  checkAmmo$1(input);
  checkReach(input);
  debug$1("Damage rolled, checking for animations");
  const handler = await AAHandler.make(input);
  if (!handler?.item || !handler?.sourceToken) {
    console.log("Automated Animations: No Item or Source Token", handler);
    return;
  }
  trafficCop$1(handler);
}
async function templateAnimation$5(input) {
  debug$1("Template placed, checking for animations");
  if (!input.item) {
    debug$1("No Item could be found");
    return;
  }
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
function checkAmmo$1(data2) {
  const ammoType = data2.item?.system?.consume?.type;
  data2.ammoItem = ammoType === "ammo" ? data2.token?.actor?.items?.get(data2.item?.system?.consume?.target) : null;
}
function checkReach(data2) {
  let reach = 0;
  if (data2.item.system?.properties?.rch) {
    reach += 1;
  }
  data2.reach = reach;
}
function getWorkflowData(data2) {
  return {
    item: data2.item,
    token: data2.token,
    targets: Array.from(data2.targets),
    hitTargets: Array.from(data2.hitTargets),
    workflow: data2
  };
}
function criticalCheck(workflow) {
  if (!workflow.isCritical && !workflow.isFumble) {
    return;
  }
  debug$1("Checking for Crit or Fumble");
  let critical = workflow.isCritical;
  let fumble = workflow.isFumble;
  let token;
  let critAnim = game.settings.get("autoanimations", "CriticalAnimation");
  let critMissAnim = game.settings.get("autoanimations", "CriticalMissAnimation");
  switch (true) {
    case (game.settings.get("autoanimations", "EnableCritical") && critical):
      token = canvas.tokens.get(workflow.tokenId);
      new Sequence({ moduleName: "Automated Animations", softFail: !game.settings.get("autoanimations", "debug") }).effect().file(critAnim).atLocation(token).play();
      break;
    case (game.settings.get("autoanimations", "EnableCriticalMiss") && fumble):
      token = canvas.tokens.get(workflow.tokenId);
      new Sequence({ moduleName: "Automated Animations", softFail: !game.settings.get("autoanimations", "debug") }).effect().file(critMissAnim).atLocation(token).play();
      break;
  }
}
const aaSw5e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$n
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$m() {
  Hooks.on("DL.Action", async (data2) => {
    const eventType = data2.type;
    let compiledData = await getRequiredData({
      itemId: data2.itemId,
      token: data2.sourceToken,
      targets: Array.isArray(data2.targets) ? data2.targets : Array.from(data2.targets),
      hitTargets: data2.hitTargets ? Array.isArray(data2.hitTargets) ? data2.hitTargets : Array.from(data2.hitTargets) : data2.targets ? Array.isArray(data2.targets) ? data2.targets : Array.from(data2.targets) : [],
      workflow: data2
    });
    if (!compiledData.item) {
      return;
    }
    if (game.settings.get("autoanimations", "playtrigger") === "hits") {
      targets = hitTargets;
    }
    const canRunAnimations = () => {
      const commonEventTypes = ["apply-healing"];
      if (!compiledData.item?.hasDamage() && !compiledData.item?.hasHealing()) {
        return true;
      }
      if (game.settings.get("autoanimations", "playtrigger") === "rolldamage") {
        return commonEventTypes.concat(["roll-damage"]).includes(eventType);
      }
      if (game.settings.get("autoanimations", "playtrigger") === "applydamage") {
        return commonEventTypes.concat(["apply-damage"]).includes(eventType);
      }
      return commonEventTypes.concat(["roll-attack"]).includes(eventType);
    };
    if (eventType && !canRunAnimations()) {
      return {};
    }
    runDemonlord(compiledData);
  });
}
async function runDemonlord(data2) {
  const handler = await AAHandler.make(data2);
  trafficCop$1(handler);
}
const aaDemonlord = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$m
}, Symbol.toStringTag, { value: "Module" }));
const PF2E_SIZE_TO_REACH = {
  tiny: 0,
  sm: 5,
  med: 5,
  lg: 5,
  huge: 10,
  grg: 15
};
function systemHooks$l() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id) {
      return;
    }
    const playOnDmg = game.settings.get("autoanimations", "playonDamageCore");
    let compiledData = await getRequiredData({
      item: msg.item,
      itemId: msg.flags.pf2e?.origin?.uuid,
      token: msg.token?.object,
      tokenId: msg.speaker?.token,
      actorId: msg.speaker?.actor,
      workflow: msg,
      playOnDamage: playOnDmg,
      bypassTemplates: true
    });
    if (compiledData.item?.type === "effect" || compiledData.item?.type === "condition") {
      debug$1("This is a Condition or Effect, exiting main workflow");
      return;
    }
    if (!compiledData.item) {
      debug$1("No Item Found, exiting main Workflow");
      return;
    }
    compiledData.hitTargets = checkOutcome(compiledData);
    runPF2e(compiledData);
  });
  Hooks.on("createMeasuredTemplate", async (template, data2, userId) => {
    if (userId !== game.user.id) {
      return;
    }
    let compiledData = await getRequiredData({
      itemUuid: template.flags?.pf2e?.origin?.uuid,
      templateData: template,
      workflow: template,
      isTemplate: true
    });
    if (template.item)
      compiledData.item = template.item;
    templateAnimation$4(compiledData);
  });
}
async function templateAnimation$4(input) {
  debug$1("Template placed, checking for animations");
  if (!input.item) {
    debug$1("No Item could be found");
    return;
  }
  if (isNewerVersion(game.system.version, "5")) {
    if (input.item.isVariant) {
      input.isVariant = true;
      input.originalItem = input.item.original;
    }
  } else {
    const templateName = input.templateData.flags?.pf2e?.origin?.name;
    if (templateName && input.item.name !== templateName) {
      const overlayId = input.item.overlays.find((o) => o.name == templateName)?._id;
      if (overlayId) {
        input.item = input.item.loadVariant({ overlayIds: [overlayId] });
        input.isVariant = true;
        input.originalItem = input.item?.original;
      }
    }
  }
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
async function runPF2e(data2) {
  const itemType = data2.item.type;
  switch (itemType) {
    case "effect":
    case "condition":
      debug$1("This is an Effect or Condition, exiting main workflow in deference to Active Effects");
      break;
    case "spell":
      runPF2eSpells(data2);
      break;
    case "weapon":
      if (!data2.workflow.isRoll) {
        return;
      }
      runPF2eWeapons(data2);
      break;
    case "consumable":
      playPF2e(data2);
      break;
    default:
      if (data2.item?.type === "feat" || data2.item.type === "action") {
        let hasAOE = await checkFeatForAOE(data2);
        if (hasAOE) {
          playPF2e(data2);
          return;
        }
      }
      let hasDamage = itemHasDamage(data2.item);
      if (hasDamage && data2.playOnDamage && data2.workflow.isDamageRoll) {
        playPF2e(data2);
      } else if (!hasDamage && !data2.workflow.isDamageRoll) {
        playPF2e(data2);
      } else if (hasDamage && !data2.playOnDamage && !data2.workflow.isDamageRoll) {
        playPF2e(data2);
      }
  }
}
async function checkFeatForAOE(data2) {
  return data2.item?.system?.description?.value?.includes("@Template");
}
function runPF2eWeapons(data2) {
  const playOnDamage = data2.playOnDamage;
  const msg = data2.workflow;
  const isAttackRoll = msg.flags.pf2e?.context?.type?.includes("attack");
  data2.extraNames = [];
  if (data2.item.type === "weapon") {
    const baseType = game.i18n.localize(CONFIG.PF2E.baseWeaponTypes[data2.item.baseType]);
    const group = game.i18n.localize(CONFIG.PF2E.weaponGroups[data2.item.group]);
    data2.extraNames.push(baseType, group);
  }
  if (playOnDamage && msg.isDamageRoll) {
    playPF2e(data2);
  } else if (!playOnDamage && isAttackRoll) {
    playPF2e(data2);
  }
}
async function runPF2eSpells(data2) {
  const msg = data2.workflow;
  const item2 = data2.item;
  const playOnDamage = data2.playOnDamage;
  msg.isDamageRoll;
  spellHasAttack(item2);
  const spellType = getSpellType(item2);
  if (item2.isVariant) {
    data2.isVariant = true;
    data2.originalItem = item2.original;
  }
  switch (spellType) {
    case "utility":
    case "save":
      if (spellHasAOE(item2)) {
        return;
      }
      if (itemHasDamage(item2) && msg.isDamageRoll) {
        playPF2e(data2);
      } else if (!itemHasDamage(item2)) {
        playPF2e(data2);
      }
      break;
    case "attack":
      if (!msg.isRoll) {
        return;
      }
      if (playOnDamage && msg.isDamageRoll) {
        playPF2e(data2);
      } else if (!playOnDamage && !msg.isDamageRoll) {
        playPF2e(data2);
      } else if (!itemHasDamage(item2) && !msg.isDamageRoll) {
        playPF2e(data2);
      }
      break;
    case "heal":
      if (msg.isDamageRoll) {
        playPF2e(data2);
      }
      break;
  }
}
async function playPF2e(input) {
  if (!input.item) {
    debug$1("No Item could be found");
    return;
  }
  if (input.item.traits) {
    const reachTrait = input.item.traits.find((t) => /^reach-\d+$/.test(t));
    let reachValue = reachTrait ? Number(reachTrait.replace("reach-", "")) : PF2E_SIZE_TO_REACH[input.item.actor?.size ?? "med"];
    if (!reachTrait && input.item.traits.has("reach")) {
      reachValue += 5;
    }
    input.reach = Math.round(reachValue / 5) - 1;
  }
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
function getSpellType(item2) {
  return item2.system.spellType?.value;
}
function spellHasAttack(item2) {
  return getSpellType(item2) === "attack";
}
function spellHasAOE(item2) {
  return item2.system.area?.value && item2.system.area?.type;
}
function itemHasDamage(item2) {
  let damage2 = item2.system?.damage?.value || item2.system?.damageRolls || {};
  return Object.keys(damage2).length;
}
function checkOutcome(input) {
  let outcome = input.workflow.flags?.pf2e?.context?.outcome;
  outcome = outcome ? outcome.toLowerCase() : "";
  let hitTargets2;
  if (input.targets.length < 2 && !game.settings.get("autoanimations", "playonDamageCore") && outcome) {
    if (outcome === "success" || outcome === "criticalsuccess") {
      hitTargets2 = input.targets;
    } else {
      hitTargets2 = false;
    }
  } else {
    hitTargets2 = input.targets;
  }
  return hitTargets2;
}
const aaPf2e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$l
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$k() {
  Hooks.on("createChatMessage", async (msg) => {
    function extractItemId(content) {
      try {
        return $(content).attr("data-item-id");
      } catch (exception) {
        console.log("COULD NOT GET ITEM ID");
        return null;
      }
    }
    const itemId = extractItemId(msg.content);
    if (!itemId) {
      return;
    }
    const tokenId = msg.speaker.token;
    const sourceToken = canvas.tokens.get(tokenId) || canvas.tokens.placeables.find((token) => token.actor?.items?.get(itemId));
    if (!sourceToken) {
      return;
    }
    const item2 = sourceToken.actor?.items?.get(itemId);
    if (item2.type === "feat") {
      return;
    }
    if (!item2.hasAttack && !item2.hasDamage) {
      let findData = funkyTest$1(msg);
      let compiledData = await getRequiredData({ itemId: findData.itemId, tokenId: findData.tokenId, actorId: findData.actorId, workflow: msg });
      runStarfinder(compiledData);
    }
  });
  Hooks.on("damageRolled", async (data2) => {
    if (!game.settings.get("autoanimations", "playonDamage") && data2.item?.hasAttack) {
      return;
    }
    Hooks.once("createChatMessage", async (msg) => {
      if (msg.user.id !== game.user.id) {
        return;
      }
      let compiledData = await getRequiredData({ item: data2.item, tokenId: msg.speaker.token, actorId: msg.speaker.actor, workflow: data2 });
      runStarfinder(compiledData);
    });
  });
  Hooks.on("attackRolled", async (data2) => {
    if (game.settings.get("autoanimations", "playonDamage") && data2.item?.hasDamage) {
      return;
    }
    Hooks.once("createChatMessage", async (msg) => {
      if (msg.user.id !== game.user.id) {
        return;
      }
      let compiledData = await getRequiredData({ item: data2.item, tokenId: msg.speaker.token, actorId: msg.speaker.actor, workflow: data2 });
      runStarfinder(compiledData);
    });
  });
}
async function runStarfinder(data2) {
  if (!data2.item) {
    return;
  }
  const handler = await AAHandler.make(data2);
  trafficCop$1(handler);
}
function funkyTest$1(msg) {
  let filterItemId = $(msg.content).filter(`[data-item-id]`);
  let itemId = filterItemId?.[0]?.attributes?.["data-item-id"]?.value || filterItemId?.prevObject?.[0]?.attributes?.["data-item-id"]?.value;
  if (!itemId) {
    const systemId = game.system.id;
    let flags = msg.flags;
    itemId = flags.itemId ?? flags.ItemId ?? flags[systemId]?.itemId ?? flags[systemId]?.ItemId ?? msg.rolls?.[0]?.options?.itemId;
  }
  let filterTokenId = $(msg.content).filter(`[data-token-id]`);
  let tokenId = filterTokenId?.[0]?.attributes?.["data-token-id"]?.value || filterTokenId?.prevObject?.[0]?.attributes?.["data-token-id"]?.value;
  let splitTokenId = tokenId?.split(".");
  if (splitTokenId?.length > 1) {
    tokenId = splitTokenId[splitTokenId.length - 1];
  }
  let filterActorId = $(msg.content).filter(`[data-actor-id]`);
  let actorId = filterActorId?.[0]?.attributes?.["data-actor-id"]?.value || filterActorId?.prevObject?.[0]?.attributes?.["data-actor-id"]?.value;
  return { itemId, tokenId, actorId };
}
const aaSfrpg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$k
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$j() {
  Hooks.on("swadeAction", async (SwadeTokenOrActor, SwadeItem, SwadeAction, SwadeRoll, userId) => {
    if (!SwadeRoll) {
      return;
    }
    const playtrigger = game.settings.get("autoanimations", "playtrigger");
    if (SwadeAction === "damage" && playtrigger === "onDamage" || SwadeAction === "formula" && playtrigger === "onAttack") {
      const controlledTokens = canvas.tokens.controlled;
      let token;
      if (controlledTokens.length > 0) {
        token = controlledTokens.find((token2) => token2.document.actorId === SwadeTokenOrActor.id);
      }
      if (token) {
        SwadeTokenOrActor = token;
      }
      runSwade(SwadeTokenOrActor, SwadeTokenOrActor, SwadeItem);
    }
  });
  Hooks.on("swadeConsumeItem", async (SwadeItem, charges, usage) => {
    const controlledTokens = canvas.tokens.controlled;
    let token;
    let SwadeTokenOrActor = SwadeItem.parent;
    if (controlledTokens.length > 0) {
      token = controlledTokens.find((token2) => token2.document.actorId === SwadeTokenOrActor.id);
    }
    if (token) {
      SwadeTokenOrActor = token;
    }
    runSwade(SwadeTokenOrActor, SwadeTokenOrActor, SwadeItem);
  });
  Hooks.on("createMeasuredTemplate", async (template, data2, userId) => {
    if (userId !== game.user.id || !template.flags?.swade?.origin)
      return;
    templateAnimation$3(await getRequiredData({ itemUuid: template.flags?.swade?.origin, templateData: template, workflow: template, isTemplate: true }));
  });
  async function get_brsw_data(data2) {
    return { token: data2.token, actor: data2.actor, item: data2.item };
  }
  Hooks.on("BRSW-RollItem", async (data2, html) => {
    const { token, actor, item: item2 } = await get_brsw_data(data2);
    if (item2.flags?.autoanimations?.menu === "templatefx" || item2.flags?.autoanimations?.menu === "preset" && item2.flags?.autoanimations?.presetType === "proToTemp") {
      return;
    } else {
      runSwade(token, actor, item2);
    }
  });
  Hooks.on("BRSW-BeforePreviewingTemplate", async (template, data2, ev) => {
    const { token, actor, item: item2 } = await get_brsw_data(data2);
    runSwade(token, actor, item2);
  });
  Hooks.on("BRSW-CreateItemCardNoRoll", async (data2) => {
    const { token, actor, item: item2 } = await get_brsw_data(data2);
    if (item2.flags?.autoanimations?.menu === "templatefx" || item2.flags?.autoanimations?.menu === "preset" && item2.flags?.autoanimations?.presetType === "proToTemp") {
      return;
    } else {
      runSwade(token, actor, item2);
    }
  });
}
async function templateAnimation$3(input) {
  debug$1("Template placed, checking for animations");
  if (!input.item) {
    debug$1("No Item could be found");
    return;
  }
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
async function runSwade(token, actor, item2) {
  let data2 = await getRequiredData({ token, actor, item: item2 });
  if (!data2.item) {
    return;
  }
  const handler = await AAHandler.make(data2);
  trafficCop$1(handler);
}
const aaSwade = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$j
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$i() {
  Hooks.on("wfrp4e:rollWeaponTest", async (data2, info) => {
    if (game.user.id !== info.user) {
      return;
    }
    let compiledData = await getRequiredData({
      item: data2.weapon,
      targets: compileTargets(data2.context?.targets),
      tokenId: info.speaker?.token,
      actorId: info.speaker?.actor,
      workflow: data2
    });
    compiledData.targets = data2.context?.targets ? Array.from(data2.context?.targets).map((token) => canvas.tokens.get(token.token)) : [];
    runWarhammer(compiledData);
  });
  Hooks.on("wfrp4e:rollPrayerTest", async (data2, info) => {
    if (data2.result.outcome != "success" && game.settings.get("autoanimations", "castOnlyOnSuccess")) {
      return;
    }
    let compiledData = await getRequiredData({
      item: data2.prayer,
      targets: compileTargets(data2.context?.targets),
      tokenId: info.speaker?.token,
      actorId: info.speaker?.actor,
      workflow: data2
    });
    runWarhammer(compiledData);
  });
  Hooks.on("wfrp4e:rollCastTest", async (data2, info) => {
    if (game.user.id !== info.user) {
      return;
    }
    if (data2.result.castOutcome != "success" && game.settings.get("autoanimations", "castOnlyOnSuccess")) {
      return;
    }
    let compiledData = await getRequiredData({
      item: data2.spell,
      targets: compileTargets(data2.context?.targets),
      tokenId: info.speaker?.token,
      actorId: info.speaker?.actor,
      workflow: data2
    });
    runWarhammer(compiledData);
  });
  Hooks.on("wfrp4e:rollTraitTest", async (data2, info) => {
    if (game.user.id !== info.user) {
      return;
    }
    let compiledData = await getRequiredData({
      item: data2.trait,
      targets: compileTargets(data2.context?.targets),
      tokenId: info.speaker?.token,
      actorId: info.speaker?.actor,
      workflow: data2
    });
    runWarhammer(compiledData);
  });
  Hooks.on("wfrp4e:rollTest", async (data2, info) => {
    if (game.user.id !== info.user) {
      return;
    }
    if (data2.result.outcome != "success" && game.settings.get("autoanimations", "castOnlyOnSuccess")) {
      return;
    }
    if (!data2.skill) {
      return;
    }
    let compiledData = await getRequiredData({
      item: data2.skill,
      targets: compileTargets(data2.context?.targets),
      tokenId: info.speaker?.token,
      actorId: info.speaker?.actor,
      workflow: data2
    });
    runWarhammer(compiledData);
  });
  Hooks.on("createMeasuredTemplate", async (template, data2, userId) => {
    if (userId !== game.user.id) {
      return;
    }
    if (!template.flags?.wfrp4e?.itemuuid) {
      return;
    }
    const uuid = template.flags.wfrp4e.itemuuid;
    templateAnimation$2(await getRequiredData({ itemUuid: uuid, templateData: template, workflow: template, isTemplate: true }));
  });
}
async function runWarhammer(data2) {
  if (!data2.item) {
    return;
  }
  const handler = await AAHandler.make(data2);
  trafficCop$1(handler);
}
function compileTargets(targets2) {
  if (!targets2) {
    return [];
  }
  return Array.from(targets2).map((token) => canvas.tokens.get(token.token));
}
async function templateAnimation$2(input) {
  debug$1("Template placed, checking for animations");
  if (!input.item) {
    debug$1("No Item could be found");
    return;
  }
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
const aaWfrpg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$i
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$h() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id) {
      return;
    }
    let compiledData = await getRequiredData({
      itemId: msg.flags?.dcc?.ItemId,
      actorId: msg.speaker?.actor,
      tokenId: msg.speaker?.token,
      workflow: msg
    });
    runDcc(compiledData);
  });
}
async function runDcc(input) {
  if (!game.settings.get("dcc", "useStandardDiceRoller")) {
    const handler = await AAHandler.make(input);
    trafficCop$1(handler);
  } else if (input.flags?.dcc?.RollType === "Damage" || input.flags?.dcc?.RollType === "SpellCheck") {
    const handler = await AAHandler.make(input);
    trafficCop$1(handler);
  }
}
const aaDcc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$h
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$g() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id) {
      return;
    }
    const actionId = msg.getFlag("pf1", "metadata")?.action;
    const chatName = $(msg.content).find(".item-name")?.text() ?? "";
    const itemFromChat = msg.itemSource;
    if (!itemFromChat) {
      return;
    }
    const item2 = itemFromChat.toObject();
    if (item2 && actionId) {
      const actionName = item2.actions?.get(actionId)?.name ?? "";
      item2.name = `${item2.name} ${actionName}`;
    } else if (item2 && chatName && chatName.includes(item2.name)) {
      item2.name = chatName;
    }
    const tokenId = msg.speaker?.token;
    const actorId = msg.speaker?.actor;
    runPF1({ item: item2, tokenId, actorId, workflow: msg });
  });
}
async function runPF1(input) {
  const requiredData = await getRequiredData(input);
  if (!requiredData.item) {
    return;
  }
  const handler = await AAHandler.make(requiredData);
  trafficCop$1(handler);
}
const aaPf1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$g
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$f() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id) {
      return;
    }
    const item2 = await fromUuid(msg.flags?.a5e?.itemId);
    const compiledData = await getRequiredData({
      item: item2,
      itemUuid: msg.flags?.a5e?.itemId,
      actorId: msg.speaker?.actorId,
      tokenId: msg.speaker?.token,
      workflow: msg
    });
    runA5e$1(compiledData);
  });
  Hooks.on("a5e.templateCreated", async (item2, templateData, userId) => {
    if (userId !== game.user.id)
      return;
    const compiledData = await getRequiredData({
      item: item2,
      templateData: templateData?.[0],
      workflow: templateData?.[0],
      isTemplate: true
    });
    runA5e$1(compiledData);
  });
}
async function runA5e$1(input) {
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
const aaA5e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$f
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$e() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id) {
      return;
    }
    let compiledData = await getRequiredData({
      itemId: msg.rolls[0].options?.itemId,
      actorId: msg.speaker?.actor,
      tokenId: msg.speaker?.token,
      workflow: msg
    });
    if (!compiledData.item) {
      return;
    }
    runA5e(compiledData);
  });
}
async function runA5e(input) {
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
const aaForbiddenLands = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$e
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$d() {
  Hooks.on("ffgDiceMessage", async (roll) => {
    let compiledData = await getRequiredData({
      item: roll.data,
      workflow: roll
    });
    if (!compiledData.item) {
      return;
    }
    runStarwarsffg(compiledData);
  });
}
async function runStarwarsffg(input) {
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
const aaStarwarsffg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$d
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$c() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id) {
      return;
    }
    let compiledData = await getRequiredData({
      itemId: msg.flags?.ose?.itemId,
      actorId: msg.speaker?.actor,
      tokenId: msg.speaker?.token,
      workflow: msg
    });
    runOse(compiledData);
  });
}
async function runOse(input) {
  const handler = await AAHandler.make(input);
  if (!handler?.item) {
    return;
  }
  trafficCop$1(handler);
}
const aaOse = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$c
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$b() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id) {
      return;
    }
    function extractItemId(content) {
      try {
        return $(content).attr("data-item-id");
      } catch (exception) {
        console.log("COULD NOT GET ITEM ID");
        return null;
      }
    }
    let compiledData = await getRequiredData({
      itemId: extractItemId(msg.content),
      actorId: msg.speaker?.actor,
      tokenId: msg.speaker?.token,
      workflow: msg
    });
    if (!compiledData.item) {
      return;
    }
    runD35E(compiledData);
  });
}
async function runD35E(input) {
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
const aaD35E = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$b
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$a() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id) {
      return;
    }
    let compiledData = await getRequiredData({
      itemId: msg.flags?.itemID,
      actorId: msg.speaker?.actor,
      tokenId: msg.speaker?.token,
      workflow: msg
    });
    runCypherSystem(compiledData);
  });
}
async function runCypherSystem(input) {
  if (input.itemId == "recovery-roll") {
    if (game.settings.get("autoanimations", "EnableOnRecoveryRoll")) {
      new Sequence().effect().file(game.settings.get("autoanimations", "RecoveryRollAnimation")).atLocation(input.token).play();
    }
  } else {
    const flagdata = input.workflow?.flags?.data;
    const diceRoll = flagdata?.roll?.total;
    if (diceRoll) {
      if (game.settings.get("autoanimations", "EnableCritical") && diceRoll >= 19) {
        new Sequence().effect().file(game.settings.get("autoanimations", "CriticalAnimation")).atLocation(input.token).play();
      } else if (game.settings.get("autoanimations", "EnableFumble") && diceRoll <= flagdata.gmiRange) {
        new Sequence().effect().file(game.settings.get("autoanimations", "FumbleAnimation")).atLocation(input.token).play();
      } else if (flagdata.pool == "Might" && game.settings.get("autoanimations", "EnableOnMightRoll")) {
        new Sequence().effect().file(game.settings.get("autoanimations", "MightRollAnimation")).atLocation(input.token).play();
      } else if (flagdata.pool == "Speed" && game.settings.get("autoanimations", "EnableOnSpeedRoll")) {
        new Sequence().effect().file(game.settings.get("autoanimations", "SpeedRollAnimation")).atLocation(input.token).play();
      } else if (flagdata.pool == "Intellect" && game.settings.get("autoanimations", "EnableOnIntellecRoll")) {
        new Sequence().effect().file(game.settings.get("autoanimations", "IntellectRollAnimation")).atLocation(input.token).play();
      }
    }
    if (input.item) {
      trafficCop$1(await AAHandler.make(input));
    }
  }
}
const aaCyphersystem = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$a
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$9() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id) {
      return;
    }
    function extractItemId(content) {
      try {
        return $(content).attr("data-item-id");
      } catch (exception) {
        console.log("COULD NOT GET ITEM ID");
        return null;
      }
    }
    let compiledData = await getRequiredData({
      itemId: extractItemId(msg.content),
      actorId: msg.speaker?.actor,
      tokenId: msg.speaker?.token,
      workflow: msg
    });
    if (!compiledData.item) {
      return;
    }
    runAlienRPG(compiledData);
  });
}
async function runAlienRPG(input) {
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
const aaAlienrpg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$9
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$8() {
  Hooks.on("createChatMessage", async (msg) => {
    checkChatMessage$2(msg);
  });
}
async function checkChatMessage$2(msg) {
  if (msg.user.id !== game.user.id) {
    return;
  }
  let findData = extactData(msg);
  if (!findData.itemId) {
    debug$1("Could not extract Item ID from Chat Message HTML");
    return;
  }
  let compiledData = await getRequiredData({
    itemId: findData.itemId,
    actorId: msg.speaker?.actor || findData.actorId,
    tokenId: msg.speaker?.token || findData.tokenId,
    workflow: msg
  });
  compiledData.attackRoll = findData.attackRoll;
  await setFireModeOptions(compiledData);
  let isAmmo = checkAmmo(compiledData);
  if (isAmmo) {
    compiledData.ammoItem = isAmmo;
  }
  const handler = await AAHandler.make(compiledData);
  if (!handler?.item || !handler?.sourceToken) {
    debug$1("No Item or Source Token", handler);
    return;
  }
  trafficCop$1(handler);
}
function getFireMode(data2) {
  let item2 = data2.item || {};
  let id = item2.id;
  let parent = item2.parent;
  let fireMode = parent?.flags?.["cyberpunk-red-core"]?.[`firetype-${id}`] ?? "single";
  data2.fireMode = fireMode;
  return fireMode;
}
async function setFireModeOptions(data2) {
  const fireMode = getFireMode(data2);
  let canMissTarget = game.settings.get("autoanimations", "canMissTarget");
  let isSuppressive = fireMode === "suppressive";
  if (!isSuppressive && canMissTarget && data2?.targets?.length) {
    data2.forceMiss = !await isHit(data2);
  }
  let autofireEnabled = game.settings.get("autoanimations", "autofire");
  if (autofireEnabled && ["suppressive", "autofire"].includes(fireMode)) {
    if (isSuppressive)
      data2.forceMiss = true;
    data2.overrideRepeat = 10;
  }
}
function checkAmmo(data2) {
  let item2 = data2.item || {};
  let token = data2.token;
  let ammoId = item2.system?.magazine?.ammoId?.split(".") ?? "";
  if (ammoId === "" || ammoId.length === 1 && ammoId[0] === "")
    ammoId = item2.system?.magazine?.ammoData?.uuid?.split(".");
  let ammoItem;
  if (ammoId) {
    let trueId = ammoId[ammoId.length - 1];
    ammoItem = token.actor?.items?.get(trueId);
  }
  return ammoItem;
}
function extactData(msg) {
  let findItemId = $(msg.content).find(`[data-item-id]`);
  let itemId = findItemId?.[0]?.attributes?.["data-item-id"]?.value;
  let findTokenId = $(msg.content).find(`[data-token-id]`);
  let tokenId = findTokenId?.[0]?.attributes?.["data-token-id"]?.value;
  let findActorId = $(msg.content).find(`[data-actor-id]`);
  let actorId = findActorId?.[0]?.attributes?.["data-actor-id"]?.value;
  let findAttackRoll = $(msg.content).find(
    `span.clickable[data-action='toggleVisibility']`
  );
  let attackRoll = parseInt(findAttackRoll?.[0]?.innerHTML ?? 999);
  return { itemId, tokenId, actorId, attackRoll };
}
function getDistance(token, target2) {
  if (token.document)
    token = token.document;
  const a = canvas.grid.measureDistance(token, target2, {
    gridSpaces: true
  });
  if (!game.settings.get("autoanimations", "useElevation"))
    return a;
  const b = token.elevation - target2.document.elevation;
  return Math.round(Math.sqrt(a * a + b * b));
}
async function getDV(dvTable, dist) {
  let pack = game.packs.get("cyberpunk-red-core.dv-tables");
  if (!pack) {
    pack = game.packs.get("cyberpunk-red-core.dvTables");
  }
  const tableId = pack.index.getName(dvTable)?._id;
  if (!tableId) {
    debug$1(`Could not get table with name "${dvTable}" from compendium`);
    return -100;
  }
  const table = await pack.getDocument(tableId);
  if (!table) {
    debug$1(
      `Could not get table with id "${tableId}" and name "${dvTable}" from compendium`
    );
    return -100;
  }
  const draw = await table.getResultsForRoll(dist);
  if (!draw || draw.length === 0) {
    debug$1(`Could not roll DV from table "${dvTable}"`);
    return -100;
  }
  return parseInt(draw[0].text);
}
async function isHit(data2) {
  let distance = getDistance(data2.token, data2.targets[0]);
  let dvTable = data2.item?.system?.dvTable ?? "";
  let dv;
  if (data2.fireMode === "autofire") {
    dv = await getDV(dvTable + " (Autofire)", distance);
    if (!dv || dv < 0) {
      dv = await getDV(dvTable, distance);
    }
  } else {
    dv = await getDV(dvTable, distance);
  }
  if (!dv || dv < 0)
    return true;
  debug$1(`Was this roll a hit: ${data2.attackRoll > dv}`);
  return data2.attackRoll > dv;
}
const aaCyberpunkred = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$8
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$7() {
  Hooks.on("createChatMessage", async (msg) => {
    checkMessage(msg);
  });
}
async function checkMessage(msg) {
  if (msg.user.id !== game.user.id) {
    return;
  }
  let compiledData = await getRequiredData({
    item: msg.flags?.item,
    spell: msg.flags?.spell,
    attackSkill: msg.flags?.attackSkill,
    damage: msg.flags?.damage,
    actorId: msg.speaker?.actor,
    tokenId: msg.speaker?.token,
    sceneId: msg.speaker?.scene,
    alias: msg.speaker?.alias,
    extraNames: [],
    workflow: msg
  });
  let attackSkillEnabled = game.settings.get("autoanimations", "attackSkill");
  let damageEnabled = game.settings.get("autoanimations", "damage");
  let spellEnabled = game.settings.get("autoanimations", "spell");
  if (!attackSkillEnabled && !damageEnabled && !spellEnabled) {
    return null;
  }
  if (compiledData.attackSkill && attackSkillEnabled) {
    compiledData.extraNames.push(compiledData.attackSkill);
  }
  if (compiledData.attackSkill && attackSkillEnabled)
    ;
  else if (compiledData.spell && spellEnabled) {
    compiledData.item = compiledData.spell;
  } else if (damageEnabled) {
    compiledData.item = { name: compiledData.damage ? "damage" : "no-damage" };
    compiledData.extraNames.push(compiledData.damage ? "damage" : "no-damage");
  } else {
    return null;
  }
  const handler = await AAHandler.make(compiledData);
  trafficCop$1(handler);
}
const aaTheWitcherTRPG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$7
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$6() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id) {
      return;
    }
    const flags = msg.flags?.twodsix ?? {};
    const itemUuid = flags.itemUUID;
    const tokenUuid = flags.tokenUUID;
    const actorUuid = flags.actorUUID;
    const rollClass = flags.rollClass;
    routeMessage$1({ itemUuid, tokenUuid, actorUuid, workflow: msg, rollClass });
  });
}
async function routeMessage$1(input) {
  const requiredData = await getRequiredData(input);
  if (!requiredData.item) {
    return;
  }
  const hasDamage = requiredData.item.system?.damage ? true : false;
  const playtrigger = game.settings.get("autoanimations", "playtrigger");
  if (!hasDamage || playtrigger === "onAttack" && input.rollClass !== "Damage") {
    runTwoDSix(requiredData);
    return;
  }
  if (hasDamage && input.rollClass === "Damage" && playtrigger === "onDamage") {
    runTwoDSix(requiredData);
    return;
  }
}
async function runTwoDSix(data2) {
  const handler = await AAHandler.make(data2);
  trafficCop$1(handler);
}
const aaTwodsix = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$6
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$5() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id || !AnimationState.enabled) {
      return;
    }
    if (msg.getFlag("od6s", "type") === "damage") {
      return;
    }
    let tokenId = "";
    let actorId = "";
    if (msg.getFlag("od6s", "vehicle") && msg.getFlag("od6s", "vehicle") !== "") {
      const document2 = await fromUuid(msg.getFlag("od6s", "vehicle"));
      if (document2.documentName === "Token") {
        tokenId = document2.id;
        const actor = game.scenes.viewed.tokens.filter((t) => t.id === document2.id)[0].actor;
        actorId = actor.id;
      } else {
        tokenId = msg.speaker?.token;
        actorId = msg.speaker?.actor;
      }
    } else {
      tokenId = msg.speaker?.token === null ? "" : msg.speaker?.token;
      actorId = msg.speaker?.actor;
    }
    let compiledData = await getRequiredData({
      itemId: msg.flags?.od6s?.itemId,
      actorId,
      tokenId,
      workflow: msg
    });
    runOd6s(compiledData);
  });
}
async function runOd6s(input) {
  const handler = await AAHandler.make(input);
  if (!handler) {
    return;
  }
  trafficCop$1(handler);
}
const aaOd6s = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$5
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$4() {
  Hooks.on("createChatMessage", async (msg) => {
    checkChatMessage$1(msg);
  });
}
async function checkChatMessage$1(msg) {
  if (msg.user.id !== game.user.id) {
    return;
  }
  let findData = funkyTest(msg);
  if (!findData.itemId) {
    debug$1("Unable to locate Item ID from Chat Message HTML");
    return;
  }
  let item2 = msg.item ?? msg.itemSource;
  let compiledData = await getRequiredData({
    itemId: findData.itemId,
    item: item2,
    actorId: msg.speaker?.actor || findData.actorId,
    tokenId: msg.speaker?.token || findData.tokenId,
    workflow: msg
  });
  const handler = await AAHandler.make(compiledData);
  if (!handler?.item || !handler?.sourceToken) {
    debug$1("No Item or Source Token", handler);
    return;
  }
  trafficCop$1(handler);
}
function funkyTest(msg) {
  let filterItemId = $(msg.content).filter(`[data-item-id]`);
  let itemId = filterItemId?.[0]?.attributes?.["data-item-id"]?.value || filterItemId?.prevObject?.[0]?.attributes?.["data-item-id"]?.value;
  if (!itemId) {
    const systemId = game.system.id;
    let flags = msg.flags;
    itemId = flags.itemId ?? flags.ItemId ?? flags[systemId]?.itemId ?? flags[systemId]?.ItemId ?? msg.rolls?.[0]?.options?.itemId;
  }
  let filterTokenId = $(msg.content).filter(`[data-token-id]`);
  let tokenId = filterTokenId?.[0]?.attributes?.["data-token-id"]?.value || filterTokenId?.prevObject?.[0]?.attributes?.["data-token-id"]?.value;
  let filterActorId = $(msg.content).filter(`[data-actor-id]`);
  let actorId = filterActorId?.[0]?.attributes?.["data-actor-id"]?.value || filterActorId?.prevObject?.[0]?.attributes?.["data-actor-id"]?.value;
  return { itemId, tokenId, actorId };
}
const aaChatmessage = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$4
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$3() {
  Hooks.on("createChatMessage", async (msg) => {
    if (msg.user.id !== game.user.id) {
      return;
    }
    const flags = msg.flags?.["dark-heresy"] ?? {};
    const itemId = flags.rollData.itemId;
    const tokenId = flags.rollData.tokenId;
    const actorId = flags.rollData.ownerId;
    const rollClass = flags.rollData.rollObject.class;
    routeMessage({ itemId, tokenId, actorId, workflow: msg, rollClass });
  });
  Hooks.on("AutomatedAnimations-WorkflowStart", onWorkflowStart);
  Hooks.on("createMeasuredTemplate", async (template, data2, userId) => {
    if (userId !== game.user.id) {
      return;
    }
    templateAnimation$1(await getRequiredData({ itemUuid: template.flags?.["dark-heresy"]?.origin, templateData: template, workflow: template, isTemplate: true }));
  });
}
async function routeMessage(input) {
  const requiredData = await getRequiredData(input);
  if (!requiredData.item) {
    return;
  }
  runDarkHeresy(requiredData);
}
async function runDarkHeresy(data2) {
  const handler = await AAHandler.make(data2);
  trafficCop$1(handler);
}
function onWorkflowStart(clonedData, animationData) {
  if (animationData.primary != null && clonedData.workflow.flags["dark-heresy"].rollData.maxAdditionalHit != null) {
    animationData.primary.options.repeat = 1 + clonedData.workflow.flags["dark-heresy"].rollData.maxAdditionalHit;
  }
}
async function templateAnimation$1(input) {
  if (!input.item) {
    return;
  }
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
const aaDarkheresy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$3
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$2() {
  Hooks.on("createChatMessage", async (msg) => {
    checkChatMessage(msg);
  });
}
const TEST = {
  Melee: "MeleeAttackTest",
  Thrown: "ThrownAttackTest",
  Range: "RangedAttackTest",
  Defense: "PhysicalDefenseTest",
  Spell: "SpellCastingTest",
  Drain: "DrainTest",
  Skill: "SkillTest"
};
async function checkChatMessage(msg) {
  if (msg.user.id !== game.user.id || !AnimationState.enabled) {
    return;
  }
  const test = await game.shadowrun5e?.test?.fromMessage(msg.id);
  if (!test) {
    return;
  }
  const compiledData = await computeCompiledData(msg, test);
  if (!compiledData) {
    return;
  }
  if (await tryAnnimationWith(compiledData)) {
    return;
  }
  switch (test.type) {
    case TEST.Spell:
      const category = compiledData.item?.system?.category;
      if (category && await tryAnnimationWith(compiledData, category)) {
        return;
      }
      break;
  }
  const skill = compiledData.item?.getActionSkill();
  if (skill && await tryAnnimationWith(compiledData, skill)) {
    return;
  }
}
async function computeCompiledData(msg, test) {
  let item2;
  switch (test.type) {
    case TEST.Skill:
      item2 = {
        name: test.data?.action?.skill
      };
      break;
    case TEST.Drain:
      item2 = {
        name: "drain"
      };
      break;
    case TEST.Defense:
      return;
    default:
      const itemUuid = test.data.sourceItemUuid;
      item2 = await fromUuid(itemUuid);
      if (!item2) {
        return;
      }
  }
  const compiledData = await getRequiredData({
    item: item2,
    actorId: msg.speaker?.actor,
    tokenId: msg.speaker?.token,
    workflow: msg
  });
  if (!compiledData) {
    return;
  }
  if (test.type == TEST.Range) {
    const message = game.messages.get(msg.id);
    const bulletCount = message.flags?.shadowrun5e?.TestData?.data?.fireMode?.value;
    if (bulletCount && bulletCount > 1) {
      compiledData.overrideRepeat = bulletCount;
    }
  }
  return compiledData;
}
async function tryAnnimationWith(compiledData, itemNameOverride) {
  if (itemNameOverride) {
    compiledData.item = {
      name: itemNameOverride
    };
  }
  const handler = await AAHandler.make(compiledData);
  if (handler?.item && handler.sourceToken) {
    trafficCop$1(handler);
    return true;
  }
  return;
}
const aaShadowrun5e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$2
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks$1() {
  Hooks.on("ds4.rollItem", async (data2) => {
    let compiledData = await getRequiredData({
      itemId: data2.id,
      actorId: data2.actor,
      workflow: data2
    });
    runDs4(compiledData);
  });
}
async function runDs4(input) {
  const handler = await AAHandler.make(input);
  if (!handler) {
    return;
  }
  trafficCop$1(handler);
}
const aaDs4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks: systemHooks$1
}, Symbol.toStringTag, { value: "Module" }));
function systemHooks() {
  Hooks.on("createMeasuredTemplate", async (template, data2, userId) => {
    if (userId !== game.user.id) {
      return;
    }
    const item2 = template.flags?.dnd4e?.item;
    item2.hasAreaTarget = true;
    const shouldPlay = shouldPlayAnimation(item2, "template");
    if (!shouldPlay) {
      return;
    }
    const reqData = await getRequiredData({
      item: item2,
      templateData: template,
      workflow: template,
      isTemplate: true
    });
    templateAnimation(reqData);
  });
  Hooks.on("dnd4e.rollAttack", async (item2, targetData, speakerData) => {
    const shouldPlay = shouldPlayAnimation(item2, "attack");
    if (!shouldPlay) {
      return;
    }
    handleAnimation(
      item2,
      speakerData,
      targetData.targets,
      targetData.targetHit
    );
  });
  Hooks.on("dnd4e.rollDamage", async (item2, speakerData) => {
    const shouldPlay = shouldPlayAnimation(item2, "damage");
    if (!shouldPlay) {
      return;
    }
    const targets2 = Array.from(game.user.targets);
    handleAnimation(item2, speakerData, targets2);
  });
  Hooks.on("dnd4e.rollHealing", async (item2, speakerData) => {
    const shouldPlay = shouldPlayAnimation(item2, "healing");
    if (!shouldPlay) {
      return;
    }
    const targets2 = Array.from(game.user.targets);
    handleAnimation(item2, speakerData, targets2);
  });
  Hooks.on("dnd4e.usePower", async (item2, speakerData) => {
    const shouldPlay = shouldPlayAnimation(item2, "usePower");
    if (!shouldPlay) {
      return;
    }
    const targets2 = Array.from(game.user.targets);
    handleAnimation(item2, speakerData, targets2);
  });
}
function shouldPlayAnimation(item2, hookName) {
  const itemData = item2.system ? item2.system : item2;
  const aaHookToUse = itemData.macro?.autoanimationHook ? itemData.macro.autoanimationHook : false;
  console.log(`should play animation for hook ${hookName}?`);
  if (!aaHookToUse) {
    const defaultHook = getItemDefault(itemData);
    console.log(`using default hook: ${defaultHook}`);
    return defaultHook === hookName;
  } else {
    console.log("has aa hook explicitly set");
    return aaHookToUse === hookName;
  }
}
function hasAreaTarget(itemData) {
  return [
    "closeBurst",
    "closeBlast",
    "rangeBurst",
    "rangeBlast",
    "wall"
  ].includes(itemData.rangeType);
}
function getItemDefault(itemData) {
  if (hasAreaTarget(itemData)) {
    return "template";
  } else if (itemData.attack?.isAttack) {
    return "attack";
  } else if (itemData.hit?.isDamage) {
    return "damage";
  } else if (itemData.hit?.isHealing) {
    return "healing";
  } else {
    return "usePower";
  }
}
async function handleAnimation(item2, speakerData, targets2, hitTargets2 = []) {
  const token = game.scenes.get(speakerData.scene).tokens.get(speakerData.token);
  const workflowData = {
    item: item2,
    token,
    actor: null,
    targets: targets2,
    workflow: item2
  };
  if (hitTargets2.length) {
    workflowData.hitTargets = hitTargets2;
  }
  const handler = await AAHandler.make(workflowData);
  if (!handler?.item || !handler?.sourceToken) {
    debug$1("Automated Animations: No Item or Source Token", handler);
    return;
  }
  trafficCop$1(handler);
}
async function templateAnimation(input) {
  debug$1("Template placed, checking for animations");
  if (!input.item) {
    debug$1("No Item could be found");
    return;
  }
  const handler = await AAHandler.make(input);
  trafficCop$1(handler);
}
const aaDnd4e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  systemHooks
}, Symbol.toStringTag, { value: "Module" }));
const systemSupport = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  D35e: aaD35E,
  TheWitcherTRPG: aaTheWitcherTRPG,
  a5e: aaA5e,
  alienrpg: aaAlienrpg,
  cyberpunkredcore: aaCyberpunkred,
  cyphersystem: aaCyphersystem,
  darkheresy: aaDarkheresy,
  dcc: aaDcc,
  demonlord: aaDemonlord,
  dnd4e: aaDnd4e,
  dnd5e: aaDnd5e,
  ds4: aaDs4,
  forbiddenlands: aaForbiddenLands,
  od6s: aaOd6s,
  ose: aaOse,
  pf1: aaPf1,
  pf2e: aaPf2e,
  sfrpg: aaSfrpg,
  shadowrun5e: aaShadowrun5e,
  standard: aaChatmessage,
  starwarsffg: aaStarwarsffg,
  sw5e: aaSw5e,
  swade: aaSwade,
  twodsix: aaTwodsix,
  wfrp4e: aaWfrpg
}, Symbol.toStringTag, { value: "Module" }));
const newMenuCss = "";
Hooks.once("socketlib.ready", function() {
  setupSocket();
});
let aaDatabase;
Hooks.on("AutomaticAnimations.Open.Menu.New", () => showAutorecMenu());
Hooks.on("AutomaticAnimations.Clear.Data", async () => {
  AAAutorecManager.restoreDefault();
});
function registerAAItemHooks() {
  Hooks.on("getItemSheetHeaderButtons", async (itemSheet, buttons) => {
    if (!game.user.isGM && game.settings.get("autoanimations", "hideFromPlayers")) {
      return;
    }
    let buttonOptions = {
      class: "aaItemSettings",
      icon: "fas fa-biohazard",
      label: "A-A",
      onclick: async () => {
        await flagMigrations.handle(itemSheet.item);
        const pf2eRuleTypes = ["condition", "effect"];
        if (game.system.id === "pf1" && itemSheet.item?.type === "buff" || game.system.id === "pf2e" && pf2eRuleTypes.includes(itemSheet.item?.type)) {
          new AEMenuApp(itemSheet.item, {}).render(true, { focus: true });
        } else {
          new ItemMenuApp(itemSheet.item, {}).render(true, { focus: true });
        }
      }
    };
    buttons.splice(0, 0, buttonOptions);
  });
  Hooks.on("getActiveEffectConfigHeaderButtons", async (aeSheet, buttons) => {
    if (!game.user.isGM && game.settings.get("autoanimations", "hideFromPlayers")) {
      return;
    }
    let buttonOptions = {
      class: "aaItemSettings",
      icon: "fas fa-biohazard",
      label: "A-A",
      onclick: async () => {
        await flagMigrations.handle(aeSheet.document);
        new AEMenuApp(aeSheet.document, {}).render(true, { focus: true });
      }
    };
    buttons.splice(0, 0, buttonOptions);
  });
}
Hooks.on("aa.workflow", async (token, item2, options2) => {
  playAnimation(token, item2, options2);
});
Hooks.on("aa.initialize", async () => {
  const s3Location = game.settings.get("autoanimations", "jb2aLocation");
  const jb2aPatreonFound = game.modules.get("jb2a_patreon");
  const jb2aFreeFound = game.modules.get("JB2A_DnD5e");
  if (game.user.isGM && (!jb2aFreeFound && !jb2aPatreonFound)) {
    if (s3Location && (s3Location.includes("jb2a_patreon") || s3Location.includes("JB2A_DnD5e")))
      ;
    else {
      ui.notifications.error(game.i18n.format("autoanimations.settings.error"));
    }
  }
  initializeAADB();
  if (game.settings.get("autoanimations", "killAllAnim") === "off") {
    AnimationState.enabled = false;
  }
});
Hooks.once("ready", async function() {
  registerAAItemHooks();
  gameSettings.initialize();
  autoRecStores.initialize();
  handleAutorec();
  Hooks.on("deleteItem", async (item2) => {
    storeDeletedItems(item2);
  });
  const systemIdClean = game.system.id.replace(/\-/g, "");
  systemSupport[systemIdClean] ? systemSupport[systemIdClean].systemHooks() : systemHooks$4();
  registerActiveEffectHooks();
  handleTemplates();
  Hooks.callAll("aa.initialize");
});
function storeDeletedItems(item2) {
  aaDeletedItems.set(item2.id, item2);
}
function handleAutorec() {
  let versionCheck = game.settings.get("autoanimations", "aaAutorec").version;
  let currentVersion = Object.keys(autoRecMigration.migrations).map((n) => Number(n)).reverse()[0];
  if (versionCheck < 5) {
    let oldData = game.settings.get("autoanimations", "aaAutorec");
    autoRecMigration.handle(oldData, { shouldSubmit: true, submitAll: true });
  } else if (versionCheck < currentVersion) {
    console.warn("Automated Animations | Updating Global Automatic Recognition Menu");
    autoRecMigration.handle(null, { shouldSubmit: true, submitAll: true, newSchema: true });
  }
}
window.AutoAnimations = AutoAnimations;
window.AutomatedAnimations = {
  AutorecManager: AAAutorecManager,
  playAnimation: (sourceToken, item2, options2 = {}) => playAnimation(sourceToken, item2, options2)
};
function handleTemplates() {
  let templatesGridHidden = game.settings.get("autoanimations", "hideTemplateGrid");
  if (templatesGridHidden === "templateLayer") {
    if (game.modules.get("tokenmagic")?.active && game.settings.get("tokenmagic", "defaultTemplateOnHover"))
      ;
    else {
      removeGridHighlightsOnLoad();
      Hooks.on("canvasReady", async () => {
        removeGridHighlightsOnLoad();
      });
      Hooks.on("createMeasuredTemplate", (template) => {
        canvas.grid.getHighlightLayer(`MeasuredTemplate.${template.id}`).visible = false;
      });
      Hooks.on("hoverMeasuredTemplate", (template, isHovered) => {
        canvas.grid.getHighlightLayer(`MeasuredTemplate.${template.id}`).visible = isHovered;
      });
    }
  }
  if (templatesGridHidden === "full") {
    if (game.modules.get("tokenmagic")?.active && game.settings.get("tokenmagic", "defaultTemplateOnHover"))
      ;
    else {
      removeGridHighlightsOnLoad();
      canvasMouseEvent();
      Hooks.on("createMeasuredTemplate", (template) => {
        canvas.grid.getHighlightLayer(`MeasuredTemplate.${template.id}`) ? canvas.grid.getHighlightLayer(`MeasuredTemplate.${template.id}`).visible = false : "";
      });
      Hooks.on("canvasReady", async () => {
        removeGridHighlightsOnLoad();
        canvasMouseEvent();
      });
    }
  }
  function removeGridHighlightsOnLoad() {
    let highlights = Object.keys(canvas.grid.highlightLayers);
    if (highlights.length) {
      highlights.forEach((e) => {
        if (e.startsWith("MeasuredTemplate")) {
          canvas.grid.getHighlightLayer(e).visible = false;
        }
      });
    }
  }
  function canvasMouseEvent() {
    canvas.stage.on("mousemove", (event) => {
      const { x: templateX, y: templateY } = event.data.getLocalPosition(canvas.templates);
      for (let template of canvas.templates.placeables) {
        const highlight = canvas.grid.getHighlightLayer(`MeasuredTemplate.${template.id}`) ?? {};
        const { x: centerX, y: centerY } = template.center;
        const mouseInTemplate = template?.shape?.contains(templateX - centerX, templateY - centerY);
        highlight.visible = mouseInTemplate;
      }
    });
  }
}
export {
  aaDatabase
};
//# sourceMappingURL=index.js.map
