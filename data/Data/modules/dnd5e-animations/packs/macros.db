{"name":"Melee Attack Advanced","type":"script","scope":"global","author":"ZIFRYb4IqOsDAbYe","img":"icons/svg/dice-target.svg","command":"//Macro created by Gazkhan - Jules\n//Modified by Sisimshow\n\n/*********************\n * STORING VARIABLES \n *********************/\n\nconst gridSize = canvas.grid.size;\nconst scaleFactor = gridSize / 100;\n\nlet source = args[1]?.sourceToken ?? token;\nlet targets = args[1]?.allTargets ?? game.user.targets;\n\n// just in case the user hasn't targetted a token, let's add a quick warning\nif (!targets || targets?.length === 0) {\n    return ui.notifications.warn(\"Please target at least one token\")\n}\n\nconst enableTrail = args[2]?.enableTrail ?? false;\nconst enableImpact = args[2]?.enableImpact ?? false;\nconst enableSound = args[2]?.enableSound ?? false;\nconst enableSwitchDistance = args[2]?.enableSwitchDistance ?? false;\nconst enableReturn = args[2]?.enableReturn ?? false;\nconst enableBlood = args[2]?.enableBlood ?? false;\nconst enableShake = args[2]?.enableShake ?? false;\nconst debug = args[2]?.debug ?? false;\n\nconst weaponGroup = args[2]?.weaponGroup ?? \"melee_attack.01\";\nconst weapon = args[2]?.weapon ?? \"butterflysword.01\";\nconst trail = args[2]?.trail ?? \"\";\nconst color = args[2]?.color ?? \"blue\";\nconst impact = args[2]?.impact ?? \"\";\nconst impactScale = args[2].impactScale ?? 1.5;\nconst soundFileMelee = args[2]?.soundFileMelee ?? \"\";\nconst soundFileRange = args[2]?.soundFileRange ?? \"\";\nconst delaySound = args[2]?.delaySound ?? 300;\nconst switchDistanceFt = args[2]?.switchDistanceFt ?? 5;\nconst range = args[2]?.range ?? \"\";\nconst returnFile = args[2]?.return ?? \"\";\nconst delayBetweenAttacks = args[2]?.delayBetweenAttacks ?? 1000;\n\nfunction log(string, variable){\n    return console.log(`%c ${string}`, 'color: #bada55', variable)\n}\n\n\n\n// Let's reconstruct the database path and fetch the array of all the variations for the chosen weapon\nconst dbPath = `jb2a.${weaponGroup}.${weapon}`;\nconst entries = Sequencer.Database.getEntry(dbPath) ?? null;\n\n// The length of the array will represent how many entries there are, \n// which we'll use later on to randomly pick the appropriate one.\nconst entriesLength = entries.length;\n\nif(debug){\n\n\n\n    log(\"source: \", source);\n    log(\"targets: \", targets);\n    log(\"weapon group: \", weaponGroup);\n    log(\"weapon: \", weapon);\n    log(\"trail: \", trail);\n    log(\"color: \", color);\n    log(\"impact: \", impact);\n    log(\"soundFileMelee: \", soundFileMelee);\n    log(\"soundFileRange: \", soundFileRange);\n    log(\"enableBlood: \", enableBlood);\n    log(\"enableSound: \", enableSound);\n    log(\"enableShake: \", enableShake);\n    log(\"enableTrail: \", enableTrail);\n    log(\"dbPath: \", dbPath);\n    log(\"entries: \", entries);\n    log(\"entries length: \", entriesLength);\n\n}\n\n\n/******************************************\n * MAIN ANIMATION FUNCTIONS INITIALIZATION*\n * ****************************************/\n\nasync function meleeAttack(target, randMelee, randTrail, impact, isMirrored, targetScale, within5ft) {\n    const sourceScale = { x: source?.document?.texture?.scaleX ?? 1, y: source?.document?.texture?.scaleY ?? 1 }\n    \n    // Here is some Maths that we use for the \"Shake\" animation of the targets, move along... nothing to see here :D\n    const amplitude = Sequencer.Helpers.random_float_between(0.0, 0.2);\n    let hitRay = new Ray(source, target);\n    const shakeDirection = { x: Math.sign(hitRay.dx), y: Math.sign(hitRay.dy) };\n    const values = {\n        x: [0, -amplitude * shakeDirection.y, amplitude * shakeDirection.y, (-amplitude * shakeDirection.y) / 4, (amplitude * shakeDirection.y) / 4, 0],\n        y: [0, amplitude * shakeDirection.x, -amplitude * shakeDirection.x, (amplitude * shakeDirection.x) / 4, (-amplitude * shakeDirection.x) / 4, 0]\n    }\n    const interval = 50;\n    const easeOption = \"easeInOutSine\";\n\n    if(debug){\n        log(\"THIS IS A: \", \"MELEE ATTACK\")\n        log(\"within 5 feet?: \", within5ft)\n        log(\"randow melee: \", randMelee)\n        log(\"random trail: \", randTrail)\n        log(\"target scale: \", targetScale)\n        log(\"source scale: \", sourceScale)\n    }\n\n    // Below is the Sequencer code for all the animations\n    // The wiki for Sequencer is the best resource to learn about it: \n    // https://fantasycomputer.works/FoundryVTT-Sequencer/#/\n    // check it out, follow the tutorials from Wasp, the developer, everything is there!\n    new Sequence()\n\n        .effect()\n        .from(source)\n        .scale({ x: sourceScale.x, y: sourceScale.y })\n        .anchor(0.5)\n        //.rotate(0)\n        //.rotateTowards(target, {rotationOffset: -90})\n        .duration(1500)\n//        .fadeOut(500)\n        .zIndex(5)\n        .playIf(within5ft)\n\n        .effect()\n        .from(source)\n        .scale({ x: sourceScale.x, y: sourceScale.y })\n        .anchor(0.5)\n        //.rotate(0)\n        //.rotateTowards(target, {rotationOffset: -90})\n        //.rotateIn(0, 500, {ease: \"easeOutCubic\"})\n        //.animateProperty(\"sprite\", \"position.y\", { from: 0, to: hitRay.distance -gridSize, duration: 500+hitRay.distance, ease: \"easeOutQuint\"})\n//        .moveTowards(target, {rotate: false, ease: \"easeOutQuint\"})\n        .duration(1500)\n//        .fadeOut(500)\n        .zIndex(5)\n        .playIf(!within5ft)\n\n        .animation()\n        .on(source)\n//        .fadeOut(50)\n\n//        .effect()\n//        .file(\"jb2a.gust_of_wind.veryfast\")\n//        .atLocation(source, {cacheLocation: true})\n//        .stretchTo(target)\n//        .randomizeMirrorY()\n//        .belowTokens()\n//        .playIf(!within5ft)\n\n        .effect()\n        .file(`${randTrail}`)\n        .atLocation(target)\n        .rotateTowards(source)\n        .rotate(180)\n        .animateProperty(\"sprite\", \"position.x\", { from: -(2.5*gridSize + hitRay.distance), to: -2.5*gridSize, duration: 500+hitRay.distance, ease: \"easeOutQuint\"})\n        .scale(0.5)\n        .mirrorY(isMirrored)\n        .zIndex(11)\n        .playIf(enableTrail)\n\n        .effect()\n        .file(`${randMelee}`)\n        .atLocation(target)\n        .rotateTowards(source)\n        .rotate(180)\n        .animateProperty(\"sprite\", \"position.x\", { from: -(2.5*gridSize + hitRay.distance), to: -2.5*gridSize, duration: 500+hitRay.distance, ease: \"easeOutQuint\"})\n        .scale(0.5)\n        .mirrorY(isMirrored)\n        .zIndex(10)\n        .waitUntilFinished(-1000) // By design, The hit should always be 1 second from the end of the weapon attack and the trail animations\n\n\n\n        .animation()\n        .on(source)\n//        .fadeIn(500)\n\n        .sound()\n        .file(soundFileMelee)\n        .playIf(enableSound)\n\n        .effect()\n        .file(`${impact}`)\n        .atLocation(target)\n        .scaleToObject(impactScale, { uniform: true })\n        .zIndex(12)\n        .playIf(enableImpact)\n\n        //START - BLOOD SPLATTER EFFECT\n        .effect()\n        .file('jb2a.liquid.splash_side.red')\n        .atLocation(target)\n        .rotateTowards(source)\n        .randomRotation()\n        .scaleToObject(1.5, { uniform: true })\n        .playIf(enableBlood)\n        .zIndex(12)\n        //END - BLOOD SPLATTER EFFECT\n\n        // START OF SHAKE SECTION\n        .animation()\n        .on(target)\n        .fadeOut(50)\n        .playIf(enableShake)\n\n        .effect()\n        .from(target)\n        .loopProperty(\"spriteContainer\", \"position.x\", {\n            values: values.x,\n            duration: interval - ((interval * amplitude) / 2),\n            gridUnits: true,\n            ease: easeOption\n        })\n        .loopProperty(\"spriteContainer\", \"position.y\", {\n            values: values.y,\n            duration: interval - ((interval * amplitude) / 2),\n            gridUnits: true,\n            ease: easeOption\n        })\n        .scale({ x: targetScale.x, y: targetScale.y })\n        .duration(interval * 9)\n        .playIf(enableShake)\n        .zIndex(1)\n        .waitUntilFinished(-150)\n\n        .animation()\n        .on(target)\n        .fadeIn(50)\n        .playIf(enableShake)\n        // END OF SHAKE SECTION\n\n        .play();\n};\n\nasync function rangedAttack(target, targetScale) {\n    if(debug){\n        log(\"THIS IS A: \", \"RANGED ATTACK\")\n        log(\"target scale: \", targetScale)\n    }\n\n    const amplitude = Sequencer.Helpers.random_float_between(0.0, 0.2);\n    let hitRay = new Ray(source, target);\n    const shakeDirection = { x: Math.sign(hitRay.dx), y: Math.sign(hitRay.dy) };\n    const values = {\n        x: [0, -amplitude * shakeDirection.y, amplitude * shakeDirection.y, (-amplitude * shakeDirection.y) / 4, (amplitude * shakeDirection.y) / 4, 0],\n        y: [0, amplitude * shakeDirection.x, -amplitude * shakeDirection.x, (amplitude * shakeDirection.x) / 4, (-amplitude * shakeDirection.x) / 4, 0]\n    }\n    const interval = 50;\n    const easeOption = \"easeInOutSine\";\n\n    new Sequence()\n\n        .sound()\n        .file(soundFileRange)\n        .playIf(enableSound)\n        .delay(delaySound)\n\n        .effect()\n        .file(range)\n        .atLocation(source)\n        .stretchTo(target)\n        .waitUntilFinished(-800)\n        .zIndex(10)\n\n        .effect()\n        .file(`${impact}`)\n        .atLocation(target)\n        .scaleToObject(1.2, { uniform: true })\n        .zIndex(12)\n        .playIf(enableImpact)\n\n        .effect()\n        .file(returnFile)\n        .atLocation(source)\n        .stretchTo(target)\n        .zIndex(10)\n        .playIf(enableReturn)\n\n        //START - BLOOD SPLATTER EFFECT\n        .effect()\n        .file('jb2a.liquid.splash_side.red')\n        .atLocation(target)\n        .rotateTowards(source)\n        .randomRotation()\n        .scaleToObject(1.5, { uniform: true })\n        .zIndex(11)\n        .playIf(enableBlood)\n        //END - BLOOD SPLATTER EFFECT\n\n        // START OF SHAKE SECTION\n        .animation()\n        .on(target)\n        .fadeOut(50)\n        .playIf(enableShake)\n\n        .effect()\n        .from(target)\n        .loopProperty(\"spriteContainer\", \"position.x\", {\n            values: values.x,\n            duration: interval - ((interval * amplitude) / 2),\n            gridUnits: true,\n            ease: easeOption\n        })\n        .loopProperty(\"spriteContainer\", \"position.y\", {\n            values: values.y,\n            duration: interval - ((interval * amplitude) / 2),\n            gridUnits: true,\n            ease: easeOption\n        })\n        .scale({ x: targetScale.x, y: targetScale.y })\n        .duration(interval * 9)\n        .playIf(enableShake)\n        .zIndex(1)\n        .waitUntilFinished(-150)\n\n        .animation()\n        .on(target)\n        .fadeIn(50)\n        .playIf(enableShake)\n        // END OF SHAKE SECTION\n\n        .play()\n}\n\n/**************************\n * ANIMATION CALL AND LOOP*\n **************************/\n\n// We will loop through this code for each targeted token and \n// pick a different random number each loop in order to have more\n// probability to pick a different animation everytime\nfor (let target of targets) {\n\n\n    let targetScale = { x: target?.document?.texture?.scaleX ?? 1, y: target?.document?.texture?.scaleY ?? 1 }\n    // Arrays start at 0. This will return a random integer which we'll use to pick a random attack variation\n    // and its corresponding trail.\n    //let rand = Sequencer.Helpers.random_int_between(0, entriesLength - 1);\n    let rand = Math.floor(Math.random() * ((entriesLength -1) + 1))\n    // Here, we rebuild the database paths and pass them along to the animation function.\n    let randMelee = `${dbPath}.${rand}`;\n    let randTrail;\n    enableTrail? randTrail =`jb2a.${weaponGroup}.${trail}.${color}.${rand}` : randTrail = 'jb2a.antilife_shell.blue_no_circle'\n    //let randTrail = `jb2a.${weaponGroup}.${trail}.${color}.${rand}`;\n    \n    // Let's add to the randomisation by mirroring the animation half the time, on top of the random attack variation.\n    let isMirrored = Math.random() < 0.5; // 50% probability. 0.1 would make it 10%, 0.2 20%...etc\n\n    // let switchDistanceFt = switchDistanceFt ?? 1000; // Placeholder\n    const targetBounds = target.bounds.pad(gridSize * (switchDistanceFt / 5 - 1 + 0.5), gridSize * (switchDistanceFt / 5 - 1 + 0.5));\n    const sourceBounds = source.bounds;\n    const within5ft = (target.bounds.pad(gridSize * (0.5), gridSize * (0.5))).intersects(sourceBounds);\n    const withinSwitchDistance = targetBounds.intersects(sourceBounds);\n\n    // This is the code which actually calls the animation function.\n    if (withinSwitchDistance || !enableSwitchDistance) {\n        await meleeAttack(target, randMelee, randTrail, impact, isMirrored, targetScale, within5ft)\n        await Sequencer.Helpers.wait(delayBetweenAttacks)\n    }\n    else {\n        await rangedAttack(target, targetScale)\n        await Sequencer.Helpers.wait(delayBetweenAttacks)\n    }\n\n    if(debug){\n        log(\"random integer: \", rand)\n        log(\"randow melee: \", randMelee)\n        log(\"random trail: \", randTrail)\n        log(\"target scale: \", targetScale)\n        log(\"switch Distance\", switchDistanceFt)\n        log(\"within switch distance: \", withinSwitchDistance)\n    }\n}","ownership":{"default":0,"ZIFRYb4IqOsDAbYe":3},"flags":{"core":{"sourceId":"Macro.Ts9WCv9L1zL78kAI"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.2.1","coreVersion":"10.291","createdTime":1687515641970,"modifiedTime":1687521054790,"lastModifiedBy":"lO87UDysxPLL0W3i"},"folder":null,"sort":0,"_id":"4yHpiLbPBUMIZHWK"}
{"name":"Export Autorec JSON","type":"script","scope":"global","author":"lO87UDysxPLL0W3i","img":"icons/svg/upgrade.svg","command":"// Use this to export a clean copy of the current Autorec.\n// Do NOT use this while still having animation entries you don't want to share.\n\nconst settings = {};\nsettings.melee = await game.settings.get('autoanimations', 'aaAutorec-melee')\nsettings.range = await game.settings.get('autoanimations', 'aaAutorec-range')\nsettings.ontoken = await game.settings.get('autoanimations', 'aaAutorec-ontoken')\nsettings.templatefx = await game.settings.get('autoanimations', 'aaAutorec-templatefx')\nsettings.preset = await game.settings.get('autoanimations', 'aaAutorec-preset')\nsettings.aura = await game.settings.get('autoanimations', 'aaAutorec-aura')\nsettings.aefx = await game.settings.get('autoanimations', 'aaAutorec-aefx')\n\nlet id = 0;\nfor (const key of Object.keys(settings)) {\n    const sorted = [...settings[key]].sort((a, b) => !!b.metaData?.name - !!a.metaData?.name)\n\n    sorted.map(x => {\n        id++\n        x.id = !Number(x.id) ? String(id) : x.id;\n        x.metaData = x.metaData ?? {};\n        x.metaData.label = x.label;\n        x.metaData.menu = x.menu;\n        x.metaData.name = x.metaData.name ?? \"5e Animations\";\n        x.metaData.moduleVersion = x.metaData.moduleVersion ?? game.modules.get(\"dnd5e-animations\").version;\n        x.metaData.version = x.metaData.version ?? Date.now();\n        return x\n    })\n\n    sorted.sort((a, b) => a.id - b.id)\n    settings[key] = sorted\n}\n\nsettings.version = await game.settings.get('autoanimations', 'aaAutorec').version\n\n// New File\nconst content = JSON.stringify(settings, null, '\\t');\nconst file = new File([content], `autorec-new.json`, { type: 'application/json' });\nvar response = await FilePicker.upload(\"data\", \"\", file);","ownership":{"default":0,"lO87UDysxPLL0W3i":3},"flags":{"core":{"sourceId":"Macro.NUrFnxBTElGs7unT"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.2.1","coreVersion":"10.291","createdTime":1672505481685,"modifiedTime":1686752945498,"lastModifiedBy":"lO87UDysxPLL0W3i"},"folder":null,"sort":0,"_id":"8TuSEFCqDT7IH35f"}
{"name":"Open Autorec Menu","type":"script","scope":"global","author":"lO87UDysxPLL0W3i","img":"icons/svg/door-exit.svg","command":"Hooks.call('AutomaticAnimations.Open.Menu.New')","ownership":{"default":0,"lO87UDysxPLL0W3i":3},"flags":{"core":{"sourceId":"Macro.RLG1DQb7QvP5UJOA"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677188526050,"modifiedTime":1677188789805,"lastModifiedBy":"lO87UDysxPLL0W3i"},"folder":null,"sort":0,"_id":"GpwL2YYqYMHiTUvO"}
{"name":"Open Update Menu","type":"script","scope":"global","author":"lO87UDysxPLL0W3i","img":"icons/svg/wall-direction.svg","command":"new autorecUpdateFormApplication().render(true)","ownership":{"default":0,"lO87UDysxPLL0W3i":3},"flags":{"core":{"sourceId":"Macro.0Ff9ogIjQsBBTjMD"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1677188560427,"modifiedTime":1677188789321,"lastModifiedBy":"lO87UDysxPLL0W3i"},"folder":null,"sort":0,"_id":"Jh1PBTsZEppXnzam"}
